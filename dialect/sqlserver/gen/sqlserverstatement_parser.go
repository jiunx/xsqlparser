// Code generated from E:/GoProject/src/github.com/2212442929/xsqlparser/dialect/sqlserver/grammer\SQLServerStatement.g4 by ANTLR 4.9.3. DO NOT EDIT.

package parser // SQLServerStatement

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 652, 5581,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 4, 153, 9, 153, 4, 154, 9, 154, 4, 155, 9, 155, 4, 156,
	9, 156, 4, 157, 9, 157, 4, 158, 9, 158, 4, 159, 9, 159, 4, 160, 9, 160,
	4, 161, 9, 161, 4, 162, 9, 162, 4, 163, 9, 163, 4, 164, 9, 164, 4, 165,
	9, 165, 4, 166, 9, 166, 4, 167, 9, 167, 4, 168, 9, 168, 4, 169, 9, 169,
	4, 170, 9, 170, 4, 171, 9, 171, 4, 172, 9, 172, 4, 173, 9, 173, 4, 174,
	9, 174, 4, 175, 9, 175, 4, 176, 9, 176, 4, 177, 9, 177, 4, 178, 9, 178,
	4, 179, 9, 179, 4, 180, 9, 180, 4, 181, 9, 181, 4, 182, 9, 182, 4, 183,
	9, 183, 4, 184, 9, 184, 4, 185, 9, 185, 4, 186, 9, 186, 4, 187, 9, 187,
	4, 188, 9, 188, 4, 189, 9, 189, 4, 190, 9, 190, 4, 191, 9, 191, 4, 192,
	9, 192, 4, 193, 9, 193, 4, 194, 9, 194, 4, 195, 9, 195, 4, 196, 9, 196,
	4, 197, 9, 197, 4, 198, 9, 198, 4, 199, 9, 199, 4, 200, 9, 200, 4, 201,
	9, 201, 4, 202, 9, 202, 4, 203, 9, 203, 4, 204, 9, 204, 4, 205, 9, 205,
	4, 206, 9, 206, 4, 207, 9, 207, 4, 208, 9, 208, 4, 209, 9, 209, 4, 210,
	9, 210, 4, 211, 9, 211, 4, 212, 9, 212, 4, 213, 9, 213, 4, 214, 9, 214,
	4, 215, 9, 215, 4, 216, 9, 216, 4, 217, 9, 217, 4, 218, 9, 218, 4, 219,
	9, 219, 4, 220, 9, 220, 4, 221, 9, 221, 4, 222, 9, 222, 4, 223, 9, 223,
	4, 224, 9, 224, 4, 225, 9, 225, 4, 226, 9, 226, 4, 227, 9, 227, 4, 228,
	9, 228, 4, 229, 9, 229, 4, 230, 9, 230, 4, 231, 9, 231, 4, 232, 9, 232,
	4, 233, 9, 233, 4, 234, 9, 234, 4, 235, 9, 235, 4, 236, 9, 236, 4, 237,
	9, 237, 4, 238, 9, 238, 4, 239, 9, 239, 4, 240, 9, 240, 4, 241, 9, 241,
	4, 242, 9, 242, 4, 243, 9, 243, 4, 244, 9, 244, 4, 245, 9, 245, 4, 246,
	9, 246, 4, 247, 9, 247, 4, 248, 9, 248, 4, 249, 9, 249, 4, 250, 9, 250,
	4, 251, 9, 251, 4, 252, 9, 252, 4, 253, 9, 253, 4, 254, 9, 254, 4, 255,
	9, 255, 4, 256, 9, 256, 4, 257, 9, 257, 4, 258, 9, 258, 4, 259, 9, 259,
	4, 260, 9, 260, 4, 261, 9, 261, 4, 262, 9, 262, 4, 263, 9, 263, 4, 264,
	9, 264, 4, 265, 9, 265, 4, 266, 9, 266, 4, 267, 9, 267, 4, 268, 9, 268,
	4, 269, 9, 269, 4, 270, 9, 270, 4, 271, 9, 271, 4, 272, 9, 272, 4, 273,
	9, 273, 4, 274, 9, 274, 4, 275, 9, 275, 4, 276, 9, 276, 4, 277, 9, 277,
	4, 278, 9, 278, 4, 279, 9, 279, 4, 280, 9, 280, 4, 281, 9, 281, 4, 282,
	9, 282, 4, 283, 9, 283, 4, 284, 9, 284, 4, 285, 9, 285, 4, 286, 9, 286,
	4, 287, 9, 287, 4, 288, 9, 288, 4, 289, 9, 289, 4, 290, 9, 290, 4, 291,
	9, 291, 4, 292, 9, 292, 4, 293, 9, 293, 4, 294, 9, 294, 4, 295, 9, 295,
	4, 296, 9, 296, 4, 297, 9, 297, 4, 298, 9, 298, 4, 299, 9, 299, 4, 300,
	9, 300, 4, 301, 9, 301, 4, 302, 9, 302, 4, 303, 9, 303, 4, 304, 9, 304,
	4, 305, 9, 305, 4, 306, 9, 306, 4, 307, 9, 307, 4, 308, 9, 308, 4, 309,
	9, 309, 4, 310, 9, 310, 4, 311, 9, 311, 4, 312, 9, 312, 4, 313, 9, 313,
	4, 314, 9, 314, 4, 315, 9, 315, 4, 316, 9, 316, 4, 317, 9, 317, 4, 318,
	9, 318, 4, 319, 9, 319, 4, 320, 9, 320, 4, 321, 9, 321, 4, 322, 9, 322,
	4, 323, 9, 323, 4, 324, 9, 324, 4, 325, 9, 325, 4, 326, 9, 326, 4, 327,
	9, 327, 4, 328, 9, 328, 4, 329, 9, 329, 4, 330, 9, 330, 4, 331, 9, 331,
	4, 332, 9, 332, 4, 333, 9, 333, 4, 334, 9, 334, 4, 335, 9, 335, 4, 336,
	9, 336, 4, 337, 9, 337, 4, 338, 9, 338, 4, 339, 9, 339, 4, 340, 9, 340,
	4, 341, 9, 341, 4, 342, 9, 342, 4, 343, 9, 343, 4, 344, 9, 344, 4, 345,
	9, 345, 4, 346, 9, 346, 4, 347, 9, 347, 4, 348, 9, 348, 4, 349, 9, 349,
	4, 350, 9, 350, 4, 351, 9, 351, 4, 352, 9, 352, 4, 353, 9, 353, 4, 354,
	9, 354, 4, 355, 9, 355, 4, 356, 9, 356, 4, 357, 9, 357, 4, 358, 9, 358,
	4, 359, 9, 359, 4, 360, 9, 360, 4, 361, 9, 361, 4, 362, 9, 362, 4, 363,
	9, 363, 4, 364, 9, 364, 4, 365, 9, 365, 4, 366, 9, 366, 4, 367, 9, 367,
	4, 368, 9, 368, 4, 369, 9, 369, 4, 370, 9, 370, 4, 371, 9, 371, 4, 372,
	9, 372, 4, 373, 9, 373, 4, 374, 9, 374, 4, 375, 9, 375, 4, 376, 9, 376,
	4, 377, 9, 377, 4, 378, 9, 378, 4, 379, 9, 379, 4, 380, 9, 380, 4, 381,
	9, 381, 4, 382, 9, 382, 4, 383, 9, 383, 4, 384, 9, 384, 4, 385, 9, 385,
	4, 386, 9, 386, 4, 387, 9, 387, 4, 388, 9, 388, 4, 389, 9, 389, 4, 390,
	9, 390, 4, 391, 9, 391, 4, 392, 9, 392, 4, 393, 9, 393, 4, 394, 9, 394,
	4, 395, 9, 395, 4, 396, 9, 396, 4, 397, 9, 397, 4, 398, 9, 398, 4, 399,
	9, 399, 4, 400, 9, 400, 4, 401, 9, 401, 4, 402, 9, 402, 4, 403, 9, 403,
	4, 404, 9, 404, 4, 405, 9, 405, 4, 406, 9, 406, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 5, 2, 868, 10, 2, 3, 2, 5, 2, 871, 10, 2, 3, 3, 5, 3,
	874, 10, 3, 3, 3, 3, 3, 5, 3, 878, 10, 3, 3, 3, 5, 3, 881, 10, 3, 3, 3,
	3, 3, 5, 3, 885, 10, 3, 3, 3, 5, 3, 888, 10, 3, 3, 3, 3, 3, 3, 3, 5, 3,
	893, 10, 3, 3, 4, 5, 4, 896, 10, 4, 3, 4, 5, 4, 899, 10, 4, 3, 4, 3, 4,
	3, 4, 3, 5, 5, 5, 905, 10, 5, 3, 5, 5, 5, 908, 10, 5, 3, 5, 3, 5, 3, 5,
	3, 5, 7, 5, 914, 10, 5, 12, 5, 14, 5, 917, 11, 5, 3, 6, 5, 6, 920, 10,
	6, 3, 6, 5, 6, 923, 10, 6, 3, 6, 3, 6, 3, 7, 5, 7, 928, 10, 7, 3, 7, 3,
	7, 5, 7, 932, 10, 7, 3, 7, 3, 7, 3, 7, 5, 7, 937, 10, 7, 3, 7, 3, 7, 5,
	7, 941, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9, 7, 9, 951,
	10, 9, 12, 9, 14, 9, 954, 11, 9, 3, 9, 5, 9, 957, 10, 9, 3, 10, 3, 10,
	3, 10, 3, 10, 7, 10, 963, 10, 10, 12, 10, 14, 10, 966, 11, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 5, 10, 972, 10, 10, 3, 11, 3, 11, 5, 11, 976, 10, 11,
	3, 12, 5, 12, 979, 10, 12, 3, 12, 3, 12, 5, 12, 983, 10, 12, 3, 12, 3,
	12, 5, 12, 987, 10, 12, 3, 12, 5, 12, 990, 10, 12, 3, 12, 5, 12, 993, 10,
	12, 3, 12, 3, 12, 5, 12, 997, 10, 12, 3, 13, 5, 13, 1000, 10, 13, 3, 13,
	5, 13, 1003, 10, 13, 3, 13, 3, 13, 5, 13, 1007, 10, 13, 3, 13, 5, 13, 1010,
	10, 13, 3, 13, 5, 13, 1013, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 1024, 10, 14, 3, 15, 3, 15, 5, 15, 1028,
	10, 15, 3, 15, 3, 15, 3, 15, 5, 15, 1033, 10, 15, 7, 15, 1035, 10, 15,
	12, 15, 14, 15, 1038, 11, 15, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 5, 17,
	1045, 10, 17, 3, 17, 3, 17, 5, 17, 1049, 10, 17, 3, 17, 7, 17, 1052, 10,
	17, 12, 17, 14, 17, 1055, 11, 17, 3, 18, 3, 18, 5, 18, 1059, 10, 18, 3,
	18, 3, 18, 5, 18, 1063, 10, 18, 3, 18, 5, 18, 1066, 10, 18, 3, 18, 5, 18,
	1069, 10, 18, 3, 18, 5, 18, 1072, 10, 18, 3, 18, 5, 18, 1075, 10, 18, 3,
	19, 3, 19, 3, 20, 3, 20, 5, 20, 1081, 10, 20, 3, 20, 3, 20, 7, 20, 1085,
	10, 20, 12, 20, 14, 20, 1088, 11, 20, 3, 21, 3, 21, 3, 21, 5, 21, 1093,
	10, 21, 3, 21, 5, 21, 1096, 10, 21, 3, 21, 5, 21, 1099, 10, 21, 3, 21,
	5, 21, 1102, 10, 21, 3, 22, 3, 22, 5, 22, 1106, 10, 22, 3, 22, 3, 22, 5,
	22, 1110, 10, 22, 3, 22, 5, 22, 1113, 10, 22, 3, 22, 3, 22, 5, 22, 1117,
	10, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22,
	1127, 10, 22, 3, 23, 3, 23, 5, 23, 1131, 10, 23, 3, 24, 3, 24, 5, 24, 1135,
	10, 24, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 28,
	3, 28, 3, 28, 7, 28, 1148, 10, 28, 12, 28, 14, 28, 1151, 11, 28, 3, 29,
	3, 29, 7, 29, 1155, 10, 29, 12, 29, 14, 29, 1158, 11, 29, 3, 30, 3, 30,
	5, 30, 1162, 10, 30, 3, 30, 5, 30, 1165, 10, 30, 3, 30, 3, 30, 5, 30, 1169,
	10, 30, 3, 30, 3, 30, 5, 30, 1173, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	5, 30, 1179, 10, 30, 3, 31, 5, 31, 1182, 10, 31, 3, 31, 5, 31, 1185, 10,
	31, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 1191, 10, 31, 3, 31, 5, 31, 1194,
	10, 31, 3, 31, 3, 31, 5, 31, 1198, 10, 31, 3, 31, 3, 31, 3, 31, 5, 31,
	1203, 10, 31, 5, 31, 1205, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 1211,
	10, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 7, 34,
	1221, 10, 34, 12, 34, 14, 34, 1224, 11, 34, 3, 35, 3, 35, 3, 35, 3, 36,
	3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 7, 37, 1237, 10, 37, 12,
	37, 14, 37, 1240, 11, 37, 3, 38, 3, 38, 5, 38, 1244, 10, 38, 3, 38, 3,
	38, 3, 38, 3, 39, 3, 39, 3, 39, 5, 39, 1252, 10, 39, 3, 39, 3, 39, 3, 39,
	5, 39, 1257, 10, 39, 5, 39, 1259, 10, 39, 3, 40, 3, 40, 3, 40, 7, 40, 1264,
	10, 40, 12, 40, 14, 40, 1267, 11, 40, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41,
	1273, 10, 41, 3, 41, 5, 41, 1276, 10, 41, 3, 42, 3, 42, 3, 42, 3, 43, 3,
	43, 3, 43, 5, 43, 1284, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 7, 44, 1326, 10, 44, 12, 44, 14, 44, 1329, 11, 44, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44,
	3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 1347, 10, 44, 12, 44, 14, 44,
	1350, 11, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 1356, 10, 44, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	5, 45, 1412, 10, 45, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3,
	47, 3, 47, 5, 47, 1423, 10, 47, 3, 48, 3, 48, 3, 49, 5, 49, 1428, 10, 49,
	3, 49, 3, 49, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 1439,
	10, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 54, 3, 54, 3, 55,
	3, 55, 5, 55, 1451, 10, 55, 3, 56, 3, 56, 3, 57, 3, 57, 3, 58, 3, 58, 3,
	59, 3, 59, 3, 59, 5, 59, 1462, 10, 59, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60,
	5, 60, 1469, 10, 60, 3, 60, 3, 60, 3, 60, 5, 60, 1474, 10, 60, 3, 61, 3,
	61, 3, 61, 5, 61, 1479, 10, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 5, 62,
	1486, 10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63, 5, 63, 1493, 10, 63, 3,
	63, 3, 63, 3, 64, 3, 64, 3, 64, 5, 64, 1500, 10, 64, 3, 64, 3, 64, 3, 65,
	3, 65, 3, 65, 5, 65, 1507, 10, 65, 3, 65, 3, 65, 3, 66, 3, 66, 3, 67, 3,
	67, 3, 68, 3, 68, 3, 68, 5, 68, 1518, 10, 68, 3, 68, 3, 68, 3, 69, 3, 69,
	3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 7, 71, 1530, 10, 71, 12, 71,
	14, 71, 1533, 11, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 7, 72,
	1541, 10, 72, 12, 72, 14, 72, 1544, 11, 72, 3, 72, 3, 72, 3, 73, 5, 73,
	1549, 10, 73, 3, 73, 3, 73, 3, 73, 7, 73, 1554, 10, 73, 12, 73, 14, 73,
	1557, 11, 73, 3, 73, 5, 73, 1560, 10, 73, 3, 74, 3, 74, 3, 75, 3, 75, 3,
	76, 3, 76, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 1572, 10, 77, 5, 77, 1574,
	10, 77, 3, 77, 3, 77, 3, 78, 5, 78, 1579, 10, 78, 3, 78, 3, 78, 3, 79,
	3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 1592, 10,
	79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 7, 79, 1602,
	10, 79, 12, 79, 14, 79, 1605, 11, 79, 3, 80, 3, 80, 3, 81, 3, 81, 3, 82,
	3, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1619, 10, 83, 3,
	83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83,
	3, 83, 3, 83, 7, 83, 1634, 10, 83, 12, 83, 14, 83, 1637, 11, 83, 3, 84,
	3, 84, 3, 85, 3, 85, 5, 85, 1643, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 5, 85, 1650, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 7, 85, 1657,
	10, 85, 12, 85, 14, 85, 1660, 11, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85,
	1666, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1675,
	10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1681, 10, 85, 3, 85, 5, 85,
	1684, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3, 86, 3,
	86, 3, 86, 3, 86, 3, 86, 7, 86, 1719, 10, 86, 12, 86, 14, 86, 1722, 11,
	86, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 5, 87,
	1733, 10, 87, 3, 87, 3, 87, 3, 87, 3, 87, 7, 87, 1739, 10, 87, 12, 87,
	14, 87, 1742, 11, 87, 3, 87, 3, 87, 3, 87, 5, 87, 1747, 10, 87, 3, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 5, 87, 1757, 10, 87, 3,
	87, 3, 87, 3, 87, 7, 87, 1762, 10, 87, 12, 87, 14, 87, 1765, 11, 87, 3,
	88, 3, 88, 3, 88, 5, 88, 1770, 10, 88, 3, 89, 3, 89, 3, 89, 5, 89, 1775,
	10, 89, 3, 89, 3, 89, 3, 89, 7, 89, 1780, 10, 89, 12, 89, 14, 89, 1783,
	11, 89, 3, 89, 5, 89, 1786, 10, 89, 3, 89, 3, 89, 3, 90, 3, 90, 3, 91,
	3, 91, 3, 92, 3, 92, 5, 92, 1796, 10, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3,
	93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 7, 94, 1810, 10, 94,
	12, 94, 14, 94, 1813, 11, 94, 3, 94, 3, 94, 5, 94, 1817, 10, 94, 3, 94,
	3, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 7, 95, 1826, 10, 95, 12, 95,
	14, 95, 1829, 11, 95, 3, 95, 5, 95, 1832, 10, 95, 3, 95, 3, 95, 3, 96,
	3, 96, 3, 96, 5, 96, 1839, 10, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5,
	96, 1846, 10, 96, 3, 97, 3, 97, 5, 97, 1850, 10, 97, 3, 97, 6, 97, 1853,
	10, 97, 13, 97, 14, 97, 1854, 3, 97, 5, 97, 1858, 10, 97, 3, 97, 3, 97,
	3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 100, 3, 100,
	3, 100, 3, 100, 5, 100, 1874, 10, 100, 3, 101, 3, 101, 3, 101, 3, 101,
	3, 101, 7, 101, 1881, 10, 101, 12, 101, 14, 101, 1884, 11, 101, 3, 101,
	3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101,
	1895, 10, 101, 5, 101, 1897, 10, 101, 3, 102, 3, 102, 3, 102, 5, 102, 1902,
	10, 102, 3, 102, 3, 102, 5, 102, 1906, 10, 102, 3, 102, 5, 102, 1909, 10,
	102, 3, 103, 3, 103, 3, 103, 5, 103, 1914, 10, 103, 3, 103, 3, 103, 3,
	103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1923, 10, 103, 3, 103, 3,
	103, 3, 103, 5, 103, 1928, 10, 103, 3, 104, 3, 104, 3, 105, 3, 105, 3,
	105, 3, 105, 5, 105, 1936, 10, 105, 3, 105, 3, 105, 3, 106, 3, 106, 3,
	106, 3, 106, 3, 106, 3, 106, 3, 106, 3, 106, 5, 106, 1948, 10, 106, 3,
	106, 3, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 5, 107, 1957, 10,
	107, 3, 107, 3, 107, 3, 107, 3, 107, 5, 107, 1963, 10, 107, 3, 108, 3,
	108, 3, 108, 3, 109, 3, 109, 3, 109, 5, 109, 1971, 10, 109, 3, 109, 5,
	109, 1974, 10, 109, 3, 109, 5, 109, 1977, 10, 109, 3, 109, 3, 109, 3, 110,
	3, 110, 3, 110, 3, 110, 3, 110, 7, 110, 1986, 10, 110, 12, 110, 14, 110,
	1989, 11, 110, 3, 111, 3, 111, 3, 111, 3, 112, 3, 112, 5, 112, 1996, 10,
	112, 3, 113, 3, 113, 3, 113, 3, 113, 3, 113, 3, 114, 3, 114, 5, 114, 2005,
	10, 114, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 3, 115, 5, 115, 2013,
	10, 115, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 5, 116, 2021,
	10, 116, 3, 117, 3, 117, 5, 117, 2025, 10, 117, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118,
	2038, 10, 118, 5, 118, 2040, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3,
	120, 3, 120, 3, 120, 5, 120, 2049, 10, 120, 3, 121, 3, 121, 3, 121, 3,
	122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 124, 3, 124, 3, 124, 3, 124, 3,
	124, 3, 124, 3, 125, 3, 125, 3, 125, 7, 125, 2068, 10, 125, 12, 125, 14,
	125, 2071, 11, 125, 3, 126, 3, 126, 5, 126, 2075, 10, 126, 3, 127, 3, 127,
	3, 127, 3, 127, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 5, 128,
	2087, 10, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 129,
	3, 129, 3, 129, 3, 129, 3, 129, 5, 129, 2100, 10, 129, 3, 130, 3, 130,
	3, 131, 3, 131, 3, 131, 7, 131, 2107, 10, 131, 12, 131, 14, 131, 2110,
	11, 131, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 134, 3, 134, 3, 134,
	3, 134, 3, 134, 3, 134, 5, 134, 2123, 10, 134, 3, 135, 3, 135, 3, 136,
	3, 136, 3, 137, 3, 137, 3, 138, 3, 138, 3, 139, 3, 139, 3, 140, 3, 140,
	5, 140, 2137, 10, 140, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141,
	3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142, 3, 142,
	3, 143, 3, 143, 3, 143, 3, 143, 3, 143, 3, 144, 3, 144, 3, 144, 5, 144,
	2162, 10, 144, 3, 144, 3, 144, 3, 144, 3, 144, 3, 144, 3, 145, 3, 145,
	3, 145, 5, 145, 2172, 10, 145, 3, 145, 3, 145, 3, 145, 3, 145, 3, 145,
	3, 146, 3, 146, 3, 146, 5, 146, 2182, 10, 146, 3, 146, 3, 146, 3, 146,
	3, 146, 3, 147, 3, 147, 3, 147, 5, 147, 2191, 10, 147, 3, 147, 3, 147,
	3, 147, 3, 147, 3, 147, 3, 147, 3, 148, 3, 148, 3, 148, 3, 148, 7, 148,
	2203, 10, 148, 12, 148, 14, 148, 2206, 11, 148, 3, 149, 3, 149, 3, 149,
	3, 149, 3, 149, 5, 149, 2213, 10, 149, 3, 149, 3, 149, 3, 149, 3, 149,
	5, 149, 2219, 10, 149, 3, 150, 3, 150, 3, 150, 3, 150, 7, 150, 2225, 10,
	150, 12, 150, 14, 150, 2228, 11, 150, 3, 151, 3, 151, 3, 151, 3, 151, 3,
	151, 3, 151, 7, 151, 2236, 10, 151, 12, 151, 14, 151, 2239, 11, 151, 3,
	152, 3, 152, 3, 152, 3, 152, 5, 152, 2245, 10, 152, 3, 152, 3, 152, 3,
	152, 3, 152, 3, 153, 3, 153, 3, 153, 3, 153, 5, 153, 2255, 10, 153, 3,
	153, 7, 153, 2258, 10, 153, 12, 153, 14, 153, 2261, 11, 153, 3, 154, 3,
	154, 3, 154, 3, 154, 3, 154, 3, 154, 3, 155, 3, 155, 3, 155, 3, 155, 3,
	155, 3, 155, 3, 156, 3, 156, 3, 156, 3, 156, 3, 156, 3, 157, 3, 157, 3,
	157, 3, 157, 3, 157, 3, 157, 3, 157, 3, 158, 3, 158, 3, 158, 3, 158, 7,
	158, 2291, 10, 158, 12, 158, 14, 158, 2294, 11, 158, 3, 159, 3, 159, 3,
	159, 3, 159, 3, 159, 3, 159, 5, 159, 2302, 10, 159, 3, 159, 5, 159, 2305,
	10, 159, 3, 160, 3, 160, 3, 160, 3, 160, 3, 160, 5, 160, 2312, 10, 160,
	3, 160, 3, 160, 3, 161, 3, 161, 3, 161, 5, 161, 2319, 10, 161, 3, 161,
	3, 161, 3, 162, 3, 162, 3, 162, 5, 162, 2326, 10, 162, 3, 162, 3, 162,
	3, 162, 3, 162, 3, 163, 3, 163, 3, 163, 5, 163, 2335, 10, 163, 3, 163,
	3, 163, 3, 163, 7, 163, 2340, 10, 163, 12, 163, 14, 163, 2343, 11, 163,
	3, 164, 3, 164, 3, 164, 5, 164, 2348, 10, 164, 3, 164, 3, 164, 3, 164,
	7, 164, 2353, 10, 164, 12, 164, 14, 164, 2356, 11, 164, 3, 165, 3, 165,
	3, 165, 5, 165, 2361, 10, 165, 3, 165, 3, 165, 3, 165, 7, 165, 2366, 10,
	165, 12, 165, 14, 165, 2369, 11, 165, 3, 166, 3, 166, 3, 166, 5, 166, 2374,
	10, 166, 3, 166, 3, 166, 3, 166, 7, 166, 2379, 10, 166, 12, 166, 14, 166,
	2382, 11, 166, 3, 167, 3, 167, 3, 167, 5, 167, 2387, 10, 167, 3, 167, 3,
	167, 3, 167, 7, 167, 2392, 10, 167, 12, 167, 14, 167, 2395, 11, 167, 3,
	167, 3, 167, 3, 167, 3, 167, 5, 167, 2401, 10, 167, 5, 167, 2403, 10, 167,
	3, 168, 3, 168, 3, 168, 5, 168, 2408, 10, 168, 3, 168, 3, 168, 3, 168,
	7, 168, 2413, 10, 168, 12, 168, 14, 168, 2416, 11, 168, 3, 169, 3, 169,
	3, 169, 3, 169, 3, 170, 3, 170, 3, 170, 3, 170, 5, 170, 2426, 10, 170,
	3, 170, 3, 170, 3, 171, 3, 171, 3, 171, 3, 171, 3, 172, 3, 172, 5, 172,
	2436, 10, 172, 3, 173, 3, 173, 3, 173, 3, 173, 3, 174, 3, 174, 3, 174,
	3, 174, 7, 174, 2446, 10, 174, 12, 174, 14, 174, 2449, 11, 174, 3, 174,
	3, 174, 5, 174, 2453, 10, 174, 3, 174, 3, 174, 3, 175, 3, 175, 3, 175,
	3, 175, 3, 175, 5, 175, 2462, 10, 175, 3, 176, 3, 176, 3, 176, 7, 176,
	2467, 10, 176, 12, 176, 14, 176, 2470, 11, 176, 3, 176, 3, 176, 5, 176,
	2474, 10, 176, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177,
	3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 5, 177, 2489, 10, 177,
	3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 5, 177,
	2499, 10, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177,
	3, 177, 3, 177, 5, 177, 2510, 10, 177, 3, 177, 5, 177, 2513, 10, 177, 3,
	177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 3, 177, 7, 177, 2523,
	10, 177, 12, 177, 14, 177, 2526, 11, 177, 3, 177, 5, 177, 2529, 10, 177,
	3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 178,
	3, 178, 3, 178, 3, 178, 3, 178, 3, 178, 3, 179, 3, 179, 5, 179, 2547, 10,
	179, 3, 179, 3, 179, 3, 179, 5, 179, 2552, 10, 179, 3, 180, 3, 180, 5,
	180, 2556, 10, 180, 3, 180, 3, 180, 3, 180, 5, 180, 2561, 10, 180, 3, 181,
	3, 181, 5, 181, 2565, 10, 181, 3, 181, 3, 181, 3, 181, 3, 181, 3, 181,
	5, 181, 2572, 10, 181, 3, 181, 7, 181, 2575, 10, 181, 12, 181, 14, 181,
	2578, 11, 181, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 5, 182, 2585, 10,
	182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 3, 182, 5, 182, 2594,
	10, 182, 3, 183, 3, 183, 5, 183, 2598, 10, 183, 3, 183, 3, 183, 5, 183,
	2602, 10, 183, 3, 184, 5, 184, 2605, 10, 184, 3, 184, 5, 184, 2608, 10,
	184, 3, 184, 5, 184, 2611, 10, 184, 3, 185, 3, 185, 3, 186, 3, 186, 3,
	186, 3, 186, 3, 186, 3, 186, 3, 186, 3, 186, 7, 186, 2623, 10, 186, 12,
	186, 14, 186, 2626, 11, 186, 3, 186, 3, 186, 5, 186, 2630, 10, 186, 3,
	187, 3, 187, 3, 187, 5, 187, 2635, 10, 187, 3, 188, 3, 188, 3, 188, 3,
	188, 3, 188, 3, 188, 3, 189, 3, 189, 3, 189, 3, 190, 3, 190, 3, 190, 3,
	191, 3, 191, 3, 191, 3, 191, 5, 191, 2653, 10, 191, 5, 191, 2655, 10, 191,
	3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 192, 3, 193, 3, 193,
	5, 193, 2666, 10, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193, 3, 193,
	5, 193, 2674, 10, 193, 3, 193, 7, 193, 2677, 10, 193, 12, 193, 14, 193,
	2680, 11, 193, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 3, 194, 5, 194,
	2688, 10, 194, 3, 195, 3, 195, 3, 195, 3, 195, 3, 195, 5, 195, 2695, 10,
	195, 3, 196, 3, 196, 3, 196, 3, 196, 5, 196, 2701, 10, 196, 3, 196, 3,
	196, 3, 196, 3, 196, 3, 197, 3, 197, 3, 197, 5, 197, 2710, 10, 197, 3,
	197, 5, 197, 2713, 10, 197, 3, 197, 5, 197, 2716, 10, 197, 3, 197, 5, 197,
	2719, 10, 197, 3, 198, 3, 198, 3, 198, 3, 198, 3, 198, 7, 198, 2726, 10,
	198, 12, 198, 14, 198, 2729, 11, 198, 3, 198, 3, 198, 3, 199, 3, 199, 3,
	199, 5, 199, 2736, 10, 199, 3, 200, 3, 200, 3, 200, 3, 201, 3, 201, 3,
	201, 3, 201, 5, 201, 2745, 10, 201, 3, 202, 3, 202, 3, 202, 7, 202, 2750,
	10, 202, 12, 202, 14, 202, 2753, 11, 202, 5, 202, 2755, 10, 202, 3, 203,
	3, 203, 3, 203, 3, 203, 3, 203, 3, 203, 5, 203, 2763, 10, 203, 5, 203,
	2765, 10, 203, 3, 203, 5, 203, 2768, 10, 203, 3, 204, 3, 204, 3, 204, 3,
	204, 3, 204, 3, 204, 3, 205, 3, 205, 5, 205, 2778, 10, 205, 3, 205, 3,
	205, 3, 205, 5, 205, 2783, 10, 205, 3, 206, 3, 206, 3, 206, 5, 206, 2788,
	10, 206, 3, 207, 3, 207, 5, 207, 2792, 10, 207, 3, 208, 5, 208, 2795, 10,
	208, 3, 208, 3, 208, 5, 208, 2799, 10, 208, 3, 208, 5, 208, 2802, 10, 208,
	3, 209, 3, 209, 3, 209, 5, 209, 2807, 10, 209, 3, 210, 3, 210, 3, 210,
	3, 210, 3, 211, 3, 211, 5, 211, 2815, 10, 211, 3, 211, 3, 211, 3, 211,
	3, 211, 3, 211, 7, 211, 2822, 10, 211, 12, 211, 14, 211, 2825, 11, 211,
	3, 212, 3, 212, 3, 212, 3, 212, 3, 212, 5, 212, 2832, 10, 212, 3, 212,
	5, 212, 2835, 10, 212, 3, 212, 5, 212, 2838, 10, 212, 3, 213, 5, 213, 2841,
	10, 213, 3, 213, 3, 213, 3, 213, 3, 213, 5, 213, 2847, 10, 213, 3, 213,
	3, 213, 5, 213, 2851, 10, 213, 3, 214, 3, 214, 3, 214, 3, 214, 7, 214,
	2857, 10, 214, 12, 214, 14, 214, 2860, 11, 214, 3, 214, 3, 214, 3, 215,
	3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 215, 3, 216,
	3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 3, 216, 5, 216, 2881, 10,
	216, 5, 216, 2883, 10, 216, 3, 217, 3, 217, 3, 217, 5, 217, 2888, 10, 217,
	5, 217, 2890, 10, 217, 3, 217, 3, 217, 3, 217, 3, 217, 3, 217, 5, 217,
	2897, 10, 217, 5, 217, 2899, 10, 217, 3, 217, 3, 217, 5, 217, 2903, 10,
	217, 3, 218, 3, 218, 3, 218, 3, 218, 7, 218, 2909, 10, 218, 12, 218, 14,
	218, 2912, 11, 218, 3, 218, 3, 218, 3, 219, 3, 219, 3, 219, 3, 219, 3,
	219, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 2925, 10, 219, 3, 219, 3,
	219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 2934, 10, 219, 3,
	219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 3,
	219, 3, 219, 3, 219, 3, 219, 5, 219, 2949, 10, 219, 3, 219, 3, 219, 3,
	219, 3, 219, 5, 219, 2955, 10, 219, 3, 219, 3, 219, 5, 219, 2959, 10, 219,
	3, 219, 3, 219, 3, 219, 3, 219, 3, 219, 5, 219, 2966, 10, 219, 3, 220,
	3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220, 3, 220,
	3, 220, 3, 220, 3, 221, 3, 221, 3, 221, 3, 221, 7, 221, 2984, 10, 221,
	12, 221, 14, 221, 2987, 11, 221, 3, 221, 3, 221, 3, 222, 3, 222, 3, 222,
	3, 222, 5, 222, 2995, 10, 222, 3, 222, 5, 222, 2998, 10, 222, 3, 222, 3,
	222, 3, 222, 3, 222, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3, 223, 3,
	224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 224, 3, 224, 3,
	224, 5, 224, 3020, 10, 224, 5, 224, 3022, 10, 224, 3, 225, 3, 225, 3, 225,
	3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 3, 225, 5, 225, 3033, 10, 225,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 3, 226,
	3, 226, 3, 226, 3, 226, 3, 226, 3, 226, 5, 226, 3049, 10, 226, 3, 226,
	3, 226, 3, 226, 5, 226, 3054, 10, 226, 7, 226, 3056, 10, 226, 12, 226,
	14, 226, 3059, 11, 226, 3, 226, 3, 226, 5, 226, 3063, 10, 226, 3, 227,
	3, 227, 3, 227, 3, 227, 3, 227, 5, 227, 3070, 10, 227, 3, 227, 3, 227,
	3, 227, 3, 227, 3, 227, 3, 227, 7, 227, 3078, 10, 227, 12, 227, 14, 227,
	3081, 11, 227, 3, 227, 3, 227, 3, 227, 3, 228, 5, 228, 3087, 10, 228, 3,
	228, 5, 228, 3090, 10, 228, 3, 229, 3, 229, 3, 229, 3, 229, 3, 229, 3,
	229, 3, 229, 3, 229, 3, 229, 5, 229, 3101, 10, 229, 3, 230, 3, 230, 5,
	230, 3105, 10, 230, 3, 230, 3, 230, 3, 230, 5, 230, 3110, 10, 230, 3, 231,
	3, 231, 3, 231, 3, 231, 5, 231, 3116, 10, 231, 3, 231, 3, 231, 3, 231,
	5, 231, 3121, 10, 231, 3, 231, 5, 231, 3124, 10, 231, 3, 232, 3, 232, 3,
	232, 3, 232, 3, 233, 3, 233, 3, 233, 7, 233, 3133, 10, 233, 12, 233, 14,
	233, 3136, 11, 233, 3, 234, 3, 234, 3, 234, 3, 234, 3, 234, 3, 234, 5,
	234, 3144, 10, 234, 3, 235, 3, 235, 5, 235, 3148, 10, 235, 3, 235, 3, 235,
	3, 235, 3, 235, 3, 235, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236, 3, 236,
	3, 236, 3, 236, 5, 236, 3163, 10, 236, 3, 237, 3, 237, 3, 237, 3, 237,
	3, 237, 5, 237, 3170, 10, 237, 3, 237, 3, 237, 3, 237, 3, 238, 3, 238,
	3, 238, 3, 238, 3, 238, 3, 238, 3, 238, 5, 238, 3182, 10, 238, 3, 238,
	5, 238, 3185, 10, 238, 3, 238, 3, 238, 5, 238, 3189, 10, 238, 3, 238, 3,
	238, 5, 238, 3193, 10, 238, 3, 239, 3, 239, 3, 239, 3, 239, 3, 239, 3,
	239, 3, 239, 5, 239, 3202, 10, 239, 3, 240, 5, 240, 3205, 10, 240, 3, 240,
	5, 240, 3208, 10, 240, 3, 240, 3, 240, 3, 240, 7, 240, 3213, 10, 240, 12,
	240, 14, 240, 3216, 11, 240, 3, 241, 3, 241, 5, 241, 3220, 10, 241, 3,
	242, 3, 242, 3, 242, 3, 242, 3, 242, 7, 242, 3227, 10, 242, 12, 242, 14,
	242, 3230, 11, 242, 3, 242, 3, 242, 3, 243, 3, 243, 3, 243, 3, 243, 3,
	243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3, 243, 3,
	243, 3, 243, 5, 243, 3249, 10, 243, 5, 243, 3251, 10, 243, 3, 244, 3, 244,
	3, 245, 3, 245, 5, 245, 3257, 10, 245, 3, 245, 3, 245, 3, 245, 7, 245,
	3262, 10, 245, 12, 245, 14, 245, 3265, 11, 245, 3, 246, 3, 246, 5, 246,
	3269, 10, 246, 3, 246, 3, 246, 3, 246, 7, 246, 3274, 10, 246, 12, 246,
	14, 246, 3277, 11, 246, 3, 247, 5, 247, 3280, 10, 247, 3, 247, 3, 247,
	3, 247, 3, 247, 5, 247, 3286, 10, 247, 3, 248, 3, 248, 3, 248, 3, 248,
	5, 248, 3292, 10, 248, 3, 249, 3, 249, 3, 249, 5, 249, 3297, 10, 249, 3,
	249, 3, 249, 3, 249, 3, 249, 5, 249, 3303, 10, 249, 3, 249, 3, 249, 3,
	249, 3, 249, 3, 249, 5, 249, 3310, 10, 249, 3, 250, 3, 250, 3, 250, 3,
	250, 5, 250, 3316, 10, 250, 3, 250, 3, 250, 3, 251, 3, 251, 3, 251, 3,
	251, 3, 251, 5, 251, 3325, 10, 251, 3, 252, 3, 252, 3, 252, 3, 252, 3,
	252, 5, 252, 3332, 10, 252, 5, 252, 3334, 10, 252, 3, 253, 3, 253, 3, 253,
	3, 253, 5, 253, 3340, 10, 253, 3, 253, 5, 253, 3343, 10, 253, 3, 253, 5,
	253, 3346, 10, 253, 3, 253, 3, 253, 3, 254, 5, 254, 3351, 10, 254, 3, 254,
	3, 254, 3, 254, 3, 254, 3, 255, 5, 255, 3358, 10, 255, 3, 255, 3, 255,
	3, 255, 3, 255, 3, 256, 3, 256, 3, 256, 5, 256, 3367, 10, 256, 3, 257,
	3, 257, 3, 257, 5, 257, 3372, 10, 257, 3, 258, 3, 258, 3, 258, 3, 259,
	3, 259, 3, 259, 3, 259, 5, 259, 3381, 10, 259, 5, 259, 3383, 10, 259, 3,
	260, 3, 260, 3, 260, 5, 260, 3388, 10, 260, 3, 261, 3, 261, 3, 261, 3,
	261, 3, 261, 3, 261, 3, 261, 5, 261, 3397, 10, 261, 5, 261, 3399, 10, 261,
	3, 261, 5, 261, 3402, 10, 261, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262,
	3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262, 3, 262,
	3, 262, 3, 262, 5, 262, 3420, 10, 262, 5, 262, 3422, 10, 262, 3, 263, 3,
	263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 3, 263, 5, 263, 3432, 10,
	263, 3, 263, 3, 263, 3, 264, 3, 264, 3, 264, 3, 265, 3, 265, 3, 265, 5,
	265, 3442, 10, 265, 3, 265, 5, 265, 3445, 10, 265, 3, 265, 3, 265, 5, 265,
	3449, 10, 265, 3, 265, 3, 265, 3, 265, 3, 265, 7, 265, 3455, 10, 265, 12,
	265, 14, 265, 3458, 11, 265, 5, 265, 3460, 10, 265, 3, 266, 3, 266, 5,
	266, 3464, 10, 266, 3, 266, 3, 266, 3, 266, 7, 266, 3469, 10, 266, 12,
	266, 14, 266, 3472, 11, 266, 3, 266, 3, 266, 7, 266, 3476, 10, 266, 12,
	266, 14, 266, 3479, 11, 266, 3, 266, 3, 266, 3, 267, 3, 267, 3, 267, 3,
	267, 7, 267, 3487, 10, 267, 12, 267, 14, 267, 3490, 11, 267, 3, 267, 3,
	267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3,
	267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 3,
	267, 3, 267, 3, 267, 3, 267, 3, 267, 3, 267, 5, 267, 3517, 10, 267, 3,
	268, 3, 268, 3, 268, 3, 268, 3, 268, 3, 268, 5, 268, 3525, 10, 268, 3,
	269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3, 269, 3,
	269, 3, 269, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 5, 270, 3543, 10,
	270, 5, 270, 3545, 10, 270, 3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 5,
	270, 3552, 10, 270, 3, 270, 5, 270, 3555, 10, 270, 5, 270, 3557, 10, 270,
	3, 270, 3, 270, 3, 270, 3, 270, 3, 270, 5, 270, 3564, 10, 270, 5, 270,
	3566, 10, 270, 3, 271, 3, 271, 3, 271, 5, 271, 3571, 10, 271, 3, 271, 3,
	271, 3, 271, 7, 271, 3576, 10, 271, 12, 271, 14, 271, 3579, 11, 271, 3,
	272, 3, 272, 5, 272, 3583, 10, 272, 3, 272, 5, 272, 3586, 10, 272, 3, 272,
	3, 272, 5, 272, 3590, 10, 272, 3, 273, 3, 273, 3, 273, 3, 273, 3, 273,
	7, 273, 3597, 10, 273, 12, 273, 14, 273, 3600, 11, 273, 5, 273, 3602, 10,
	273, 3, 274, 3, 274, 3, 274, 3, 274, 7, 274, 3608, 10, 274, 12, 274, 14,
	274, 3611, 11, 274, 3, 274, 5, 274, 3614, 10, 274, 3, 275, 3, 275, 5, 275,
	3618, 10, 275, 3, 275, 3, 275, 3, 275, 5, 275, 3623, 10, 275, 3, 275, 3,
	275, 3, 275, 5, 275, 3628, 10, 275, 3, 276, 3, 276, 5, 276, 3632, 10, 276,
	3, 276, 3, 276, 3, 277, 3, 277, 3, 277, 3, 277, 3, 277, 7, 277, 3641, 10,
	277, 12, 277, 14, 277, 3644, 11, 277, 3, 277, 3, 277, 3, 278, 3, 278, 5,
	278, 3650, 10, 278, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279, 3656, 10, 279,
	3, 279, 3, 279, 5, 279, 3660, 10, 279, 3, 279, 3, 279, 5, 279, 3664, 10,
	279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 3, 279, 5, 279, 3672, 10,
	279, 5, 279, 3674, 10, 279, 3, 279, 5, 279, 3677, 10, 279, 3, 279, 3, 279,
	3, 280, 3, 280, 3, 280, 5, 280, 3684, 10, 280, 3, 280, 3, 280, 3, 280,
	5, 280, 3689, 10, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280, 3, 280,
	3, 280, 5, 280, 3698, 10, 280, 3, 281, 3, 281, 3, 281, 5, 281, 3703, 10,
	281, 3, 281, 3, 281, 3, 281, 3, 281, 7, 281, 3709, 10, 281, 12, 281, 14,
	281, 3712, 11, 281, 3, 281, 3, 281, 3, 281, 3, 281, 5, 281, 3718, 10, 281,
	3, 282, 3, 282, 3, 282, 3, 282, 3, 283, 3, 283, 5, 283, 3726, 10, 283,
	3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 5, 283, 3735, 10,
	283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3, 283, 3,
	283, 3, 283, 5, 283, 3747, 10, 283, 3, 284, 3, 284, 3, 284, 3, 284, 3,
	284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 3, 284, 7, 284, 3761,
	10, 284, 12, 284, 14, 284, 3764, 11, 284, 5, 284, 3766, 10, 284, 5, 284,
	3768, 10, 284, 3, 285, 5, 285, 3771, 10, 285, 3, 285, 5, 285, 3774, 10,
	285, 3, 285, 5, 285, 3777, 10, 285, 3, 285, 5, 285, 3780, 10, 285, 3, 286,
	3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286,
	3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 3, 286, 5, 286, 3798, 10, 286,
	3, 287, 3, 287, 3, 287, 5, 287, 3803, 10, 287, 3, 287, 3, 287, 3, 287,
	5, 287, 3808, 10, 287, 3, 287, 3, 287, 3, 287, 5, 287, 3813, 10, 287, 3,
	287, 5, 287, 3816, 10, 287, 7, 287, 3818, 10, 287, 12, 287, 14, 287, 3821,
	11, 287, 3, 287, 3, 287, 3, 288, 3, 288, 3, 288, 5, 288, 3828, 10, 288,
	3, 289, 3, 289, 3, 289, 3, 289, 3, 289, 3, 289, 3, 289, 3, 289, 7, 289,
	3838, 10, 289, 12, 289, 14, 289, 3841, 11, 289, 5, 289, 3843, 10, 289,
	3, 289, 5, 289, 3846, 10, 289, 3, 289, 3, 289, 3, 289, 3, 289, 3, 289,
	3, 290, 3, 290, 3, 290, 3, 290, 3, 290, 3, 290, 7, 290, 3859, 10, 290,
	12, 290, 14, 290, 3862, 11, 290, 5, 290, 3864, 10, 290, 3, 290, 5, 290,
	3867, 10, 290, 3, 290, 3, 290, 5, 290, 3871, 10, 290, 3, 290, 3, 290, 5,
	290, 3875, 10, 290, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3, 291, 7,
	291, 3883, 10, 291, 12, 291, 14, 291, 3886, 11, 291, 5, 291, 3888, 10,
	291, 3, 291, 5, 291, 3891, 10, 291, 3, 291, 3, 291, 3, 291, 3, 291, 3,
	291, 3, 292, 3, 292, 3, 292, 3, 292, 5, 292, 3902, 10, 292, 3, 292, 7,
	292, 3905, 10, 292, 12, 292, 14, 292, 3908, 11, 292, 3, 293, 7, 293, 3911,
	10, 293, 12, 293, 14, 293, 3914, 11, 293, 3, 294, 5, 294, 3917, 10, 294,
	3, 294, 5, 294, 3920, 10, 294, 3, 294, 3, 294, 3, 294, 3, 294, 3, 294,
	3, 294, 3, 294, 3, 294, 3, 294, 5, 294, 3931, 10, 294, 3, 294, 5, 294,
	3934, 10, 294, 3, 294, 3, 294, 3, 294, 5, 294, 3939, 10, 294, 5, 294, 3941,
	10, 294, 3, 295, 3, 295, 3, 295, 3, 295, 3, 295, 3, 295, 3, 295, 3, 295,
	3, 295, 3, 295, 5, 295, 3953, 10, 295, 3, 295, 5, 295, 3956, 10, 295, 3,
	296, 3, 296, 3, 296, 7, 296, 3961, 10, 296, 12, 296, 14, 296, 3964, 11,
	296, 5, 296, 3966, 10, 296, 3, 297, 3, 297, 5, 297, 3970, 10, 297, 3, 297,
	3, 297, 5, 297, 3974, 10, 297, 3, 297, 5, 297, 3977, 10, 297, 3, 298, 5,
	298, 3980, 10, 298, 3, 298, 3, 298, 5, 298, 3984, 10, 298, 3, 298, 3, 298,
	3, 298, 3, 299, 3, 299, 3, 299, 3, 299, 7, 299, 3993, 10, 299, 12, 299,
	14, 299, 3996, 11, 299, 5, 299, 3998, 10, 299, 3, 300, 3, 300, 3, 300,
	3, 300, 3, 300, 5, 300, 4005, 10, 300, 3, 301, 5, 301, 4008, 10, 301, 3,
	301, 3, 301, 5, 301, 4012, 10, 301, 3, 301, 3, 301, 3, 301, 3, 301, 3,
	301, 5, 301, 4019, 10, 301, 3, 301, 3, 301, 3, 301, 5, 301, 4024, 10, 301,
	3, 301, 3, 301, 3, 301, 3, 301, 3, 301, 3, 301, 3, 301, 7, 301, 4033, 10,
	301, 12, 301, 14, 301, 4036, 11, 301, 3, 301, 3, 301, 5, 301, 4040, 10,
	301, 5, 301, 4042, 10, 301, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 3,
	302, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 5, 302, 4055, 10, 302, 3,
	302, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 3, 302, 5,
	302, 4066, 10, 302, 3, 303, 3, 303, 3, 303, 3, 303, 7, 303, 4072, 10, 303,
	12, 303, 14, 303, 4075, 11, 303, 5, 303, 4077, 10, 303, 3, 303, 3, 303,
	5, 303, 4081, 10, 303, 3, 303, 3, 303, 3, 303, 3, 303, 5, 303, 4087, 10,
	303, 3, 304, 3, 304, 3, 305, 3, 305, 3, 305, 3, 305, 7, 305, 4095, 10,
	305, 12, 305, 14, 305, 4098, 11, 305, 3, 306, 3, 306, 3, 306, 3, 306, 3,
	306, 7, 306, 4105, 10, 306, 12, 306, 14, 306, 4108, 11, 306, 3, 306, 3,
	306, 5, 306, 4112, 10, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3, 306, 3,
	307, 3, 307, 3, 307, 3, 307, 3, 307, 5, 307, 4124, 10, 307, 3, 307, 3,
	307, 3, 307, 3, 307, 5, 307, 4130, 10, 307, 3, 307, 5, 307, 4133, 10, 307,
	3, 307, 5, 307, 4136, 10, 307, 3, 307, 5, 307, 4139, 10, 307, 3, 307, 5,
	307, 4142, 10, 307, 3, 307, 5, 307, 4145, 10, 307, 3, 307, 5, 307, 4148,
	10, 307, 3, 307, 3, 307, 5, 307, 4152, 10, 307, 3, 307, 3, 307, 3, 307,
	5, 307, 4157, 10, 307, 3, 307, 3, 307, 3, 307, 3, 307, 3, 307, 5, 307,
	4164, 10, 307, 3, 308, 3, 308, 3, 308, 3, 308, 3, 308, 5, 308, 4171, 10,
	308, 3, 309, 3, 309, 3, 309, 3, 309, 3, 309, 3, 309, 3, 310, 3, 310, 3,
	310, 3, 310, 3, 310, 5, 310, 4184, 10, 310, 3, 311, 3, 311, 3, 311, 3,
	311, 3, 311, 3, 311, 3, 311, 3, 311, 3, 311, 3, 311, 5, 311, 4196, 10,
	311, 3, 311, 3, 311, 3, 311, 3, 311, 5, 311, 4202, 10, 311, 3, 311, 3,
	311, 3, 311, 3, 311, 3, 311, 3, 311, 3, 311, 5, 311, 4211, 10, 311, 3,
	311, 5, 311, 4214, 10, 311, 3, 312, 3, 312, 5, 312, 4218, 10, 312, 3, 312,
	3, 312, 5, 312, 4222, 10, 312, 3, 312, 3, 312, 3, 312, 3, 312, 3, 312,
	7, 312, 4229, 10, 312, 12, 312, 14, 312, 4232, 11, 312, 3, 312, 3, 312,
	5, 312, 4236, 10, 312, 3, 312, 3, 312, 3, 312, 3, 312, 3, 312, 3, 312,
	3, 312, 5, 312, 4245, 10, 312, 5, 312, 4247, 10, 312, 3, 312, 3, 312, 3,
	312, 5, 312, 4252, 10, 312, 5, 312, 4254, 10, 312, 3, 313, 3, 313, 3, 313,
	7, 313, 4259, 10, 313, 12, 313, 14, 313, 4262, 11, 313, 3, 314, 3, 314,
	3, 314, 3, 314, 3, 314, 3, 314, 7, 314, 4270, 10, 314, 12, 314, 14, 314,
	4273, 11, 314, 3, 314, 3, 314, 3, 314, 3, 314, 3, 314, 3, 314, 5, 314,
	4281, 10, 314, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 5, 315, 4288, 10,
	315, 5, 315, 4290, 10, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 7,
	315, 4297, 10, 315, 12, 315, 14, 315, 4300, 11, 315, 3, 315, 3, 315, 5,
	315, 4304, 10, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 5, 315, 4311,
	10, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 5, 315, 4318, 10, 315,
	3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 3, 315,
	3, 315, 3, 315, 3, 315, 3, 315, 3, 315, 7, 315, 4334, 10, 315, 12, 315,
	14, 315, 4337, 11, 315, 3, 315, 3, 315, 5, 315, 4341, 10, 315, 3, 315,
	3, 315, 5, 315, 4345, 10, 315, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316,
	3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316,
	3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316,
	3, 316, 3, 316, 5, 316, 4372, 10, 316, 3, 316, 5, 316, 4375, 10, 316, 3,
	316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 5, 316, 4384, 10,
	316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3,
	316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3, 316, 3,
	316, 3, 316, 3, 316, 3, 316, 7, 316, 4407, 10, 316, 12, 316, 14, 316, 4410,
	11, 316, 5, 316, 4412, 10, 316, 5, 316, 4414, 10, 316, 3, 317, 3, 317,
	3, 317, 5, 317, 4419, 10, 317, 3, 318, 3, 318, 3, 318, 3, 318, 3, 318,
	3, 318, 5, 318, 4427, 10, 318, 3, 319, 3, 319, 3, 319, 3, 319, 3, 319,
	3, 319, 3, 319, 3, 319, 3, 319, 3, 319, 3, 319, 3, 319, 3, 319, 3, 319,
	3, 319, 3, 319, 3, 319, 3, 319, 3, 319, 5, 319, 4448, 10, 319, 5, 319,
	4450, 10, 319, 3, 320, 3, 320, 3, 320, 3, 320, 3, 320, 3, 320, 3, 320,
	5, 320, 4459, 10, 320, 3, 320, 5, 320, 4462, 10, 320, 3, 321, 3, 321, 3,
	321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 7,
	321, 4475, 10, 321, 12, 321, 14, 321, 4478, 11, 321, 3, 321, 3, 321, 5,
	321, 4482, 10, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 7, 321, 4489,
	10, 321, 12, 321, 14, 321, 4492, 11, 321, 3, 321, 3, 321, 3, 321, 3, 321,
	3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321, 3, 321,
	3, 321, 3, 321, 7, 321, 4509, 10, 321, 12, 321, 14, 321, 4512, 11, 321,
	5, 321, 4514, 10, 321, 3, 321, 3, 321, 5, 321, 4518, 10, 321, 3, 322, 3,
	322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 3, 322, 5,
	322, 4530, 10, 322, 5, 322, 4532, 10, 322, 3, 323, 3, 323, 3, 323, 3, 323,
	3, 323, 3, 323, 3, 323, 3, 323, 3, 323, 3, 323, 3, 323, 5, 323, 4545, 10,
	323, 5, 323, 4547, 10, 323, 3, 324, 3, 324, 3, 324, 3, 324, 3, 324, 3,
	324, 3, 324, 3, 324, 5, 324, 4557, 10, 324, 3, 325, 3, 325, 3, 325, 3,
	325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3,
	325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3,
	325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3,
	325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3, 325, 3,
	325, 3, 325, 3, 325, 3, 325, 5, 325, 4602, 10, 325, 3, 326, 3, 326, 3,
	326, 3, 326, 5, 326, 4608, 10, 326, 3, 327, 3, 327, 3, 327, 3, 327, 3,
	327, 3, 327, 3, 327, 5, 327, 4617, 10, 327, 3, 327, 3, 327, 3, 327, 3,
	327, 3, 327, 3, 327, 3, 327, 3, 327, 3, 327, 3, 327, 3, 327, 3, 327, 3,
	327, 5, 327, 4632, 10, 327, 3, 328, 3, 328, 5, 328, 4636, 10, 328, 3, 329,
	3, 329, 3, 329, 3, 329, 3, 329, 7, 329, 4643, 10, 329, 12, 329, 14, 329,
	4646, 11, 329, 3, 329, 3, 329, 3, 329, 5, 329, 4651, 10, 329, 3, 329, 3,
	329, 3, 329, 3, 329, 3, 329, 3, 329, 7, 329, 4659, 10, 329, 12, 329, 14,
	329, 4662, 11, 329, 3, 329, 3, 329, 3, 329, 3, 329, 3, 329, 3, 329, 5,
	329, 4670, 10, 329, 3, 330, 3, 330, 3, 330, 3, 330, 3, 330, 3, 330, 3,
	330, 3, 330, 3, 330, 5, 330, 4681, 10, 330, 3, 331, 3, 331, 3, 331, 3,
	331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 5, 331, 4693, 10,
	331, 5, 331, 4695, 10, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3, 331, 3,
	331, 5, 331, 4703, 10, 331, 3, 332, 3, 332, 3, 332, 3, 332, 3, 332, 3,
	332, 3, 332, 3, 333, 3, 333, 3, 333, 3, 333, 3, 333, 5, 333, 4717, 10,
	333, 3, 333, 3, 333, 3, 333, 3, 333, 7, 333, 4723, 10, 333, 12, 333, 14,
	333, 4726, 11, 333, 3, 333, 3, 333, 5, 333, 4730, 10, 333, 5, 333, 4732,
	10, 333, 3, 334, 3, 334, 3, 334, 3, 334, 3, 334, 3, 334, 3, 334, 5, 334,
	4741, 10, 334, 3, 335, 3, 335, 3, 335, 3, 335, 5, 335, 4747, 10, 335, 3,
	336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3,
	336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3, 336, 3,
	336, 5, 336, 4768, 10, 336, 3, 337, 3, 337, 3, 337, 3, 337, 3, 337, 5,
	337, 4775, 10, 337, 3, 337, 3, 337, 3, 337, 3, 337, 7, 337, 4781, 10, 337,
	12, 337, 14, 337, 4784, 11, 337, 3, 337, 3, 337, 5, 337, 4788, 10, 337,
	5, 337, 4790, 10, 337, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338,
	3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338,
	3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338,
	3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338, 3, 338,
	3, 338, 3, 338, 3, 338, 3, 338, 7, 338, 4829, 10, 338, 12, 338, 14, 338,
	4832, 11, 338, 3, 338, 3, 338, 5, 338, 4836, 10, 338, 3, 339, 3, 339, 3,
	339, 3, 339, 3, 339, 3, 339, 3, 339, 3, 339, 3, 339, 3, 339, 3, 339, 3,
	339, 3, 339, 5, 339, 4851, 10, 339, 3, 340, 3, 340, 3, 340, 3, 340, 3,
	340, 3, 340, 5, 340, 4859, 10, 340, 3, 341, 3, 341, 3, 341, 3, 341, 3,
	341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3,
	341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 3, 341, 5, 341, 4882,
	10, 341, 3, 342, 3, 342, 3, 342, 3, 342, 3, 342, 3, 342, 3, 342, 5, 342,
	4891, 10, 342, 3, 343, 3, 343, 3, 343, 3, 343, 3, 343, 3, 343, 5, 343,
	4899, 10, 343, 3, 344, 3, 344, 3, 344, 3, 344, 3, 344, 3, 345, 3, 345,
	3, 345, 3, 345, 5, 345, 4910, 10, 345, 3, 345, 3, 345, 3, 345, 5, 345,
	4915, 10, 345, 3, 346, 3, 346, 3, 346, 3, 346, 7, 346, 4921, 10, 346, 12,
	346, 14, 346, 4924, 11, 346, 3, 346, 3, 346, 3, 347, 3, 347, 3, 347, 3,
	347, 7, 347, 4932, 10, 347, 12, 347, 14, 347, 4935, 11, 347, 3, 347, 3,
	347, 3, 348, 3, 348, 3, 348, 3, 348, 3, 348, 3, 348, 5, 348, 4945, 10,
	348, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 3, 349, 5, 349, 4954,
	10, 349, 3, 350, 3, 350, 3, 350, 3, 350, 3, 350, 5, 350, 4961, 10, 350,
	3, 351, 3, 351, 5, 351, 4965, 10, 351, 3, 352, 3, 352, 3, 352, 3, 352,
	5, 352, 4971, 10, 352, 3, 352, 3, 352, 3, 352, 3, 352, 3, 352, 3, 353,
	3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353, 3, 353,
	3, 353, 3, 353, 3, 353, 3, 353, 5, 353, 4992, 10, 353, 3, 353, 3, 353,
	3, 353, 3, 354, 3, 354, 3, 354, 3, 354, 3, 354, 3, 354, 3, 354, 7, 354,
	5004, 10, 354, 12, 354, 14, 354, 5007, 11, 354, 5, 354, 5009, 10, 354,
	3, 354, 3, 354, 3, 355, 3, 355, 3, 355, 3, 355, 3, 355, 7, 355, 5018, 10,
	355, 12, 355, 14, 355, 5021, 11, 355, 3, 355, 3, 355, 5, 355, 5025, 10,
	355, 3, 356, 3, 356, 3, 356, 3, 356, 5, 356, 5031, 10, 356, 3, 357, 3,
	357, 5, 357, 5035, 10, 357, 3, 357, 3, 357, 3, 357, 5, 357, 5040, 10, 357,
	3, 358, 3, 358, 3, 358, 5, 358, 5045, 10, 358, 3, 359, 3, 359, 3, 359,
	5, 359, 5050, 10, 359, 3, 360, 3, 360, 3, 360, 5, 360, 5055, 10, 360, 3,
	361, 3, 361, 3, 361, 3, 361, 3, 362, 3, 362, 5, 362, 5063, 10, 362, 3,
	362, 3, 362, 3, 362, 5, 362, 5068, 10, 362, 7, 362, 5070, 10, 362, 12,
	362, 14, 362, 5073, 11, 362, 3, 363, 5, 363, 5076, 10, 363, 3, 363, 3,
	363, 3, 364, 3, 364, 3, 364, 7, 364, 5083, 10, 364, 12, 364, 14, 364, 5086,
	11, 364, 3, 365, 5, 365, 5089, 10, 365, 3, 365, 3, 365, 3, 366, 3, 366,
	5, 366, 5095, 10, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366,
	3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366, 3, 366,
	5, 366, 5112, 10, 366, 3, 367, 3, 367, 5, 367, 5116, 10, 367, 3, 367, 3,
	367, 3, 367, 3, 367, 3, 367, 5, 367, 5123, 10, 367, 3, 367, 3, 367, 3,
	367, 3, 367, 3, 367, 3, 367, 3, 367, 3, 367, 5, 367, 5133, 10, 367, 3,
	368, 3, 368, 3, 368, 3, 368, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 5, 369, 5145, 10, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 5, 369, 5166, 10, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 5, 369, 5180, 10, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3, 369, 3,
	369, 5, 369, 5214, 10, 369, 3, 370, 3, 370, 3, 370, 3, 370, 3, 370, 3,
	370, 5, 370, 5222, 10, 370, 5, 370, 5224, 10, 370, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 5, 371, 5240, 10, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	5, 371, 5246, 10, 371, 3, 371, 3, 371, 5, 371, 5250, 10, 371, 3, 371, 3,
	371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 5, 371, 5261,
	10, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 5, 371, 5274, 10, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 5, 371, 5289, 10, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 5, 371, 5326, 10, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 5, 371, 5333, 10, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 5, 371, 5341, 10, 371, 3, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 5, 371, 5350, 10, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 5, 371, 5358, 10, 371, 3, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 5, 371, 5367, 10, 371, 3, 371, 3, 371,
	3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 3, 371, 5, 371,
	5379, 10, 371, 3, 372, 3, 372, 3, 372, 3, 372, 3, 372, 5, 372, 5386, 10,
	372, 3, 372, 5, 372, 5389, 10, 372, 5, 372, 5391, 10, 372, 3, 373, 3, 373,
	3, 373, 3, 373, 3, 373, 3, 373, 3, 373, 3, 373, 5, 373, 5401, 10, 373,
	3, 374, 3, 374, 3, 374, 3, 374, 3, 374, 3, 374, 3, 374, 3, 374, 3, 374,
	3, 374, 5, 374, 5413, 10, 374, 3, 375, 3, 375, 3, 375, 3, 375, 3, 376,
	3, 376, 3, 376, 3, 376, 3, 377, 3, 377, 3, 377, 3, 377, 3, 377, 3, 378,
	3, 378, 3, 378, 3, 378, 3, 378, 3, 379, 3, 379, 3, 379, 3, 379, 3, 380,
	3, 380, 3, 380, 3, 380, 3, 380, 5, 380, 5442, 10, 380, 3, 381, 3, 381,
	3, 381, 3, 381, 3, 381, 3, 382, 3, 382, 3, 382, 3, 382, 3, 383, 3, 383,
	3, 383, 3, 383, 3, 384, 3, 384, 3, 385, 3, 385, 3, 385, 3, 386, 3, 386,
	3, 386, 3, 387, 3, 387, 3, 387, 3, 388, 3, 388, 3, 388, 3, 389, 3, 389,
	3, 389, 3, 390, 3, 390, 3, 390, 3, 391, 3, 391, 3, 391, 3, 392, 3, 392,
	3, 392, 3, 393, 3, 393, 3, 393, 3, 394, 3, 394, 3, 394, 3, 395, 3, 395,
	3, 395, 3, 395, 3, 395, 3, 395, 3, 395, 3, 395, 5, 395, 5497, 10, 395,
	3, 395, 3, 395, 3, 395, 3, 395, 3, 396, 3, 396, 3, 397, 3, 397, 3, 397,
	3, 397, 5, 397, 5509, 10, 397, 3, 397, 3, 397, 3, 397, 3, 397, 5, 397,
	5515, 10, 397, 5, 397, 5517, 10, 397, 5, 397, 5519, 10, 397, 3, 398, 3,
	398, 3, 398, 3, 398, 3, 398, 5, 398, 5526, 10, 398, 3, 399, 3, 399, 3,
	399, 3, 399, 5, 399, 5532, 10, 399, 5, 399, 5534, 10, 399, 3, 399, 3, 399,
	3, 399, 3, 399, 3, 399, 3, 399, 5, 399, 5542, 10, 399, 3, 400, 3, 400,
	5, 400, 5546, 10, 400, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401, 3, 401,
	5, 401, 5554, 10, 401, 3, 402, 3, 402, 5, 402, 5558, 10, 402, 3, 403, 3,
	403, 3, 403, 3, 403, 5, 403, 5564, 10, 403, 3, 404, 3, 404, 3, 405, 3,
	405, 5, 405, 5570, 10, 405, 3, 405, 3, 405, 3, 406, 3, 406, 3, 406, 3,
	406, 3, 406, 5, 406, 5579, 10, 406, 3, 406, 2, 6, 156, 164, 170, 172, 407,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
	200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
	230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
	260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
	290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
	320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
	350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
	380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
	410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
	440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468,
	470, 472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498,
	500, 502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528,
	530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558,
	560, 562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588,
	590, 592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618,
	620, 622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648,
	650, 652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678,
	680, 682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708,
	710, 712, 714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738,
	740, 742, 744, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768,
	770, 772, 774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798,
	800, 802, 804, 806, 808, 810, 2, 85, 4, 2, 79, 79, 113, 113, 4, 2, 89,
	89, 93, 93, 4, 2, 88, 88, 91, 92, 3, 2, 439, 440, 4, 2, 116, 116, 262,
	262, 5, 2, 190, 190, 262, 262, 305, 305, 4, 2, 190, 191, 262, 262, 4, 2,
	156, 156, 195, 195, 3, 2, 199, 200, 3, 2, 134, 136, 3, 2, 108, 109, 49,
	2, 54, 54, 70, 71, 82, 82, 117, 117, 122, 123, 127, 128, 132, 132, 134,
	134, 137, 138, 140, 140, 142, 143, 147, 152, 155, 156, 158, 158, 160, 161,
	163, 165, 168, 169, 172, 172, 175, 175, 202, 203, 208, 208, 213, 213, 215,
	221, 223, 224, 233, 234, 237, 241, 243, 244, 246, 256, 258, 263, 265, 273,
	275, 296, 304, 418, 420, 420, 426, 426, 438, 440, 477, 477, 479, 485, 487,
	492, 495, 495, 497, 502, 507, 507, 512, 513, 515, 517, 519, 521, 523, 532,
	543, 638, 640, 640, 3, 2, 644, 645, 4, 2, 4, 4, 103, 103, 4, 2, 5, 5, 104,
	104, 4, 2, 6, 6, 106, 106, 4, 2, 107, 109, 222, 222, 3, 2, 113, 114, 3,
	2, 24, 29, 5, 2, 6, 7, 15, 16, 213, 213, 3, 2, 148, 152, 3, 2, 220, 221,
	4, 2, 168, 168, 420, 420, 3, 2, 119, 120, 4, 2, 244, 244, 254, 254, 10,
	2, 130, 130, 134, 135, 172, 174, 176, 184, 213, 213, 329, 329, 422, 437,
	644, 644, 4, 2, 221, 221, 285, 285, 4, 2, 385, 385, 402, 402, 7, 2, 220,
	220, 243, 243, 274, 274, 279, 279, 382, 382, 11, 2, 277, 277, 289, 289,
	378, 379, 385, 385, 394, 395, 399, 400, 405, 405, 417, 417, 471, 471, 4,
	2, 97, 97, 276, 276, 5, 2, 239, 239, 274, 274, 292, 292, 3, 2, 298, 299,
	4, 2, 175, 175, 275, 275, 3, 2, 72, 73, 4, 2, 234, 234, 257, 257, 4, 2,
	252, 252, 284, 284, 3, 2, 240, 241, 3, 2, 49, 50, 4, 2, 107, 107, 153,
	153, 5, 2, 220, 220, 274, 274, 279, 279, 4, 2, 265, 266, 280, 280, 3, 2,
	397, 398, 3, 2, 91, 92, 4, 2, 226, 226, 273, 273, 3, 2, 155, 156, 5, 2,
	139, 139, 141, 143, 246, 249, 5, 2, 60, 60, 156, 156, 238, 238, 4, 2, 274,
	274, 476, 476, 5, 2, 88, 88, 202, 202, 276, 276, 3, 2, 482, 485, 4, 2,
	13, 13, 482, 485, 3, 2, 492, 493, 3, 2, 494, 497, 4, 2, 202, 202, 498,
	499, 5, 2, 210, 210, 438, 438, 506, 506, 5, 2, 346, 346, 501, 501, 517,
	517, 4, 2, 234, 234, 526, 526, 4, 2, 113, 113, 228, 228, 3, 2, 622, 623,
	3, 2, 483, 484, 6, 2, 97, 97, 276, 276, 530, 530, 616, 616, 4, 2, 277,
	277, 614, 615, 4, 2, 202, 202, 541, 541, 3, 2, 611, 613, 4, 2, 200, 200,
	608, 609, 3, 2, 538, 539, 4, 2, 210, 210, 540, 540, 4, 2, 249, 250, 592,
	592, 4, 2, 165, 165, 590, 590, 4, 2, 238, 238, 276, 276, 6, 2, 113, 113,
	238, 238, 274, 274, 585, 585, 4, 2, 249, 249, 592, 592, 5, 2, 88, 88, 199,
	199, 570, 570, 4, 2, 274, 274, 568, 569, 4, 2, 250, 250, 548, 548, 4, 2,
	203, 203, 308, 308, 3, 2, 311, 312, 4, 2, 203, 203, 313, 313, 3, 2, 346,
	347, 4, 2, 203, 203, 370, 370, 7, 2, 55, 55, 203, 203, 232, 233, 269, 269,
	275, 275, 4, 2, 235, 235, 295, 295, 2, 6286, 2, 867, 3, 2, 2, 2, 4, 873,
	3, 2, 2, 2, 6, 895, 3, 2, 2, 2, 8, 904, 3, 2, 2, 2, 10, 919, 3, 2, 2, 2,
	12, 927, 3, 2, 2, 2, 14, 942, 3, 2, 2, 2, 16, 946, 3, 2, 2, 2, 18, 971,
	3, 2, 2, 2, 20, 975, 3, 2, 2, 2, 22, 978, 3, 2, 2, 2, 24, 999, 3, 2, 2,
	2, 26, 1023, 3, 2, 2, 2, 28, 1025, 3, 2, 2, 2, 30, 1039, 3, 2, 2, 2, 32,
	1041, 3, 2, 2, 2, 34, 1056, 3, 2, 2, 2, 36, 1076, 3, 2, 2, 2, 38, 1080,
	3, 2, 2, 2, 40, 1101, 3, 2, 2, 2, 42, 1103, 3, 2, 2, 2, 44, 1130, 3, 2,
	2, 2, 46, 1134, 3, 2, 2, 2, 48, 1136, 3, 2, 2, 2, 50, 1138, 3, 2, 2, 2,
	52, 1141, 3, 2, 2, 2, 54, 1144, 3, 2, 2, 2, 56, 1152, 3, 2, 2, 2, 58, 1178,
	3, 2, 2, 2, 60, 1204, 3, 2, 2, 2, 62, 1210, 3, 2, 2, 2, 64, 1212, 3, 2,
	2, 2, 66, 1215, 3, 2, 2, 2, 68, 1225, 3, 2, 2, 2, 70, 1228, 3, 2, 2, 2,
	72, 1232, 3, 2, 2, 2, 74, 1241, 3, 2, 2, 2, 76, 1248, 3, 2, 2, 2, 78, 1260,
	3, 2, 2, 2, 80, 1268, 3, 2, 2, 2, 82, 1277, 3, 2, 2, 2, 84, 1283, 3, 2,
	2, 2, 86, 1355, 3, 2, 2, 2, 88, 1411, 3, 2, 2, 2, 90, 1413, 3, 2, 2, 2,
	92, 1422, 3, 2, 2, 2, 94, 1424, 3, 2, 2, 2, 96, 1427, 3, 2, 2, 2, 98, 1438,
	3, 2, 2, 2, 100, 1440, 3, 2, 2, 2, 102, 1442, 3, 2, 2, 2, 104, 1444, 3,
	2, 2, 2, 106, 1446, 3, 2, 2, 2, 108, 1450, 3, 2, 2, 2, 110, 1452, 3, 2,
	2, 2, 112, 1454, 3, 2, 2, 2, 114, 1456, 3, 2, 2, 2, 116, 1461, 3, 2, 2,
	2, 118, 1468, 3, 2, 2, 2, 120, 1478, 3, 2, 2, 2, 122, 1485, 3, 2, 2, 2,
	124, 1492, 3, 2, 2, 2, 126, 1499, 3, 2, 2, 2, 128, 1506, 3, 2, 2, 2, 130,
	1510, 3, 2, 2, 2, 132, 1512, 3, 2, 2, 2, 134, 1517, 3, 2, 2, 2, 136, 1521,
	3, 2, 2, 2, 138, 1523, 3, 2, 2, 2, 140, 1525, 3, 2, 2, 2, 142, 1536, 3,
	2, 2, 2, 144, 1548, 3, 2, 2, 2, 146, 1561, 3, 2, 2, 2, 148, 1563, 3, 2,
	2, 2, 150, 1565, 3, 2, 2, 2, 152, 1567, 3, 2, 2, 2, 154, 1578, 3, 2, 2,
	2, 156, 1591, 3, 2, 2, 2, 158, 1606, 3, 2, 2, 2, 160, 1608, 3, 2, 2, 2,
	162, 1610, 3, 2, 2, 2, 164, 1612, 3, 2, 2, 2, 166, 1638, 3, 2, 2, 2, 168,
	1683, 3, 2, 2, 2, 170, 1685, 3, 2, 2, 2, 172, 1756, 3, 2, 2, 2, 174, 1769,
	3, 2, 2, 2, 176, 1771, 3, 2, 2, 2, 178, 1789, 3, 2, 2, 2, 180, 1791, 3,
	2, 2, 2, 182, 1795, 3, 2, 2, 2, 184, 1797, 3, 2, 2, 2, 186, 1804, 3, 2,
	2, 2, 188, 1820, 3, 2, 2, 2, 190, 1845, 3, 2, 2, 2, 192, 1847, 3, 2, 2,
	2, 194, 1861, 3, 2, 2, 2, 196, 1866, 3, 2, 2, 2, 198, 1873, 3, 2, 2, 2,
	200, 1875, 3, 2, 2, 2, 202, 1901, 3, 2, 2, 2, 204, 1913, 3, 2, 2, 2, 206,
	1929, 3, 2, 2, 2, 208, 1931, 3, 2, 2, 2, 210, 1939, 3, 2, 2, 2, 212, 1951,
	3, 2, 2, 2, 214, 1964, 3, 2, 2, 2, 216, 1967, 3, 2, 2, 2, 218, 1980, 3,
	2, 2, 2, 220, 1990, 3, 2, 2, 2, 222, 1995, 3, 2, 2, 2, 224, 1997, 3, 2,
	2, 2, 226, 2004, 3, 2, 2, 2, 228, 2012, 3, 2, 2, 2, 230, 2020, 3, 2, 2,
	2, 232, 2022, 3, 2, 2, 2, 234, 2039, 3, 2, 2, 2, 236, 2041, 3, 2, 2, 2,
	238, 2045, 3, 2, 2, 2, 240, 2050, 3, 2, 2, 2, 242, 2053, 3, 2, 2, 2, 244,
	2055, 3, 2, 2, 2, 246, 2058, 3, 2, 2, 2, 248, 2064, 3, 2, 2, 2, 250, 2074,
	3, 2, 2, 2, 252, 2076, 3, 2, 2, 2, 254, 2080, 3, 2, 2, 2, 256, 2094, 3,
	2, 2, 2, 258, 2101, 3, 2, 2, 2, 260, 2103, 3, 2, 2, 2, 262, 2111, 3, 2,
	2, 2, 264, 2113, 3, 2, 2, 2, 266, 2116, 3, 2, 2, 2, 268, 2124, 3, 2, 2,
	2, 270, 2126, 3, 2, 2, 2, 272, 2128, 3, 2, 2, 2, 274, 2130, 3, 2, 2, 2,
	276, 2132, 3, 2, 2, 2, 278, 2136, 3, 2, 2, 2, 280, 2138, 3, 2, 2, 2, 282,
	2144, 3, 2, 2, 2, 284, 2153, 3, 2, 2, 2, 286, 2158, 3, 2, 2, 2, 288, 2168,
	3, 2, 2, 2, 290, 2178, 3, 2, 2, 2, 292, 2187, 3, 2, 2, 2, 294, 2198, 3,
	2, 2, 2, 296, 2207, 3, 2, 2, 2, 298, 2220, 3, 2, 2, 2, 300, 2229, 3, 2,
	2, 2, 302, 2240, 3, 2, 2, 2, 304, 2250, 3, 2, 2, 2, 306, 2262, 3, 2, 2,
	2, 308, 2268, 3, 2, 2, 2, 310, 2274, 3, 2, 2, 2, 312, 2279, 3, 2, 2, 2,
	314, 2286, 3, 2, 2, 2, 316, 2295, 3, 2, 2, 2, 318, 2306, 3, 2, 2, 2, 320,
	2315, 3, 2, 2, 2, 322, 2322, 3, 2, 2, 2, 324, 2331, 3, 2, 2, 2, 326, 2344,
	3, 2, 2, 2, 328, 2357, 3, 2, 2, 2, 330, 2370, 3, 2, 2, 2, 332, 2383, 3,
	2, 2, 2, 334, 2404, 3, 2, 2, 2, 336, 2417, 3, 2, 2, 2, 338, 2421, 3, 2,
	2, 2, 340, 2429, 3, 2, 2, 2, 342, 2435, 3, 2, 2, 2, 344, 2437, 3, 2, 2,
	2, 346, 2441, 3, 2, 2, 2, 348, 2461, 3, 2, 2, 2, 350, 2463, 3, 2, 2, 2,
	352, 2528, 3, 2, 2, 2, 354, 2530, 3, 2, 2, 2, 356, 2546, 3, 2, 2, 2, 358,
	2555, 3, 2, 2, 2, 360, 2564, 3, 2, 2, 2, 362, 2593, 3, 2, 2, 2, 364, 2597,
	3, 2, 2, 2, 366, 2604, 3, 2, 2, 2, 368, 2612, 3, 2, 2, 2, 370, 2614, 3,
	2, 2, 2, 372, 2634, 3, 2, 2, 2, 374, 2636, 3, 2, 2, 2, 376, 2642, 3, 2,
	2, 2, 378, 2645, 3, 2, 2, 2, 380, 2654, 3, 2, 2, 2, 382, 2656, 3, 2, 2,
	2, 384, 2665, 3, 2, 2, 2, 386, 2687, 3, 2, 2, 2, 388, 2694, 3, 2, 2, 2,
	390, 2696, 3, 2, 2, 2, 392, 2706, 3, 2, 2, 2, 394, 2720, 3, 2, 2, 2, 396,
	2735, 3, 2, 2, 2, 398, 2737, 3, 2, 2, 2, 400, 2740, 3, 2, 2, 2, 402, 2754,
	3, 2, 2, 2, 404, 2756, 3, 2, 2, 2, 406, 2769, 3, 2, 2, 2, 408, 2777, 3,
	2, 2, 2, 410, 2784, 3, 2, 2, 2, 412, 2791, 3, 2, 2, 2, 414, 2794, 3, 2,
	2, 2, 416, 2803, 3, 2, 2, 2, 418, 2808, 3, 2, 2, 2, 420, 2814, 3, 2, 2,
	2, 422, 2826, 3, 2, 2, 2, 424, 2850, 3, 2, 2, 2, 426, 2852, 3, 2, 2, 2,
	428, 2863, 3, 2, 2, 2, 430, 2882, 3, 2, 2, 2, 432, 2889, 3, 2, 2, 2, 434,
	2904, 3, 2, 2, 2, 436, 2965, 3, 2, 2, 2, 438, 2967, 3, 2, 2, 2, 440, 2979,
	3, 2, 2, 2, 442, 2997, 3, 2, 2, 2, 444, 3003, 3, 2, 2, 2, 446, 3021, 3,
	2, 2, 2, 448, 3023, 3, 2, 2, 2, 450, 3062, 3, 2, 2, 2, 452, 3064, 3, 2,
	2, 2, 454, 3086, 3, 2, 2, 2, 456, 3100, 3, 2, 2, 2, 458, 3104, 3, 2, 2,
	2, 460, 3111, 3, 2, 2, 2, 462, 3125, 3, 2, 2, 2, 464, 3129, 3, 2, 2, 2,
	466, 3143, 3, 2, 2, 2, 468, 3147, 3, 2, 2, 2, 470, 3162, 3, 2, 2, 2, 472,
	3164, 3, 2, 2, 2, 474, 3174, 3, 2, 2, 2, 476, 3194, 3, 2, 2, 2, 478, 3204,
	3, 2, 2, 2, 480, 3217, 3, 2, 2, 2, 482, 3221, 3, 2, 2, 2, 484, 3250, 3,
	2, 2, 2, 486, 3252, 3, 2, 2, 2, 488, 3254, 3, 2, 2, 2, 490, 3266, 3, 2,
	2, 2, 492, 3279, 3, 2, 2, 2, 494, 3287, 3, 2, 2, 2, 496, 3293, 3, 2, 2,
	2, 498, 3311, 3, 2, 2, 2, 500, 3319, 3, 2, 2, 2, 502, 3326, 3, 2, 2, 2,
	504, 3335, 3, 2, 2, 2, 506, 3350, 3, 2, 2, 2, 508, 3357, 3, 2, 2, 2, 510,
	3366, 3, 2, 2, 2, 512, 3368, 3, 2, 2, 2, 514, 3373, 3, 2, 2, 2, 516, 3376,
	3, 2, 2, 2, 518, 3387, 3, 2, 2, 2, 520, 3389, 3, 2, 2, 2, 522, 3421, 3,
	2, 2, 2, 524, 3423, 3, 2, 2, 2, 526, 3435, 3, 2, 2, 2, 528, 3441, 3, 2,
	2, 2, 530, 3461, 3, 2, 2, 2, 532, 3516, 3, 2, 2, 2, 534, 3524, 3, 2, 2,
	2, 536, 3526, 3, 2, 2, 2, 538, 3544, 3, 2, 2, 2, 540, 3567, 3, 2, 2, 2,
	542, 3589, 3, 2, 2, 2, 544, 3601, 3, 2, 2, 2, 546, 3603, 3, 2, 2, 2, 548,
	3627, 3, 2, 2, 2, 550, 3629, 3, 2, 2, 2, 552, 3635, 3, 2, 2, 2, 554, 3649,
	3, 2, 2, 2, 556, 3651, 3, 2, 2, 2, 558, 3697, 3, 2, 2, 2, 560, 3717, 3,
	2, 2, 2, 562, 3719, 3, 2, 2, 2, 564, 3746, 3, 2, 2, 2, 566, 3767, 3, 2,
	2, 2, 568, 3770, 3, 2, 2, 2, 570, 3797, 3, 2, 2, 2, 572, 3799, 3, 2, 2,
	2, 574, 3827, 3, 2, 2, 2, 576, 3829, 3, 2, 2, 2, 578, 3852, 3, 2, 2, 2,
	580, 3876, 3, 2, 2, 2, 582, 3901, 3, 2, 2, 2, 584, 3912, 3, 2, 2, 2, 586,
	3940, 3, 2, 2, 2, 588, 3952, 3, 2, 2, 2, 590, 3965, 3, 2, 2, 2, 592, 3967,
	3, 2, 2, 2, 594, 3979, 3, 2, 2, 2, 596, 3988, 3, 2, 2, 2, 598, 4004, 3,
	2, 2, 2, 600, 4041, 3, 2, 2, 2, 602, 4065, 3, 2, 2, 2, 604, 4076, 3, 2,
	2, 2, 606, 4088, 3, 2, 2, 2, 608, 4090, 3, 2, 2, 2, 610, 4099, 3, 2, 2,
	2, 612, 4123, 3, 2, 2, 2, 614, 4170, 3, 2, 2, 2, 616, 4172, 3, 2, 2, 2,
	618, 4183, 3, 2, 2, 2, 620, 4213, 3, 2, 2, 2, 622, 4217, 3, 2, 2, 2, 624,
	4255, 3, 2, 2, 2, 626, 4280, 3, 2, 2, 2, 628, 4344, 3, 2, 2, 2, 630, 4413,
	3, 2, 2, 2, 632, 4415, 3, 2, 2, 2, 634, 4426, 3, 2, 2, 2, 636, 4449, 3,
	2, 2, 2, 638, 4461, 3, 2, 2, 2, 640, 4517, 3, 2, 2, 2, 642, 4531, 3, 2,
	2, 2, 644, 4546, 3, 2, 2, 2, 646, 4556, 3, 2, 2, 2, 648, 4601, 3, 2, 2,
	2, 650, 4607, 3, 2, 2, 2, 652, 4631, 3, 2, 2, 2, 654, 4635, 3, 2, 2, 2,
	656, 4669, 3, 2, 2, 2, 658, 4671, 3, 2, 2, 2, 660, 4702, 3, 2, 2, 2, 662,
	4704, 3, 2, 2, 2, 664, 4711, 3, 2, 2, 2, 666, 4740, 3, 2, 2, 2, 668, 4746,
	3, 2, 2, 2, 670, 4767, 3, 2, 2, 2, 672, 4769, 3, 2, 2, 2, 674, 4835, 3,
	2, 2, 2, 676, 4850, 3, 2, 2, 2, 678, 4858, 3, 2, 2, 2, 680, 4881, 3, 2,
	2, 2, 682, 4890, 3, 2, 2, 2, 684, 4898, 3, 2, 2, 2, 686, 4900, 3, 2, 2,
	2, 688, 4914, 3, 2, 2, 2, 690, 4916, 3, 2, 2, 2, 692, 4927, 3, 2, 2, 2,
	694, 4944, 3, 2, 2, 2, 696, 4953, 3, 2, 2, 2, 698, 4960, 3, 2, 2, 2, 700,
	4964, 3, 2, 2, 2, 702, 4966, 3, 2, 2, 2, 704, 4977, 3, 2, 2, 2, 706, 4996,
	3, 2, 2, 2, 708, 5024, 3, 2, 2, 2, 710, 5026, 3, 2, 2, 2, 712, 5032, 3,
	2, 2, 2, 714, 5041, 3, 2, 2, 2, 716, 5046, 3, 2, 2, 2, 718, 5051, 3, 2,
	2, 2, 720, 5056, 3, 2, 2, 2, 722, 5060, 3, 2, 2, 2, 724, 5075, 3, 2, 2,
	2, 726, 5079, 3, 2, 2, 2, 728, 5088, 3, 2, 2, 2, 730, 5111, 3, 2, 2, 2,
	732, 5132, 3, 2, 2, 2, 734, 5134, 3, 2, 2, 2, 736, 5213, 3, 2, 2, 2, 738,
	5223, 3, 2, 2, 2, 740, 5378, 3, 2, 2, 2, 742, 5390, 3, 2, 2, 2, 744, 5400,
	3, 2, 2, 2, 746, 5402, 3, 2, 2, 2, 748, 5414, 3, 2, 2, 2, 750, 5418, 3,
	2, 2, 2, 752, 5422, 3, 2, 2, 2, 754, 5427, 3, 2, 2, 2, 756, 5432, 3, 2,
	2, 2, 758, 5441, 3, 2, 2, 2, 760, 5443, 3, 2, 2, 2, 762, 5448, 3, 2, 2,
	2, 764, 5452, 3, 2, 2, 2, 766, 5456, 3, 2, 2, 2, 768, 5458, 3, 2, 2, 2,
	770, 5461, 3, 2, 2, 2, 772, 5464, 3, 2, 2, 2, 774, 5467, 3, 2, 2, 2, 776,
	5470, 3, 2, 2, 2, 778, 5473, 3, 2, 2, 2, 780, 5476, 3, 2, 2, 2, 782, 5479,
	3, 2, 2, 2, 784, 5482, 3, 2, 2, 2, 786, 5485, 3, 2, 2, 2, 788, 5496, 3,
	2, 2, 2, 790, 5502, 3, 2, 2, 2, 792, 5504, 3, 2, 2, 2, 794, 5520, 3, 2,
	2, 2, 796, 5527, 3, 2, 2, 2, 798, 5543, 3, 2, 2, 2, 800, 5547, 3, 2, 2,
	2, 802, 5555, 3, 2, 2, 2, 804, 5559, 3, 2, 2, 2, 806, 5565, 3, 2, 2, 2,
	808, 5567, 3, 2, 2, 2, 810, 5578, 3, 2, 2, 2, 812, 868, 5, 30, 16, 2, 813,
	868, 5, 4, 3, 2, 814, 868, 5, 12, 7, 2, 815, 868, 5, 22, 12, 2, 816, 868,
	5, 282, 142, 2, 817, 868, 5, 302, 152, 2, 818, 868, 5, 322, 162, 2, 819,
	868, 5, 278, 140, 2, 820, 868, 5, 284, 143, 2, 821, 868, 5, 288, 145, 2,
	822, 868, 5, 290, 146, 2, 823, 868, 5, 292, 147, 2, 824, 868, 5, 294, 148,
	2, 825, 868, 5, 296, 149, 2, 826, 868, 5, 298, 150, 2, 827, 868, 5, 300,
	151, 2, 828, 868, 5, 312, 157, 2, 829, 868, 5, 314, 158, 2, 830, 868, 5,
	304, 153, 2, 831, 868, 5, 316, 159, 2, 832, 868, 5, 318, 160, 2, 833, 868,
	5, 320, 161, 2, 834, 868, 5, 324, 163, 2, 835, 868, 5, 326, 164, 2, 836,
	868, 5, 328, 165, 2, 837, 868, 5, 330, 166, 2, 838, 868, 5, 332, 167, 2,
	839, 868, 5, 334, 168, 2, 840, 868, 5, 336, 169, 2, 841, 868, 5, 338, 170,
	2, 842, 868, 5, 340, 171, 2, 843, 868, 5, 286, 144, 2, 844, 868, 5, 786,
	394, 2, 845, 868, 5, 792, 397, 2, 846, 868, 5, 794, 398, 2, 847, 868, 5,
	788, 395, 2, 848, 868, 5, 796, 399, 2, 849, 868, 5, 798, 400, 2, 850, 868,
	5, 800, 401, 2, 851, 868, 5, 802, 402, 2, 852, 868, 5, 804, 403, 2, 853,
	868, 5, 710, 356, 2, 854, 868, 5, 712, 357, 2, 855, 868, 5, 714, 358, 2,
	856, 868, 5, 768, 385, 2, 857, 868, 5, 770, 386, 2, 858, 868, 5, 772, 387,
	2, 859, 868, 5, 774, 388, 2, 860, 868, 5, 776, 389, 2, 861, 868, 5, 778,
	390, 2, 862, 868, 5, 780, 391, 2, 863, 868, 5, 782, 392, 2, 864, 868, 5,
	784, 393, 2, 865, 868, 5, 806, 404, 2, 866, 868, 5, 808, 405, 2, 867, 812,
	3, 2, 2, 2, 867, 813, 3, 2, 2, 2, 867, 814, 3, 2, 2, 2, 867, 815, 3, 2,
	2, 2, 867, 816, 3, 2, 2, 2, 867, 817, 3, 2, 2, 2, 867, 818, 3, 2, 2, 2,
	867, 819, 3, 2, 2, 2, 867, 820, 3, 2, 2, 2, 867, 821, 3, 2, 2, 2, 867,
	822, 3, 2, 2, 2, 867, 823, 3, 2, 2, 2, 867, 824, 3, 2, 2, 2, 867, 825,
	3, 2, 2, 2, 867, 826, 3, 2, 2, 2, 867, 827, 3, 2, 2, 2, 867, 828, 3, 2,
	2, 2, 867, 829, 3, 2, 2, 2, 867, 830, 3, 2, 2, 2, 867, 831, 3, 2, 2, 2,
	867, 832, 3, 2, 2, 2, 867, 833, 3, 2, 2, 2, 867, 834, 3, 2, 2, 2, 867,
	835, 3, 2, 2, 2, 867, 836, 3, 2, 2, 2, 867, 837, 3, 2, 2, 2, 867, 838,
	3, 2, 2, 2, 867, 839, 3, 2, 2, 2, 867, 840, 3, 2, 2, 2, 867, 841, 3, 2,
	2, 2, 867, 842, 3, 2, 2, 2, 867, 843, 3, 2, 2, 2, 867, 844, 3, 2, 2, 2,
	867, 845, 3, 2, 2, 2, 867, 846, 3, 2, 2, 2, 867, 847, 3, 2, 2, 2, 867,
	848, 3, 2, 2, 2, 867, 849, 3, 2, 2, 2, 867, 850, 3, 2, 2, 2, 867, 851,
	3, 2, 2, 2, 867, 852, 3, 2, 2, 2, 867, 853, 3, 2, 2, 2, 867, 854, 3, 2,
	2, 2, 867, 855, 3, 2, 2, 2, 867, 856, 3, 2, 2, 2, 867, 857, 3, 2, 2, 2,
	867, 858, 3, 2, 2, 2, 867, 859, 3, 2, 2, 2, 867, 860, 3, 2, 2, 2, 867,
	861, 3, 2, 2, 2, 867, 862, 3, 2, 2, 2, 867, 863, 3, 2, 2, 2, 867, 864,
	3, 2, 2, 2, 867, 865, 3, 2, 2, 2, 867, 866, 3, 2, 2, 2, 868, 870, 3, 2,
	2, 2, 869, 871, 7, 43, 2, 2, 870, 869, 3, 2, 2, 2, 870, 871, 3, 2, 2, 2,
	871, 3, 3, 2, 2, 2, 872, 874, 5, 72, 37, 2, 873, 872, 3, 2, 2, 2, 873,
	874, 3, 2, 2, 2, 874, 875, 3, 2, 2, 2, 875, 877, 7, 48, 2, 2, 876, 878,
	5, 42, 22, 2, 877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 880, 3,
	2, 2, 2, 879, 881, 7, 75, 2, 2, 880, 879, 3, 2, 2, 2, 880, 881, 3, 2, 2,
	2, 881, 882, 3, 2, 2, 2, 882, 887, 5, 126, 64, 2, 883, 885, 7, 96, 2, 2,
	884, 883, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 886, 3, 2, 2, 2, 886,
	888, 5, 46, 24, 2, 887, 884, 3, 2, 2, 2, 887, 888, 3, 2, 2, 2, 888, 892,
	3, 2, 2, 2, 889, 893, 5, 6, 4, 2, 890, 893, 5, 8, 5, 2, 891, 893, 5, 10,
	6, 2, 892, 889, 3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 892, 891, 3, 2, 2, 2,
	893, 5, 3, 2, 2, 2, 894, 896, 5, 140, 71, 2, 895, 894, 3, 2, 2, 2, 895,
	896, 3, 2, 2, 2, 896, 898, 3, 2, 2, 2, 897, 899, 5, 76, 39, 2, 898, 897,
	3, 2, 2, 2, 898, 899, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 901, 7, 153,
	2, 2, 901, 902, 7, 76, 2, 2, 902, 7, 3, 2, 2, 2, 903, 905, 5, 140, 71,
	2, 904, 903, 3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 907, 3, 2, 2, 2, 906,
	908, 5, 76, 39, 2, 907, 906, 3, 2, 2, 2, 907, 908, 3, 2, 2, 2, 908, 909,
	3, 2, 2, 2, 909, 910, 7, 76, 2, 2, 910, 915, 5, 18, 10, 2, 911, 912, 7,
	37, 2, 2, 912, 914, 5, 18, 10, 2, 913, 911, 3, 2, 2, 2, 914, 917, 3, 2,
	2, 2, 915, 913, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 9, 3, 2, 2, 2, 917,
	915, 3, 2, 2, 2, 918, 920, 5, 140, 71, 2, 919, 918, 3, 2, 2, 2, 919, 920,
	3, 2, 2, 2, 920, 922, 3, 2, 2, 2, 921, 923, 5, 76, 39, 2, 922, 921, 3,
	2, 2, 2, 922, 923, 3, 2, 2, 2, 923, 924, 3, 2, 2, 2, 924, 925, 5, 30, 16,
	2, 925, 11, 3, 2, 2, 2, 926, 928, 5, 72, 37, 2, 927, 926, 3, 2, 2, 2, 927,
	928, 3, 2, 2, 2, 928, 929, 3, 2, 2, 2, 929, 931, 7, 49, 2, 2, 930, 932,
	5, 42, 22, 2, 931, 930, 3, 2, 2, 2, 931, 932, 3, 2, 2, 2, 932, 933, 3,
	2, 2, 2, 933, 934, 5, 54, 28, 2, 934, 936, 5, 16, 9, 2, 935, 937, 5, 64,
	33, 2, 936, 935, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2, 937, 940, 3, 2, 2, 2,
	938, 939, 7, 229, 2, 2, 939, 941, 5, 86, 44, 2, 940, 938, 3, 2, 2, 2, 940,
	941, 3, 2, 2, 2, 941, 13, 3, 2, 2, 2, 942, 943, 5, 134, 68, 2, 943, 944,
	7, 24, 2, 2, 944, 945, 5, 20, 11, 2, 945, 15, 3, 2, 2, 2, 946, 947, 7,
	59, 2, 2, 947, 952, 5, 14, 8, 2, 948, 949, 7, 37, 2, 2, 949, 951, 5, 14,
	8, 2, 950, 948, 3, 2, 2, 2, 951, 954, 3, 2, 2, 2, 952, 950, 3, 2, 2, 2,
	952, 953, 3, 2, 2, 2, 953, 956, 3, 2, 2, 2, 954, 952, 3, 2, 2, 2, 955,
	957, 5, 52, 27, 2, 956, 955, 3, 2, 2, 2, 956, 957, 3, 2, 2, 2, 957, 17,
	3, 2, 2, 2, 958, 959, 7, 31, 2, 2, 959, 964, 5, 20, 11, 2, 960, 961, 7,
	37, 2, 2, 961, 963, 5, 20, 11, 2, 962, 960, 3, 2, 2, 2, 963, 966, 3, 2,
	2, 2, 964, 962, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 967, 3, 2, 2, 2,
	966, 964, 3, 2, 2, 2, 967, 968, 7, 32, 2, 2, 968, 972, 3, 2, 2, 2, 969,
	970, 7, 31, 2, 2, 970, 972, 7, 32, 2, 2, 971, 958, 3, 2, 2, 2, 971, 969,
	3, 2, 2, 2, 972, 19, 3, 2, 2, 2, 973, 976, 5, 156, 79, 2, 974, 976, 7,
	153, 2, 2, 975, 973, 3, 2, 2, 2, 975, 974, 3, 2, 2, 2, 976, 21, 3, 2, 2,
	2, 977, 979, 5, 72, 37, 2, 978, 977, 3, 2, 2, 2, 978, 979, 3, 2, 2, 2,
	979, 980, 3, 2, 2, 2, 980, 982, 7, 50, 2, 2, 981, 983, 5, 42, 22, 2, 982,
	981, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2, 983, 986, 3, 2, 2, 2, 984, 987,
	5, 24, 13, 2, 985, 987, 5, 26, 14, 2, 986, 984, 3, 2, 2, 2, 986, 985, 3,
	2, 2, 2, 987, 989, 3, 2, 2, 2, 988, 990, 5, 76, 39, 2, 989, 988, 3, 2,
	2, 2, 989, 990, 3, 2, 2, 2, 990, 992, 3, 2, 2, 2, 991, 993, 5, 64, 33,
	2, 992, 991, 3, 2, 2, 2, 992, 993, 3, 2, 2, 2, 993, 996, 3, 2, 2, 2, 994,
	995, 7, 229, 2, 2, 995, 997, 5, 86, 44, 2, 996, 994, 3, 2, 2, 2, 996, 997,
	3, 2, 2, 2, 997, 23, 3, 2, 2, 2, 998, 1000, 7, 85, 2, 2, 999, 998, 3, 2,
	2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1002, 3, 2, 2, 2, 1001, 1003, 7, 31,
	2, 2, 1002, 1001, 3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1004, 3, 2,
	2, 2, 1004, 1006, 5, 126, 64, 2, 1005, 1007, 7, 32, 2, 2, 1006, 1005, 3,
	2, 2, 2, 1006, 1007, 3, 2, 2, 2, 1007, 1012, 3, 2, 2, 2, 1008, 1010, 7,
	96, 2, 2, 1009, 1008, 3, 2, 2, 2, 1009, 1010, 3, 2, 2, 2, 1010, 1011, 3,
	2, 2, 2, 1011, 1013, 5, 46, 24, 2, 1012, 1009, 3, 2, 2, 2, 1012, 1013,
	3, 2, 2, 2, 1013, 25, 3, 2, 2, 2, 1014, 1015, 5, 28, 15, 2, 1015, 1016,
	7, 85, 2, 2, 1016, 1017, 5, 54, 28, 2, 1017, 1024, 3, 2, 2, 2, 1018, 1019,
	7, 85, 2, 2, 1019, 1020, 5, 28, 15, 2, 1020, 1021, 7, 94, 2, 2, 1021, 1022,
	5, 54, 28, 2, 1022, 1024, 3, 2, 2, 2, 1023, 1014, 3, 2, 2, 2, 1023, 1018,
	3, 2, 2, 2, 1024, 27, 3, 2, 2, 2, 1025, 1027, 5, 126, 64, 2, 1026, 1028,
	7, 21, 2, 2, 1027, 1026, 3, 2, 2, 2, 1027, 1028, 3, 2, 2, 2, 1028, 1036,
	3, 2, 2, 2, 1029, 1030, 7, 37, 2, 2, 1030, 1032, 5, 126, 64, 2, 1031, 1033,
	7, 21, 2, 2, 1032, 1031, 3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 1035,
	3, 2, 2, 2, 1034, 1029, 3, 2, 2, 2, 1035, 1038, 3, 2, 2, 2, 1036, 1034,
	3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 29, 3, 2, 2, 2, 1038, 1036, 3,
	2, 2, 2, 1039, 1040, 5, 32, 17, 2, 1040, 31, 3, 2, 2, 2, 1041, 1053, 5,
	34, 18, 2, 1042, 1044, 7, 78, 2, 2, 1043, 1045, 7, 113, 2, 2, 1044, 1043,
	3, 2, 2, 2, 1044, 1045, 3, 2, 2, 2, 1045, 1049, 3, 2, 2, 2, 1046, 1049,
	7, 187, 2, 2, 1047, 1049, 7, 188, 2, 2, 1048, 1042, 3, 2, 2, 2, 1048, 1046,
	3, 2, 2, 2, 1048, 1047, 3, 2, 2, 2, 1049, 1050, 3, 2, 2, 2, 1050, 1052,
	5, 34, 18, 2, 1051, 1048, 3, 2, 2, 2, 1052, 1055, 3, 2, 2, 2, 1053, 1051,
	3, 2, 2, 2, 1053, 1054, 3, 2, 2, 2, 1054, 33, 3, 2, 2, 2, 1055, 1053, 3,
	2, 2, 2, 1056, 1058, 7, 47, 2, 2, 1057, 1059, 5, 36, 19, 2, 1058, 1057,
	3, 2, 2, 2, 1058, 1059, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060, 1062,
	5, 38, 20, 2, 1061, 1063, 5, 52, 27, 2, 1062, 1061, 3, 2, 2, 2, 1062, 1063,
	3, 2, 2, 2, 1063, 1065, 3, 2, 2, 2, 1064, 1066, 5, 64, 33, 2, 1065, 1064,
	3, 2, 2, 2, 1065, 1066, 3, 2, 2, 2, 1066, 1068, 3, 2, 2, 2, 1067, 1069,
	5, 66, 34, 2, 1068, 1067, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 1071,
	3, 2, 2, 2, 1070, 1072, 5, 68, 35, 2, 1071, 1070, 3, 2, 2, 2, 1071, 1072,
	3, 2, 2, 2, 1072, 1074, 3, 2, 2, 2, 1073, 1075, 5, 200, 101, 2, 1074, 1073,
	3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 35, 3, 2, 2, 2, 1076, 1077, 9,
	2, 2, 2, 1077, 37, 3, 2, 2, 2, 1078, 1081, 5, 48, 25, 2, 1079, 1081, 5,
	40, 21, 2, 1080, 1078, 3, 2, 2, 2, 1080, 1079, 3, 2, 2, 2, 1081, 1086,
	3, 2, 2, 2, 1082, 1083, 7, 37, 2, 2, 1083, 1085, 5, 40, 21, 2, 1084, 1082,
	3, 2, 2, 2, 1085, 1088, 3, 2, 2, 2, 1086, 1084, 3, 2, 2, 2, 1086, 1087,
	3, 2, 2, 2, 1087, 39, 3, 2, 2, 2, 1088, 1086, 3, 2, 2, 2, 1089, 1093, 5,
	42, 22, 2, 1090, 1093, 5, 134, 68, 2, 1091, 1093, 5, 156, 79, 2, 1092,
	1089, 3, 2, 2, 2, 1092, 1090, 3, 2, 2, 2, 1092, 1091, 3, 2, 2, 2, 1093,
	1098, 3, 2, 2, 2, 1094, 1096, 7, 96, 2, 2, 1095, 1094, 3, 2, 2, 2, 1095,
	1096, 3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 1099, 5, 46, 24, 2, 1098,
	1095, 3, 2, 2, 2, 1098, 1099, 3, 2, 2, 2, 1099, 1102, 3, 2, 2, 2, 1100,
	1102, 5, 50, 26, 2, 1101, 1092, 3, 2, 2, 2, 1101, 1100, 3, 2, 2, 2, 1102,
	41, 3, 2, 2, 2, 1103, 1105, 7, 219, 2, 2, 1104, 1106, 7, 31, 2, 2, 1105,
	1104, 3, 2, 2, 2, 1105, 1106, 3, 2, 2, 2, 1106, 1107, 3, 2, 2, 2, 1107,
	1109, 5, 44, 23, 2, 1108, 1110, 7, 32, 2, 2, 1109, 1108, 3, 2, 2, 2, 1109,
	1110, 3, 2, 2, 2, 1110, 1112, 3, 2, 2, 2, 1111, 1113, 7, 185, 2, 2, 1112,
	1111, 3, 2, 2, 2, 1112, 1113, 3, 2, 2, 2, 1113, 1116, 3, 2, 2, 2, 1114,
	1115, 7, 77, 2, 2, 1115, 1117, 7, 186, 2, 2, 1116, 1114, 3, 2, 2, 2, 1116,
	1117, 3, 2, 2, 2, 1117, 1126, 3, 2, 2, 2, 1118, 1119, 7, 418, 2, 2, 1119,
	1120, 7, 31, 2, 2, 1120, 1121, 7, 32, 2, 2, 1121, 1122, 7, 278, 2, 2, 1122,
	1123, 7, 31, 2, 2, 1123, 1124, 5, 200, 101, 2, 1124, 1125, 7, 32, 2, 2,
	1125, 1127, 3, 2, 2, 2, 1126, 1118, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2,
	1127, 43, 3, 2, 2, 2, 1128, 1131, 5, 96, 49, 2, 1129, 1131, 5, 90, 46,
	2, 1130, 1128, 3, 2, 2, 2, 1130, 1129, 3, 2, 2, 2, 1131, 45, 3, 2, 2, 2,
	1132, 1135, 5, 108, 55, 2, 1133, 1135, 7, 645, 2, 2, 1134, 1132, 3, 2,
	2, 2, 1134, 1133, 3, 2, 2, 2, 1135, 47, 3, 2, 2, 2, 1136, 1137, 7, 17,
	2, 2, 1137, 49, 3, 2, 2, 2, 1138, 1139, 5, 108, 55, 2, 1139, 1140, 7, 21,
	2, 2, 1140, 51, 3, 2, 2, 2, 1141, 1142, 7, 85, 2, 2, 1142, 1143, 5, 54,
	28, 2, 1143, 53, 3, 2, 2, 2, 1144, 1149, 5, 56, 29, 2, 1145, 1146, 7, 37,
	2, 2, 1146, 1148, 5, 56, 29, 2, 1147, 1145, 3, 2, 2, 2, 1148, 1151, 3,
	2, 2, 2, 1149, 1147, 3, 2, 2, 2, 1149, 1150, 3, 2, 2, 2, 1150, 55, 3, 2,
	2, 2, 1151, 1149, 3, 2, 2, 2, 1152, 1156, 5, 58, 30, 2, 1153, 1155, 5,
	60, 31, 2, 1154, 1153, 3, 2, 2, 2, 1155, 1158, 3, 2, 2, 2, 1156, 1154,
	3, 2, 2, 2, 1156, 1157, 3, 2, 2, 2, 1157, 57, 3, 2, 2, 2, 1158, 1156, 3,
	2, 2, 2, 1159, 1164, 5, 126, 64, 2, 1160, 1162, 7, 96, 2, 2, 1161, 1160,
	3, 2, 2, 2, 1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1165,
	5, 46, 24, 2, 1164, 1161, 3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165, 1179,
	3, 2, 2, 2, 1166, 1168, 5, 70, 36, 2, 1167, 1169, 7, 96, 2, 2, 1168, 1167,
	3, 2, 2, 2, 1168, 1169, 3, 2, 2, 2, 1169, 1170, 3, 2, 2, 2, 1170, 1172,
	5, 46, 24, 2, 1171, 1173, 5, 140, 71, 2, 1172, 1171, 3, 2, 2, 2, 1172,
	1173, 3, 2, 2, 2, 1173, 1179, 3, 2, 2, 2, 1174, 1175, 7, 31, 2, 2, 1175,
	1176, 5, 54, 28, 2, 1176, 1177, 7, 32, 2, 2, 1177, 1179, 3, 2, 2, 2, 1178,
	1159, 3, 2, 2, 2, 1178, 1166, 3, 2, 2, 2, 1178, 1174, 3, 2, 2, 2, 1179,
	59, 3, 2, 2, 2, 1180, 1182, 7, 86, 2, 2, 1181, 1180, 3, 2, 2, 2, 1181,
	1182, 3, 2, 2, 2, 1182, 1184, 3, 2, 2, 2, 1183, 1185, 9, 3, 2, 2, 1184,
	1183, 3, 2, 2, 2, 1184, 1185, 3, 2, 2, 2, 1185, 1186, 3, 2, 2, 2, 1186,
	1187, 7, 87, 2, 2, 1187, 1188, 3, 2, 2, 2, 1188, 1190, 5, 58, 30, 2, 1189,
	1191, 5, 62, 32, 2, 1190, 1189, 3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191,
	1205, 3, 2, 2, 2, 1192, 1194, 7, 86, 2, 2, 1193, 1192, 3, 2, 2, 2, 1193,
	1194, 3, 2, 2, 2, 1194, 1195, 3, 2, 2, 2, 1195, 1197, 9, 4, 2, 2, 1196,
	1198, 7, 90, 2, 2, 1197, 1196, 3, 2, 2, 2, 1197, 1198, 3, 2, 2, 2, 1198,
	1199, 3, 2, 2, 2, 1199, 1200, 7, 87, 2, 2, 1200, 1202, 5, 58, 30, 2, 1201,
	1203, 5, 62, 32, 2, 1202, 1201, 3, 2, 2, 2, 1202, 1203, 3, 2, 2, 2, 1203,
	1205, 3, 2, 2, 2, 1204, 1181, 3, 2, 2, 2, 1204, 1193, 3, 2, 2, 2, 1205,
	61, 3, 2, 2, 2, 1206, 1207, 7, 97, 2, 2, 1207, 1211, 5, 156, 79, 2, 1208,
	1209, 7, 94, 2, 2, 1209, 1211, 5, 140, 71, 2, 1210, 1206, 3, 2, 2, 2, 1210,
	1208, 3, 2, 2, 2, 1211, 63, 3, 2, 2, 2, 1212, 1213, 7, 95, 2, 2, 1213,
	1214, 5, 156, 79, 2, 1214, 65, 3, 2, 2, 2, 1215, 1216, 7, 117, 2, 2, 1216,
	1217, 7, 118, 2, 2, 1217, 1222, 5, 202, 102, 2, 1218, 1219, 7, 37, 2, 2,
	1219, 1221, 5, 202, 102, 2, 1220, 1218, 3, 2, 2, 2, 1221, 1224, 3, 2, 2,
	2, 1222, 1220, 3, 2, 2, 2, 1222, 1223, 3, 2, 2, 2, 1223, 67, 3, 2, 2, 2,
	1224, 1222, 3, 2, 2, 2, 1225, 1226, 7, 121, 2, 2, 1226, 1227, 5, 156, 79,
	2, 1227, 69, 3, 2, 2, 2, 1228, 1229, 7, 31, 2, 2, 1229, 1230, 5, 32, 17,
	2, 1230, 1231, 7, 32, 2, 2, 1231, 71, 3, 2, 2, 2, 1232, 1233, 7, 77, 2,
	2, 1233, 1238, 5, 74, 38, 2, 1234, 1235, 7, 37, 2, 2, 1235, 1237, 5, 74,
	38, 2, 1236, 1234, 3, 2, 2, 2, 1237, 1240, 3, 2, 2, 2, 1238, 1236, 3, 2,
	2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 73, 3, 2, 2, 2, 1240, 1238, 3, 2, 2,
	2, 1241, 1243, 5, 108, 55, 2, 1242, 1244, 5, 140, 71, 2, 1243, 1242, 3,
	2, 2, 2, 1243, 1244, 3, 2, 2, 2, 1244, 1245, 3, 2, 2, 2, 1245, 1246, 7,
	96, 2, 2, 1246, 1247, 5, 70, 36, 2, 1247, 75, 3, 2, 2, 2, 1248, 1251, 7,
	438, 2, 2, 1249, 1252, 5, 78, 40, 2, 1250, 1252, 5, 82, 42, 2, 1251, 1249,
	3, 2, 2, 2, 1251, 1250, 3, 2, 2, 2, 1252, 1258, 3, 2, 2, 2, 1253, 1254,
	7, 75, 2, 2, 1254, 1256, 5, 84, 43, 2, 1255, 1257, 5, 140, 71, 2, 1256,
	1255, 3, 2, 2, 2, 1256, 1257, 3, 2, 2, 2, 1257, 1259, 3, 2, 2, 2, 1258,
	1253, 3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259, 77, 3, 2, 2, 2, 1260, 1265,
	5, 80, 41, 2, 1261, 1262, 7, 37, 2, 2, 1262, 1264, 5, 80, 41, 2, 1263,
	1261, 3, 2, 2, 2, 1264, 1267, 3, 2, 2, 2, 1265, 1263, 3, 2, 2, 2, 1265,
	1266, 3, 2, 2, 2, 1266, 79, 3, 2, 2, 2, 1267, 1265, 3, 2, 2, 2, 1268, 1269,
	9, 5, 2, 2, 1269, 1270, 7, 20, 2, 2, 1270, 1275, 5, 138, 70, 2, 1271, 1273,
	7, 96, 2, 2, 1272, 1271, 3, 2, 2, 2, 1272, 1273, 3, 2, 2, 2, 1273, 1274,
	3, 2, 2, 2, 1274, 1276, 5, 46, 24, 2, 1275, 1272, 3, 2, 2, 2, 1275, 1276,
	3, 2, 2, 2, 1276, 81, 3, 2, 2, 2, 1277, 1278, 9, 5, 2, 2, 1278, 1279, 7,
	21, 2, 2, 1279, 83, 3, 2, 2, 2, 1280, 1281, 7, 42, 2, 2, 1281, 1284, 5,
	138, 70, 2, 1282, 1284, 5, 126, 64, 2, 1283, 1280, 3, 2, 2, 2, 1283, 1282,
	3, 2, 2, 2, 1284, 85, 3, 2, 2, 2, 1285, 1286, 9, 6, 2, 2, 1286, 1356, 7,
	117, 2, 2, 1287, 1288, 9, 7, 2, 2, 1288, 1356, 7, 78, 2, 2, 1289, 1290,
	9, 8, 2, 2, 1290, 1356, 7, 87, 2, 2, 1291, 1292, 7, 192, 2, 2, 1292, 1356,
	7, 193, 2, 2, 1293, 1294, 7, 194, 2, 2, 1294, 1356, 7, 647, 2, 2, 1295,
	1296, 7, 195, 2, 2, 1296, 1356, 7, 116, 2, 2, 1297, 1298, 9, 9, 2, 2, 1298,
	1356, 7, 459, 2, 2, 1299, 1300, 9, 9, 2, 2, 1300, 1356, 7, 460, 2, 2, 1301,
	1356, 7, 461, 2, 2, 1302, 1303, 7, 196, 2, 2, 1303, 1356, 7, 197, 2, 2,
	1304, 1305, 7, 462, 2, 2, 1305, 1356, 7, 197, 2, 2, 1306, 1307, 7, 463,
	2, 2, 1307, 1308, 7, 24, 2, 2, 1308, 1356, 7, 649, 2, 2, 1309, 1310, 7,
	464, 2, 2, 1310, 1311, 7, 24, 2, 2, 1311, 1356, 7, 649, 2, 2, 1312, 1313,
	7, 271, 2, 2, 1313, 1356, 7, 647, 2, 2, 1314, 1315, 7, 465, 2, 2, 1315,
	1356, 7, 647, 2, 2, 1316, 1356, 7, 466, 2, 2, 1317, 1318, 7, 198, 2, 2,
	1318, 1319, 7, 101, 2, 2, 1319, 1320, 7, 31, 2, 2, 1320, 1321, 7, 42, 2,
	2, 1321, 1327, 5, 138, 70, 2, 1322, 1326, 7, 222, 2, 2, 1323, 1324, 7,
	24, 2, 2, 1324, 1326, 5, 108, 55, 2, 1325, 1322, 3, 2, 2, 2, 1325, 1323,
	3, 2, 2, 2, 1326, 1329, 3, 2, 2, 2, 1327, 1325, 3, 2, 2, 2, 1327, 1328,
	3, 2, 2, 2, 1328, 1330, 3, 2, 2, 2, 1329, 1327, 3, 2, 2, 2, 1330, 1331,
	7, 32, 2, 2, 1331, 1356, 3, 2, 2, 2, 1332, 1333, 7, 198, 2, 2, 1333, 1334,
	7, 101, 2, 2, 1334, 1356, 7, 222, 2, 2, 1335, 1336, 7, 467, 2, 2, 1336,
	1356, 9, 10, 2, 2, 1337, 1338, 7, 468, 2, 2, 1338, 1356, 7, 647, 2, 2,
	1339, 1356, 7, 469, 2, 2, 1340, 1341, 7, 470, 2, 2, 1341, 1356, 7, 197,
	2, 2, 1342, 1343, 7, 189, 2, 2, 1343, 1344, 7, 201, 2, 2, 1344, 1348, 7,
	31, 2, 2, 1345, 1347, 5, 88, 45, 2, 1346, 1345, 3, 2, 2, 2, 1347, 1350,
	3, 2, 2, 2, 1348, 1346, 3, 2, 2, 2, 1348, 1349, 3, 2, 2, 2, 1349, 1351,
	3, 2, 2, 2, 1350, 1348, 3, 2, 2, 2, 1351, 1356, 7, 32, 2, 2, 1352, 1353,
	7, 189, 2, 2, 1353, 1354, 7, 197, 2, 2, 1354, 1356, 7, 652, 2, 2, 1355,
	1285, 3, 2, 2, 2, 1355, 1287, 3, 2, 2, 2, 1355, 1289, 3, 2, 2, 2, 1355,
	1291, 3, 2, 2, 2, 1355, 1293, 3, 2, 2, 2, 1355, 1295, 3, 2, 2, 2, 1355,
	1297, 3, 2, 2, 2, 1355, 1299, 3, 2, 2, 2, 1355, 1301, 3, 2, 2, 2, 1355,
	1302, 3, 2, 2, 2, 1355, 1304, 3, 2, 2, 2, 1355, 1306, 3, 2, 2, 2, 1355,
	1309, 3, 2, 2, 2, 1355, 1312, 3, 2, 2, 2, 1355, 1314, 3, 2, 2, 2, 1355,
	1316, 3, 2, 2, 2, 1355, 1317, 3, 2, 2, 2, 1355, 1332, 3, 2, 2, 2, 1355,
	1335, 3, 2, 2, 2, 1355, 1337, 3, 2, 2, 2, 1355, 1339, 3, 2, 2, 2, 1355,
	1340, 3, 2, 2, 2, 1355, 1342, 3, 2, 2, 2, 1355, 1352, 3, 2, 2, 2, 1356,
	87, 3, 2, 2, 2, 1357, 1358, 7, 39, 2, 2, 1358, 1359, 7, 441, 2, 2, 1359,
	1412, 7, 39, 2, 2, 1360, 1361, 7, 39, 2, 2, 1361, 1362, 7, 442, 2, 2, 1362,
	1412, 7, 39, 2, 2, 1363, 1364, 7, 39, 2, 2, 1364, 1365, 7, 443, 2, 2, 1365,
	1412, 7, 39, 2, 2, 1366, 1367, 7, 39, 2, 2, 1367, 1368, 7, 444, 2, 2, 1368,
	1412, 7, 39, 2, 2, 1369, 1370, 7, 39, 2, 2, 1370, 1371, 7, 445, 2, 2, 1371,
	1412, 7, 39, 2, 2, 1372, 1373, 7, 39, 2, 2, 1373, 1374, 7, 446, 2, 2, 1374,
	1412, 7, 39, 2, 2, 1375, 1376, 7, 39, 2, 2, 1376, 1377, 7, 447, 2, 2, 1377,
	1412, 7, 39, 2, 2, 1378, 1379, 7, 39, 2, 2, 1379, 1380, 7, 448, 2, 2, 1380,
	1412, 7, 39, 2, 2, 1381, 1382, 7, 39, 2, 2, 1382, 1383, 7, 449, 2, 2, 1383,
	1412, 7, 39, 2, 2, 1384, 1385, 7, 39, 2, 2, 1385, 1386, 7, 450, 2, 2, 1386,
	1412, 7, 39, 2, 2, 1387, 1388, 7, 39, 2, 2, 1388, 1389, 7, 451, 2, 2, 1389,
	1412, 7, 39, 2, 2, 1390, 1391, 7, 39, 2, 2, 1391, 1392, 7, 452, 2, 2, 1392,
	1412, 7, 39, 2, 2, 1393, 1394, 7, 39, 2, 2, 1394, 1395, 7, 453, 2, 2, 1395,
	1412, 7, 39, 2, 2, 1396, 1397, 7, 39, 2, 2, 1397, 1398, 7, 454, 2, 2, 1398,
	1412, 7, 39, 2, 2, 1399, 1400, 7, 39, 2, 2, 1400, 1401, 7, 455, 2, 2, 1401,
	1412, 7, 39, 2, 2, 1402, 1403, 7, 39, 2, 2, 1403, 1404, 7, 456, 2, 2, 1404,
	1412, 7, 39, 2, 2, 1405, 1406, 7, 39, 2, 2, 1406, 1407, 7, 457, 2, 2, 1407,
	1412, 7, 39, 2, 2, 1408, 1409, 7, 39, 2, 2, 1409, 1410, 7, 458, 2, 2, 1410,
	1412, 7, 39, 2, 2, 1411, 1357, 3, 2, 2, 2, 1411, 1360, 3, 2, 2, 2, 1411,
	1363, 3, 2, 2, 2, 1411, 1366, 3, 2, 2, 2, 1411, 1369, 3, 2, 2, 2, 1411,
	1372, 3, 2, 2, 2, 1411, 1375, 3, 2, 2, 2, 1411, 1378, 3, 2, 2, 2, 1411,
	1381, 3, 2, 2, 2, 1411, 1384, 3, 2, 2, 2, 1411, 1387, 3, 2, 2, 2, 1411,
	1390, 3, 2, 2, 2, 1411, 1393, 3, 2, 2, 2, 1411, 1396, 3, 2, 2, 2, 1411,
	1399, 3, 2, 2, 2, 1411, 1402, 3, 2, 2, 2, 1411, 1405, 3, 2, 2, 2, 1411,
	1408, 3, 2, 2, 2, 1412, 89, 3, 2, 2, 2, 1413, 1414, 7, 41, 2, 2, 1414,
	91, 3, 2, 2, 2, 1415, 1423, 5, 94, 48, 2, 1416, 1423, 5, 96, 49, 2, 1417,
	1423, 5, 98, 50, 2, 1418, 1423, 5, 100, 51, 2, 1419, 1423, 5, 102, 52,
	2, 1420, 1423, 5, 104, 53, 2, 1421, 1423, 5, 106, 54, 2, 1422, 1415, 3,
	2, 2, 2, 1422, 1416, 3, 2, 2, 2, 1422, 1417, 3, 2, 2, 2, 1422, 1418, 3,
	2, 2, 2, 1422, 1419, 3, 2, 2, 2, 1422, 1420, 3, 2, 2, 2, 1422, 1421, 3,
	2, 2, 2, 1423, 93, 3, 2, 2, 2, 1424, 1425, 7, 645, 2, 2, 1425, 95, 3, 2,
	2, 2, 1426, 1428, 7, 16, 2, 2, 1427, 1426, 3, 2, 2, 2, 1427, 1428, 3, 2,
	2, 2, 1428, 1429, 3, 2, 2, 2, 1429, 1430, 7, 646, 2, 2, 1430, 97, 3, 2,
	2, 2, 1431, 1432, 9, 11, 2, 2, 1432, 1439, 7, 645, 2, 2, 1433, 1434, 7,
	33, 2, 2, 1434, 1435, 5, 108, 55, 2, 1435, 1436, 7, 645, 2, 2, 1436, 1437,
	7, 34, 2, 2, 1437, 1439, 3, 2, 2, 2, 1438, 1431, 3, 2, 2, 2, 1438, 1433,
	3, 2, 2, 2, 1439, 99, 3, 2, 2, 2, 1440, 1441, 7, 650, 2, 2, 1441, 101,
	3, 2, 2, 2, 1442, 1443, 7, 651, 2, 2, 1443, 103, 3, 2, 2, 2, 1444, 1445,
	9, 12, 2, 2, 1445, 105, 3, 2, 2, 2, 1446, 1447, 7, 107, 2, 2, 1447, 107,
	3, 2, 2, 2, 1448, 1451, 7, 644, 2, 2, 1449, 1451, 5, 110, 56, 2, 1450,
	1448, 3, 2, 2, 2, 1450, 1449, 3, 2, 2, 2, 1451, 109, 3, 2, 2, 2, 1452,
	1453, 9, 13, 2, 2, 1453, 111, 3, 2, 2, 2, 1454, 1455, 5, 108, 55, 2, 1455,
	113, 3, 2, 2, 2, 1456, 1457, 5, 108, 55, 2, 1457, 115, 3, 2, 2, 2, 1458,
	1459, 5, 136, 69, 2, 1459, 1460, 7, 20, 2, 2, 1460, 1462, 3, 2, 2, 2, 1461,
	1458, 3, 2, 2, 2, 1461, 1462, 3, 2, 2, 2, 1462, 1463, 3, 2, 2, 2, 1463,
	1464, 5, 138, 70, 2, 1464, 117, 3, 2, 2, 2, 1465, 1466, 5, 136, 69, 2,
	1466, 1467, 7, 20, 2, 2, 1467, 1469, 3, 2, 2, 2, 1468, 1465, 3, 2, 2, 2,
	1468, 1469, 3, 2, 2, 2, 1469, 1470, 3, 2, 2, 2, 1470, 1473, 5, 138, 70,
	2, 1471, 1472, 7, 43, 2, 2, 1472, 1474, 5, 96, 49, 2, 1473, 1471, 3, 2,
	2, 2, 1473, 1474, 3, 2, 2, 2, 1474, 119, 3, 2, 2, 2, 1475, 1476, 5, 136,
	69, 2, 1476, 1477, 7, 20, 2, 2, 1477, 1479, 3, 2, 2, 2, 1478, 1475, 3,
	2, 2, 2, 1478, 1479, 3, 2, 2, 2, 1479, 1480, 3, 2, 2, 2, 1480, 1481, 5,
	138, 70, 2, 1481, 121, 3, 2, 2, 2, 1482, 1483, 5, 114, 58, 2, 1483, 1484,
	7, 20, 2, 2, 1484, 1486, 3, 2, 2, 2, 1485, 1482, 3, 2, 2, 2, 1485, 1486,
	3, 2, 2, 2, 1486, 1487, 3, 2, 2, 2, 1487, 1488, 5, 138, 70, 2, 1488, 123,
	3, 2, 2, 2, 1489, 1490, 5, 114, 58, 2, 1490, 1491, 7, 20, 2, 2, 1491, 1493,
	3, 2, 2, 2, 1492, 1489, 3, 2, 2, 2, 1492, 1493, 3, 2, 2, 2, 1493, 1494,
	3, 2, 2, 2, 1494, 1495, 5, 138, 70, 2, 1495, 125, 3, 2, 2, 2, 1496, 1497,
	5, 136, 69, 2, 1497, 1498, 7, 20, 2, 2, 1498, 1500, 3, 2, 2, 2, 1499, 1496,
	3, 2, 2, 2, 1499, 1500, 3, 2, 2, 2, 1500, 1501, 3, 2, 2, 2, 1501, 1502,
	5, 138, 70, 2, 1502, 127, 3, 2, 2, 2, 1503, 1504, 5, 114, 58, 2, 1504,
	1505, 7, 20, 2, 2, 1505, 1507, 3, 2, 2, 2, 1506, 1503, 3, 2, 2, 2, 1506,
	1507, 3, 2, 2, 2, 1507, 1508, 3, 2, 2, 2, 1508, 1509, 5, 138, 70, 2, 1509,
	129, 3, 2, 2, 2, 1510, 1511, 5, 138, 70, 2, 1511, 131, 3, 2, 2, 2, 1512,
	1513, 5, 138, 70, 2, 1513, 133, 3, 2, 2, 2, 1514, 1515, 5, 136, 69, 2,
	1515, 1516, 7, 20, 2, 2, 1516, 1518, 3, 2, 2, 2, 1517, 1514, 3, 2, 2, 2,
	1517, 1518, 3, 2, 2, 2, 1518, 1519, 3, 2, 2, 2, 1519, 1520, 5, 138, 70,
	2, 1520, 135, 3, 2, 2, 2, 1521, 1522, 5, 108, 55, 2, 1522, 137, 3, 2, 2,
	2, 1523, 1524, 5, 108, 55, 2, 1524, 139, 3, 2, 2, 2, 1525, 1526, 7, 31,
	2, 2, 1526, 1531, 5, 134, 68, 2, 1527, 1528, 7, 37, 2, 2, 1528, 1530, 5,
	134, 68, 2, 1529, 1527, 3, 2, 2, 2, 1530, 1533, 3, 2, 2, 2, 1531, 1529,
	3, 2, 2, 2, 1531, 1532, 3, 2, 2, 2, 1532, 1534, 3, 2, 2, 2, 1533, 1531,
	3, 2, 2, 2, 1534, 1535, 7, 32, 2, 2, 1535, 141, 3, 2, 2, 2, 1536, 1537,
	7, 31, 2, 2, 1537, 1542, 5, 232, 117, 2, 1538, 1539, 7, 37, 2, 2, 1539,
	1541, 5, 232, 117, 2, 1540, 1538, 3, 2, 2, 2, 1541, 1544, 3, 2, 2, 2, 1542,
	1540, 3, 2, 2, 2, 1542, 1543, 3, 2, 2, 2, 1543, 1545, 3, 2, 2, 2, 1544,
	1542, 3, 2, 2, 2, 1545, 1546, 7, 32, 2, 2, 1546, 143, 3, 2, 2, 2, 1547,
	1549, 7, 31, 2, 2, 1548, 1547, 3, 2, 2, 2, 1548, 1549, 3, 2, 2, 2, 1549,
	1550, 3, 2, 2, 2, 1550, 1555, 5, 126, 64, 2, 1551, 1552, 7, 37, 2, 2, 1552,
	1554, 5, 126, 64, 2, 1553, 1551, 3, 2, 2, 2, 1554, 1557, 3, 2, 2, 2, 1555,
	1553, 3, 2, 2, 2, 1555, 1556, 3, 2, 2, 2, 1556, 1559, 3, 2, 2, 2, 1557,
	1555, 3, 2, 2, 2, 1558, 1560, 7, 32, 2, 2, 1559, 1558, 3, 2, 2, 2, 1559,
	1560, 3, 2, 2, 2, 1560, 145, 3, 2, 2, 2, 1561, 1562, 5, 108, 55, 2, 1562,
	147, 3, 2, 2, 2, 1563, 1564, 5, 108, 55, 2, 1564, 149, 3, 2, 2, 2, 1565,
	1566, 9, 14, 2, 2, 1566, 151, 3, 2, 2, 2, 1567, 1573, 7, 31, 2, 2, 1568,
	1571, 7, 646, 2, 2, 1569, 1570, 7, 37, 2, 2, 1570, 1572, 7, 646, 2, 2,
	1571, 1569, 3, 2, 2, 2, 1571, 1572, 3, 2, 2, 2, 1572, 1574, 3, 2, 2, 2,
	1573, 1568, 3, 2, 2, 2, 1573, 1574, 3, 2, 2, 2, 1574, 1575, 3, 2, 2, 2,
	1575, 1576, 7, 32, 2, 2, 1576, 153, 3, 2, 2, 2, 1577, 1579, 7, 64, 2, 2,
	1578, 1577, 3, 2, 2, 2, 1578, 1579, 3, 2, 2, 2, 1579, 1580, 3, 2, 2, 2,
	1580, 1581, 7, 67, 2, 2, 1581, 155, 3, 2, 2, 2, 1582, 1583, 8, 79, 1, 2,
	1583, 1584, 5, 162, 82, 2, 1584, 1585, 5, 156, 79, 5, 1585, 1592, 3, 2,
	2, 2, 1586, 1587, 7, 31, 2, 2, 1587, 1588, 5, 156, 79, 2, 1588, 1589, 7,
	32, 2, 2, 1589, 1592, 3, 2, 2, 2, 1590, 1592, 5, 164, 83, 2, 1591, 1582,
	3, 2, 2, 2, 1591, 1586, 3, 2, 2, 2, 1591, 1590, 3, 2, 2, 2, 1592, 1603,
	3, 2, 2, 2, 1593, 1594, 12, 7, 2, 2, 1594, 1595, 5, 158, 80, 2, 1595, 1596,
	5, 156, 79, 8, 1596, 1602, 3, 2, 2, 2, 1597, 1598, 12, 6, 2, 2, 1598, 1599,
	5, 160, 81, 2, 1599, 1600, 5, 156, 79, 7, 1600, 1602, 3, 2, 2, 2, 1601,
	1593, 3, 2, 2, 2, 1601, 1597, 3, 2, 2, 2, 1602, 1605, 3, 2, 2, 2, 1603,
	1601, 3, 2, 2, 2, 1603, 1604, 3, 2, 2, 2, 1604, 157, 3, 2, 2, 2, 1605,
	1603, 3, 2, 2, 2, 1606, 1607, 9, 15, 2, 2, 1607, 159, 3, 2, 2, 2, 1608,
	1609, 9, 16, 2, 2, 1609, 161, 3, 2, 2, 2, 1610, 1611, 9, 17, 2, 2, 1611,
	163, 3, 2, 2, 2, 1612, 1613, 8, 83, 1, 2, 1613, 1614, 5, 168, 85, 2, 1614,
	1635, 3, 2, 2, 2, 1615, 1616, 12, 7, 2, 2, 1616, 1618, 7, 105, 2, 2, 1617,
	1619, 7, 106, 2, 2, 1618, 1617, 3, 2, 2, 2, 1618, 1619, 3, 2, 2, 2, 1619,
	1620, 3, 2, 2, 2, 1620, 1634, 9, 18, 2, 2, 1621, 1622, 12, 6, 2, 2, 1622,
	1623, 7, 22, 2, 2, 1623, 1634, 5, 168, 85, 2, 1624, 1625, 12, 5, 2, 2,
	1625, 1626, 5, 166, 84, 2, 1626, 1627, 5, 168, 85, 2, 1627, 1634, 3, 2,
	2, 2, 1628, 1629, 12, 4, 2, 2, 1629, 1630, 5, 166, 84, 2, 1630, 1631, 9,
	19, 2, 2, 1631, 1632, 5, 70, 36, 2, 1632, 1634, 3, 2, 2, 2, 1633, 1615,
	3, 2, 2, 2, 1633, 1621, 3, 2, 2, 2, 1633, 1624, 3, 2, 2, 2, 1633, 1628,
	3, 2, 2, 2, 1634, 1637, 3, 2, 2, 2, 1635, 1633, 3, 2, 2, 2, 1635, 1636,
	3, 2, 2, 2, 1636, 165, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1638, 1639,
	9, 20, 2, 2, 1639, 167, 3, 2, 2, 2, 1640, 1642, 5, 170, 86, 2, 1641, 1643,
	7, 106, 2, 2, 1642, 1641, 3, 2, 2, 2, 1642, 1643, 3, 2, 2, 2, 1643, 1644,
	3, 2, 2, 2, 1644, 1645, 7, 112, 2, 2, 1645, 1646, 5, 70, 36, 2, 1646, 1684,
	3, 2, 2, 2, 1647, 1649, 5, 170, 86, 2, 1648, 1650, 7, 106, 2, 2, 1649,
	1648, 3, 2, 2, 2, 1649, 1650, 3, 2, 2, 2, 1650, 1651, 3, 2, 2, 2, 1651,
	1652, 7, 112, 2, 2, 1652, 1653, 7, 31, 2, 2, 1653, 1658, 5, 156, 79, 2,
	1654, 1655, 7, 37, 2, 2, 1655, 1657, 5, 156, 79, 2, 1656, 1654, 3, 2, 2,
	2, 1657, 1660, 3, 2, 2, 2, 1658, 1656, 3, 2, 2, 2, 1658, 1659, 3, 2, 2,
	2, 1659, 1661, 3, 2, 2, 2, 1660, 1658, 3, 2, 2, 2, 1661, 1662, 7, 32, 2,
	2, 1662, 1684, 3, 2, 2, 2, 1663, 1665, 5, 170, 86, 2, 1664, 1666, 7, 106,
	2, 2, 1665, 1664, 3, 2, 2, 2, 1665, 1666, 3, 2, 2, 2, 1666, 1667, 3, 2,
	2, 2, 1667, 1668, 7, 111, 2, 2, 1668, 1669, 5, 170, 86, 2, 1669, 1670,
	7, 103, 2, 2, 1670, 1671, 5, 168, 85, 2, 1671, 1684, 3, 2, 2, 2, 1672,
	1674, 5, 170, 86, 2, 1673, 1675, 7, 106, 2, 2, 1674, 1673, 3, 2, 2, 2,
	1674, 1675, 3, 2, 2, 2, 1675, 1676, 3, 2, 2, 2, 1676, 1677, 7, 115, 2,
	2, 1677, 1680, 5, 172, 87, 2, 1678, 1679, 7, 214, 2, 2, 1679, 1681, 5,
	172, 87, 2, 1680, 1678, 3, 2, 2, 2, 1680, 1681, 3, 2, 2, 2, 1681, 1684,
	3, 2, 2, 2, 1682, 1684, 5, 170, 86, 2, 1683, 1640, 3, 2, 2, 2, 1683, 1647,
	3, 2, 2, 2, 1683, 1663, 3, 2, 2, 2, 1683, 1672, 3, 2, 2, 2, 1683, 1682,
	3, 2, 2, 2, 1684, 169, 3, 2, 2, 2, 1685, 1686, 8, 86, 1, 2, 1686, 1687,
	5, 172, 87, 2, 1687, 1720, 3, 2, 2, 2, 1688, 1689, 12, 13, 2, 2, 1689,
	1690, 7, 8, 2, 2, 1690, 1719, 5, 170, 86, 14, 1691, 1692, 12, 12, 2, 2,
	1692, 1693, 7, 9, 2, 2, 1693, 1719, 5, 170, 86, 13, 1694, 1695, 12, 11,
	2, 2, 1695, 1696, 7, 10, 2, 2, 1696, 1719, 5, 170, 86, 12, 1697, 1698,
	12, 10, 2, 2, 1698, 1699, 7, 11, 2, 2, 1699, 1719, 5, 170, 86, 11, 1700,
	1701, 12, 9, 2, 2, 1701, 1702, 7, 15, 2, 2, 1702, 1719, 5, 170, 86, 10,
	1703, 1704, 12, 8, 2, 2, 1704, 1705, 7, 16, 2, 2, 1705, 1719, 5, 170, 86,
	9, 1706, 1707, 12, 7, 2, 2, 1707, 1708, 7, 17, 2, 2, 1708, 1719, 5, 170,
	86, 8, 1709, 1710, 12, 6, 2, 2, 1710, 1711, 7, 18, 2, 2, 1711, 1719, 5,
	170, 86, 7, 1712, 1713, 12, 5, 2, 2, 1713, 1714, 7, 13, 2, 2, 1714, 1719,
	5, 170, 86, 6, 1715, 1716, 12, 4, 2, 2, 1716, 1717, 7, 12, 2, 2, 1717,
	1719, 5, 170, 86, 5, 1718, 1688, 3, 2, 2, 2, 1718, 1691, 3, 2, 2, 2, 1718,
	1694, 3, 2, 2, 2, 1718, 1697, 3, 2, 2, 2, 1718, 1700, 3, 2, 2, 2, 1718,
	1703, 3, 2, 2, 2, 1718, 1706, 3, 2, 2, 2, 1718, 1709, 3, 2, 2, 2, 1718,
	1712, 3, 2, 2, 2, 1718, 1715, 3, 2, 2, 2, 1719, 1722, 3, 2, 2, 2, 1720,
	1718, 3, 2, 2, 2, 1720, 1721, 3, 2, 2, 2, 1721, 171, 3, 2, 2, 2, 1722,
	1720, 3, 2, 2, 2, 1723, 1724, 8, 87, 1, 2, 1724, 1757, 5, 174, 88, 2, 1725,
	1757, 5, 90, 46, 2, 1726, 1757, 5, 92, 47, 2, 1727, 1757, 5, 134, 68, 2,
	1728, 1757, 5, 264, 133, 2, 1729, 1730, 9, 21, 2, 2, 1730, 1757, 5, 172,
	87, 8, 1731, 1733, 7, 220, 2, 2, 1732, 1731, 3, 2, 2, 2, 1732, 1733, 3,
	2, 2, 2, 1733, 1734, 3, 2, 2, 2, 1734, 1735, 7, 31, 2, 2, 1735, 1740, 5,
	156, 79, 2, 1736, 1737, 7, 37, 2, 2, 1737, 1739, 5, 156, 79, 2, 1738, 1736,
	3, 2, 2, 2, 1739, 1742, 3, 2, 2, 2, 1740, 1738, 3, 2, 2, 2, 1740, 1741,
	3, 2, 2, 2, 1741, 1743, 3, 2, 2, 2, 1742, 1740, 3, 2, 2, 2, 1743, 1744,
	7, 32, 2, 2, 1744, 1757, 3, 2, 2, 2, 1745, 1747, 7, 110, 2, 2, 1746, 1745,
	3, 2, 2, 2, 1746, 1747, 3, 2, 2, 2, 1747, 1748, 3, 2, 2, 2, 1748, 1757,
	5, 70, 36, 2, 1749, 1750, 7, 33, 2, 2, 1750, 1751, 5, 108, 55, 2, 1751,
	1752, 5, 156, 79, 2, 1752, 1753, 7, 34, 2, 2, 1753, 1757, 3, 2, 2, 2, 1754,
	1757, 5, 192, 97, 2, 1755, 1757, 5, 198, 100, 2, 1756, 1723, 3, 2, 2, 2,
	1756, 1725, 3, 2, 2, 2, 1756, 1726, 3, 2, 2, 2, 1756, 1727, 3, 2, 2, 2,
	1756, 1728, 3, 2, 2, 2, 1756, 1729, 3, 2, 2, 2, 1756, 1732, 3, 2, 2, 2,
	1756, 1746, 3, 2, 2, 2, 1756, 1749, 3, 2, 2, 2, 1756, 1754, 3, 2, 2, 2,
	1756, 1755, 3, 2, 2, 2, 1757, 1763, 3, 2, 2, 2, 1758, 1759, 12, 9, 2, 2,
	1759, 1760, 7, 5, 2, 2, 1760, 1762, 5, 172, 87, 10, 1761, 1758, 3, 2, 2,
	2, 1762, 1765, 3, 2, 2, 2, 1763, 1761, 3, 2, 2, 2, 1763, 1764, 3, 2, 2,
	2, 1764, 173, 3, 2, 2, 2, 1765, 1763, 3, 2, 2, 2, 1766, 1770, 5, 176, 89,
	2, 1767, 1770, 5, 182, 92, 2, 1768, 1770, 5, 188, 95, 2, 1769, 1766, 3,
	2, 2, 2, 1769, 1767, 3, 2, 2, 2, 1769, 1768, 3, 2, 2, 2, 1770, 175, 3,
	2, 2, 2, 1771, 1772, 5, 178, 90, 2, 1772, 1774, 7, 31, 2, 2, 1773, 1775,
	5, 180, 91, 2, 1774, 1773, 3, 2, 2, 2, 1774, 1775, 3, 2, 2, 2, 1775, 1785,
	3, 2, 2, 2, 1776, 1781, 5, 156, 79, 2, 1777, 1778, 7, 37, 2, 2, 1778, 1780,
	5, 156, 79, 2, 1779, 1777, 3, 2, 2, 2, 1780, 1783, 3, 2, 2, 2, 1781, 1779,
	3, 2, 2, 2, 1781, 1782, 3, 2, 2, 2, 1782, 1786, 3, 2, 2, 2, 1783, 1781,
	3, 2, 2, 2, 1784, 1786, 7, 17, 2, 2, 1785, 1776, 3, 2, 2, 2, 1785, 1784,
	3, 2, 2, 2, 1785, 1786, 3, 2, 2, 2, 1786, 1787, 3, 2, 2, 2, 1787, 1788,
	7, 32, 2, 2, 1788, 177, 3, 2, 2, 2, 1789, 1790, 9, 22, 2, 2, 1790, 179,
	3, 2, 2, 2, 1791, 1792, 7, 79, 2, 2, 1792, 181, 3, 2, 2, 2, 1793, 1796,
	5, 184, 93, 2, 1794, 1796, 5, 186, 94, 2, 1795, 1793, 3, 2, 2, 2, 1795,
	1794, 3, 2, 2, 2, 1796, 183, 3, 2, 2, 2, 1797, 1798, 7, 82, 2, 2, 1798,
	1799, 7, 31, 2, 2, 1799, 1800, 5, 156, 79, 2, 1800, 1801, 7, 96, 2, 2,
	1801, 1802, 5, 204, 103, 2, 1802, 1803, 7, 32, 2, 2, 1803, 185, 3, 2, 2,
	2, 1804, 1805, 7, 130, 2, 2, 1805, 1806, 7, 31, 2, 2, 1806, 1811, 5, 156,
	79, 2, 1807, 1808, 7, 37, 2, 2, 1808, 1810, 5, 156, 79, 2, 1809, 1807,
	3, 2, 2, 2, 1810, 1813, 3, 2, 2, 2, 1811, 1809, 3, 2, 2, 2, 1811, 1812,
	3, 2, 2, 2, 1812, 1816, 3, 2, 2, 2, 1813, 1811, 3, 2, 2, 2, 1814, 1815,
	7, 94, 2, 2, 1815, 1817, 5, 258, 130, 2, 1816, 1814, 3, 2, 2, 2, 1816,
	1817, 3, 2, 2, 2, 1817, 1818, 3, 2, 2, 2, 1818, 1819, 7, 32, 2, 2, 1819,
	187, 3, 2, 2, 2, 1820, 1821, 5, 190, 96, 2, 1821, 1831, 7, 31, 2, 2, 1822,
	1827, 5, 156, 79, 2, 1823, 1824, 7, 37, 2, 2, 1824, 1826, 5, 156, 79, 2,
	1825, 1823, 3, 2, 2, 2, 1826, 1829, 3, 2, 2, 2, 1827, 1825, 3, 2, 2, 2,
	1827, 1828, 3, 2, 2, 2, 1828, 1832, 3, 2, 2, 2, 1829, 1827, 3, 2, 2, 2,
	1830, 1832, 7, 17, 2, 2, 1831, 1822, 3, 2, 2, 2, 1831, 1830, 3, 2, 2, 2,
	1831, 1832, 3, 2, 2, 2, 1832, 1833, 3, 2, 2, 2, 1833, 1834, 7, 32, 2, 2,
	1834, 189, 3, 2, 2, 2, 1835, 1836, 5, 136, 69, 2, 1836, 1837, 7, 20, 2,
	2, 1837, 1839, 3, 2, 2, 2, 1838, 1835, 3, 2, 2, 2, 1838, 1839, 3, 2, 2,
	2, 1839, 1840, 3, 2, 2, 2, 1840, 1846, 5, 108, 55, 2, 1841, 1846, 7, 98,
	2, 2, 1842, 1846, 7, 137, 2, 2, 1843, 1846, 7, 138, 2, 2, 1844, 1846, 7,
	133, 2, 2, 1845, 1838, 3, 2, 2, 2, 1845, 1841, 3, 2, 2, 2, 1845, 1842,
	3, 2, 2, 2, 1845, 1843, 3, 2, 2, 2, 1845, 1844, 3, 2, 2, 2, 1846, 191,
	3, 2, 2, 2, 1847, 1849, 7, 80, 2, 2, 1848, 1850, 5, 172, 87, 2, 1849, 1848,
	3, 2, 2, 2, 1849, 1850, 3, 2, 2, 2, 1850, 1852, 3, 2, 2, 2, 1851, 1853,
	5, 194, 98, 2, 1852, 1851, 3, 2, 2, 2, 1853, 1854, 3, 2, 2, 2, 1854, 1852,
	3, 2, 2, 2, 1854, 1855, 3, 2, 2, 2, 1855, 1857, 3, 2, 2, 2, 1856, 1858,
	5, 196, 99, 2, 1857, 1856, 3, 2, 2, 2, 1857, 1858, 3, 2, 2, 2, 1858, 1859,
	3, 2, 2, 2, 1859, 1860, 7, 257, 2, 2, 1860, 193, 3, 2, 2, 2, 1861, 1862,
	7, 81, 2, 2, 1862, 1863, 5, 156, 79, 2, 1863, 1864, 7, 100, 2, 2, 1864,
	1865, 5, 156, 79, 2, 1865, 195, 3, 2, 2, 2, 1866, 1867, 7, 99, 2, 2, 1867,
	1868, 5, 156, 79, 2, 1868, 197, 3, 2, 2, 2, 1869, 1874, 5, 214, 108, 2,
	1870, 1874, 5, 208, 105, 2, 1871, 1874, 5, 210, 106, 2, 1872, 1874, 5,
	212, 107, 2, 1873, 1869, 3, 2, 2, 2, 1873, 1870, 3, 2, 2, 2, 1873, 1871,
	3, 2, 2, 2, 1873, 1872, 3, 2, 2, 2, 1874, 199, 3, 2, 2, 2, 1875, 1876,
	7, 116, 2, 2, 1876, 1877, 7, 118, 2, 2, 1877, 1882, 5, 202, 102, 2, 1878,
	1879, 7, 37, 2, 2, 1879, 1881, 5, 202, 102, 2, 1880, 1878, 3, 2, 2, 2,
	1881, 1884, 3, 2, 2, 2, 1882, 1880, 3, 2, 2, 2, 1882, 1883, 3, 2, 2, 2,
	1883, 1896, 3, 2, 2, 2, 1884, 1882, 3, 2, 2, 2, 1885, 1886, 7, 123, 2,
	2, 1886, 1887, 5, 156, 79, 2, 1887, 1894, 9, 23, 2, 2, 1888, 1889, 7, 419,
	2, 2, 1889, 1890, 9, 24, 2, 2, 1890, 1891, 5, 156, 79, 2, 1891, 1892, 9,
	23, 2, 2, 1892, 1893, 7, 421, 2, 2, 1893, 1895, 3, 2, 2, 2, 1894, 1888,
	3, 2, 2, 2, 1894, 1895, 3, 2, 2, 2, 1895, 1897, 3, 2, 2, 2, 1896, 1885,
	3, 2, 2, 2, 1896, 1897, 3, 2, 2, 2, 1897, 201, 3, 2, 2, 2, 1898, 1902,
	5, 134, 68, 2, 1899, 1902, 5, 96, 49, 2, 1900, 1902, 5, 156, 79, 2, 1901,
	1898, 3, 2, 2, 2, 1901, 1899, 3, 2, 2, 2, 1901, 1900, 3, 2, 2, 2, 1902,
	1905, 3, 2, 2, 2, 1903, 1904, 7, 242, 2, 2, 1904, 1906, 5, 108, 55, 2,
	1905, 1903, 3, 2, 2, 2, 1905, 1906, 3, 2, 2, 2, 1906, 1908, 3, 2, 2, 2,
	1907, 1909, 9, 25, 2, 2, 1908, 1907, 3, 2, 2, 2, 1908, 1909, 3, 2, 2, 2,
	1909, 203, 3, 2, 2, 2, 1910, 1911, 5, 258, 130, 2, 1911, 1912, 7, 20, 2,
	2, 1912, 1914, 3, 2, 2, 2, 1913, 1910, 3, 2, 2, 2, 1913, 1914, 3, 2, 2,
	2, 1914, 1915, 3, 2, 2, 2, 1915, 1927, 5, 206, 104, 2, 1916, 1928, 5, 152,
	77, 2, 1917, 1918, 7, 31, 2, 2, 1918, 1919, 7, 148, 2, 2, 1919, 1928, 7,
	32, 2, 2, 1920, 1922, 7, 31, 2, 2, 1921, 1923, 9, 26, 2, 2, 1922, 1921,
	3, 2, 2, 2, 1922, 1923, 3, 2, 2, 2, 1923, 1924, 3, 2, 2, 2, 1924, 1925,
	5, 258, 130, 2, 1925, 1926, 7, 32, 2, 2, 1926, 1928, 3, 2, 2, 2, 1927,
	1916, 3, 2, 2, 2, 1927, 1917, 3, 2, 2, 2, 1927, 1920, 3, 2, 2, 2, 1927,
	1928, 3, 2, 2, 2, 1928, 205, 3, 2, 2, 2, 1929, 1930, 9, 27, 2, 2, 1930,
	207, 3, 2, 2, 2, 1931, 1935, 7, 644, 2, 2, 1932, 1933, 7, 77, 2, 2, 1933,
	1934, 7, 135, 2, 2, 1934, 1936, 7, 297, 2, 2, 1935, 1932, 3, 2, 2, 2, 1935,
	1936, 3, 2, 2, 2, 1936, 1937, 3, 2, 2, 2, 1937, 1938, 7, 645, 2, 2, 1938,
	209, 3, 2, 2, 2, 1939, 1940, 7, 82, 2, 2, 1940, 1941, 7, 31, 2, 2, 1941,
	1942, 5, 156, 79, 2, 1942, 1943, 7, 96, 2, 2, 1943, 1947, 5, 204, 103,
	2, 1944, 1945, 7, 31, 2, 2, 1945, 1946, 7, 646, 2, 2, 1946, 1948, 7, 32,
	2, 2, 1947, 1944, 3, 2, 2, 2, 1947, 1948, 3, 2, 2, 2, 1948, 1949, 3, 2,
	2, 2, 1949, 1950, 7, 32, 2, 2, 1950, 211, 3, 2, 2, 2, 1951, 1952, 7, 245,
	2, 2, 1952, 1956, 5, 204, 103, 2, 1953, 1954, 7, 31, 2, 2, 1954, 1955,
	7, 646, 2, 2, 1955, 1957, 7, 32, 2, 2, 1956, 1953, 3, 2, 2, 2, 1956, 1957,
	3, 2, 2, 2, 1957, 1958, 3, 2, 2, 2, 1958, 1959, 7, 37, 2, 2, 1959, 1962,
	5, 156, 79, 2, 1960, 1961, 7, 37, 2, 2, 1961, 1963, 7, 646, 2, 2, 1962,
	1960, 3, 2, 2, 2, 1962, 1963, 3, 2, 2, 2, 1963, 213, 3, 2, 2, 2, 1964,
	1965, 5, 174, 88, 2, 1965, 1966, 5, 216, 109, 2, 1966, 215, 3, 2, 2, 2,
	1967, 1968, 7, 278, 2, 2, 1968, 1970, 7, 31, 2, 2, 1969, 1971, 5, 218,
	110, 2, 1970, 1969, 3, 2, 2, 2, 1970, 1971, 3, 2, 2, 2, 1971, 1973, 3,
	2, 2, 2, 1972, 1974, 5, 200, 101, 2, 1973, 1972, 3, 2, 2, 2, 1973, 1974,
	3, 2, 2, 2, 1974, 1976, 3, 2, 2, 2, 1975, 1977, 5, 220, 111, 2, 1976, 1975,
	3, 2, 2, 2, 1976, 1977, 3, 2, 2, 2, 1977, 1978, 3, 2, 2, 2, 1978, 1979,
	7, 32, 2, 2, 1979, 217, 3, 2, 2, 2, 1980, 1981, 7, 217, 2, 2, 1981, 1982,
	7, 118, 2, 2, 1982, 1987, 5, 156, 79, 2, 1983, 1984, 7, 37, 2, 2, 1984,
	1986, 5, 156, 79, 2, 1985, 1983, 3, 2, 2, 2, 1986, 1989, 3, 2, 2, 2, 1987,
	1985, 3, 2, 2, 2, 1987, 1988, 3, 2, 2, 2, 1988, 219, 3, 2, 2, 2, 1989,
	1987, 3, 2, 2, 2, 1990, 1991, 9, 28, 2, 2, 1991, 1992, 5, 222, 112, 2,
	1992, 221, 3, 2, 2, 2, 1993, 1996, 5, 228, 115, 2, 1994, 1996, 5, 224,
	113, 2, 1995, 1993, 3, 2, 2, 2, 1995, 1994, 3, 2, 2, 2, 1996, 223, 3, 2,
	2, 2, 1997, 1998, 7, 111, 2, 2, 1998, 1999, 5, 226, 114, 2, 1999, 2000,
	7, 103, 2, 2, 2000, 2001, 5, 226, 114, 2, 2001, 225, 3, 2, 2, 2, 2002,
	2005, 5, 228, 115, 2, 2003, 2005, 5, 230, 116, 2, 2004, 2002, 3, 2, 2,
	2, 2004, 2003, 3, 2, 2, 2, 2005, 227, 3, 2, 2, 2, 2006, 2007, 7, 267, 2,
	2, 2007, 2013, 7, 283, 2, 2, 2008, 2009, 7, 646, 2, 2, 2009, 2013, 7, 283,
	2, 2, 2010, 2011, 7, 154, 2, 2, 2011, 2013, 7, 220, 2, 2, 2012, 2006, 3,
	2, 2, 2, 2012, 2008, 3, 2, 2, 2, 2012, 2010, 3, 2, 2, 2, 2013, 229, 3,
	2, 2, 2, 2014, 2015, 7, 267, 2, 2, 2015, 2021, 7, 261, 2, 2, 2016, 2017,
	7, 646, 2, 2, 2017, 2021, 7, 261, 2, 2, 2018, 2019, 7, 154, 2, 2, 2019,
	2021, 7, 220, 2, 2, 2020, 2014, 3, 2, 2, 2, 2020, 2016, 3, 2, 2, 2, 2020,
	2018, 3, 2, 2, 2, 2021, 231, 3, 2, 2, 2, 2022, 2024, 5, 134, 68, 2, 2023,
	2025, 9, 25, 2, 2, 2024, 2023, 3, 2, 2, 2, 2024, 2025, 3, 2, 2, 2, 2025,
	233, 3, 2, 2, 2, 2026, 2027, 7, 260, 2, 2, 2027, 2028, 7, 24, 2, 2, 2028,
	2040, 7, 646, 2, 2, 2029, 2040, 5, 240, 121, 2, 2030, 2031, 9, 29, 2, 2,
	2031, 2040, 5, 238, 120, 2, 2032, 2033, 7, 271, 2, 2, 2033, 2034, 7, 24,
	2, 2, 2034, 2040, 7, 646, 2, 2, 2035, 2037, 5, 236, 119, 2, 2036, 2038,
	5, 246, 124, 2, 2037, 2036, 3, 2, 2, 2, 2037, 2038, 3, 2, 2, 2, 2038, 2040,
	3, 2, 2, 2, 2039, 2026, 3, 2, 2, 2, 2039, 2029, 3, 2, 2, 2, 2039, 2030,
	3, 2, 2, 2, 2039, 2032, 3, 2, 2, 2, 2039, 2035, 3, 2, 2, 2, 2040, 235,
	3, 2, 2, 2, 2041, 2042, 7, 387, 2, 2, 2042, 2043, 7, 24, 2, 2, 2043, 2044,
	9, 30, 2, 2, 2044, 237, 3, 2, 2, 2, 2045, 2046, 7, 24, 2, 2, 2046, 2048,
	7, 646, 2, 2, 2047, 2049, 7, 250, 2, 2, 2048, 2047, 3, 2, 2, 2, 2048, 2049,
	3, 2, 2, 2, 2049, 239, 3, 2, 2, 2, 2050, 2051, 5, 242, 122, 2, 2051, 2052,
	5, 244, 123, 2, 2052, 241, 3, 2, 2, 2, 2053, 2054, 9, 31, 2, 2, 2054, 243,
	3, 2, 2, 2, 2055, 2056, 7, 24, 2, 2, 2056, 2057, 9, 32, 2, 2, 2057, 245,
	3, 2, 2, 2, 2058, 2059, 7, 97, 2, 2, 2059, 2060, 7, 218, 2, 2, 2060, 2061,
	7, 31, 2, 2, 2061, 2062, 5, 248, 125, 2, 2062, 2063, 7, 32, 2, 2, 2063,
	247, 3, 2, 2, 2, 2064, 2069, 5, 250, 126, 2, 2065, 2066, 7, 37, 2, 2, 2066,
	2068, 5, 250, 126, 2, 2067, 2065, 3, 2, 2, 2, 2068, 2071, 3, 2, 2, 2, 2069,
	2067, 3, 2, 2, 2, 2069, 2070, 3, 2, 2, 2, 2070, 249, 3, 2, 2, 2, 2071,
	2069, 3, 2, 2, 2, 2072, 2075, 7, 646, 2, 2, 2073, 2075, 5, 252, 127, 2,
	2074, 2072, 3, 2, 2, 2, 2074, 2073, 3, 2, 2, 2, 2075, 251, 3, 2, 2, 2,
	2076, 2077, 7, 646, 2, 2, 2077, 2078, 7, 102, 2, 2, 2078, 2079, 7, 646,
	2, 2, 2079, 253, 3, 2, 2, 2, 2080, 2081, 7, 393, 2, 2, 2081, 2082, 7, 31,
	2, 2, 2082, 2083, 7, 402, 2, 2, 2083, 2084, 7, 24, 2, 2, 2084, 2086, 7,
	646, 2, 2, 2085, 2087, 7, 250, 2, 2, 2086, 2085, 3, 2, 2, 2, 2086, 2087,
	3, 2, 2, 2, 2087, 2088, 3, 2, 2, 2, 2088, 2089, 7, 37, 2, 2, 2089, 2090,
	7, 377, 2, 2, 2090, 2091, 7, 24, 2, 2, 2091, 2092, 9, 33, 2, 2, 2092, 2093,
	7, 32, 2, 2, 2093, 255, 3, 2, 2, 2, 2094, 2099, 7, 97, 2, 2, 2095, 2096,
	7, 31, 2, 2, 2096, 2097, 5, 254, 128, 2, 2097, 2098, 7, 32, 2, 2, 2098,
	2100, 3, 2, 2, 2, 2099, 2095, 3, 2, 2, 2, 2099, 2100, 3, 2, 2, 2, 2100,
	257, 3, 2, 2, 2, 2101, 2102, 7, 644, 2, 2, 2102, 259, 3, 2, 2, 2, 2103,
	2108, 5, 258, 130, 2, 2104, 2105, 7, 37, 2, 2, 2105, 2107, 5, 258, 130,
	2, 2106, 2104, 3, 2, 2, 2, 2107, 2110, 3, 2, 2, 2, 2108, 2106, 3, 2, 2,
	2, 2108, 2109, 3, 2, 2, 2, 2109, 261, 3, 2, 2, 2, 2110, 2108, 3, 2, 2,
	2, 2111, 2112, 7, 3, 2, 2, 2112, 263, 3, 2, 2, 2, 2113, 2114, 7, 42, 2,
	2, 2114, 2115, 5, 108, 55, 2, 2115, 265, 3, 2, 2, 2, 2116, 2117, 9, 34,
	2, 2, 2117, 2122, 7, 96, 2, 2, 2118, 2123, 7, 502, 2, 2, 2119, 2123, 7,
	292, 2, 2, 2120, 2123, 7, 507, 2, 2, 2121, 2123, 5, 94, 48, 2, 2122, 2118,
	3, 2, 2, 2, 2122, 2119, 3, 2, 2, 2, 2122, 2120, 3, 2, 2, 2, 2122, 2121,
	3, 2, 2, 2, 2123, 267, 3, 2, 2, 2, 2124, 2125, 5, 108, 55, 2, 2125, 269,
	3, 2, 2, 2, 2126, 2127, 5, 264, 133, 2, 2127, 271, 3, 2, 2, 2, 2128, 2129,
	5, 108, 55, 2, 2129, 273, 3, 2, 2, 2, 2130, 2131, 5, 264, 133, 2, 2131,
	275, 3, 2, 2, 2, 2132, 2133, 9, 35, 2, 2, 2133, 277, 3, 2, 2, 2, 2134,
	2137, 5, 280, 141, 2, 2135, 2137, 5, 700, 351, 2, 2136, 2134, 3, 2, 2,
	2, 2136, 2135, 3, 2, 2, 2, 2137, 279, 3, 2, 2, 2, 2138, 2139, 7, 51, 2,
	2, 2139, 2140, 7, 60, 2, 2, 2140, 2141, 5, 126, 64, 2, 2141, 2142, 5, 342,
	172, 2, 2142, 2143, 5, 344, 173, 2, 2143, 281, 3, 2, 2, 2, 2144, 2145,
	7, 51, 2, 2, 2145, 2146, 5, 454, 228, 2, 2146, 2147, 7, 62, 2, 2, 2147,
	2148, 5, 146, 74, 2, 2148, 2149, 7, 97, 2, 2, 2149, 2150, 5, 126, 64, 2,
	2150, 2151, 5, 142, 72, 2, 2151, 2152, 5, 622, 312, 2, 2152, 283, 3, 2,
	2, 2, 2153, 2154, 7, 51, 2, 2, 2154, 2155, 7, 203, 2, 2, 2155, 2156, 5,
	112, 57, 2, 2156, 2157, 5, 528, 265, 2, 2157, 285, 3, 2, 2, 2, 2158, 2161,
	7, 51, 2, 2, 2159, 2160, 7, 104, 2, 2, 2160, 2162, 7, 52, 2, 2, 2161, 2159,
	3, 2, 2, 2, 2161, 2162, 3, 2, 2, 2, 2162, 2163, 3, 2, 2, 2, 2163, 2164,
	7, 70, 2, 2, 2164, 2165, 5, 116, 59, 2, 2165, 2166, 5, 572, 287, 2, 2166,
	2167, 5, 574, 288, 2, 2167, 287, 3, 2, 2, 2, 2168, 2171, 7, 51, 2, 2, 2169,
	2170, 7, 104, 2, 2, 2170, 2172, 7, 52, 2, 2, 2171, 2169, 3, 2, 2, 2, 2171,
	2172, 3, 2, 2, 2, 2172, 2173, 3, 2, 2, 2, 2173, 2174, 9, 36, 2, 2, 2174,
	2175, 5, 118, 60, 2, 2175, 2176, 5, 590, 296, 2, 2176, 2177, 5, 594, 298,
	2, 2177, 289, 3, 2, 2, 2, 2178, 2181, 7, 51, 2, 2, 2179, 2180, 7, 104,
	2, 2, 2180, 2182, 7, 52, 2, 2, 2181, 2179, 3, 2, 2, 2, 2181, 2182, 3, 2,
	2, 2, 2182, 2183, 3, 2, 2, 2, 2183, 2184, 7, 74, 2, 2, 2184, 2185, 5, 120,
	61, 2, 2185, 2186, 5, 604, 303, 2, 2186, 291, 3, 2, 2, 2, 2187, 2190, 7,
	51, 2, 2, 2188, 2189, 7, 104, 2, 2, 2189, 2191, 7, 52, 2, 2, 2190, 2188,
	3, 2, 2, 2, 2190, 2191, 3, 2, 2, 2, 2191, 2192, 3, 2, 2, 2, 2192, 2193,
	7, 71, 2, 2, 2193, 2194, 5, 122, 62, 2, 2194, 2195, 7, 97, 2, 2, 2195,
	2196, 5, 618, 310, 2, 2196, 2197, 5, 612, 307, 2, 2197, 293, 3, 2, 2, 2,
	2198, 2199, 7, 51, 2, 2, 2199, 2200, 7, 376, 2, 2, 2200, 2204, 5, 124,
	63, 2, 2201, 2203, 5, 620, 311, 2, 2202, 2201, 3, 2, 2, 2, 2203, 2206,
	3, 2, 2, 2, 2204, 2202, 3, 2, 2, 2, 2204, 2205, 3, 2, 2, 2, 2205, 295,
	3, 2, 2, 2, 2206, 2204, 3, 2, 2, 2, 2207, 2208, 7, 51, 2, 2, 2208, 2209,
	7, 343, 2, 2, 2209, 2212, 5, 132, 67, 2, 2210, 2211, 7, 639, 2, 2, 2211,
	2213, 7, 645, 2, 2, 2212, 2210, 3, 2, 2, 2, 2212, 2213, 3, 2, 2, 2, 2213,
	2214, 3, 2, 2, 2, 2214, 2215, 7, 97, 2, 2, 2215, 2216, 7, 363, 2, 2, 2216,
	2218, 5, 128, 65, 2, 2217, 2219, 5, 690, 346, 2, 2218, 2217, 3, 2, 2, 2,
	2218, 2219, 3, 2, 2, 2, 2219, 297, 3, 2, 2, 2, 2220, 2221, 7, 51, 2, 2,
	2221, 2222, 7, 55, 2, 2, 2222, 2226, 5, 696, 349, 2, 2223, 2225, 5, 698,
	350, 2, 2224, 2223, 3, 2, 2, 2, 2225, 2228, 3, 2, 2, 2, 2226, 2224, 3,
	2, 2, 2, 2226, 2227, 3, 2, 2, 2, 2227, 299, 3, 2, 2, 2, 2228, 2226, 3,
	2, 2, 2, 2229, 2230, 7, 52, 2, 2, 2230, 2231, 7, 60, 2, 2, 2231, 2232,
	5, 126, 64, 2, 2232, 2237, 5, 456, 229, 2, 2233, 2234, 7, 37, 2, 2, 2234,
	2236, 5, 456, 229, 2, 2235, 2233, 3, 2, 2, 2, 2236, 2239, 3, 2, 2, 2, 2237,
	2235, 3, 2, 2, 2, 2237, 2238, 3, 2, 2, 2, 2238, 301, 3, 2, 2, 2, 2239,
	2237, 3, 2, 2, 2, 2240, 2241, 7, 52, 2, 2, 2241, 2244, 7, 62, 2, 2, 2242,
	2245, 5, 146, 74, 2, 2243, 2245, 7, 113, 2, 2, 2244, 2242, 3, 2, 2, 2,
	2244, 2243, 3, 2, 2, 2, 2245, 2246, 3, 2, 2, 2, 2246, 2247, 7, 97, 2, 2,
	2247, 2248, 5, 126, 64, 2, 2248, 2249, 5, 628, 315, 2, 2249, 303, 3, 2,
	2, 2, 2250, 2251, 7, 52, 2, 2, 2251, 2254, 7, 203, 2, 2, 2252, 2255, 5,
	112, 57, 2, 2253, 2255, 7, 154, 2, 2, 2254, 2252, 3, 2, 2, 2, 2254, 2253,
	3, 2, 2, 2, 2255, 2259, 3, 2, 2, 2, 2256, 2258, 5, 640, 321, 2, 2257, 2256,
	3, 2, 2, 2, 2258, 2261, 3, 2, 2, 2, 2259, 2257, 3, 2, 2, 2, 2259, 2260,
	3, 2, 2, 2, 2260, 305, 3, 2, 2, 2, 2261, 2259, 3, 2, 2, 2, 2262, 2263,
	7, 52, 2, 2, 2263, 2264, 9, 36, 2, 2, 2264, 2265, 5, 118, 60, 2, 2265,
	2266, 5, 590, 296, 2, 2266, 2267, 5, 594, 298, 2, 2267, 307, 3, 2, 2, 2,
	2268, 2269, 7, 52, 2, 2, 2269, 2270, 7, 70, 2, 2, 2270, 2271, 5, 116, 59,
	2, 2271, 2272, 5, 572, 287, 2, 2272, 2273, 5, 574, 288, 2, 2273, 309, 3,
	2, 2, 2, 2274, 2275, 7, 52, 2, 2, 2275, 2276, 7, 74, 2, 2, 2276, 2277,
	5, 120, 61, 2, 2277, 2278, 5, 604, 303, 2, 2278, 311, 3, 2, 2, 2, 2279,
	2280, 7, 52, 2, 2, 2280, 2281, 7, 71, 2, 2, 2281, 2282, 5, 122, 62, 2,
	2282, 2283, 7, 97, 2, 2, 2283, 2284, 5, 618, 310, 2, 2284, 2285, 5, 612,
	307, 2, 2285, 313, 3, 2, 2, 2, 2286, 2287, 7, 52, 2, 2, 2287, 2288, 7,
	376, 2, 2, 2288, 2292, 5, 124, 63, 2, 2289, 2291, 5, 620, 311, 2, 2290,
	2289, 3, 2, 2, 2, 2291, 2294, 3, 2, 2, 2, 2292, 2290, 3, 2, 2, 2, 2292,
	2293, 3, 2, 2, 2, 2293, 315, 3, 2, 2, 2, 2294, 2292, 3, 2, 2, 2, 2295,
	2296, 7, 52, 2, 2, 2296, 2297, 7, 343, 2, 2, 2297, 2301, 5, 132, 67, 2,
	2298, 2299, 7, 97, 2, 2, 2299, 2300, 7, 363, 2, 2, 2300, 2302, 5, 128,
	65, 2, 2301, 2298, 3, 2, 2, 2, 2301, 2302, 3, 2, 2, 2, 2302, 2304, 3, 2,
	2, 2, 2303, 2305, 5, 692, 347, 2, 2304, 2303, 3, 2, 2, 2, 2304, 2305, 3,
	2, 2, 2, 2305, 317, 3, 2, 2, 2, 2306, 2307, 7, 52, 2, 2, 2307, 2308, 7,
	55, 2, 2, 2308, 2309, 5, 114, 58, 2, 2309, 2311, 7, 640, 2, 2, 2310, 2312,
	5, 762, 382, 2, 2311, 2310, 3, 2, 2, 2, 2311, 2312, 3, 2, 2, 2, 2312, 2313,
	3, 2, 2, 2, 2313, 2314, 5, 258, 130, 2, 2314, 319, 3, 2, 2, 2, 2315, 2316,
	7, 53, 2, 2, 2316, 2318, 7, 60, 2, 2, 2317, 2319, 5, 526, 264, 2, 2318,
	2317, 3, 2, 2, 2, 2318, 2319, 3, 2, 2, 2, 2319, 2320, 3, 2, 2, 2, 2320,
	2321, 5, 144, 73, 2, 2321, 321, 3, 2, 2, 2, 2322, 2323, 7, 53, 2, 2, 2323,
	2325, 7, 62, 2, 2, 2324, 2326, 5, 526, 264, 2, 2325, 2324, 3, 2, 2, 2,
	2325, 2326, 3, 2, 2, 2, 2326, 2327, 3, 2, 2, 2, 2327, 2328, 5, 146, 74,
	2, 2328, 2329, 7, 97, 2, 2, 2329, 2330, 5, 126, 64, 2, 2330, 323, 3, 2,
	2, 2, 2331, 2332, 7, 53, 2, 2, 2332, 2334, 7, 203, 2, 2, 2333, 2335, 5,
	526, 264, 2, 2334, 2333, 3, 2, 2, 2, 2334, 2335, 3, 2, 2, 2, 2335, 2336,
	3, 2, 2, 2, 2336, 2341, 5, 112, 57, 2, 2337, 2338, 7, 37, 2, 2, 2338, 2340,
	5, 112, 57, 2, 2339, 2337, 3, 2, 2, 2, 2340, 2343, 3, 2, 2, 2, 2341, 2339,
	3, 2, 2, 2, 2341, 2342, 3, 2, 2, 2, 2342, 325, 3, 2, 2, 2, 2343, 2341,
	3, 2, 2, 2, 2344, 2345, 7, 53, 2, 2, 2345, 2347, 7, 70, 2, 2, 2346, 2348,
	5, 526, 264, 2, 2347, 2346, 3, 2, 2, 2, 2347, 2348, 3, 2, 2, 2, 2348, 2349,
	3, 2, 2, 2, 2349, 2354, 5, 116, 59, 2, 2350, 2351, 7, 37, 2, 2, 2351, 2353,
	5, 116, 59, 2, 2352, 2350, 3, 2, 2, 2, 2353, 2356, 3, 2, 2, 2, 2354, 2352,
	3, 2, 2, 2, 2354, 2355, 3, 2, 2, 2, 2355, 327, 3, 2, 2, 2, 2356, 2354,
	3, 2, 2, 2, 2357, 2358, 7, 53, 2, 2, 2358, 2360, 9, 36, 2, 2, 2359, 2361,
	5, 526, 264, 2, 2360, 2359, 3, 2, 2, 2, 2360, 2361, 3, 2, 2, 2, 2361, 2362,
	3, 2, 2, 2, 2362, 2367, 5, 118, 60, 2, 2363, 2364, 7, 37, 2, 2, 2364, 2366,
	5, 118, 60, 2, 2365, 2363, 3, 2, 2, 2, 2366, 2369, 3, 2, 2, 2, 2367, 2365,
	3, 2, 2, 2, 2367, 2368, 3, 2, 2, 2, 2368, 329, 3, 2, 2, 2, 2369, 2367,
	3, 2, 2, 2, 2370, 2371, 7, 53, 2, 2, 2371, 2373, 7, 74, 2, 2, 2372, 2374,
	5, 526, 264, 2, 2373, 2372, 3, 2, 2, 2, 2373, 2374, 3, 2, 2, 2, 2374, 2375,
	3, 2, 2, 2, 2375, 2380, 5, 120, 61, 2, 2376, 2377, 7, 37, 2, 2, 2377, 2379,
	5, 120, 61, 2, 2378, 2376, 3, 2, 2, 2, 2379, 2382, 3, 2, 2, 2, 2380, 2378,
	3, 2, 2, 2, 2380, 2381, 3, 2, 2, 2, 2381, 331, 3, 2, 2, 2, 2382, 2380,
	3, 2, 2, 2, 2383, 2384, 7, 53, 2, 2, 2384, 2386, 7, 71, 2, 2, 2385, 2387,
	5, 526, 264, 2, 2386, 2385, 3, 2, 2, 2, 2386, 2387, 3, 2, 2, 2, 2387, 2388,
	3, 2, 2, 2, 2388, 2393, 5, 122, 62, 2, 2389, 2390, 7, 37, 2, 2, 2390, 2392,
	5, 122, 62, 2, 2391, 2389, 3, 2, 2, 2, 2392, 2395, 3, 2, 2, 2, 2393, 2391,
	3, 2, 2, 2, 2393, 2394, 3, 2, 2, 2, 2394, 2402, 3, 2, 2, 2, 2395, 2393,
	3, 2, 2, 2, 2396, 2400, 7, 97, 2, 2, 2397, 2401, 7, 203, 2, 2, 2398, 2399,
	7, 113, 2, 2, 2399, 2401, 7, 313, 2, 2, 2400, 2397, 3, 2, 2, 2, 2400, 2398,
	3, 2, 2, 2, 2401, 2403, 3, 2, 2, 2, 2402, 2396, 3, 2, 2, 2, 2402, 2403,
	3, 2, 2, 2, 2403, 333, 3, 2, 2, 2, 2404, 2405, 7, 53, 2, 2, 2405, 2407,
	7, 376, 2, 2, 2406, 2408, 5, 526, 264, 2, 2407, 2406, 3, 2, 2, 2, 2407,
	2408, 3, 2, 2, 2, 2408, 2409, 3, 2, 2, 2, 2409, 2414, 5, 124, 63, 2, 2410,
	2411, 7, 37, 2, 2, 2411, 2413, 5, 124, 63, 2, 2412, 2410, 3, 2, 2, 2, 2413,
	2416, 3, 2, 2, 2, 2414, 2412, 3, 2, 2, 2, 2414, 2415, 3, 2, 2, 2, 2415,
	335, 3, 2, 2, 2, 2416, 2414, 3, 2, 2, 2, 2417, 2418, 7, 53, 2, 2, 2418,
	2419, 7, 343, 2, 2, 2419, 2420, 5, 132, 67, 2, 2420, 337, 3, 2, 2, 2, 2421,
	2422, 7, 53, 2, 2, 2422, 2425, 7, 55, 2, 2, 2423, 2424, 7, 98, 2, 2, 2424,
	2426, 7, 110, 2, 2, 2425, 2423, 3, 2, 2, 2, 2425, 2426, 3, 2, 2, 2, 2426,
	2427, 3, 2, 2, 2, 2427, 2428, 5, 114, 58, 2, 2428, 339, 3, 2, 2, 2, 2429,
	2430, 7, 54, 2, 2, 2430, 2431, 7, 60, 2, 2, 2431, 2432, 5, 126, 64, 2,
	2432, 341, 3, 2, 2, 2, 2433, 2434, 7, 96, 2, 2, 2434, 2436, 7, 259, 2,
	2, 2435, 2433, 3, 2, 2, 2, 2435, 2436, 3, 2, 2, 2, 2436, 343, 3, 2, 2,
	2, 2437, 2438, 5, 346, 174, 2, 2438, 2439, 5, 430, 216, 2, 2439, 2440,
	5, 432, 217, 2, 2440, 345, 3, 2, 2, 2, 2441, 2442, 7, 31, 2, 2, 2442, 2447,
	5, 348, 175, 2, 2443, 2444, 7, 37, 2, 2, 2444, 2446, 5, 348, 175, 2, 2445,
	2443, 3, 2, 2, 2, 2446, 2449, 3, 2, 2, 2, 2447, 2445, 3, 2, 2, 2, 2447,
	2448, 3, 2, 2, 2, 2448, 2452, 3, 2, 2, 2, 2449, 2447, 3, 2, 2, 2, 2450,
	2451, 7, 37, 2, 2, 2451, 2453, 5, 428, 215, 2, 2452, 2450, 3, 2, 2, 2,
	2452, 2453, 3, 2, 2, 2, 2453, 2454, 3, 2, 2, 2, 2454, 2455, 7, 32, 2, 2,
	2455, 347, 3, 2, 2, 2, 2456, 2462, 5, 350, 176, 2, 2457, 2462, 5, 404,
	203, 2, 2458, 2462, 5, 406, 204, 2, 2459, 2462, 5, 408, 205, 2, 2460, 2462,
	5, 422, 212, 2, 2461, 2456, 3, 2, 2, 2, 2461, 2457, 3, 2, 2, 2, 2461, 2458,
	3, 2, 2, 2, 2461, 2459, 3, 2, 2, 2, 2461, 2460, 3, 2, 2, 2, 2462, 349,
	3, 2, 2, 2, 2463, 2464, 5, 134, 68, 2, 2464, 2468, 5, 204, 103, 2, 2465,
	2467, 5, 352, 177, 2, 2466, 2465, 3, 2, 2, 2, 2467, 2470, 3, 2, 2, 2, 2468,
	2466, 3, 2, 2, 2, 2468, 2469, 3, 2, 2, 2, 2469, 2471, 3, 2, 2, 2, 2470,
	2468, 3, 2, 2, 2, 2471, 2473, 5, 402, 202, 2, 2472, 2474, 5, 392, 197,
	2, 2473, 2472, 3, 2, 2, 2, 2473, 2474, 3, 2, 2, 2, 2474, 351, 3, 2, 2,
	2, 2475, 2529, 7, 258, 2, 2, 2476, 2477, 7, 242, 2, 2, 2477, 2529, 5, 150,
	76, 2, 2478, 2529, 7, 293, 2, 2, 2479, 2480, 7, 270, 2, 2, 2480, 2481,
	7, 77, 2, 2, 2481, 2482, 7, 31, 2, 2, 2482, 2483, 7, 70, 2, 2, 2483, 2484,
	7, 24, 2, 2, 2484, 2485, 7, 645, 2, 2, 2485, 2529, 7, 32, 2, 2, 2486, 2487,
	7, 63, 2, 2, 2487, 2489, 5, 258, 130, 2, 2488, 2486, 3, 2, 2, 2, 2488,
	2489, 3, 2, 2, 2, 2489, 2490, 3, 2, 2, 2, 2490, 2491, 7, 153, 2, 2, 2491,
	2529, 5, 156, 79, 2, 2492, 2498, 7, 264, 2, 2, 2493, 2494, 7, 31, 2, 2,
	2494, 2495, 7, 646, 2, 2, 2495, 2496, 7, 37, 2, 2, 2496, 2497, 7, 646,
	2, 2, 2497, 2499, 7, 32, 2, 2, 2498, 2493, 3, 2, 2, 2, 2498, 2499, 3, 2,
	2, 2, 2499, 2529, 3, 2, 2, 2, 2500, 2501, 7, 106, 2, 2, 2501, 2502, 7,
	101, 2, 2, 2502, 2529, 7, 288, 2, 2, 2503, 2504, 7, 227, 2, 2, 2504, 2505,
	7, 224, 2, 2, 2505, 2506, 7, 96, 2, 2, 2506, 2507, 7, 220, 2, 2, 2507,
	2509, 9, 37, 2, 2, 2508, 2510, 7, 215, 2, 2, 2509, 2508, 3, 2, 2, 2, 2509,
	2510, 3, 2, 2, 2, 2510, 2529, 3, 2, 2, 2, 2511, 2513, 7, 106, 2, 2, 2512,
	2511, 3, 2, 2, 2, 2512, 2513, 3, 2, 2, 2, 2513, 2514, 3, 2, 2, 2, 2514,
	2529, 7, 107, 2, 2, 2515, 2529, 7, 290, 2, 2, 2516, 2517, 7, 256, 2, 2,
	2517, 2518, 7, 77, 2, 2, 2518, 2529, 5, 354, 178, 2, 2519, 2524, 5, 356,
	179, 2, 2520, 2521, 7, 37, 2, 2, 2521, 2523, 5, 356, 179, 2, 2522, 2520,
	3, 2, 2, 2, 2523, 2526, 3, 2, 2, 2, 2524, 2522, 3, 2, 2, 2, 2524, 2525,
	3, 2, 2, 2, 2525, 2529, 3, 2, 2, 2, 2526, 2524, 3, 2, 2, 2, 2527, 2529,
	5, 392, 197, 2, 2528, 2475, 3, 2, 2, 2, 2528, 2476, 3, 2, 2, 2, 2528, 2478,
	3, 2, 2, 2, 2528, 2479, 3, 2, 2, 2, 2528, 2488, 3, 2, 2, 2, 2528, 2492,
	3, 2, 2, 2, 2528, 2500, 3, 2, 2, 2, 2528, 2503, 3, 2, 2, 2, 2528, 2512,
	3, 2, 2, 2, 2528, 2515, 3, 2, 2, 2, 2528, 2516, 3, 2, 2, 2, 2528, 2519,
	3, 2, 2, 2, 2528, 2527, 3, 2, 2, 2, 2529, 353, 3, 2, 2, 2, 2530, 2531,
	7, 31, 2, 2, 2531, 2532, 7, 383, 2, 2, 2532, 2533, 7, 24, 2, 2, 2533, 2534,
	5, 258, 130, 2, 2534, 2535, 7, 37, 2, 2, 2535, 2536, 7, 389, 2, 2, 2536,
	2537, 7, 24, 2, 2, 2537, 2538, 9, 38, 2, 2, 2538, 2539, 7, 37, 2, 2, 2539,
	2540, 7, 237, 2, 2, 2540, 2541, 7, 24, 2, 2, 2541, 2542, 7, 645, 2, 2,
	2542, 2543, 7, 32, 2, 2, 2543, 355, 3, 2, 2, 2, 2544, 2545, 7, 63, 2, 2,
	2545, 2547, 5, 148, 75, 2, 2546, 2544, 3, 2, 2, 2, 2546, 2547, 3, 2, 2,
	2, 2547, 2551, 3, 2, 2, 2, 2548, 2552, 5, 364, 183, 2, 2549, 2552, 5, 384,
	193, 2, 2550, 2552, 5, 390, 196, 2, 2551, 2548, 3, 2, 2, 2, 2551, 2549,
	3, 2, 2, 2, 2551, 2550, 3, 2, 2, 2, 2552, 357, 3, 2, 2, 2, 2553, 2554,
	7, 63, 2, 2, 2554, 2556, 5, 148, 75, 2, 2555, 2553, 3, 2, 2, 2, 2555, 2556,
	3, 2, 2, 2, 2556, 2560, 3, 2, 2, 2, 2557, 2561, 5, 364, 183, 2, 2558, 2561,
	5, 360, 181, 2, 2559, 2561, 5, 390, 196, 2, 2560, 2557, 3, 2, 2, 2, 2560,
	2558, 3, 2, 2, 2, 2560, 2559, 3, 2, 2, 2, 2561, 359, 3, 2, 2, 2, 2562,
	2563, 7, 66, 2, 2, 2563, 2565, 7, 67, 2, 2, 2564, 2562, 3, 2, 2, 2, 2564,
	2565, 3, 2, 2, 2, 2565, 2566, 3, 2, 2, 2, 2566, 2571, 5, 126, 64, 2, 2567,
	2568, 7, 31, 2, 2, 2568, 2569, 5, 134, 68, 2, 2569, 2570, 7, 32, 2, 2,
	2570, 2572, 3, 2, 2, 2, 2571, 2567, 3, 2, 2, 2, 2571, 2572, 3, 2, 2, 2,
	2572, 2576, 3, 2, 2, 2, 2573, 2575, 5, 362, 182, 2, 2574, 2573, 3, 2, 2,
	2, 2575, 2578, 3, 2, 2, 2, 2576, 2574, 3, 2, 2, 2, 2576, 2577, 3, 2, 2,
	2, 2577, 361, 3, 2, 2, 2, 2578, 2576, 3, 2, 2, 2, 2579, 2580, 7, 97, 2,
	2, 2580, 2584, 7, 50, 2, 2, 2581, 2582, 7, 228, 2, 2, 2582, 2585, 7, 236,
	2, 2, 2583, 2585, 7, 225, 2, 2, 2584, 2581, 3, 2, 2, 2, 2584, 2583, 3,
	2, 2, 2, 2585, 2594, 3, 2, 2, 2, 2586, 2587, 7, 97, 2, 2, 2587, 2588, 7,
	49, 2, 2, 2588, 2589, 7, 228, 2, 2, 2589, 2594, 7, 236, 2, 2, 2590, 2591,
	7, 106, 2, 2, 2591, 2592, 7, 101, 2, 2, 2592, 2594, 7, 288, 2, 2, 2593,
	2579, 3, 2, 2, 2, 2593, 2586, 3, 2, 2, 2, 2593, 2590, 3, 2, 2, 2, 2594,
	363, 3, 2, 2, 2, 2595, 2598, 5, 154, 78, 2, 2596, 2598, 7, 65, 2, 2, 2597,
	2595, 3, 2, 2, 2, 2597, 2596, 3, 2, 2, 2, 2598, 2601, 3, 2, 2, 2, 2599,
	2602, 5, 366, 184, 2, 2600, 2602, 5, 380, 191, 2, 2601, 2599, 3, 2, 2,
	2, 2601, 2600, 3, 2, 2, 2, 2602, 365, 3, 2, 2, 2, 2603, 2605, 5, 368, 185,
	2, 2604, 2603, 3, 2, 2, 2, 2604, 2605, 3, 2, 2, 2, 2605, 2607, 3, 2, 2,
	2, 2606, 2608, 5, 370, 186, 2, 2607, 2606, 3, 2, 2, 2, 2607, 2608, 3, 2,
	2, 2, 2608, 2610, 3, 2, 2, 2, 2609, 2611, 5, 372, 187, 2, 2610, 2609, 3,
	2, 2, 2, 2610, 2611, 3, 2, 2, 2, 2611, 367, 3, 2, 2, 2, 2612, 2613, 9,
	39, 2, 2, 2613, 369, 3, 2, 2, 2, 2614, 2629, 7, 77, 2, 2, 2615, 2616, 7,
	260, 2, 2, 2616, 2617, 7, 24, 2, 2, 2617, 2630, 7, 646, 2, 2, 2618, 2619,
	7, 31, 2, 2, 2619, 2624, 5, 234, 118, 2, 2620, 2621, 7, 37, 2, 2, 2621,
	2623, 5, 234, 118, 2, 2622, 2620, 3, 2, 2, 2, 2623, 2626, 3, 2, 2, 2, 2624,
	2622, 3, 2, 2, 2, 2624, 2625, 3, 2, 2, 2, 2625, 2627, 3, 2, 2, 2, 2626,
	2624, 3, 2, 2, 2, 2627, 2628, 7, 32, 2, 2, 2628, 2630, 3, 2, 2, 2, 2629,
	2615, 3, 2, 2, 2, 2629, 2618, 3, 2, 2, 2, 2630, 371, 3, 2, 2, 2, 2631,
	2635, 5, 374, 188, 2, 2632, 2635, 5, 376, 189, 2, 2633, 2635, 5, 378, 190,
	2, 2634, 2631, 3, 2, 2, 2, 2634, 2632, 3, 2, 2, 2, 2634, 2633, 3, 2, 2,
	2, 2635, 373, 3, 2, 2, 2, 2636, 2637, 7, 97, 2, 2, 2637, 2638, 5, 114,
	58, 2, 2638, 2639, 7, 31, 2, 2, 2639, 2640, 5, 134, 68, 2, 2640, 2641,
	7, 32, 2, 2, 2641, 375, 3, 2, 2, 2, 2642, 2643, 7, 97, 2, 2, 2643, 2644,
	5, 258, 130, 2, 2644, 377, 3, 2, 2, 2, 2645, 2646, 7, 97, 2, 2, 2646, 2647,
	7, 645, 2, 2, 2647, 379, 3, 2, 2, 2, 2648, 2655, 7, 241, 2, 2, 2649, 2650,
	7, 241, 2, 2, 2650, 2652, 7, 262, 2, 2, 2651, 2653, 5, 382, 192, 2, 2652,
	2651, 3, 2, 2, 2, 2652, 2653, 3, 2, 2, 2, 2653, 2655, 3, 2, 2, 2, 2654,
	2648, 3, 2, 2, 2, 2654, 2649, 3, 2, 2, 2, 2655, 381, 3, 2, 2, 2, 2656,
	2657, 7, 77, 2, 2, 2657, 2658, 7, 31, 2, 2, 2658, 2659, 7, 381, 2, 2, 2659,
	2660, 7, 24, 2, 2, 2660, 2661, 7, 646, 2, 2, 2661, 2662, 7, 32, 2, 2, 2662,
	383, 3, 2, 2, 2, 2663, 2664, 7, 66, 2, 2, 2664, 2666, 7, 67, 2, 2, 2665,
	2663, 3, 2, 2, 2, 2665, 2666, 3, 2, 2, 2, 2666, 2667, 3, 2, 2, 2, 2667,
	2668, 7, 231, 2, 2, 2668, 2673, 5, 126, 64, 2, 2669, 2670, 7, 31, 2, 2,
	2670, 2671, 5, 134, 68, 2, 2671, 2672, 7, 32, 2, 2, 2672, 2674, 3, 2, 2,
	2, 2673, 2669, 3, 2, 2, 2, 2673, 2674, 3, 2, 2, 2, 2674, 2678, 3, 2, 2,
	2, 2675, 2677, 5, 386, 194, 2, 2676, 2675, 3, 2, 2, 2, 2677, 2680, 3, 2,
	2, 2, 2678, 2676, 3, 2, 2, 2, 2678, 2679, 3, 2, 2, 2, 2679, 385, 3, 2,
	2, 2, 2680, 2678, 3, 2, 2, 2, 2681, 2682, 7, 97, 2, 2, 2682, 2683, 9, 40,
	2, 2, 2683, 2688, 5, 388, 195, 2, 2684, 2685, 7, 106, 2, 2, 2685, 2686,
	7, 101, 2, 2, 2686, 2688, 7, 288, 2, 2, 2687, 2681, 3, 2, 2, 2, 2687, 2684,
	3, 2, 2, 2, 2688, 387, 3, 2, 2, 2, 2689, 2690, 7, 228, 2, 2, 2690, 2695,
	7, 236, 2, 2, 2691, 2695, 7, 225, 2, 2, 2692, 2693, 7, 59, 2, 2, 2693,
	2695, 9, 41, 2, 2, 2694, 2689, 3, 2, 2, 2, 2694, 2691, 3, 2, 2, 2, 2694,
	2692, 3, 2, 2, 2, 2695, 389, 3, 2, 2, 2, 2696, 2700, 7, 226, 2, 2, 2697,
	2698, 7, 106, 2, 2, 2698, 2699, 7, 101, 2, 2, 2699, 2701, 7, 288, 2, 2,
	2700, 2697, 3, 2, 2, 2, 2700, 2701, 3, 2, 2, 2, 2701, 2702, 3, 2, 2, 2,
	2702, 2703, 7, 31, 2, 2, 2703, 2704, 5, 156, 79, 2, 2704, 2705, 7, 32,
	2, 2, 2705, 391, 3, 2, 2, 2, 2706, 2707, 7, 62, 2, 2, 2707, 2709, 5, 146,
	74, 2, 2708, 2710, 5, 368, 185, 2, 2709, 2708, 3, 2, 2, 2, 2709, 2710,
	3, 2, 2, 2, 2710, 2712, 3, 2, 2, 2, 2711, 2713, 5, 394, 198, 2, 2712, 2711,
	3, 2, 2, 2, 2712, 2713, 3, 2, 2, 2, 2713, 2715, 3, 2, 2, 2, 2714, 2716,
	5, 396, 199, 2, 2715, 2714, 3, 2, 2, 2, 2715, 2716, 3, 2, 2, 2, 2716, 2718,
	3, 2, 2, 2, 2717, 2719, 5, 400, 201, 2, 2718, 2717, 3, 2, 2, 2, 2718, 2719,
	3, 2, 2, 2, 2719, 393, 3, 2, 2, 2, 2720, 2721, 7, 77, 2, 2, 2721, 2722,
	7, 31, 2, 2, 2722, 2727, 5, 234, 118, 2, 2723, 2724, 7, 37, 2, 2, 2724,
	2726, 5, 234, 118, 2, 2725, 2723, 3, 2, 2, 2, 2726, 2729, 3, 2, 2, 2, 2727,
	2725, 3, 2, 2, 2, 2727, 2728, 3, 2, 2, 2, 2728, 2730, 3, 2, 2, 2, 2729,
	2727, 3, 2, 2, 2, 2730, 2731, 7, 32, 2, 2, 2731, 395, 3, 2, 2, 2, 2732,
	2736, 5, 374, 188, 2, 2733, 2736, 5, 376, 189, 2, 2734, 2736, 5, 398, 200,
	2, 2735, 2732, 3, 2, 2, 2, 2735, 2733, 3, 2, 2, 2, 2735, 2734, 3, 2, 2,
	2, 2736, 397, 3, 2, 2, 2, 2737, 2738, 7, 97, 2, 2, 2738, 2739, 7, 153,
	2, 2, 2739, 399, 3, 2, 2, 2, 2740, 2744, 7, 407, 2, 2, 2741, 2745, 5, 258,
	130, 2, 2742, 2745, 5, 114, 58, 2, 2743, 2745, 7, 645, 2, 2, 2744, 2741,
	3, 2, 2, 2, 2744, 2742, 3, 2, 2, 2, 2744, 2743, 3, 2, 2, 2, 2745, 401,
	3, 2, 2, 2, 2746, 2751, 5, 356, 179, 2, 2747, 2748, 7, 37, 2, 2, 2748,
	2750, 5, 356, 179, 2, 2749, 2747, 3, 2, 2, 2, 2750, 2753, 3, 2, 2, 2, 2751,
	2749, 3, 2, 2, 2, 2751, 2752, 3, 2, 2, 2, 2752, 2755, 3, 2, 2, 2, 2753,
	2751, 3, 2, 2, 2, 2754, 2746, 3, 2, 2, 2, 2754, 2755, 3, 2, 2, 2, 2755,
	403, 3, 2, 2, 2, 2756, 2757, 5, 134, 68, 2, 2757, 2758, 7, 96, 2, 2, 2758,
	2764, 5, 156, 79, 2, 2759, 2762, 7, 282, 2, 2, 2760, 2761, 7, 106, 2, 2,
	2761, 2763, 7, 107, 2, 2, 2762, 2760, 3, 2, 2, 2, 2762, 2763, 3, 2, 2,
	2, 2763, 2765, 3, 2, 2, 2, 2764, 2759, 3, 2, 2, 2, 2764, 2765, 3, 2, 2,
	2, 2765, 2767, 3, 2, 2, 2, 2766, 2768, 5, 358, 180, 2, 2767, 2766, 3, 2,
	2, 2, 2767, 2768, 3, 2, 2, 2, 2768, 405, 3, 2, 2, 2, 2769, 2770, 5, 258,
	130, 2, 2770, 2771, 7, 644, 2, 2, 2771, 2772, 7, 384, 2, 2, 2772, 2773,
	7, 101, 2, 2, 2773, 2774, 7, 380, 2, 2, 2774, 407, 3, 2, 2, 2, 2775, 2776,
	7, 63, 2, 2, 2776, 2778, 5, 148, 75, 2, 2777, 2775, 3, 2, 2, 2, 2777, 2778,
	3, 2, 2, 2, 2778, 2782, 3, 2, 2, 2, 2779, 2783, 5, 410, 206, 2, 2780, 2783,
	5, 420, 211, 2, 2781, 2783, 5, 390, 196, 2, 2782, 2779, 3, 2, 2, 2, 2782,
	2780, 3, 2, 2, 2, 2782, 2781, 3, 2, 2, 2, 2783, 409, 3, 2, 2, 2, 2784,
	2787, 5, 412, 207, 2, 2785, 2788, 5, 414, 208, 2, 2786, 2788, 5, 416, 209,
	2, 2787, 2785, 3, 2, 2, 2, 2787, 2786, 3, 2, 2, 2, 2788, 411, 3, 2, 2,
	2, 2789, 2792, 5, 154, 78, 2, 2790, 2792, 7, 65, 2, 2, 2791, 2789, 3, 2,
	2, 2, 2791, 2790, 3, 2, 2, 2, 2792, 413, 3, 2, 2, 2, 2793, 2795, 5, 368,
	185, 2, 2794, 2793, 3, 2, 2, 2, 2794, 2795, 3, 2, 2, 2, 2795, 2796, 3,
	2, 2, 2, 2796, 2798, 5, 140, 71, 2, 2797, 2799, 5, 370, 186, 2, 2798, 2797,
	3, 2, 2, 2, 2798, 2799, 3, 2, 2, 2, 2799, 2801, 3, 2, 2, 2, 2800, 2802,
	5, 372, 187, 2, 2801, 2800, 3, 2, 2, 2, 2801, 2802, 3, 2, 2, 2, 2802, 415,
	3, 2, 2, 2, 2803, 2806, 7, 241, 2, 2, 2804, 2807, 5, 140, 71, 2, 2805,
	2807, 5, 418, 210, 2, 2806, 2804, 3, 2, 2, 2, 2806, 2805, 3, 2, 2, 2, 2807,
	417, 3, 2, 2, 2, 2808, 2809, 7, 262, 2, 2, 2809, 2810, 5, 140, 71, 2, 2810,
	2811, 5, 382, 192, 2, 2811, 419, 3, 2, 2, 2, 2812, 2813, 7, 66, 2, 2, 2813,
	2815, 7, 67, 2, 2, 2814, 2812, 3, 2, 2, 2, 2814, 2815, 3, 2, 2, 2, 2815,
	2816, 3, 2, 2, 2, 2816, 2817, 5, 140, 71, 2, 2817, 2818, 7, 231, 2, 2,
	2818, 2819, 5, 126, 64, 2, 2819, 2823, 5, 140, 71, 2, 2820, 2822, 5, 386,
	194, 2, 2821, 2820, 3, 2, 2, 2, 2822, 2825, 3, 2, 2, 2, 2823, 2821, 3,
	2, 2, 2, 2823, 2824, 3, 2, 2, 2, 2824, 421, 3, 2, 2, 2, 2825, 2823, 3,
	2, 2, 2, 2826, 2827, 7, 62, 2, 2, 2827, 2828, 5, 146, 74, 2, 2828, 2831,
	5, 424, 213, 2, 2829, 2830, 7, 77, 2, 2, 2830, 2832, 5, 426, 214, 2, 2831,
	2829, 3, 2, 2, 2, 2831, 2832, 3, 2, 2, 2, 2832, 2834, 3, 2, 2, 2, 2833,
	2835, 5, 396, 199, 2, 2834, 2833, 3, 2, 2, 2, 2834, 2835, 3, 2, 2, 2, 2835,
	2837, 3, 2, 2, 2, 2836, 2838, 5, 400, 201, 2, 2837, 2836, 3, 2, 2, 2, 2837,
	2838, 3, 2, 2, 2, 2838, 423, 3, 2, 2, 2, 2839, 2841, 5, 368, 185, 2, 2840,
	2839, 3, 2, 2, 2, 2840, 2841, 3, 2, 2, 2, 2841, 2842, 3, 2, 2, 2, 2842,
	2851, 5, 140, 71, 2, 2843, 2844, 7, 240, 2, 2, 2844, 2851, 7, 243, 2, 2,
	2845, 2847, 7, 241, 2, 2, 2846, 2845, 3, 2, 2, 2, 2846, 2847, 3, 2, 2,
	2, 2847, 2848, 3, 2, 2, 2, 2848, 2849, 7, 243, 2, 2, 2849, 2851, 5, 140,
	71, 2, 2850, 2840, 3, 2, 2, 2, 2850, 2843, 3, 2, 2, 2, 2850, 2846, 3, 2,
	2, 2, 2851, 425, 3, 2, 2, 2, 2852, 2853, 7, 31, 2, 2, 2853, 2858, 5, 234,
	118, 2, 2854, 2855, 7, 37, 2, 2, 2855, 2857, 5, 234, 118, 2, 2856, 2854,
	3, 2, 2, 2, 2857, 2860, 3, 2, 2, 2, 2858, 2856, 3, 2, 2, 2, 2858, 2859,
	3, 2, 2, 2, 2859, 2861, 3, 2, 2, 2, 2860, 2858, 3, 2, 2, 2, 2861, 2862,
	7, 32, 2, 2, 2862, 427, 3, 2, 2, 2, 2863, 2864, 7, 281, 2, 2, 2864, 2865,
	7, 101, 2, 2, 2865, 2866, 7, 390, 2, 2, 2866, 2867, 7, 31, 2, 2, 2867,
	2868, 5, 134, 68, 2, 2868, 2869, 7, 37, 2, 2, 2869, 2870, 5, 134, 68, 2,
	2870, 2871, 7, 32, 2, 2, 2871, 429, 3, 2, 2, 2, 2872, 2880, 7, 97, 2, 2,
	2873, 2874, 5, 114, 58, 2, 2874, 2875, 7, 31, 2, 2, 2875, 2876, 5, 134,
	68, 2, 2876, 2877, 7, 32, 2, 2, 2877, 2881, 3, 2, 2, 2, 2878, 2881, 5,
	258, 130, 2, 2879, 2881, 7, 645, 2, 2, 2880, 2873, 3, 2, 2, 2, 2880, 2878,
	3, 2, 2, 2, 2880, 2879, 3, 2, 2, 2, 2881, 2883, 3, 2, 2, 2, 2882, 2872,
	3, 2, 2, 2, 2882, 2883, 3, 2, 2, 2, 2883, 431, 3, 2, 2, 2, 2884, 2887,
	7, 392, 2, 2, 2885, 2888, 5, 258, 130, 2, 2886, 2888, 7, 645, 2, 2, 2887,
	2885, 3, 2, 2, 2, 2887, 2886, 3, 2, 2, 2, 2888, 2890, 3, 2, 2, 2, 2889,
	2884, 3, 2, 2, 2, 2889, 2890, 3, 2, 2, 2, 2890, 2898, 3, 2, 2, 2, 2891,
	2892, 7, 407, 2, 2, 2892, 2897, 5, 114, 58, 2, 2893, 2894, 5, 258, 130,
	2, 2894, 2895, 7, 645, 2, 2, 2895, 2897, 3, 2, 2, 2, 2896, 2891, 3, 2,
	2, 2, 2896, 2893, 3, 2, 2, 2, 2897, 2899, 3, 2, 2, 2, 2898, 2896, 3, 2,
	2, 2, 2898, 2899, 3, 2, 2, 2, 2899, 2902, 3, 2, 2, 2, 2900, 2901, 7, 77,
	2, 2, 2901, 2903, 5, 434, 218, 2, 2902, 2900, 3, 2, 2, 2, 2902, 2903, 3,
	2, 2, 2, 2903, 433, 3, 2, 2, 2, 2904, 2905, 7, 31, 2, 2, 2905, 2910, 5,
	436, 219, 2, 2906, 2907, 7, 37, 2, 2, 2907, 2909, 5, 436, 219, 2, 2908,
	2906, 3, 2, 2, 2, 2909, 2912, 3, 2, 2, 2, 2910, 2908, 3, 2, 2, 2, 2910,
	2911, 3, 2, 2, 2, 2911, 2913, 3, 2, 2, 2, 2912, 2910, 3, 2, 2, 2, 2913,
	2914, 7, 32, 2, 2, 2914, 435, 3, 2, 2, 2, 2915, 2916, 7, 387, 2, 2, 2916,
	2917, 7, 24, 2, 2, 2917, 2924, 9, 42, 2, 2, 2918, 2919, 7, 97, 2, 2, 2919,
	2920, 7, 218, 2, 2, 2920, 2921, 7, 31, 2, 2, 2921, 2922, 5, 248, 125, 2,
	2922, 2923, 7, 32, 2, 2, 2923, 2925, 3, 2, 2, 2, 2924, 2918, 3, 2, 2, 2,
	2924, 2925, 3, 2, 2, 2, 2925, 2966, 3, 2, 2, 2, 2926, 2927, 7, 409, 2,
	2, 2927, 2928, 7, 24, 2, 2, 2928, 2966, 5, 258, 130, 2, 2929, 2930, 7,
	408, 2, 2, 2930, 2933, 7, 24, 2, 2, 2931, 2934, 5, 150, 76, 2, 2932, 2934,
	7, 386, 2, 2, 2933, 2931, 3, 2, 2, 2, 2933, 2932, 3, 2, 2, 2, 2934, 2966,
	3, 2, 2, 2, 2935, 2936, 7, 411, 2, 2, 2936, 2937, 7, 24, 2, 2, 2937, 2966,
	5, 258, 130, 2, 2938, 2939, 7, 412, 2, 2, 2939, 2940, 7, 24, 2, 2, 2940,
	2966, 5, 258, 130, 2, 2941, 2942, 7, 410, 2, 2, 2942, 2943, 7, 24, 2, 2,
	2943, 2966, 5, 258, 130, 2, 2944, 2945, 7, 391, 2, 2, 2945, 2946, 7, 24,
	2, 2, 2946, 2948, 7, 97, 2, 2, 2947, 2949, 5, 524, 263, 2, 2948, 2947,
	3, 2, 2, 2, 2948, 2949, 3, 2, 2, 2, 2949, 2966, 3, 2, 2, 2, 2950, 2951,
	7, 406, 2, 2, 2951, 2958, 7, 24, 2, 2, 2952, 2954, 7, 97, 2, 2, 2953, 2955,
	5, 440, 221, 2, 2954, 2953, 3, 2, 2, 2, 2954, 2955, 3, 2, 2, 2, 2955, 2959,
	3, 2, 2, 2, 2956, 2957, 7, 276, 2, 2, 2957, 2959, 5, 444, 223, 2, 2958,
	2952, 3, 2, 2, 2, 2958, 2956, 3, 2, 2, 2, 2959, 2966, 3, 2, 2, 2, 2960,
	2966, 5, 446, 224, 2, 2961, 2966, 5, 448, 225, 2, 2962, 2966, 5, 450, 226,
	2, 2963, 2966, 5, 438, 220, 2, 2964, 2966, 5, 452, 227, 2, 2965, 2915,
	3, 2, 2, 2, 2965, 2926, 3, 2, 2, 2, 2965, 2929, 3, 2, 2, 2, 2965, 2935,
	3, 2, 2, 2, 2965, 2938, 3, 2, 2, 2, 2965, 2941, 3, 2, 2, 2, 2965, 2944,
	3, 2, 2, 2, 2965, 2950, 3, 2, 2, 2, 2965, 2960, 3, 2, 2, 2, 2965, 2961,
	3, 2, 2, 2, 2965, 2962, 3, 2, 2, 2, 2965, 2963, 3, 2, 2, 2, 2965, 2964,
	3, 2, 2, 2, 2966, 437, 3, 2, 2, 2, 2967, 2968, 7, 472, 2, 2, 2968, 2969,
	7, 24, 2, 2, 2969, 2970, 7, 97, 2, 2, 2970, 2971, 7, 31, 2, 2, 2971, 2972,
	7, 473, 2, 2, 2972, 2973, 7, 24, 2, 2, 2973, 2974, 5, 134, 68, 2, 2974,
	2975, 7, 37, 2, 2, 2975, 2976, 7, 474, 2, 2, 2976, 2977, 7, 24, 2, 2, 2977,
	2978, 5, 510, 256, 2, 2978, 439, 3, 2, 2, 2, 2979, 2980, 7, 31, 2, 2, 2980,
	2985, 5, 442, 222, 2, 2981, 2982, 7, 37, 2, 2, 2982, 2984, 5, 442, 222,
	2, 2983, 2981, 3, 2, 2, 2, 2984, 2987, 3, 2, 2, 2, 2985, 2983, 3, 2, 2,
	2, 2985, 2986, 3, 2, 2, 2, 2986, 2988, 3, 2, 2, 2, 2987, 2985, 3, 2, 2,
	2, 2988, 2989, 7, 32, 2, 2, 2989, 441, 3, 2, 2, 2, 2990, 2991, 7, 413,
	2, 2, 2991, 2994, 7, 24, 2, 2, 2992, 2995, 7, 107, 2, 2, 2993, 2995, 5,
	174, 88, 2, 2994, 2992, 3, 2, 2, 2, 2994, 2993, 3, 2, 2, 2, 2995, 2996,
	3, 2, 2, 2, 2996, 2998, 7, 37, 2, 2, 2997, 2990, 3, 2, 2, 2, 2997, 2998,
	3, 2, 2, 2, 2998, 2999, 3, 2, 2, 2, 2999, 3000, 7, 404, 2, 2, 3000, 3001,
	7, 24, 2, 2, 3001, 3002, 9, 43, 2, 2, 3002, 443, 3, 2, 2, 2, 3003, 3004,
	7, 31, 2, 2, 3004, 3005, 7, 404, 2, 2, 3005, 3006, 7, 24, 2, 2, 3006, 3007,
	7, 280, 2, 2, 3007, 3008, 7, 32, 2, 2, 3008, 445, 3, 2, 2, 2, 3009, 3010,
	7, 403, 2, 2, 3010, 3011, 7, 24, 2, 2, 3011, 3022, 7, 97, 2, 2, 3012, 3013,
	7, 255, 2, 2, 3013, 3014, 7, 24, 2, 2, 3014, 3022, 9, 44, 2, 2, 3015, 3016,
	7, 391, 2, 2, 3016, 3017, 7, 24, 2, 2, 3017, 3019, 7, 97, 2, 2, 3018, 3020,
	5, 524, 263, 2, 3019, 3018, 3, 2, 2, 2, 3019, 3020, 3, 2, 2, 2, 3020, 3022,
	3, 2, 2, 2, 3021, 3009, 3, 2, 2, 2, 3021, 3012, 3, 2, 2, 2, 3021, 3015,
	3, 2, 2, 2, 3022, 447, 3, 2, 2, 2, 3023, 3024, 7, 253, 2, 2, 3024, 3032,
	7, 24, 2, 2, 3025, 3026, 7, 262, 2, 2, 3026, 3027, 7, 31, 2, 2, 3027, 3028,
	5, 134, 68, 2, 3028, 3029, 7, 32, 2, 2, 3029, 3033, 3, 2, 2, 2, 3030, 3033,
	7, 396, 2, 2, 3031, 3033, 7, 287, 2, 2, 3032, 3025, 3, 2, 2, 2, 3032, 3030,
	3, 2, 2, 2, 3032, 3031, 3, 2, 2, 2, 3033, 449, 3, 2, 2, 2, 3034, 3035,
	7, 240, 2, 2, 3035, 3036, 7, 243, 2, 2, 3036, 3063, 7, 62, 2, 2, 3037,
	3038, 7, 240, 2, 2, 3038, 3039, 7, 243, 2, 2, 3039, 3040, 7, 62, 2, 2,
	3040, 3041, 7, 116, 2, 2, 3041, 3063, 5, 140, 71, 2, 3042, 3063, 7, 263,
	2, 2, 3043, 3044, 7, 240, 2, 2, 3044, 3045, 7, 62, 2, 2, 3045, 3046, 7,
	31, 2, 2, 3046, 3048, 5, 134, 68, 2, 3047, 3049, 9, 25, 2, 2, 3048, 3047,
	3, 2, 2, 2, 3048, 3049, 3, 2, 2, 2, 3049, 3057, 3, 2, 2, 2, 3050, 3051,
	7, 37, 2, 2, 3051, 3053, 5, 134, 68, 2, 3052, 3054, 9, 25, 2, 2, 3053,
	3052, 3, 2, 2, 2, 3053, 3054, 3, 2, 2, 2, 3054, 3056, 3, 2, 2, 2, 3055,
	3050, 3, 2, 2, 2, 3056, 3059, 3, 2, 2, 2, 3057, 3055, 3, 2, 2, 2, 3057,
	3058, 3, 2, 2, 2, 3058, 3060, 3, 2, 2, 2, 3059, 3057, 3, 2, 2, 2, 3060,
	3061, 7, 32, 2, 2, 3061, 3063, 3, 2, 2, 2, 3062, 3034, 3, 2, 2, 2, 3062,
	3037, 3, 2, 2, 2, 3062, 3042, 3, 2, 2, 2, 3062, 3043, 3, 2, 2, 2, 3063,
	451, 3, 2, 2, 2, 3064, 3065, 7, 217, 2, 2, 3065, 3066, 7, 31, 2, 2, 3066,
	3067, 5, 134, 68, 2, 3067, 3069, 7, 285, 2, 2, 3068, 3070, 9, 45, 2, 2,
	3069, 3068, 3, 2, 2, 2, 3069, 3070, 3, 2, 2, 2, 3070, 3071, 3, 2, 2, 2,
	3071, 3072, 7, 101, 2, 2, 3072, 3073, 7, 76, 2, 2, 3073, 3074, 7, 31, 2,
	2, 3074, 3079, 5, 172, 87, 2, 3075, 3076, 7, 37, 2, 2, 3076, 3078, 5, 172,
	87, 2, 3077, 3075, 3, 2, 2, 2, 3078, 3081, 3, 2, 2, 2, 3079, 3077, 3, 2,
	2, 2, 3079, 3080, 3, 2, 2, 2, 3080, 3082, 3, 2, 2, 2, 3081, 3079, 3, 2,
	2, 2, 3082, 3083, 7, 32, 2, 2, 3083, 3084, 7, 32, 2, 2, 3084, 453, 3, 2,
	2, 2, 3085, 3087, 7, 65, 2, 2, 3086, 3085, 3, 2, 2, 2, 3086, 3087, 3, 2,
	2, 2, 3087, 3089, 3, 2, 2, 2, 3088, 3090, 5, 368, 185, 2, 3089, 3088, 3,
	2, 2, 2, 3089, 3090, 3, 2, 2, 2, 3090, 455, 3, 2, 2, 2, 3091, 3101, 5,
	458, 230, 2, 3092, 3101, 5, 460, 231, 2, 3093, 3101, 5, 476, 239, 2, 3094,
	3101, 5, 492, 247, 2, 3095, 3101, 5, 494, 248, 2, 3096, 3101, 5, 496, 249,
	2, 3097, 3101, 5, 498, 250, 2, 3098, 3101, 5, 522, 262, 2, 3099, 3101,
	7, 286, 2, 2, 3100, 3091, 3, 2, 2, 2, 3100, 3092, 3, 2, 2, 2, 3100, 3093,
	3, 2, 2, 2, 3100, 3094, 3, 2, 2, 2, 3100, 3095, 3, 2, 2, 2, 3100, 3096,
	3, 2, 2, 2, 3100, 3097, 3, 2, 2, 2, 3100, 3098, 3, 2, 2, 2, 3100, 3099,
	3, 2, 2, 2, 3101, 457, 3, 2, 2, 2, 3102, 3103, 7, 77, 2, 2, 3103, 3105,
	9, 46, 2, 2, 3104, 3102, 3, 2, 2, 2, 3104, 3105, 3, 2, 2, 2, 3105, 3106,
	3, 2, 2, 2, 3106, 3109, 7, 58, 2, 2, 3107, 3110, 5, 464, 233, 2, 3108,
	3110, 5, 470, 236, 2, 3109, 3107, 3, 2, 2, 2, 3109, 3108, 3, 2, 2, 2, 3110,
	459, 3, 2, 2, 2, 3111, 3112, 5, 462, 232, 2, 3112, 3115, 5, 204, 103, 2,
	3113, 3114, 7, 242, 2, 2, 3114, 3116, 5, 150, 76, 2, 3115, 3113, 3, 2,
	2, 2, 3115, 3116, 3, 2, 2, 2, 3116, 3120, 3, 2, 2, 2, 3117, 3121, 7, 107,
	2, 2, 3118, 3119, 7, 106, 2, 2, 3119, 3121, 7, 107, 2, 2, 3120, 3117, 3,
	2, 2, 2, 3120, 3118, 3, 2, 2, 2, 3120, 3121, 3, 2, 2, 2, 3121, 3123, 3,
	2, 2, 2, 3122, 3124, 7, 293, 2, 2, 3123, 3122, 3, 2, 2, 2, 3123, 3124,
	3, 2, 2, 2, 3124, 461, 3, 2, 2, 2, 3125, 3126, 7, 52, 2, 2, 3126, 3127,
	7, 61, 2, 2, 3127, 3128, 5, 134, 68, 2, 3128, 463, 3, 2, 2, 2, 3129, 3134,
	5, 466, 234, 2, 3130, 3131, 7, 37, 2, 2, 3131, 3133, 5, 466, 234, 2, 3132,
	3130, 3, 2, 2, 2, 3133, 3136, 3, 2, 2, 2, 3134, 3132, 3, 2, 2, 2, 3134,
	3135, 3, 2, 2, 2, 3135, 465, 3, 2, 2, 2, 3136, 3134, 3, 2, 2, 2, 3137,
	3144, 5, 350, 176, 2, 3138, 3144, 5, 404, 203, 2, 3139, 3144, 5, 406, 204,
	2, 3140, 3144, 5, 408, 205, 2, 3141, 3144, 5, 512, 257, 2, 3142, 3144,
	5, 468, 235, 2, 3143, 3137, 3, 2, 2, 2, 3143, 3138, 3, 2, 2, 2, 3143, 3139,
	3, 2, 2, 2, 3143, 3140, 3, 2, 2, 2, 3143, 3141, 3, 2, 2, 2, 3143, 3142,
	3, 2, 2, 2, 3144, 467, 3, 2, 2, 2, 3145, 3146, 7, 63, 2, 2, 3146, 3148,
	5, 148, 75, 2, 3147, 3145, 3, 2, 2, 2, 3147, 3148, 3, 2, 2, 2, 3148, 3149,
	3, 2, 2, 2, 3149, 3150, 7, 153, 2, 2, 3150, 3151, 5, 172, 87, 2, 3151,
	3152, 7, 101, 2, 2, 3152, 3153, 5, 134, 68, 2, 3153, 469, 3, 2, 2, 2, 3154,
	3155, 5, 472, 237, 2, 3155, 3156, 7, 37, 2, 2, 3156, 3157, 5, 428, 215,
	2, 3157, 3163, 3, 2, 2, 2, 3158, 3159, 5, 428, 215, 2, 3159, 3160, 7, 37,
	2, 2, 3160, 3161, 5, 472, 237, 2, 3161, 3163, 3, 2, 2, 2, 3162, 3154, 3,
	2, 2, 2, 3162, 3158, 3, 2, 2, 2, 3163, 471, 3, 2, 2, 2, 3164, 3165, 5,
	474, 238, 2, 3165, 3166, 7, 153, 2, 2, 3166, 3169, 5, 172, 87, 2, 3167,
	3168, 7, 77, 2, 2, 3168, 3170, 7, 76, 2, 2, 3169, 3167, 3, 2, 2, 2, 3169,
	3170, 3, 2, 2, 2, 3170, 3171, 3, 2, 2, 2, 3171, 3172, 7, 37, 2, 2, 3172,
	3173, 5, 474, 238, 2, 3173, 473, 3, 2, 2, 2, 3174, 3175, 5, 134, 68, 2,
	3175, 3176, 5, 206, 104, 2, 3176, 3177, 7, 227, 2, 2, 3177, 3178, 7, 224,
	2, 2, 3178, 3179, 7, 96, 2, 2, 3179, 3181, 7, 220, 2, 2, 3180, 3182, 9,
	37, 2, 2, 3181, 3180, 3, 2, 2, 2, 3181, 3182, 3, 2, 2, 2, 3182, 3184, 3,
	2, 2, 2, 3183, 3185, 7, 215, 2, 2, 3184, 3183, 3, 2, 2, 2, 3184, 3185,
	3, 2, 2, 2, 3185, 3188, 3, 2, 2, 2, 3186, 3187, 7, 106, 2, 2, 3187, 3189,
	7, 107, 2, 2, 3188, 3186, 3, 2, 2, 2, 3188, 3189, 3, 2, 2, 2, 3189, 3192,
	3, 2, 2, 2, 3190, 3191, 7, 63, 2, 2, 3191, 3193, 5, 258, 130, 2, 3192,
	3190, 3, 2, 2, 2, 3192, 3193, 3, 2, 2, 2, 3193, 475, 3, 2, 2, 2, 3194,
	3201, 7, 53, 2, 2, 3195, 3202, 5, 478, 240, 2, 3196, 3202, 5, 488, 245,
	2, 3197, 3202, 5, 490, 246, 2, 3198, 3199, 7, 281, 2, 2, 3199, 3200, 7,
	101, 2, 2, 3200, 3202, 7, 390, 2, 2, 3201, 3195, 3, 2, 2, 2, 3201, 3196,
	3, 2, 2, 2, 3201, 3197, 3, 2, 2, 2, 3201, 3198, 3, 2, 2, 2, 3202, 477,
	3, 2, 2, 2, 3203, 3205, 7, 63, 2, 2, 3204, 3203, 3, 2, 2, 2, 3204, 3205,
	3, 2, 2, 2, 3205, 3207, 3, 2, 2, 2, 3206, 3208, 5, 526, 264, 2, 3207, 3206,
	3, 2, 2, 2, 3207, 3208, 3, 2, 2, 2, 3208, 3209, 3, 2, 2, 2, 3209, 3214,
	5, 480, 241, 2, 3210, 3211, 7, 37, 2, 2, 3211, 3213, 5, 480, 241, 2, 3212,
	3210, 3, 2, 2, 2, 3213, 3216, 3, 2, 2, 2, 3214, 3212, 3, 2, 2, 2, 3214,
	3215, 3, 2, 2, 2, 3215, 479, 3, 2, 2, 2, 3216, 3214, 3, 2, 2, 2, 3217,
	3219, 5, 148, 75, 2, 3218, 3220, 5, 482, 242, 2, 3219, 3218, 3, 2, 2, 2,
	3219, 3220, 3, 2, 2, 2, 3220, 481, 3, 2, 2, 2, 3221, 3222, 7, 77, 2, 2,
	3222, 3223, 7, 31, 2, 2, 3223, 3228, 5, 484, 243, 2, 3224, 3225, 7, 37,
	2, 2, 3225, 3227, 5, 484, 243, 2, 3226, 3224, 3, 2, 2, 2, 3227, 3230, 3,
	2, 2, 2, 3228, 3226, 3, 2, 2, 2, 3228, 3229, 3, 2, 2, 2, 3229, 3231, 3,
	2, 2, 2, 3230, 3228, 3, 2, 2, 2, 3231, 3232, 7, 32, 2, 2, 3232, 483, 3,
	2, 2, 2, 3233, 3234, 7, 271, 2, 2, 3234, 3235, 7, 24, 2, 2, 3235, 3251,
	7, 646, 2, 2, 3236, 3237, 7, 277, 2, 2, 3237, 3238, 7, 24, 2, 2, 3238,
	3251, 5, 486, 244, 2, 3239, 3240, 7, 272, 2, 2, 3240, 3248, 7, 102, 2,
	2, 3241, 3242, 5, 114, 58, 2, 3242, 3243, 7, 31, 2, 2, 3243, 3244, 5, 134,
	68, 2, 3244, 3245, 7, 32, 2, 2, 3245, 3249, 3, 2, 2, 2, 3246, 3249, 5,
	258, 130, 2, 3247, 3249, 7, 645, 2, 2, 3248, 3241, 3, 2, 2, 2, 3248, 3246,
	3, 2, 2, 2, 3248, 3247, 3, 2, 2, 2, 3249, 3251, 3, 2, 2, 2, 3250, 3233,
	3, 2, 2, 2, 3250, 3236, 3, 2, 2, 2, 3250, 3239, 3, 2, 2, 2, 3251, 485,
	3, 2, 2, 2, 3252, 3253, 9, 32, 2, 2, 3253, 487, 3, 2, 2, 2, 3254, 3256,
	7, 61, 2, 2, 3255, 3257, 5, 526, 264, 2, 3256, 3255, 3, 2, 2, 2, 3256,
	3257, 3, 2, 2, 2, 3257, 3258, 3, 2, 2, 2, 3258, 3263, 5, 134, 68, 2, 3259,
	3260, 7, 37, 2, 2, 3260, 3262, 5, 134, 68, 2, 3261, 3259, 3, 2, 2, 2, 3262,
	3265, 3, 2, 2, 2, 3263, 3261, 3, 2, 2, 2, 3263, 3264, 3, 2, 2, 2, 3264,
	489, 3, 2, 2, 2, 3265, 3263, 3, 2, 2, 2, 3266, 3268, 7, 62, 2, 2, 3267,
	3269, 5, 526, 264, 2, 3268, 3267, 3, 2, 2, 2, 3268, 3269, 3, 2, 2, 2, 3269,
	3270, 3, 2, 2, 2, 3270, 3275, 5, 146, 74, 2, 3271, 3272, 7, 37, 2, 2, 3272,
	3274, 5, 146, 74, 2, 3273, 3271, 3, 2, 2, 2, 3274, 3277, 3, 2, 2, 2, 3275,
	3273, 3, 2, 2, 2, 3275, 3276, 3, 2, 2, 2, 3276, 491, 3, 2, 2, 2, 3277,
	3275, 3, 2, 2, 2, 3278, 3280, 7, 77, 2, 2, 3279, 3278, 3, 2, 2, 2, 3279,
	3280, 3, 2, 2, 2, 3280, 3281, 3, 2, 2, 2, 3281, 3282, 9, 46, 2, 2, 3282,
	3285, 7, 63, 2, 2, 3283, 3286, 7, 113, 2, 2, 3284, 3286, 5, 148, 75, 2,
	3285, 3283, 3, 2, 2, 2, 3285, 3284, 3, 2, 2, 2, 3286, 493, 3, 2, 2, 2,
	3287, 3288, 9, 47, 2, 2, 3288, 3291, 7, 71, 2, 2, 3289, 3292, 7, 113, 2,
	2, 3290, 3292, 5, 260, 131, 2, 3291, 3289, 3, 2, 2, 2, 3291, 3290, 3, 2,
	2, 2, 3292, 495, 3, 2, 2, 2, 3293, 3296, 7, 294, 2, 2, 3294, 3295, 7, 217,
	2, 2, 3295, 3297, 5, 156, 79, 2, 3296, 3294, 3, 2, 2, 2, 3296, 3297, 3,
	2, 2, 2, 3297, 3298, 3, 2, 2, 2, 3298, 3299, 7, 102, 2, 2, 3299, 3302,
	5, 126, 64, 2, 3300, 3301, 7, 217, 2, 2, 3301, 3303, 5, 156, 79, 2, 3302,
	3300, 3, 2, 2, 2, 3302, 3303, 3, 2, 2, 2, 3303, 3309, 3, 2, 2, 2, 3304,
	3305, 7, 77, 2, 2, 3305, 3306, 7, 31, 2, 2, 3306, 3307, 5, 254, 128, 2,
	3307, 3308, 7, 32, 2, 2, 3308, 3310, 3, 2, 2, 2, 3309, 3304, 3, 2, 2, 2,
	3309, 3310, 3, 2, 2, 2, 3310, 497, 3, 2, 2, 2, 3311, 3312, 7, 59, 2, 2,
	3312, 3315, 7, 31, 2, 2, 3313, 3316, 5, 500, 251, 2, 3314, 3316, 5, 502,
	252, 2, 3315, 3313, 3, 2, 2, 2, 3315, 3314, 3, 2, 2, 2, 3316, 3317, 3,
	2, 2, 2, 3317, 3318, 7, 32, 2, 2, 3318, 499, 3, 2, 2, 2, 3319, 3320, 7,
	407, 2, 2, 3320, 3324, 7, 24, 2, 2, 3321, 3325, 5, 114, 58, 2, 3322, 3325,
	5, 258, 130, 2, 3323, 3325, 7, 645, 2, 2, 3324, 3321, 3, 2, 2, 2, 3324,
	3322, 3, 2, 2, 2, 3324, 3323, 3, 2, 2, 2, 3325, 501, 3, 2, 2, 2, 3326,
	3327, 7, 391, 2, 2, 3327, 3333, 7, 24, 2, 2, 3328, 3334, 7, 276, 2, 2,
	3329, 3331, 7, 97, 2, 2, 3330, 3332, 5, 504, 253, 2, 3331, 3330, 3, 2,
	2, 2, 3331, 3332, 3, 2, 2, 2, 3332, 3334, 3, 2, 2, 2, 3333, 3328, 3, 2,
	2, 2, 3333, 3329, 3, 2, 2, 2, 3334, 503, 3, 2, 2, 2, 3335, 3339, 7, 31,
	2, 2, 3336, 3337, 7, 415, 2, 2, 3337, 3338, 7, 24, 2, 2, 3338, 3340, 5,
	126, 64, 2, 3339, 3336, 3, 2, 2, 2, 3339, 3340, 3, 2, 2, 2, 3340, 3342,
	3, 2, 2, 2, 3341, 3343, 5, 506, 254, 2, 3342, 3341, 3, 2, 2, 2, 3342, 3343,
	3, 2, 2, 2, 3343, 3345, 3, 2, 2, 2, 3344, 3346, 5, 508, 255, 2, 3345, 3344,
	3, 2, 2, 2, 3345, 3346, 3, 2, 2, 2, 3346, 3347, 3, 2, 2, 2, 3347, 3348,
	7, 32, 2, 2, 3348, 505, 3, 2, 2, 2, 3349, 3351, 7, 37, 2, 2, 3350, 3349,
	3, 2, 2, 2, 3350, 3351, 3, 2, 2, 2, 3351, 3352, 3, 2, 2, 2, 3352, 3353,
	7, 388, 2, 2, 3353, 3354, 7, 24, 2, 2, 3354, 3355, 5, 486, 244, 2, 3355,
	507, 3, 2, 2, 2, 3356, 3358, 7, 37, 2, 2, 3357, 3356, 3, 2, 2, 2, 3357,
	3358, 3, 2, 2, 2, 3358, 3359, 3, 2, 2, 2, 3359, 3360, 7, 414, 2, 2, 3360,
	3361, 7, 24, 2, 2, 3361, 3362, 5, 510, 256, 2, 3362, 509, 3, 2, 2, 2, 3363,
	3367, 7, 268, 2, 2, 3364, 3365, 7, 646, 2, 2, 3365, 3367, 9, 48, 2, 2,
	3366, 3363, 3, 2, 2, 2, 3366, 3364, 3, 2, 2, 2, 3367, 511, 3, 2, 2, 2,
	3368, 3371, 5, 514, 258, 2, 3369, 3372, 5, 516, 259, 2, 3370, 3372, 5,
	520, 261, 2, 3371, 3369, 3, 2, 2, 2, 3371, 3370, 3, 2, 2, 2, 3372, 513,
	3, 2, 2, 2, 3373, 3374, 7, 62, 2, 2, 3374, 3375, 5, 146, 74, 2, 3375, 515,
	3, 2, 2, 2, 3376, 3382, 7, 241, 2, 2, 3377, 3383, 5, 418, 210, 2, 3378,
	3380, 5, 142, 72, 2, 3379, 3381, 5, 518, 260, 2, 3380, 3379, 3, 2, 2, 2,
	3380, 3381, 3, 2, 2, 2, 3381, 3383, 3, 2, 2, 2, 3382, 3377, 3, 2, 2, 2,
	3382, 3378, 3, 2, 2, 2, 3383, 517, 3, 2, 2, 2, 3384, 3385, 7, 97, 2, 2,
	3385, 3388, 5, 258, 130, 2, 3386, 3388, 7, 153, 2, 2, 3387, 3384, 3, 2,
	2, 2, 3387, 3386, 3, 2, 2, 2, 3388, 519, 3, 2, 2, 2, 3389, 3390, 7, 240,
	2, 2, 3390, 3398, 7, 243, 2, 2, 3391, 3392, 7, 77, 2, 2, 3392, 3393, 7,
	385, 2, 2, 3393, 3394, 7, 24, 2, 2, 3394, 3396, 7, 646, 2, 2, 3395, 3397,
	7, 250, 2, 2, 3396, 3395, 3, 2, 2, 2, 3396, 3397, 3, 2, 2, 2, 3397, 3399,
	3, 2, 2, 2, 3398, 3391, 3, 2, 2, 2, 3398, 3399, 3, 2, 2, 2, 3399, 3401,
	3, 2, 2, 2, 3400, 3402, 5, 396, 199, 2, 3401, 3400, 3, 2, 2, 2, 3401, 3402,
	3, 2, 2, 2, 3402, 521, 3, 2, 2, 2, 3403, 3404, 7, 59, 2, 2, 3404, 3405,
	7, 31, 2, 2, 3405, 3406, 7, 416, 2, 2, 3406, 3407, 7, 24, 2, 2, 3407, 3408,
	9, 49, 2, 2, 3408, 3422, 7, 32, 2, 2, 3409, 3410, 7, 403, 2, 2, 3410, 3411,
	7, 24, 2, 2, 3411, 3422, 7, 97, 2, 2, 3412, 3413, 7, 255, 2, 2, 3413, 3414,
	7, 24, 2, 2, 3414, 3422, 9, 44, 2, 2, 3415, 3416, 7, 391, 2, 2, 3416, 3417,
	7, 24, 2, 2, 3417, 3419, 7, 97, 2, 2, 3418, 3420, 5, 524, 263, 2, 3419,
	3418, 3, 2, 2, 2, 3419, 3420, 3, 2, 2, 2, 3420, 3422, 3, 2, 2, 2, 3421,
	3403, 3, 2, 2, 2, 3421, 3409, 3, 2, 2, 2, 3421, 3412, 3, 2, 2, 2, 3421,
	3415, 3, 2, 2, 2, 3422, 523, 3, 2, 2, 2, 3423, 3424, 7, 31, 2, 2, 3424,
	3425, 7, 415, 2, 2, 3425, 3426, 7, 24, 2, 2, 3426, 3431, 5, 126, 64, 2,
	3427, 3428, 7, 37, 2, 2, 3428, 3429, 7, 388, 2, 2, 3429, 3430, 7, 24, 2,
	2, 3430, 3432, 5, 486, 244, 2, 3431, 3427, 3, 2, 2, 2, 3431, 3432, 3, 2,
	2, 2, 3432, 3433, 3, 2, 2, 2, 3433, 3434, 7, 32, 2, 2, 3434, 525, 3, 2,
	2, 2, 3435, 3436, 7, 98, 2, 2, 3436, 3437, 7, 110, 2, 2, 3437, 527, 3,
	2, 2, 2, 3438, 3439, 7, 475, 2, 2, 3439, 3440, 7, 24, 2, 2, 3440, 3442,
	9, 50, 2, 2, 3441, 3438, 3, 2, 2, 2, 3441, 3442, 3, 2, 2, 2, 3442, 3444,
	3, 2, 2, 2, 3443, 3445, 5, 530, 266, 2, 3444, 3443, 3, 2, 2, 2, 3444, 3445,
	3, 2, 2, 2, 3445, 3448, 3, 2, 2, 2, 3446, 3447, 7, 242, 2, 2, 3447, 3449,
	5, 258, 130, 2, 3448, 3446, 3, 2, 2, 2, 3448, 3449, 3, 2, 2, 2, 3449, 3459,
	3, 2, 2, 2, 3450, 3451, 7, 77, 2, 2, 3451, 3456, 5, 532, 267, 2, 3452,
	3453, 7, 37, 2, 2, 3453, 3455, 5, 532, 267, 2, 3454, 3452, 3, 2, 2, 2,
	3455, 3458, 3, 2, 2, 2, 3456, 3454, 3, 2, 2, 2, 3456, 3457, 3, 2, 2, 2,
	3457, 3460, 3, 2, 2, 2, 3458, 3456, 3, 2, 2, 2, 3459, 3450, 3, 2, 2, 2,
	3459, 3460, 3, 2, 2, 2, 3460, 529, 3, 2, 2, 2, 3461, 3463, 7, 97, 2, 2,
	3462, 3464, 7, 64, 2, 2, 3463, 3462, 3, 2, 2, 2, 3463, 3464, 3, 2, 2, 2,
	3464, 3465, 3, 2, 2, 2, 3465, 3470, 5, 536, 269, 2, 3466, 3467, 7, 37,
	2, 2, 3467, 3469, 5, 536, 269, 2, 3468, 3466, 3, 2, 2, 2, 3469, 3472, 3,
	2, 2, 2, 3470, 3468, 3, 2, 2, 2, 3470, 3471, 3, 2, 2, 2, 3471, 3477, 3,
	2, 2, 2, 3472, 3470, 3, 2, 2, 2, 3473, 3474, 7, 37, 2, 2, 3474, 3476, 5,
	540, 271, 2, 3475, 3473, 3, 2, 2, 2, 3476, 3479, 3, 2, 2, 2, 3477, 3475,
	3, 2, 2, 2, 3477, 3478, 3, 2, 2, 2, 3478, 3480, 3, 2, 2, 2, 3479, 3477,
	3, 2, 2, 2, 3480, 3481, 5, 544, 273, 2, 3481, 531, 3, 2, 2, 2, 3482, 3483,
	7, 258, 2, 2, 3483, 3488, 5, 534, 268, 2, 3484, 3485, 7, 37, 2, 2, 3485,
	3487, 5, 534, 268, 2, 3486, 3484, 3, 2, 2, 2, 3487, 3490, 3, 2, 2, 2, 3488,
	3486, 3, 2, 2, 2, 3488, 3489, 3, 2, 2, 2, 3489, 3517, 3, 2, 2, 2, 3490,
	3488, 3, 2, 2, 2, 3491, 3492, 7, 629, 2, 2, 3492, 3493, 7, 24, 2, 2, 3493,
	3517, 5, 258, 130, 2, 3494, 3495, 7, 630, 2, 2, 3495, 3496, 7, 24, 2, 2,
	3496, 3517, 5, 258, 130, 2, 3497, 3498, 7, 632, 2, 2, 3498, 3499, 7, 24,
	2, 2, 3499, 3517, 9, 32, 2, 2, 3500, 3501, 7, 633, 2, 2, 3501, 3502, 7,
	24, 2, 2, 3502, 3517, 9, 32, 2, 2, 3503, 3504, 7, 634, 2, 2, 3504, 3505,
	7, 24, 2, 2, 3505, 3517, 5, 258, 130, 2, 3506, 3507, 7, 490, 2, 2, 3507,
	3517, 9, 32, 2, 2, 3508, 3509, 7, 491, 2, 2, 3509, 3517, 9, 32, 2, 2, 3510,
	3511, 7, 635, 2, 2, 3511, 3512, 7, 24, 2, 2, 3512, 3513, 7, 97, 2, 2, 3513,
	3514, 7, 636, 2, 2, 3514, 3515, 7, 24, 2, 2, 3515, 3517, 5, 258, 130, 2,
	3516, 3482, 3, 2, 2, 2, 3516, 3491, 3, 2, 2, 2, 3516, 3494, 3, 2, 2, 2,
	3516, 3497, 3, 2, 2, 2, 3516, 3500, 3, 2, 2, 2, 3516, 3503, 3, 2, 2, 2,
	3516, 3506, 3, 2, 2, 2, 3516, 3508, 3, 2, 2, 2, 3516, 3510, 3, 2, 2, 2,
	3517, 533, 3, 2, 2, 2, 3518, 3519, 7, 489, 2, 2, 3519, 3520, 7, 24, 2,
	2, 3520, 3525, 9, 51, 2, 2, 3521, 3522, 7, 636, 2, 2, 3522, 3523, 7, 24,
	2, 2, 3523, 3525, 5, 258, 130, 2, 3524, 3518, 3, 2, 2, 2, 3524, 3521, 3,
	2, 2, 2, 3525, 535, 3, 2, 2, 2, 3526, 3527, 7, 31, 2, 2, 3527, 3528, 7,
	169, 2, 2, 3528, 3529, 7, 24, 2, 2, 3529, 3530, 5, 258, 130, 2, 3530, 3531,
	7, 37, 2, 2, 3531, 3532, 7, 477, 2, 2, 3532, 3533, 7, 24, 2, 2, 3533, 3534,
	7, 645, 2, 2, 3534, 3535, 5, 538, 270, 2, 3535, 3536, 7, 32, 2, 2, 3536,
	537, 3, 2, 2, 2, 3537, 3538, 7, 37, 2, 2, 3538, 3539, 7, 478, 2, 2, 3539,
	3540, 7, 24, 2, 2, 3540, 3542, 5, 96, 49, 2, 3541, 3543, 9, 52, 2, 2, 3542,
	3541, 3, 2, 2, 2, 3542, 3543, 3, 2, 2, 2, 3543, 3545, 3, 2, 2, 2, 3544,
	3537, 3, 2, 2, 2, 3544, 3545, 3, 2, 2, 2, 3545, 3556, 3, 2, 2, 2, 3546,
	3547, 7, 37, 2, 2, 3547, 3548, 7, 479, 2, 2, 3548, 3554, 7, 24, 2, 2, 3549,
	3551, 5, 96, 49, 2, 3550, 3552, 9, 52, 2, 2, 3551, 3550, 3, 2, 2, 2, 3551,
	3552, 3, 2, 2, 2, 3552, 3555, 3, 2, 2, 2, 3553, 3555, 7, 481, 2, 2, 3554,
	3549, 3, 2, 2, 2, 3554, 3553, 3, 2, 2, 2, 3555, 3557, 3, 2, 2, 2, 3556,
	3546, 3, 2, 2, 2, 3556, 3557, 3, 2, 2, 2, 3557, 3565, 3, 2, 2, 2, 3558,
	3559, 7, 37, 2, 2, 3559, 3560, 7, 480, 2, 2, 3560, 3561, 7, 24, 2, 2, 3561,
	3563, 5, 96, 49, 2, 3562, 3564, 9, 53, 2, 2, 3563, 3562, 3, 2, 2, 2, 3563,
	3564, 3, 2, 2, 2, 3564, 3566, 3, 2, 2, 2, 3565, 3558, 3, 2, 2, 2, 3565,
	3566, 3, 2, 2, 2, 3566, 539, 3, 2, 2, 2, 3567, 3568, 7, 488, 2, 2, 3568,
	3570, 5, 258, 130, 2, 3569, 3571, 5, 542, 272, 2, 3570, 3569, 3, 2, 2,
	2, 3570, 3571, 3, 2, 2, 2, 3571, 3572, 3, 2, 2, 2, 3572, 3577, 5, 536,
	269, 2, 3573, 3574, 7, 37, 2, 2, 3574, 3576, 5, 536, 269, 2, 3575, 3573,
	3, 2, 2, 2, 3576, 3579, 3, 2, 2, 2, 3577, 3575, 3, 2, 2, 2, 3577, 3578,
	3, 2, 2, 2, 3578, 541, 3, 2, 2, 2, 3579, 3577, 3, 2, 2, 2, 3580, 3581,
	7, 486, 2, 2, 3581, 3583, 7, 258, 2, 2, 3582, 3580, 3, 2, 2, 2, 3582, 3583,
	3, 2, 2, 2, 3583, 3585, 3, 2, 2, 2, 3584, 3586, 7, 153, 2, 2, 3585, 3584,
	3, 2, 2, 2, 3585, 3586, 3, 2, 2, 2, 3586, 3590, 3, 2, 2, 2, 3587, 3588,
	7, 486, 2, 2, 3588, 3590, 7, 487, 2, 2, 3589, 3582, 3, 2, 2, 2, 3589, 3587,
	3, 2, 2, 2, 3590, 543, 3, 2, 2, 2, 3591, 3592, 7, 370, 2, 2, 3592, 3593,
	7, 97, 2, 2, 3593, 3598, 5, 536, 269, 2, 3594, 3595, 7, 37, 2, 2, 3595,
	3597, 5, 536, 269, 2, 3596, 3594, 3, 2, 2, 2, 3597, 3600, 3, 2, 2, 2, 3598,
	3596, 3, 2, 2, 2, 3598, 3599, 3, 2, 2, 2, 3599, 3602, 3, 2, 2, 2, 3600,
	3598, 3, 2, 2, 2, 3601, 3591, 3, 2, 2, 2, 3601, 3602, 3, 2, 2, 2, 3602,
	545, 3, 2, 2, 2, 3603, 3613, 7, 204, 2, 2, 3604, 3609, 5, 548, 275, 2,
	3605, 3606, 7, 37, 2, 2, 3606, 3608, 5, 548, 275, 2, 3607, 3605, 3, 2,
	2, 2, 3608, 3611, 3, 2, 2, 2, 3609, 3607, 3, 2, 2, 2, 3609, 3610, 3, 2,
	2, 2, 3610, 3614, 3, 2, 2, 2, 3611, 3609, 3, 2, 2, 2, 3612, 3614, 5, 550,
	276, 2, 3613, 3604, 3, 2, 2, 2, 3613, 3612, 3, 2, 2, 2, 3614, 547, 3, 2,
	2, 2, 3615, 3617, 5, 264, 133, 2, 3616, 3618, 7, 96, 2, 2, 3617, 3616,
	3, 2, 2, 2, 3617, 3618, 3, 2, 2, 2, 3618, 3619, 3, 2, 2, 2, 3619, 3622,
	5, 204, 103, 2, 3620, 3621, 7, 24, 2, 2, 3621, 3623, 5, 172, 87, 2, 3622,
	3620, 3, 2, 2, 2, 3622, 3623, 3, 2, 2, 2, 3623, 3628, 3, 2, 2, 2, 3624,
	3625, 5, 264, 133, 2, 3625, 3626, 7, 205, 2, 2, 3626, 3628, 3, 2, 2, 2,
	3627, 3615, 3, 2, 2, 2, 3627, 3624, 3, 2, 2, 2, 3628, 549, 3, 2, 2, 2,
	3629, 3631, 5, 264, 133, 2, 3630, 3632, 7, 96, 2, 2, 3631, 3630, 3, 2,
	2, 2, 3631, 3632, 3, 2, 2, 2, 3632, 3633, 3, 2, 2, 2, 3633, 3634, 5, 552,
	277, 2, 3634, 551, 3, 2, 2, 2, 3635, 3636, 7, 60, 2, 2, 3636, 3637, 7,
	31, 2, 2, 3637, 3642, 5, 554, 278, 2, 3638, 3639, 7, 37, 2, 2, 3639, 3641,
	5, 554, 278, 2, 3640, 3638, 3, 2, 2, 2, 3641, 3644, 3, 2, 2, 2, 3642, 3640,
	3, 2, 2, 2, 3642, 3643, 3, 2, 2, 2, 3643, 3645, 3, 2, 2, 2, 3644, 3642,
	3, 2, 2, 2, 3645, 3646, 7, 32, 2, 2, 3646, 553, 3, 2, 2, 2, 3647, 3650,
	5, 556, 279, 2, 3648, 3650, 5, 560, 281, 2, 3649, 3647, 3, 2, 2, 2, 3649,
	3648, 3, 2, 2, 2, 3650, 555, 3, 2, 2, 2, 3651, 3655, 5, 134, 68, 2, 3652,
	3656, 5, 206, 104, 2, 3653, 3654, 7, 96, 2, 2, 3654, 3656, 5, 156, 79,
	2, 3655, 3652, 3, 2, 2, 2, 3655, 3653, 3, 2, 2, 2, 3656, 3659, 3, 2, 2,
	2, 3657, 3658, 7, 242, 2, 2, 3658, 3660, 5, 150, 76, 2, 3659, 3657, 3,
	2, 2, 2, 3659, 3660, 3, 2, 2, 2, 3660, 3673, 3, 2, 2, 2, 3661, 3662, 7,
	153, 2, 2, 3662, 3664, 5, 156, 79, 2, 3663, 3661, 3, 2, 2, 2, 3663, 3664,
	3, 2, 2, 2, 3664, 3674, 3, 2, 2, 2, 3665, 3671, 7, 264, 2, 2, 3666, 3667,
	7, 31, 2, 2, 3667, 3668, 7, 646, 2, 2, 3668, 3669, 7, 37, 2, 2, 3669, 3670,
	7, 646, 2, 2, 3670, 3672, 7, 32, 2, 2, 3671, 3666, 3, 2, 2, 2, 3671, 3672,
	3, 2, 2, 2, 3672, 3674, 3, 2, 2, 2, 3673, 3663, 3, 2, 2, 2, 3673, 3665,
	3, 2, 2, 2, 3674, 3676, 3, 2, 2, 2, 3675, 3677, 7, 290, 2, 2, 3676, 3675,
	3, 2, 2, 2, 3676, 3677, 3, 2, 2, 2, 3677, 3678, 3, 2, 2, 2, 3678, 3679,
	5, 558, 280, 2, 3679, 557, 3, 2, 2, 2, 3680, 3684, 7, 107, 2, 2, 3681,
	3682, 7, 106, 2, 2, 3682, 3684, 7, 107, 2, 2, 3683, 3680, 3, 2, 2, 2, 3683,
	3681, 3, 2, 2, 2, 3683, 3684, 3, 2, 2, 2, 3684, 3698, 3, 2, 2, 2, 3685,
	3686, 7, 64, 2, 2, 3686, 3689, 7, 67, 2, 2, 3687, 3689, 7, 65, 2, 2, 3688,
	3685, 3, 2, 2, 2, 3688, 3687, 3, 2, 2, 2, 3688, 3689, 3, 2, 2, 2, 3689,
	3698, 3, 2, 2, 2, 3690, 3691, 7, 226, 2, 2, 3691, 3692, 7, 31, 2, 2, 3692,
	3693, 5, 156, 79, 2, 3693, 3694, 7, 32, 2, 2, 3694, 3698, 3, 2, 2, 2, 3695,
	3696, 7, 77, 2, 2, 3696, 3698, 5, 234, 118, 2, 3697, 3683, 3, 2, 2, 2,
	3697, 3688, 3, 2, 2, 2, 3697, 3690, 3, 2, 2, 2, 3697, 3695, 3, 2, 2, 2,
	3698, 559, 3, 2, 2, 2, 3699, 3700, 7, 64, 2, 2, 3700, 3703, 7, 67, 2, 2,
	3701, 3703, 7, 65, 2, 2, 3702, 3699, 3, 2, 2, 2, 3702, 3701, 3, 2, 2, 2,
	3703, 3704, 3, 2, 2, 2, 3704, 3705, 7, 31, 2, 2, 3705, 3710, 5, 134, 68,
	2, 3706, 3707, 7, 37, 2, 2, 3707, 3709, 5, 134, 68, 2, 3708, 3706, 3, 2,
	2, 2, 3709, 3712, 3, 2, 2, 2, 3710, 3708, 3, 2, 2, 2, 3710, 3711, 3, 2,
	2, 2, 3711, 3713, 3, 2, 2, 2, 3712, 3710, 3, 2, 2, 2, 3713, 3714, 7, 32,
	2, 2, 3714, 3718, 3, 2, 2, 2, 3715, 3716, 7, 226, 2, 2, 3716, 3718, 5,
	156, 79, 2, 3717, 3702, 3, 2, 2, 2, 3717, 3715, 3, 2, 2, 2, 3718, 561,
	3, 2, 2, 2, 3719, 3720, 7, 59, 2, 2, 3720, 3721, 5, 264, 133, 2, 3721,
	3722, 5, 564, 283, 2, 3722, 563, 3, 2, 2, 2, 3723, 3724, 7, 20, 2, 2, 3724,
	3726, 5, 108, 55, 2, 3725, 3723, 3, 2, 2, 2, 3725, 3726, 3, 2, 2, 2, 3726,
	3727, 3, 2, 2, 2, 3727, 3734, 7, 24, 2, 2, 3728, 3735, 5, 156, 79, 2, 3729,
	3730, 5, 108, 55, 2, 3730, 3731, 7, 20, 2, 2, 3731, 3732, 5, 108, 55, 2,
	3732, 3735, 3, 2, 2, 2, 3733, 3735, 7, 652, 2, 2, 3734, 3728, 3, 2, 2,
	2, 3734, 3729, 3, 2, 2, 2, 3734, 3733, 3, 2, 2, 2, 3735, 3747, 3, 2, 2,
	2, 3736, 3737, 5, 570, 286, 2, 3737, 3738, 5, 156, 79, 2, 3738, 3747, 3,
	2, 2, 2, 3739, 3740, 7, 24, 2, 2, 3740, 3747, 5, 566, 284, 2, 3741, 3742,
	7, 24, 2, 2, 3742, 3743, 7, 31, 2, 2, 3743, 3744, 5, 30, 16, 2, 3744, 3745,
	7, 32, 2, 2, 3745, 3747, 3, 2, 2, 2, 3746, 3725, 3, 2, 2, 2, 3746, 3736,
	3, 2, 2, 2, 3746, 3739, 3, 2, 2, 2, 3746, 3741, 3, 2, 2, 2, 3747, 565,
	3, 2, 2, 2, 3748, 3768, 5, 264, 133, 2, 3749, 3750, 7, 205, 2, 2, 3750,
	3751, 5, 568, 285, 2, 3751, 3752, 7, 101, 2, 2, 3752, 3753, 5, 30, 16,
	2, 3753, 3765, 7, 101, 2, 2, 3754, 3766, 7, 202, 2, 2, 3755, 3756, 7, 49,
	2, 2, 3756, 3757, 7, 206, 2, 2, 3757, 3762, 5, 138, 70, 2, 3758, 3759,
	7, 37, 2, 2, 3759, 3761, 5, 138, 70, 2, 3760, 3758, 3, 2, 2, 2, 3761, 3764,
	3, 2, 2, 2, 3762, 3760, 3, 2, 2, 2, 3762, 3763, 3, 2, 2, 2, 3763, 3766,
	3, 2, 2, 2, 3764, 3762, 3, 2, 2, 2, 3765, 3754, 3, 2, 2, 2, 3765, 3755,
	3, 2, 2, 2, 3766, 3768, 3, 2, 2, 2, 3767, 3748, 3, 2, 2, 2, 3767, 3749,
	3, 2, 2, 2, 3768, 567, 3, 2, 2, 2, 3769, 3771, 9, 54, 2, 2, 3770, 3769,
	3, 2, 2, 2, 3770, 3771, 3, 2, 2, 2, 3771, 3773, 3, 2, 2, 2, 3772, 3774,
	9, 55, 2, 2, 3773, 3772, 3, 2, 2, 2, 3773, 3774, 3, 2, 2, 2, 3774, 3776,
	3, 2, 2, 2, 3775, 3777, 9, 56, 2, 2, 3776, 3775, 3, 2, 2, 2, 3776, 3777,
	3, 2, 2, 2, 3777, 3779, 3, 2, 2, 2, 3778, 3780, 7, 500, 2, 2, 3779, 3778,
	3, 2, 2, 2, 3779, 3780, 3, 2, 2, 2, 3780, 569, 3, 2, 2, 2, 3781, 3782,
	7, 15, 2, 2, 3782, 3798, 7, 24, 2, 2, 3783, 3784, 7, 16, 2, 2, 3784, 3798,
	7, 24, 2, 2, 3785, 3786, 7, 17, 2, 2, 3786, 3798, 7, 24, 2, 2, 3787, 3788,
	7, 18, 2, 2, 3788, 3798, 7, 24, 2, 2, 3789, 3790, 7, 13, 2, 2, 3790, 3798,
	7, 24, 2, 2, 3791, 3792, 7, 9, 2, 2, 3792, 3798, 7, 24, 2, 2, 3793, 3794,
	7, 12, 2, 2, 3794, 3798, 7, 24, 2, 2, 3795, 3796, 7, 8, 2, 2, 3796, 3798,
	7, 24, 2, 2, 3797, 3781, 3, 2, 2, 2, 3797, 3783, 3, 2, 2, 2, 3797, 3785,
	3, 2, 2, 2, 3797, 3787, 3, 2, 2, 2, 3797, 3789, 3, 2, 2, 2, 3797, 3791,
	3, 2, 2, 2, 3797, 3793, 3, 2, 2, 2, 3797, 3795, 3, 2, 2, 2, 3798, 571,
	3, 2, 2, 2, 3799, 3819, 7, 31, 2, 2, 3800, 3802, 5, 264, 133, 2, 3801,
	3803, 7, 96, 2, 2, 3802, 3801, 3, 2, 2, 2, 3802, 3803, 3, 2, 2, 2, 3803,
	3807, 3, 2, 2, 2, 3804, 3805, 5, 136, 69, 2, 3805, 3806, 7, 20, 2, 2, 3806,
	3808, 3, 2, 2, 2, 3807, 3804, 3, 2, 2, 2, 3807, 3808, 3, 2, 2, 2, 3808,
	3809, 3, 2, 2, 2, 3809, 3812, 5, 204, 103, 2, 3810, 3811, 7, 24, 2, 2,
	3811, 3813, 5, 258, 130, 2, 3812, 3810, 3, 2, 2, 2, 3812, 3813, 3, 2, 2,
	2, 3813, 3815, 3, 2, 2, 2, 3814, 3816, 7, 210, 2, 2, 3815, 3814, 3, 2,
	2, 2, 3815, 3816, 3, 2, 2, 2, 3816, 3818, 3, 2, 2, 2, 3817, 3800, 3, 2,
	2, 2, 3818, 3821, 3, 2, 2, 2, 3819, 3817, 3, 2, 2, 2, 3819, 3820, 3, 2,
	2, 2, 3820, 3822, 3, 2, 2, 2, 3821, 3819, 3, 2, 2, 2, 3822, 3823, 7, 32,
	2, 2, 3823, 573, 3, 2, 2, 2, 3824, 3828, 5, 580, 291, 2, 3825, 3828, 5,
	578, 290, 2, 3826, 3828, 5, 576, 289, 2, 3827, 3824, 3, 2, 2, 2, 3827,
	3825, 3, 2, 2, 2, 3827, 3826, 3, 2, 2, 2, 3828, 575, 3, 2, 2, 2, 3829,
	3830, 7, 207, 2, 2, 3830, 3831, 5, 264, 133, 2, 3831, 3832, 7, 60, 2, 2,
	3832, 3842, 5, 346, 174, 2, 3833, 3834, 7, 77, 2, 2, 3834, 3839, 5, 586,
	294, 2, 3835, 3836, 7, 37, 2, 2, 3836, 3838, 5, 586, 294, 2, 3837, 3835,
	3, 2, 2, 2, 3838, 3841, 3, 2, 2, 2, 3839, 3837, 3, 2, 2, 2, 3839, 3840,
	3, 2, 2, 2, 3840, 3843, 3, 2, 2, 2, 3841, 3839, 3, 2, 2, 2, 3842, 3833,
	3, 2, 2, 2, 3842, 3843, 3, 2, 2, 2, 3843, 3845, 3, 2, 2, 2, 3844, 3846,
	7, 96, 2, 2, 3845, 3844, 3, 2, 2, 2, 3845, 3846, 3, 2, 2, 2, 3846, 3847,
	3, 2, 2, 2, 3847, 3848, 7, 124, 2, 2, 3848, 3849, 5, 584, 293, 2, 3849,
	3850, 7, 209, 2, 2, 3850, 3851, 7, 257, 2, 2, 3851, 577, 3, 2, 2, 2, 3852,
	3853, 7, 207, 2, 2, 3853, 3863, 7, 60, 2, 2, 3854, 3855, 7, 77, 2, 2, 3855,
	3860, 5, 586, 294, 2, 3856, 3857, 7, 37, 2, 2, 3857, 3859, 5, 586, 294,
	2, 3858, 3856, 3, 2, 2, 2, 3859, 3862, 3, 2, 2, 2, 3860, 3858, 3, 2, 2,
	2, 3860, 3861, 3, 2, 2, 2, 3861, 3864, 3, 2, 2, 2, 3862, 3860, 3, 2, 2,
	2, 3863, 3854, 3, 2, 2, 2, 3863, 3864, 3, 2, 2, 2, 3864, 3866, 3, 2, 2,
	2, 3865, 3867, 7, 96, 2, 2, 3866, 3865, 3, 2, 2, 2, 3866, 3867, 3, 2, 2,
	2, 3867, 3868, 3, 2, 2, 2, 3868, 3870, 7, 209, 2, 2, 3869, 3871, 7, 31,
	2, 2, 3870, 3869, 3, 2, 2, 2, 3870, 3871, 3, 2, 2, 2, 3871, 3872, 3, 2,
	2, 2, 3872, 3874, 5, 30, 16, 2, 3873, 3875, 7, 32, 2, 2, 3874, 3873, 3,
	2, 2, 2, 3874, 3875, 3, 2, 2, 2, 3875, 579, 3, 2, 2, 2, 3876, 3877, 7,
	207, 2, 2, 3877, 3887, 5, 204, 103, 2, 3878, 3879, 7, 77, 2, 2, 3879, 3884,
	5, 586, 294, 2, 3880, 3881, 7, 37, 2, 2, 3881, 3883, 5, 586, 294, 2, 3882,
	3880, 3, 2, 2, 2, 3883, 3886, 3, 2, 2, 2, 3884, 3882, 3, 2, 2, 2, 3884,
	3885, 3, 2, 2, 2, 3885, 3888, 3, 2, 2, 2, 3886, 3884, 3, 2, 2, 2, 3887,
	3878, 3, 2, 2, 2, 3887, 3888, 3, 2, 2, 2, 3888, 3890, 3, 2, 2, 2, 3889,
	3891, 7, 96, 2, 2, 3890, 3889, 3, 2, 2, 2, 3890, 3891, 3, 2, 2, 2, 3891,
	3892, 3, 2, 2, 2, 3892, 3893, 7, 124, 2, 2, 3893, 3894, 5, 584, 293, 2,
	3894, 3895, 7, 209, 2, 2, 3895, 3896, 5, 156, 79, 2, 3896, 581, 3, 2, 2,
	2, 3897, 3898, 5, 350, 176, 2, 3898, 3899, 5, 356, 179, 2, 3899, 3902,
	3, 2, 2, 2, 3900, 3902, 5, 404, 203, 2, 3901, 3897, 3, 2, 2, 2, 3901, 3900,
	3, 2, 2, 2, 3902, 3906, 3, 2, 2, 2, 3903, 3905, 5, 408, 205, 2, 3904, 3903,
	3, 2, 2, 2, 3905, 3908, 3, 2, 2, 2, 3906, 3904, 3, 2, 2, 2, 3906, 3907,
	3, 2, 2, 2, 3907, 583, 3, 2, 2, 2, 3908, 3906, 3, 2, 2, 2, 3909, 3911,
	5, 588, 295, 2, 3910, 3909, 3, 2, 2, 2, 3911, 3914, 3, 2, 2, 2, 3912, 3910,
	3, 2, 2, 2, 3912, 3913, 3, 2, 2, 2, 3913, 585, 3, 2, 2, 2, 3914, 3912,
	3, 2, 2, 2, 3915, 3917, 7, 346, 2, 2, 3916, 3915, 3, 2, 2, 2, 3916, 3917,
	3, 2, 2, 2, 3917, 3941, 3, 2, 2, 2, 3918, 3920, 7, 501, 2, 2, 3919, 3918,
	3, 2, 2, 2, 3919, 3920, 3, 2, 2, 2, 3920, 3941, 3, 2, 2, 2, 3921, 3922,
	7, 207, 2, 2, 3922, 3923, 7, 107, 2, 2, 3923, 3924, 7, 97, 2, 2, 3924,
	3925, 7, 107, 2, 2, 3925, 3931, 7, 503, 2, 2, 3926, 3927, 7, 504, 2, 2,
	3927, 3928, 7, 97, 2, 2, 3928, 3929, 7, 107, 2, 2, 3929, 3931, 7, 503,
	2, 2, 3930, 3921, 3, 2, 2, 2, 3930, 3926, 3, 2, 2, 2, 3930, 3931, 3, 2,
	2, 2, 3931, 3941, 3, 2, 2, 2, 3932, 3934, 5, 266, 134, 2, 3933, 3932, 3,
	2, 2, 2, 3933, 3934, 3, 2, 2, 2, 3934, 3941, 3, 2, 2, 2, 3935, 3936, 7,
	631, 2, 2, 3936, 3937, 7, 24, 2, 2, 3937, 3939, 9, 32, 2, 2, 3938, 3935,
	3, 2, 2, 2, 3938, 3939, 3, 2, 2, 2, 3939, 3941, 3, 2, 2, 2, 3940, 3916,
	3, 2, 2, 2, 3940, 3919, 3, 2, 2, 2, 3940, 3930, 3, 2, 2, 2, 3940, 3933,
	3, 2, 2, 2, 3940, 3938, 3, 2, 2, 2, 3941, 587, 3, 2, 2, 2, 3942, 3953,
	5, 278, 140, 2, 3943, 3953, 5, 300, 151, 2, 3944, 3953, 5, 320, 161, 2,
	3945, 3953, 5, 340, 171, 2, 3946, 3953, 5, 4, 3, 2, 3947, 3953, 5, 12,
	7, 2, 3948, 3953, 5, 22, 12, 2, 3949, 3953, 5, 30, 16, 2, 3950, 3953, 5,
	562, 282, 2, 3951, 3953, 5, 546, 274, 2, 3952, 3942, 3, 2, 2, 2, 3952,
	3943, 3, 2, 2, 2, 3952, 3944, 3, 2, 2, 2, 3952, 3945, 3, 2, 2, 2, 3952,
	3946, 3, 2, 2, 2, 3952, 3947, 3, 2, 2, 2, 3952, 3948, 3, 2, 2, 2, 3952,
	3949, 3, 2, 2, 2, 3952, 3950, 3, 2, 2, 2, 3952, 3951, 3, 2, 2, 2, 3953,
	3955, 3, 2, 2, 2, 3954, 3956, 7, 43, 2, 2, 3955, 3954, 3, 2, 2, 2, 3955,
	3956, 3, 2, 2, 2, 3956, 589, 3, 2, 2, 2, 3957, 3962, 5, 592, 297, 2, 3958,
	3959, 7, 37, 2, 2, 3959, 3961, 5, 592, 297, 2, 3960, 3958, 3, 2, 2, 2,
	3961, 3964, 3, 2, 2, 2, 3962, 3960, 3, 2, 2, 2, 3962, 3963, 3, 2, 2, 2,
	3963, 3966, 3, 2, 2, 2, 3964, 3962, 3, 2, 2, 2, 3965, 3957, 3, 2, 2, 2,
	3965, 3966, 3, 2, 2, 2, 3966, 591, 3, 2, 2, 2, 3967, 3969, 5, 548, 275,
	2, 3968, 3970, 7, 505, 2, 2, 3969, 3968, 3, 2, 2, 2, 3969, 3970, 3, 2,
	2, 2, 3970, 3973, 3, 2, 2, 2, 3971, 3972, 7, 24, 2, 2, 3972, 3974, 5, 92,
	47, 2, 3973, 3971, 3, 2, 2, 2, 3973, 3974, 3, 2, 2, 2, 3974, 3976, 3, 2,
	2, 2, 3975, 3977, 9, 57, 2, 2, 3976, 3975, 3, 2, 2, 2, 3976, 3977, 3, 2,
	2, 2, 3977, 593, 3, 2, 2, 2, 3978, 3980, 5, 596, 299, 2, 3979, 3978, 3,
	2, 2, 2, 3979, 3980, 3, 2, 2, 2, 3980, 3983, 3, 2, 2, 2, 3981, 3982, 7,
	101, 2, 2, 3982, 3984, 7, 288, 2, 2, 3983, 3981, 3, 2, 2, 2, 3983, 3984,
	3, 2, 2, 2, 3984, 3985, 3, 2, 2, 2, 3985, 3986, 7, 96, 2, 2, 3986, 3987,
	5, 600, 301, 2, 3987, 595, 3, 2, 2, 2, 3988, 3997, 7, 77, 2, 2, 3989, 3994,
	5, 598, 300, 2, 3990, 3991, 7, 37, 2, 2, 3991, 3993, 5, 598, 300, 2, 3992,
	3990, 3, 2, 2, 2, 3993, 3996, 3, 2, 2, 2, 3994, 3992, 3, 2, 2, 2, 3994,
	3995, 3, 2, 2, 2, 3995, 3998, 3, 2, 2, 2, 3996, 3994, 3, 2, 2, 2, 3997,
	3989, 3, 2, 2, 2, 3997, 3998, 3, 2, 2, 2, 3998, 597, 3, 2, 2, 2, 3999,
	4005, 7, 346, 2, 2, 4000, 4005, 7, 469, 2, 2, 4001, 4005, 5, 266, 134,
	2, 4002, 4005, 7, 516, 2, 2, 4003, 4005, 7, 501, 2, 2, 4004, 3999, 3, 2,
	2, 2, 4004, 4000, 3, 2, 2, 2, 4004, 4001, 3, 2, 2, 2, 4004, 4002, 3, 2,
	2, 2, 4004, 4003, 3, 2, 2, 2, 4005, 599, 3, 2, 2, 2, 4006, 4008, 7, 124,
	2, 2, 4007, 4006, 3, 2, 2, 2, 4007, 4008, 3, 2, 2, 2, 4008, 4009, 3, 2,
	2, 2, 4009, 4011, 5, 584, 293, 2, 4010, 4012, 7, 257, 2, 2, 4011, 4010,
	3, 2, 2, 2, 4011, 4012, 3, 2, 2, 2, 4012, 4042, 3, 2, 2, 2, 4013, 4014,
	7, 333, 2, 2, 4014, 4018, 7, 169, 2, 2, 4015, 4016, 5, 136, 69, 2, 4016,
	4017, 7, 20, 2, 2, 4017, 4019, 3, 2, 2, 2, 4018, 4015, 3, 2, 2, 2, 4018,
	4019, 3, 2, 2, 2, 4019, 4023, 3, 2, 2, 2, 4020, 4021, 5, 136, 69, 2, 4021,
	4022, 7, 20, 2, 2, 4022, 4024, 3, 2, 2, 2, 4023, 4020, 3, 2, 2, 2, 4023,
	4024, 3, 2, 2, 2, 4024, 4025, 3, 2, 2, 2, 4025, 4042, 5, 138, 70, 2, 4026,
	4027, 7, 124, 2, 2, 4027, 4028, 7, 508, 2, 2, 4028, 4029, 7, 77, 2, 2,
	4029, 4034, 5, 602, 302, 2, 4030, 4031, 7, 37, 2, 2, 4031, 4033, 5, 602,
	302, 2, 4032, 4030, 3, 2, 2, 2, 4033, 4036, 3, 2, 2, 2, 4034, 4032, 3,
	2, 2, 2, 4034, 4035, 3, 2, 2, 2, 4035, 4037, 3, 2, 2, 2, 4036, 4034, 3,
	2, 2, 2, 4037, 4039, 5, 584, 293, 2, 4038, 4040, 7, 257, 2, 2, 4039, 4038,
	3, 2, 2, 2, 4039, 4040, 3, 2, 2, 2, 4040, 4042, 3, 2, 2, 2, 4041, 4007,
	3, 2, 2, 2, 4041, 4013, 3, 2, 2, 2, 4041, 4026, 3, 2, 2, 2, 4042, 601,
	3, 2, 2, 2, 4043, 4044, 7, 509, 2, 2, 4044, 4045, 7, 24, 2, 2, 4045, 4066,
	5, 94, 48, 2, 4046, 4047, 7, 235, 2, 2, 4047, 4048, 7, 511, 2, 2, 4048,
	4049, 7, 510, 2, 2, 4049, 4054, 7, 24, 2, 2, 4050, 4055, 7, 512, 2, 2,
	4051, 4052, 7, 513, 2, 2, 4052, 4055, 7, 514, 2, 2, 4053, 4055, 7, 515,
	2, 2, 4054, 4050, 3, 2, 2, 2, 4054, 4051, 3, 2, 2, 2, 4054, 4053, 3, 2,
	2, 2, 4055, 4066, 3, 2, 2, 2, 4056, 4057, 7, 624, 2, 2, 4057, 4058, 7,
	24, 2, 2, 4058, 4066, 5, 96, 49, 2, 4059, 4060, 7, 637, 2, 2, 4060, 4061,
	7, 24, 2, 2, 4061, 4066, 5, 94, 48, 2, 4062, 4063, 7, 638, 2, 2, 4063,
	4064, 7, 24, 2, 2, 4064, 4066, 9, 32, 2, 2, 4065, 4043, 3, 2, 2, 2, 4065,
	4046, 3, 2, 2, 2, 4065, 4056, 3, 2, 2, 2, 4065, 4059, 3, 2, 2, 2, 4065,
	4062, 3, 2, 2, 2, 4066, 603, 3, 2, 2, 2, 4067, 4068, 7, 77, 2, 2, 4068,
	4073, 5, 606, 304, 2, 4069, 4070, 7, 37, 2, 2, 4070, 4072, 5, 606, 304,
	2, 4071, 4069, 3, 2, 2, 2, 4072, 4075, 3, 2, 2, 2, 4073, 4071, 3, 2, 2,
	2, 4073, 4074, 3, 2, 2, 2, 4074, 4077, 3, 2, 2, 2, 4075, 4073, 3, 2, 2,
	2, 4076, 4067, 3, 2, 2, 2, 4076, 4077, 3, 2, 2, 2, 4077, 4078, 3, 2, 2,
	2, 4078, 4080, 7, 96, 2, 2, 4079, 4081, 5, 608, 305, 2, 4080, 4079, 3,
	2, 2, 2, 4080, 4081, 3, 2, 2, 2, 4081, 4082, 3, 2, 2, 2, 4082, 4086, 5,
	30, 16, 2, 4083, 4084, 7, 77, 2, 2, 4084, 4085, 7, 226, 2, 2, 4085, 4087,
	7, 229, 2, 2, 4086, 4083, 3, 2, 2, 2, 4086, 4087, 3, 2, 2, 2, 4087, 605,
	3, 2, 2, 2, 4088, 4089, 9, 58, 2, 2, 4089, 607, 3, 2, 2, 2, 4090, 4091,
	7, 77, 2, 2, 4091, 4096, 5, 610, 306, 2, 4092, 4093, 7, 37, 2, 2, 4093,
	4095, 5, 610, 306, 2, 4094, 4092, 3, 2, 2, 2, 4095, 4098, 3, 2, 2, 2, 4096,
	4094, 3, 2, 2, 2, 4096, 4097, 3, 2, 2, 2, 4097, 609, 3, 2, 2, 2, 4098,
	4096, 3, 2, 2, 2, 4099, 4111, 5, 138, 70, 2, 4100, 4101, 7, 31, 2, 2, 4101,
	4106, 5, 134, 68, 2, 4102, 4103, 7, 37, 2, 2, 4103, 4105, 5, 134, 68, 2,
	4104, 4102, 3, 2, 2, 2, 4105, 4108, 3, 2, 2, 2, 4106, 4104, 3, 2, 2, 2,
	4106, 4107, 3, 2, 2, 2, 4107, 4109, 3, 2, 2, 2, 4108, 4106, 3, 2, 2, 2,
	4109, 4110, 7, 32, 2, 2, 4110, 4112, 3, 2, 2, 2, 4111, 4100, 3, 2, 2, 2,
	4111, 4112, 3, 2, 2, 2, 4112, 4113, 3, 2, 2, 2, 4113, 4114, 7, 96, 2, 2,
	4114, 4115, 7, 31, 2, 2, 4115, 4116, 5, 30, 16, 2, 4116, 4117, 7, 32, 2,
	2, 4117, 611, 3, 2, 2, 2, 4118, 4119, 7, 77, 2, 2, 4119, 4120, 5, 614,
	308, 2, 4120, 4121, 7, 37, 2, 2, 4121, 4122, 5, 614, 308, 2, 4122, 4124,
	3, 2, 2, 2, 4123, 4118, 3, 2, 2, 2, 4123, 4124, 3, 2, 2, 2, 4124, 4129,
	3, 2, 2, 2, 4125, 4130, 7, 101, 2, 2, 4126, 4130, 7, 518, 2, 2, 4127, 4128,
	7, 519, 2, 2, 4128, 4130, 7, 206, 2, 2, 4129, 4125, 3, 2, 2, 2, 4129, 4126,
	3, 2, 2, 2, 4129, 4127, 3, 2, 2, 2, 4130, 4132, 3, 2, 2, 2, 4131, 4133,
	7, 48, 2, 2, 4132, 4131, 3, 2, 2, 2, 4132, 4133, 3, 2, 2, 2, 4133, 4135,
	3, 2, 2, 2, 4134, 4136, 7, 37, 2, 2, 4135, 4134, 3, 2, 2, 2, 4135, 4136,
	3, 2, 2, 2, 4136, 4138, 3, 2, 2, 2, 4137, 4139, 7, 49, 2, 2, 4138, 4137,
	3, 2, 2, 2, 4138, 4139, 3, 2, 2, 2, 4139, 4141, 3, 2, 2, 2, 4140, 4142,
	7, 37, 2, 2, 4141, 4140, 3, 2, 2, 2, 4141, 4142, 3, 2, 2, 2, 4142, 4144,
	3, 2, 2, 2, 4143, 4145, 7, 50, 2, 2, 4144, 4143, 3, 2, 2, 2, 4144, 4145,
	3, 2, 2, 2, 4145, 4147, 3, 2, 2, 2, 4146, 4148, 7, 37, 2, 2, 4147, 4146,
	3, 2, 2, 2, 4147, 4148, 3, 2, 2, 2, 4148, 4151, 3, 2, 2, 2, 4149, 4150,
	7, 77, 2, 2, 4150, 4152, 7, 520, 2, 2, 4151, 4149, 3, 2, 2, 2, 4151, 4152,
	3, 2, 2, 2, 4152, 4156, 3, 2, 2, 2, 4153, 4154, 7, 106, 2, 2, 4154, 4155,
	7, 101, 2, 2, 4155, 4157, 7, 288, 2, 2, 4156, 4153, 3, 2, 2, 2, 4156, 4157,
	3, 2, 2, 2, 4157, 4158, 3, 2, 2, 2, 4158, 4163, 7, 96, 2, 2, 4159, 4164,
	5, 584, 293, 2, 4160, 4161, 7, 333, 2, 2, 4161, 4162, 7, 169, 2, 2, 4162,
	4164, 5, 616, 309, 2, 4163, 4159, 3, 2, 2, 2, 4163, 4160, 3, 2, 2, 2, 4164,
	613, 3, 2, 2, 2, 4165, 4171, 7, 346, 2, 2, 4166, 4171, 5, 266, 134, 2,
	4167, 4171, 7, 516, 2, 2, 4168, 4171, 7, 501, 2, 2, 4169, 4171, 3, 2, 2,
	2, 4170, 4165, 3, 2, 2, 2, 4170, 4166, 3, 2, 2, 2, 4170, 4167, 3, 2, 2,
	2, 4170, 4168, 3, 2, 2, 2, 4170, 4169, 3, 2, 2, 2, 4171, 615, 3, 2, 2,
	2, 4172, 4173, 5, 138, 70, 2, 4173, 4174, 7, 20, 2, 2, 4174, 4175, 5, 138,
	70, 2, 4175, 4176, 7, 20, 2, 2, 4176, 4177, 5, 138, 70, 2, 4177, 617, 3,
	2, 2, 2, 4178, 4184, 5, 126, 64, 2, 4179, 4184, 5, 120, 61, 2, 4180, 4181,
	7, 113, 2, 2, 4181, 4184, 7, 313, 2, 2, 4182, 4184, 7, 203, 2, 2, 4183,
	4178, 3, 2, 2, 2, 4183, 4179, 3, 2, 2, 2, 4183, 4180, 3, 2, 2, 2, 4183,
	4182, 3, 2, 2, 2, 4184, 619, 3, 2, 2, 2, 4185, 4186, 7, 96, 2, 2, 4186,
	4214, 5, 204, 103, 2, 4187, 4188, 9, 59, 2, 2, 4188, 4189, 7, 77, 2, 2,
	4189, 4214, 5, 156, 79, 2, 4190, 4191, 7, 521, 2, 2, 4191, 4192, 7, 118,
	2, 2, 4192, 4214, 5, 156, 79, 2, 4193, 4195, 7, 524, 2, 2, 4194, 4196,
	5, 156, 79, 2, 4195, 4194, 3, 2, 2, 2, 4195, 4196, 3, 2, 2, 2, 4196, 4214,
	3, 2, 2, 2, 4197, 4198, 7, 228, 2, 2, 4198, 4214, 7, 524, 2, 2, 4199, 4201,
	7, 525, 2, 2, 4200, 4202, 5, 156, 79, 2, 4201, 4200, 3, 2, 2, 2, 4201,
	4202, 3, 2, 2, 2, 4202, 4214, 3, 2, 2, 2, 4203, 4204, 7, 228, 2, 2, 4204,
	4214, 7, 525, 2, 2, 4205, 4206, 7, 523, 2, 2, 4206, 4214, 5, 156, 79, 2,
	4207, 4208, 7, 228, 2, 2, 4208, 4214, 7, 523, 2, 2, 4209, 4211, 7, 228,
	2, 2, 4210, 4209, 3, 2, 2, 2, 4210, 4211, 3, 2, 2, 2, 4211, 4212, 3, 2,
	2, 2, 4212, 4214, 7, 522, 2, 2, 4213, 4185, 3, 2, 2, 2, 4213, 4187, 3,
	2, 2, 2, 4213, 4190, 3, 2, 2, 2, 4213, 4193, 3, 2, 2, 2, 4213, 4197, 3,
	2, 2, 2, 4213, 4199, 3, 2, 2, 2, 4213, 4203, 3, 2, 2, 2, 4213, 4205, 3,
	2, 2, 2, 4213, 4207, 3, 2, 2, 2, 4213, 4210, 3, 2, 2, 2, 4214, 621, 3,
	2, 2, 2, 4215, 4216, 7, 533, 2, 2, 4216, 4218, 5, 142, 72, 2, 4217, 4215,
	3, 2, 2, 2, 4217, 4218, 3, 2, 2, 2, 4218, 4221, 3, 2, 2, 2, 4219, 4220,
	7, 95, 2, 2, 4220, 4222, 5, 624, 313, 2, 4221, 4219, 3, 2, 2, 2, 4221,
	4222, 3, 2, 2, 2, 4222, 4235, 3, 2, 2, 2, 4223, 4224, 7, 77, 2, 2, 4224,
	4225, 7, 31, 2, 2, 4225, 4230, 5, 630, 316, 2, 4226, 4227, 7, 37, 2, 2,
	4227, 4229, 5, 630, 316, 2, 4228, 4226, 3, 2, 2, 2, 4229, 4232, 3, 2, 2,
	2, 4230, 4228, 3, 2, 2, 2, 4230, 4231, 3, 2, 2, 2, 4231, 4233, 3, 2, 2,
	2, 4232, 4230, 3, 2, 2, 2, 4233, 4234, 7, 32, 2, 2, 4234, 4236, 3, 2, 2,
	2, 4235, 4223, 3, 2, 2, 2, 4235, 4236, 3, 2, 2, 2, 4236, 4246, 3, 2, 2,
	2, 4237, 4244, 7, 97, 2, 2, 4238, 4239, 5, 114, 58, 2, 4239, 4240, 7, 31,
	2, 2, 4240, 4241, 5, 134, 68, 2, 4241, 4242, 7, 32, 2, 2, 4242, 4245, 3,
	2, 2, 2, 4243, 4245, 5, 138, 70, 2, 4244, 4238, 3, 2, 2, 2, 4244, 4243,
	3, 2, 2, 2, 4245, 4247, 3, 2, 2, 2, 4246, 4237, 3, 2, 2, 2, 4246, 4247,
	3, 2, 2, 2, 4247, 4253, 3, 2, 2, 2, 4248, 4251, 7, 407, 2, 2, 4249, 4252,
	5, 138, 70, 2, 4250, 4252, 5, 94, 48, 2, 4251, 4249, 3, 2, 2, 2, 4251,
	4250, 3, 2, 2, 2, 4252, 4254, 3, 2, 2, 2, 4253, 4248, 3, 2, 2, 2, 4253,
	4254, 3, 2, 2, 2, 4254, 623, 3, 2, 2, 2, 4255, 4260, 5, 626, 314, 2, 4256,
	4257, 7, 103, 2, 2, 4257, 4259, 5, 626, 314, 2, 4258, 4256, 3, 2, 2, 2,
	4259, 4262, 3, 2, 2, 2, 4260, 4258, 3, 2, 2, 2, 4260, 4261, 3, 2, 2, 2,
	4261, 625, 3, 2, 2, 2, 4262, 4260, 3, 2, 2, 2, 4263, 4264, 5, 134, 68,
	2, 4264, 4265, 7, 112, 2, 2, 4265, 4266, 7, 31, 2, 2, 4266, 4271, 5, 156,
	79, 2, 4267, 4268, 7, 37, 2, 2, 4268, 4270, 5, 156, 79, 2, 4269, 4267,
	3, 2, 2, 2, 4270, 4273, 3, 2, 2, 2, 4271, 4269, 3, 2, 2, 2, 4271, 4272,
	3, 2, 2, 2, 4272, 4274, 3, 2, 2, 2, 4273, 4271, 3, 2, 2, 2, 4274, 4275,
	7, 32, 2, 2, 4275, 4281, 3, 2, 2, 2, 4276, 4277, 5, 134, 68, 2, 4277, 4278,
	5, 166, 84, 2, 4278, 4279, 5, 156, 79, 2, 4279, 4281, 3, 2, 2, 2, 4280,
	4263, 3, 2, 2, 2, 4280, 4276, 3, 2, 2, 2, 4281, 627, 3, 2, 2, 2, 4282,
	4289, 7, 286, 2, 2, 4283, 4284, 7, 217, 2, 2, 4284, 4287, 7, 24, 2, 2,
	4285, 4288, 7, 113, 2, 2, 4286, 4288, 5, 156, 79, 2, 4287, 4285, 3, 2,
	2, 2, 4287, 4286, 3, 2, 2, 2, 4288, 4290, 3, 2, 2, 2, 4289, 4283, 3, 2,
	2, 2, 4289, 4290, 3, 2, 2, 2, 4290, 4303, 3, 2, 2, 2, 4291, 4292, 7, 77,
	2, 2, 4292, 4293, 7, 31, 2, 2, 4293, 4298, 5, 630, 316, 2, 4294, 4295,
	7, 37, 2, 2, 4295, 4297, 5, 630, 316, 2, 4296, 4294, 3, 2, 2, 2, 4297,
	4300, 3, 2, 2, 2, 4298, 4296, 3, 2, 2, 2, 4298, 4299, 3, 2, 2, 2, 4299,
	4301, 3, 2, 2, 2, 4300, 4298, 3, 2, 2, 2, 4301, 4302, 7, 32, 2, 2, 4302,
	4304, 3, 2, 2, 2, 4303, 4291, 3, 2, 2, 2, 4303, 4304, 3, 2, 2, 2, 4304,
	4345, 3, 2, 2, 2, 4305, 4345, 7, 156, 2, 2, 4306, 4310, 7, 529, 2, 2, 4307,
	4308, 7, 217, 2, 2, 4308, 4309, 7, 24, 2, 2, 4309, 4311, 5, 156, 79, 2,
	4310, 4307, 3, 2, 2, 2, 4310, 4311, 3, 2, 2, 2, 4311, 4317, 3, 2, 2, 2,
	4312, 4313, 7, 77, 2, 2, 4313, 4314, 7, 31, 2, 2, 4314, 4315, 5, 634, 318,
	2, 4315, 4316, 7, 32, 2, 2, 4316, 4318, 3, 2, 2, 2, 4317, 4312, 3, 2, 2,
	2, 4317, 4318, 3, 2, 2, 2, 4318, 4345, 3, 2, 2, 2, 4319, 4320, 7, 59, 2,
	2, 4320, 4321, 7, 31, 2, 2, 4321, 4322, 5, 636, 319, 2, 4322, 4323, 7,
	37, 2, 2, 4323, 4324, 5, 636, 319, 2, 4324, 4325, 3, 2, 2, 2, 4325, 4326,
	7, 32, 2, 2, 4326, 4345, 3, 2, 2, 2, 4327, 4340, 7, 530, 2, 2, 4328, 4329,
	7, 77, 2, 2, 4329, 4330, 7, 31, 2, 2, 4330, 4335, 5, 638, 320, 2, 4331,
	4332, 7, 37, 2, 2, 4332, 4334, 5, 638, 320, 2, 4333, 4331, 3, 2, 2, 2,
	4334, 4337, 3, 2, 2, 2, 4335, 4333, 3, 2, 2, 2, 4335, 4336, 3, 2, 2, 2,
	4336, 4338, 3, 2, 2, 2, 4337, 4335, 3, 2, 2, 2, 4338, 4339, 7, 32, 2, 2,
	4339, 4341, 3, 2, 2, 2, 4340, 4328, 3, 2, 2, 2, 4340, 4341, 3, 2, 2, 2,
	4341, 4345, 3, 2, 2, 2, 4342, 4345, 7, 531, 2, 2, 4343, 4345, 7, 532, 2,
	2, 4344, 4282, 3, 2, 2, 2, 4344, 4305, 3, 2, 2, 2, 4344, 4306, 3, 2, 2,
	2, 4344, 4319, 3, 2, 2, 2, 4344, 4327, 3, 2, 2, 2, 4344, 4342, 3, 2, 2,
	2, 4344, 4343, 3, 2, 2, 2, 4345, 629, 3, 2, 2, 2, 4346, 4347, 7, 405, 2,
	2, 4347, 4348, 7, 24, 2, 2, 4348, 4414, 9, 32, 2, 2, 4349, 4350, 7, 260,
	2, 2, 4350, 4351, 7, 24, 2, 2, 4351, 4414, 5, 156, 79, 2, 4352, 4353, 7,
	399, 2, 2, 4353, 4354, 7, 24, 2, 2, 4354, 4414, 9, 32, 2, 2, 4355, 4356,
	7, 400, 2, 2, 4356, 4357, 7, 24, 2, 2, 4357, 4414, 9, 32, 2, 2, 4358, 4359,
	7, 395, 2, 2, 4359, 4360, 7, 24, 2, 2, 4360, 4414, 9, 32, 2, 2, 4361, 4362,
	7, 394, 2, 2, 4362, 4363, 7, 24, 2, 2, 4363, 4414, 9, 32, 2, 2, 4364, 4365,
	7, 417, 2, 2, 4365, 4366, 7, 24, 2, 2, 4366, 4414, 9, 32, 2, 2, 4367, 4368,
	7, 277, 2, 2, 4368, 4374, 7, 24, 2, 2, 4369, 4371, 7, 97, 2, 2, 4370, 4372,
	5, 254, 128, 2, 4371, 4370, 3, 2, 2, 2, 4371, 4372, 3, 2, 2, 2, 4372, 4375,
	3, 2, 2, 2, 4373, 4375, 7, 276, 2, 2, 4374, 4369, 3, 2, 2, 2, 4374, 4373,
	3, 2, 2, 2, 4375, 4414, 3, 2, 2, 2, 4376, 4377, 7, 289, 2, 2, 4377, 4378,
	7, 24, 2, 2, 4378, 4414, 9, 32, 2, 2, 4379, 4380, 7, 402, 2, 2, 4380, 4381,
	7, 24, 2, 2, 4381, 4383, 5, 156, 79, 2, 4382, 4384, 7, 250, 2, 2, 4383,
	4382, 3, 2, 2, 2, 4383, 4384, 3, 2, 2, 2, 4384, 4414, 3, 2, 2, 2, 4385,
	4386, 7, 379, 2, 2, 4386, 4387, 7, 24, 2, 2, 4387, 4414, 9, 32, 2, 2, 4388,
	4389, 7, 378, 2, 2, 4389, 4390, 7, 24, 2, 2, 4390, 4414, 9, 32, 2, 2, 4391,
	4392, 7, 471, 2, 2, 4392, 4393, 7, 24, 2, 2, 4393, 4414, 9, 32, 2, 2, 4394,
	4395, 7, 271, 2, 2, 4395, 4396, 7, 24, 2, 2, 4396, 4414, 5, 156, 79, 2,
	4397, 4398, 7, 387, 2, 2, 4398, 4399, 7, 24, 2, 2, 4399, 4411, 9, 30, 2,
	2, 4400, 4401, 7, 97, 2, 2, 4401, 4402, 7, 218, 2, 2, 4402, 4403, 7, 31,
	2, 2, 4403, 4408, 5, 632, 317, 2, 4404, 4405, 7, 37, 2, 2, 4405, 4407,
	5, 632, 317, 2, 4406, 4404, 3, 2, 2, 2, 4407, 4410, 3, 2, 2, 2, 4408, 4406,
	3, 2, 2, 2, 4408, 4409, 3, 2, 2, 2, 4409, 4412, 3, 2, 2, 2, 4410, 4408,
	3, 2, 2, 2, 4411, 4400, 3, 2, 2, 2, 4411, 4412, 3, 2, 2, 2, 4412, 4414,
	3, 2, 2, 2, 4413, 4346, 3, 2, 2, 2, 4413, 4349, 3, 2, 2, 2, 4413, 4352,
	3, 2, 2, 2, 4413, 4355, 3, 2, 2, 2, 4413, 4358, 3, 2, 2, 2, 4413, 4361,
	3, 2, 2, 2, 4413, 4364, 3, 2, 2, 2, 4413, 4367, 3, 2, 2, 2, 4413, 4376,
	3, 2, 2, 2, 4413, 4379, 3, 2, 2, 2, 4413, 4385, 3, 2, 2, 2, 4413, 4388,
	3, 2, 2, 2, 4413, 4391, 3, 2, 2, 2, 4413, 4394, 3, 2, 2, 2, 4413, 4397,
	3, 2, 2, 2, 4414, 631, 3, 2, 2, 2, 4415, 4418, 5, 156, 79, 2, 4416, 4417,
	7, 102, 2, 2, 4417, 4419, 5, 156, 79, 2, 4418, 4416, 3, 2, 2, 2, 4418,
	4419, 3, 2, 2, 2, 4419, 633, 3, 2, 2, 2, 4420, 4421, 7, 527, 2, 2, 4421,
	4422, 7, 24, 2, 2, 4422, 4427, 9, 32, 2, 2, 4423, 4424, 7, 528, 2, 2, 4424,
	4425, 7, 24, 2, 2, 4425, 4427, 9, 32, 2, 2, 4426, 4420, 3, 2, 2, 2, 4426,
	4423, 3, 2, 2, 2, 4427, 635, 3, 2, 2, 2, 4428, 4429, 7, 379, 2, 2, 4429,
	4430, 7, 24, 2, 2, 4430, 4450, 9, 32, 2, 2, 4431, 4432, 7, 378, 2, 2, 4432,
	4433, 7, 24, 2, 2, 4433, 4450, 9, 32, 2, 2, 4434, 4435, 7, 471, 2, 2, 4435,
	4436, 7, 24, 2, 2, 4436, 4450, 9, 32, 2, 2, 4437, 4438, 7, 400, 2, 2, 4438,
	4439, 7, 24, 2, 2, 4439, 4450, 9, 32, 2, 2, 4440, 4441, 7, 395, 2, 2, 4441,
	4442, 7, 24, 2, 2, 4442, 4450, 9, 32, 2, 2, 4443, 4444, 7, 385, 2, 2, 4444,
	4445, 7, 24, 2, 2, 4445, 4447, 5, 156, 79, 2, 4446, 4448, 7, 250, 2, 2,
	4447, 4446, 3, 2, 2, 2, 4447, 4448, 3, 2, 2, 2, 4448, 4450, 3, 2, 2, 2,
	4449, 4428, 3, 2, 2, 2, 4449, 4431, 3, 2, 2, 2, 4449, 4434, 3, 2, 2, 2,
	4449, 4437, 3, 2, 2, 2, 4449, 4440, 3, 2, 2, 2, 4449, 4443, 3, 2, 2, 2,
	4450, 637, 3, 2, 2, 2, 4451, 4452, 7, 271, 2, 2, 4452, 4453, 7, 24, 2,
	2, 4453, 4462, 5, 156, 79, 2, 4454, 4455, 7, 402, 2, 2, 4455, 4456, 7,
	24, 2, 2, 4456, 4458, 5, 156, 79, 2, 4457, 4459, 7, 250, 2, 2, 4458, 4457,
	3, 2, 2, 2, 4458, 4459, 3, 2, 2, 2, 4459, 4462, 3, 2, 2, 2, 4460, 4462,
	5, 254, 128, 2, 4461, 4451, 3, 2, 2, 2, 4461, 4454, 3, 2, 2, 2, 4461, 4460,
	3, 2, 2, 2, 4462, 639, 3, 2, 2, 2, 4463, 4464, 7, 542, 2, 2, 4464, 4465,
	7, 169, 2, 2, 4465, 4466, 7, 24, 2, 2, 4466, 4518, 5, 112, 57, 2, 4467,
	4468, 7, 242, 2, 2, 4468, 4518, 5, 258, 130, 2, 4469, 4518, 5, 650, 326,
	2, 4470, 4471, 7, 59, 2, 2, 4471, 4476, 5, 648, 325, 2, 4472, 4473, 7,
	37, 2, 2, 4473, 4475, 5, 648, 325, 2, 4474, 4472, 3, 2, 2, 2, 4475, 4478,
	3, 2, 2, 2, 4476, 4474, 3, 2, 2, 2, 4476, 4477, 3, 2, 2, 2, 4477, 4481,
	3, 2, 2, 2, 4478, 4476, 3, 2, 2, 2, 4479, 4480, 7, 77, 2, 2, 4480, 4482,
	5, 688, 345, 2, 4481, 4479, 3, 2, 2, 2, 4481, 4482, 3, 2, 2, 2, 4482, 4518,
	3, 2, 2, 2, 4483, 4484, 7, 542, 2, 2, 4484, 4485, 7, 31, 2, 2, 4485, 4490,
	5, 644, 323, 2, 4486, 4487, 7, 37, 2, 2, 4487, 4489, 5, 644, 323, 2, 4488,
	4486, 3, 2, 2, 2, 4489, 4492, 3, 2, 2, 2, 4490, 4488, 3, 2, 2, 2, 4490,
	4491, 3, 2, 2, 2, 4491, 4493, 3, 2, 2, 2, 4492, 4490, 3, 2, 2, 2, 4493,
	4494, 7, 32, 2, 2, 4494, 4518, 3, 2, 2, 2, 4495, 4496, 7, 542, 2, 2, 4496,
	4497, 7, 625, 2, 2, 4497, 4498, 7, 24, 2, 2, 4498, 4518, 7, 645, 2, 2,
	4499, 4500, 7, 58, 2, 2, 4500, 4501, 7, 627, 2, 2, 4501, 4502, 7, 97, 2,
	2, 4502, 4503, 7, 313, 2, 2, 4503, 4513, 5, 258, 130, 2, 4504, 4505, 7,
	77, 2, 2, 4505, 4510, 5, 642, 322, 2, 4506, 4507, 7, 37, 2, 2, 4507, 4509,
	5, 642, 322, 2, 4508, 4506, 3, 2, 2, 2, 4509, 4512, 3, 2, 2, 2, 4510, 4508,
	3, 2, 2, 2, 4510, 4511, 3, 2, 2, 2, 4511, 4514, 3, 2, 2, 2, 4512, 4510,
	3, 2, 2, 2, 4513, 4504, 3, 2, 2, 2, 4513, 4514, 3, 2, 2, 2, 4514, 4518,
	3, 2, 2, 2, 4515, 4518, 7, 628, 2, 2, 4516, 4518, 7, 626, 2, 2, 4517, 4463,
	3, 2, 2, 2, 4517, 4467, 3, 2, 2, 2, 4517, 4469, 3, 2, 2, 2, 4517, 4470,
	3, 2, 2, 2, 4517, 4483, 3, 2, 2, 2, 4517, 4495, 3, 2, 2, 2, 4517, 4499,
	3, 2, 2, 2, 4517, 4515, 3, 2, 2, 2, 4517, 4516, 3, 2, 2, 2, 4518, 641,
	3, 2, 2, 2, 4519, 4520, 7, 621, 2, 2, 4520, 4521, 7, 24, 2, 2, 4521, 4532,
	9, 60, 2, 2, 4522, 4523, 7, 619, 2, 2, 4523, 4529, 7, 24, 2, 2, 4524, 4530,
	5, 646, 324, 2, 4525, 4526, 7, 620, 2, 2, 4526, 4527, 7, 24, 2, 2, 4527,
	4530, 5, 112, 57, 2, 4528, 4530, 9, 61, 2, 2, 4529, 4524, 3, 2, 2, 2, 4529,
	4525, 3, 2, 2, 2, 4529, 4528, 3, 2, 2, 2, 4530, 4532, 3, 2, 2, 2, 4531,
	4519, 3, 2, 2, 2, 4531, 4522, 3, 2, 2, 2, 4532, 643, 3, 2, 2, 2, 4533,
	4534, 7, 479, 2, 2, 4534, 4535, 7, 24, 2, 2, 4535, 4536, 7, 646, 2, 2,
	4536, 4547, 9, 62, 2, 2, 4537, 4538, 7, 606, 2, 2, 4538, 4539, 7, 24, 2,
	2, 4539, 4547, 7, 645, 2, 2, 4540, 4541, 7, 619, 2, 2, 4541, 4544, 7, 24,
	2, 2, 4542, 4545, 7, 645, 2, 2, 4543, 4545, 5, 646, 324, 2, 4544, 4542,
	3, 2, 2, 2, 4544, 4543, 3, 2, 2, 2, 4545, 4547, 3, 2, 2, 2, 4546, 4533,
	3, 2, 2, 2, 4546, 4537, 3, 2, 2, 2, 4546, 4540, 3, 2, 2, 2, 4547, 645,
	3, 2, 2, 2, 4548, 4557, 7, 645, 2, 2, 4549, 4550, 7, 618, 2, 2, 4550, 4551,
	7, 31, 2, 2, 4551, 4552, 5, 258, 130, 2, 4552, 4553, 7, 24, 2, 2, 4553,
	4554, 7, 645, 2, 2, 4554, 4555, 7, 32, 2, 2, 4555, 4557, 3, 2, 2, 2, 4556,
	4548, 3, 2, 2, 2, 4556, 4549, 3, 2, 2, 2, 4557, 647, 3, 2, 2, 2, 4558,
	4602, 5, 658, 330, 2, 4559, 4602, 5, 660, 331, 2, 4560, 4602, 5, 662, 332,
	2, 4561, 4602, 5, 664, 333, 2, 4562, 4563, 7, 475, 2, 2, 4563, 4564, 7,
	24, 2, 2, 4564, 4602, 9, 50, 2, 2, 4565, 4602, 5, 668, 335, 2, 4566, 4567,
	7, 617, 2, 2, 4567, 4602, 9, 32, 2, 2, 4568, 4569, 7, 346, 2, 2, 4569,
	4602, 9, 63, 2, 2, 4570, 4602, 9, 64, 2, 2, 4571, 4602, 9, 65, 2, 2, 4572,
	4602, 9, 66, 2, 2, 4573, 4574, 7, 638, 2, 2, 4574, 4575, 7, 24, 2, 2, 4575,
	4602, 9, 67, 2, 2, 4576, 4602, 5, 670, 336, 2, 4577, 4578, 7, 258, 2, 2,
	4578, 4579, 7, 31, 2, 2, 4579, 4580, 5, 534, 268, 2, 4580, 4581, 7, 32,
	2, 2, 4581, 4602, 3, 2, 2, 2, 4582, 4583, 7, 52, 2, 2, 4583, 4584, 7, 203,
	2, 2, 4584, 4585, 7, 59, 2, 2, 4585, 4602, 7, 610, 2, 2, 4586, 4587, 7,
	607, 2, 2, 4587, 4602, 9, 32, 2, 2, 4588, 4589, 7, 467, 2, 2, 4589, 4602,
	9, 10, 2, 2, 4590, 4602, 5, 672, 337, 2, 4591, 4602, 5, 678, 340, 2, 4592,
	4602, 5, 684, 343, 2, 4593, 4602, 5, 682, 342, 2, 4594, 4602, 5, 680, 341,
	2, 4595, 4602, 5, 686, 344, 2, 4596, 4602, 5, 688, 345, 2, 4597, 4598,
	7, 605, 2, 2, 4598, 4602, 9, 32, 2, 2, 4599, 4600, 7, 604, 2, 2, 4600,
	4602, 9, 32, 2, 2, 4601, 4558, 3, 2, 2, 2, 4601, 4559, 3, 2, 2, 2, 4601,
	4560, 3, 2, 2, 2, 4601, 4561, 3, 2, 2, 2, 4601, 4562, 3, 2, 2, 2, 4601,
	4565, 3, 2, 2, 2, 4601, 4566, 3, 2, 2, 2, 4601, 4568, 3, 2, 2, 2, 4601,
	4570, 3, 2, 2, 2, 4601, 4571, 3, 2, 2, 2, 4601, 4572, 3, 2, 2, 2, 4601,
	4573, 3, 2, 2, 2, 4601, 4576, 3, 2, 2, 2, 4601, 4577, 3, 2, 2, 2, 4601,
	4582, 3, 2, 2, 2, 4601, 4586, 3, 2, 2, 2, 4601, 4588, 3, 2, 2, 2, 4601,
	4590, 3, 2, 2, 2, 4601, 4591, 3, 2, 2, 2, 4601, 4592, 3, 2, 2, 2, 4601,
	4593, 3, 2, 2, 2, 4601, 4594, 3, 2, 2, 2, 4601, 4595, 3, 2, 2, 2, 4601,
	4596, 3, 2, 2, 2, 4601, 4597, 3, 2, 2, 2, 4601, 4599, 3, 2, 2, 2, 4602,
	649, 3, 2, 2, 2, 4603, 4608, 5, 656, 329, 2, 4604, 4608, 5, 536, 269, 2,
	4605, 4608, 5, 652, 327, 2, 4606, 4608, 5, 654, 328, 2, 4607, 4603, 3,
	2, 2, 2, 4607, 4604, 3, 2, 2, 2, 4607, 4605, 3, 2, 2, 2, 4607, 4606, 3,
	2, 2, 2, 4608, 651, 3, 2, 2, 2, 4609, 4610, 7, 58, 2, 2, 4610, 4611, 7,
	488, 2, 2, 4611, 4616, 5, 258, 130, 2, 4612, 4613, 7, 486, 2, 2, 4613,
	4617, 7, 258, 2, 2, 4614, 4615, 7, 486, 2, 2, 4615, 4617, 7, 487, 2, 2,
	4616, 4612, 3, 2, 2, 2, 4616, 4614, 3, 2, 2, 2, 4616, 4617, 3, 2, 2, 2,
	4617, 4632, 3, 2, 2, 2, 4618, 4619, 7, 537, 2, 2, 4619, 4620, 7, 488, 2,
	2, 4620, 4632, 5, 258, 130, 2, 4621, 4622, 7, 542, 2, 2, 4622, 4623, 7,
	488, 2, 2, 4623, 4624, 5, 258, 130, 2, 4624, 4625, 5, 654, 328, 2, 4625,
	4632, 3, 2, 2, 2, 4626, 4632, 7, 153, 2, 2, 4627, 4628, 7, 169, 2, 2, 4628,
	4629, 7, 24, 2, 2, 4629, 4632, 5, 258, 130, 2, 4630, 4632, 9, 68, 2, 2,
	4631, 4609, 3, 2, 2, 2, 4631, 4618, 3, 2, 2, 2, 4631, 4621, 3, 2, 2, 2,
	4631, 4626, 3, 2, 2, 2, 4631, 4627, 3, 2, 2, 2, 4631, 4630, 3, 2, 2, 2,
	4632, 653, 3, 2, 2, 2, 4633, 4636, 9, 69, 2, 2, 4634, 4636, 9, 65, 2, 2,
	4635, 4633, 3, 2, 2, 2, 4635, 4634, 3, 2, 2, 2, 4636, 655, 3, 2, 2, 2,
	4637, 4638, 7, 58, 2, 2, 4638, 4639, 7, 350, 2, 2, 4639, 4644, 5, 536,
	269, 2, 4640, 4641, 7, 37, 2, 2, 4641, 4643, 5, 536, 269, 2, 4642, 4640,
	3, 2, 2, 2, 4643, 4646, 3, 2, 2, 2, 4644, 4642, 3, 2, 2, 2, 4644, 4645,
	3, 2, 2, 2, 4645, 4650, 3, 2, 2, 2, 4646, 4644, 3, 2, 2, 2, 4647, 4648,
	7, 102, 2, 2, 4648, 4649, 7, 488, 2, 2, 4649, 4651, 5, 258, 130, 2, 4650,
	4647, 3, 2, 2, 2, 4650, 4651, 3, 2, 2, 2, 4651, 4670, 3, 2, 2, 2, 4652,
	4653, 7, 58, 2, 2, 4653, 4654, 7, 370, 2, 2, 4654, 4655, 7, 350, 2, 2,
	4655, 4660, 5, 536, 269, 2, 4656, 4657, 7, 37, 2, 2, 4657, 4659, 5, 536,
	269, 2, 4658, 4656, 3, 2, 2, 2, 4659, 4662, 3, 2, 2, 2, 4660, 4658, 3,
	2, 2, 2, 4660, 4661, 3, 2, 2, 2, 4661, 4670, 3, 2, 2, 2, 4662, 4660, 3,
	2, 2, 2, 4663, 4664, 7, 537, 2, 2, 4664, 4665, 7, 350, 2, 2, 4665, 4670,
	7, 645, 2, 2, 4666, 4667, 7, 542, 2, 2, 4667, 4668, 7, 350, 2, 2, 4668,
	4670, 5, 536, 269, 2, 4669, 4637, 3, 2, 2, 2, 4669, 4652, 3, 2, 2, 2, 4669,
	4663, 3, 2, 2, 2, 4669, 4666, 3, 2, 2, 2, 4670, 657, 3, 2, 2, 2, 4671,
	4672, 7, 543, 2, 2, 4672, 4673, 7, 24, 2, 2, 4673, 4680, 9, 32, 2, 2, 4674,
	4675, 7, 31, 2, 2, 4675, 4676, 7, 544, 2, 2, 4676, 4677, 7, 24, 2, 2, 4677,
	4678, 5, 258, 130, 2, 4678, 4679, 7, 32, 2, 2, 4679, 4681, 3, 2, 2, 2,
	4680, 4674, 3, 2, 2, 2, 4680, 4681, 3, 2, 2, 2, 4681, 659, 3, 2, 2, 2,
	4682, 4683, 7, 603, 2, 2, 4683, 4703, 9, 32, 2, 2, 4684, 4694, 7, 601,
	2, 2, 4685, 4695, 7, 276, 2, 2, 4686, 4692, 7, 97, 2, 2, 4687, 4688, 7,
	31, 2, 2, 4688, 4689, 7, 602, 2, 2, 4689, 4690, 7, 24, 2, 2, 4690, 4691,
	9, 32, 2, 2, 4691, 4693, 7, 32, 2, 2, 4692, 4687, 3, 2, 2, 2, 4692, 4693,
	3, 2, 2, 2, 4693, 4695, 3, 2, 2, 2, 4694, 4685, 3, 2, 2, 2, 4694, 4686,
	3, 2, 2, 2, 4695, 4703, 3, 2, 2, 2, 4696, 4697, 7, 600, 2, 2, 4697, 4703,
	9, 32, 2, 2, 4698, 4699, 7, 599, 2, 2, 4699, 4703, 9, 32, 2, 2, 4700, 4701,
	7, 598, 2, 2, 4701, 4703, 9, 32, 2, 2, 4702, 4682, 3, 2, 2, 2, 4702, 4684,
	3, 2, 2, 2, 4702, 4696, 3, 2, 2, 2, 4702, 4698, 3, 2, 2, 2, 4702, 4700,
	3, 2, 2, 2, 4703, 661, 3, 2, 2, 2, 4704, 4705, 7, 596, 2, 2, 4705, 4706,
	7, 31, 2, 2, 4706, 4707, 7, 597, 2, 2, 4707, 4708, 7, 24, 2, 2, 4708, 4709,
	9, 32, 2, 2, 4709, 4710, 7, 32, 2, 2, 4710, 663, 3, 2, 2, 2, 4711, 4731,
	7, 595, 2, 2, 4712, 4713, 7, 24, 2, 2, 4713, 4732, 7, 276, 2, 2, 4714,
	4715, 7, 24, 2, 2, 4715, 4717, 7, 97, 2, 2, 4716, 4714, 3, 2, 2, 2, 4716,
	4717, 3, 2, 2, 2, 4717, 4729, 3, 2, 2, 2, 4718, 4719, 7, 31, 2, 2, 4719,
	4724, 5, 666, 334, 2, 4720, 4721, 7, 37, 2, 2, 4721, 4723, 5, 666, 334,
	2, 4722, 4720, 3, 2, 2, 2, 4723, 4726, 3, 2, 2, 2, 4724, 4722, 3, 2, 2,
	2, 4724, 4725, 3, 2, 2, 2, 4725, 4727, 3, 2, 2, 2, 4726, 4724, 3, 2, 2,
	2, 4727, 4728, 7, 32, 2, 2, 4728, 4730, 3, 2, 2, 2, 4729, 4718, 3, 2, 2,
	2, 4729, 4730, 3, 2, 2, 2, 4730, 4732, 3, 2, 2, 2, 4731, 4712, 3, 2, 2,
	2, 4731, 4716, 3, 2, 2, 2, 4732, 665, 3, 2, 2, 2, 4733, 4734, 7, 594, 2,
	2, 4734, 4735, 7, 24, 2, 2, 4735, 4741, 9, 32, 2, 2, 4736, 4737, 7, 593,
	2, 2, 4737, 4738, 7, 24, 2, 2, 4738, 4739, 7, 646, 2, 2, 4739, 4741, 9,
	70, 2, 2, 4740, 4733, 3, 2, 2, 2, 4740, 4736, 3, 2, 2, 2, 4741, 667, 3,
	2, 2, 2, 4742, 4743, 7, 591, 2, 2, 4743, 4747, 9, 32, 2, 2, 4744, 4745,
	7, 589, 2, 2, 4745, 4747, 9, 71, 2, 2, 4746, 4742, 3, 2, 2, 2, 4746, 4744,
	3, 2, 2, 2, 4747, 669, 3, 2, 2, 2, 4748, 4749, 7, 490, 2, 2, 4749, 4768,
	9, 32, 2, 2, 4750, 4751, 7, 491, 2, 2, 4751, 4768, 9, 32, 2, 2, 4752, 4753,
	7, 629, 2, 2, 4753, 4754, 7, 24, 2, 2, 4754, 4768, 7, 645, 2, 2, 4755,
	4756, 7, 630, 2, 2, 4756, 4757, 7, 24, 2, 2, 4757, 4768, 7, 645, 2, 2,
	4758, 4759, 7, 632, 2, 2, 4759, 4760, 7, 24, 2, 2, 4760, 4768, 9, 32, 2,
	2, 4761, 4762, 7, 633, 2, 2, 4762, 4763, 7, 24, 2, 2, 4763, 4768, 9, 32,
	2, 2, 4764, 4765, 7, 634, 2, 2, 4765, 4766, 7, 24, 2, 2, 4766, 4768, 7,
	646, 2, 2, 4767, 4748, 3, 2, 2, 2, 4767, 4750, 3, 2, 2, 2, 4767, 4752,
	3, 2, 2, 2, 4767, 4755, 3, 2, 2, 2, 4767, 4758, 3, 2, 2, 2, 4767, 4761,
	3, 2, 2, 2, 4767, 4764, 3, 2, 2, 2, 4768, 671, 3, 2, 2, 2, 4769, 4789,
	7, 588, 2, 2, 4770, 4771, 7, 24, 2, 2, 4771, 4790, 7, 276, 2, 2, 4772,
	4773, 7, 24, 2, 2, 4773, 4775, 7, 97, 2, 2, 4774, 4772, 3, 2, 2, 2, 4774,
	4775, 3, 2, 2, 2, 4775, 4787, 3, 2, 2, 2, 4776, 4777, 7, 31, 2, 2, 4777,
	4782, 5, 674, 338, 2, 4778, 4779, 7, 37, 2, 2, 4779, 4781, 5, 674, 338,
	2, 4780, 4778, 3, 2, 2, 2, 4781, 4784, 3, 2, 2, 2, 4782, 4780, 3, 2, 2,
	2, 4782, 4783, 3, 2, 2, 2, 4783, 4785, 3, 2, 2, 2, 4784, 4782, 3, 2, 2,
	2, 4785, 4786, 7, 32, 2, 2, 4786, 4788, 3, 2, 2, 2, 4787, 4776, 3, 2, 2,
	2, 4787, 4788, 3, 2, 2, 2, 4788, 4790, 3, 2, 2, 2, 4789, 4770, 3, 2, 2,
	2, 4789, 4774, 3, 2, 2, 2, 4790, 673, 3, 2, 2, 2, 4791, 4792, 7, 587, 2,
	2, 4792, 4793, 7, 24, 2, 2, 4793, 4836, 9, 65, 2, 2, 4794, 4795, 7, 584,
	2, 2, 4795, 4796, 7, 24, 2, 2, 4796, 4797, 7, 31, 2, 2, 4797, 4798, 7,
	586, 2, 2, 4798, 4799, 7, 24, 2, 2, 4799, 4800, 7, 646, 2, 2, 4800, 4836,
	7, 32, 2, 2, 4801, 4802, 7, 583, 2, 2, 4802, 4803, 7, 24, 2, 2, 4803, 4836,
	7, 646, 2, 2, 4804, 4805, 7, 582, 2, 2, 4805, 4806, 7, 24, 2, 2, 4806,
	4836, 7, 646, 2, 2, 4807, 4808, 7, 581, 2, 2, 4808, 4809, 7, 24, 2, 2,
	4809, 4836, 7, 646, 2, 2, 4810, 4811, 7, 580, 2, 2, 4811, 4812, 7, 24,
	2, 2, 4812, 4836, 9, 72, 2, 2, 4813, 4814, 7, 579, 2, 2, 4814, 4815, 7,
	24, 2, 2, 4815, 4836, 9, 73, 2, 2, 4816, 4817, 7, 578, 2, 2, 4817, 4818,
	7, 24, 2, 2, 4818, 4836, 7, 646, 2, 2, 4819, 4820, 7, 577, 2, 2, 4820,
	4821, 7, 24, 2, 2, 4821, 4836, 9, 32, 2, 2, 4822, 4823, 7, 576, 2, 2, 4823,
	4824, 7, 24, 2, 2, 4824, 4825, 7, 31, 2, 2, 4825, 4830, 5, 676, 339, 2,
	4826, 4827, 7, 37, 2, 2, 4827, 4829, 5, 676, 339, 2, 4828, 4826, 3, 2,
	2, 2, 4829, 4832, 3, 2, 2, 2, 4830, 4828, 3, 2, 2, 2, 4830, 4831, 3, 2,
	2, 2, 4831, 4833, 3, 2, 2, 2, 4832, 4830, 3, 2, 2, 2, 4833, 4834, 7, 32,
	2, 2, 4834, 4836, 3, 2, 2, 2, 4835, 4791, 3, 2, 2, 2, 4835, 4794, 3, 2,
	2, 2, 4835, 4801, 3, 2, 2, 2, 4835, 4804, 3, 2, 2, 2, 4835, 4807, 3, 2,
	2, 2, 4835, 4810, 3, 2, 2, 2, 4835, 4813, 3, 2, 2, 2, 4835, 4816, 3, 2,
	2, 2, 4835, 4819, 3, 2, 2, 2, 4835, 4822, 3, 2, 2, 2, 4836, 675, 3, 2,
	2, 2, 4837, 4838, 7, 574, 2, 2, 4838, 4839, 7, 24, 2, 2, 4839, 4840, 7,
	646, 2, 2, 4840, 4851, 9, 74, 2, 2, 4841, 4842, 7, 575, 2, 2, 4842, 4843,
	7, 24, 2, 2, 4843, 4851, 7, 646, 2, 2, 4844, 4845, 7, 573, 2, 2, 4845,
	4846, 7, 24, 2, 2, 4846, 4851, 7, 646, 2, 2, 4847, 4848, 7, 572, 2, 2,
	4848, 4849, 7, 24, 2, 2, 4849, 4851, 7, 646, 2, 2, 4850, 4837, 3, 2, 2,
	2, 4850, 4841, 3, 2, 2, 2, 4850, 4844, 3, 2, 2, 2, 4850, 4847, 3, 2, 2,
	2, 4851, 677, 3, 2, 2, 2, 4852, 4853, 7, 571, 2, 2, 4853, 4859, 9, 75,
	2, 2, 4854, 4855, 7, 569, 2, 2, 4855, 4859, 9, 32, 2, 2, 4856, 4857, 7,
	567, 2, 2, 4857, 4859, 9, 76, 2, 2, 4858, 4852, 3, 2, 2, 2, 4858, 4854,
	3, 2, 2, 2, 4858, 4856, 3, 2, 2, 2, 4859, 679, 3, 2, 2, 2, 4860, 4861,
	7, 566, 2, 2, 4861, 4882, 9, 32, 2, 2, 4862, 4863, 7, 565, 2, 2, 4863,
	4882, 9, 32, 2, 2, 4864, 4865, 7, 564, 2, 2, 4865, 4882, 9, 32, 2, 2, 4866,
	4867, 7, 563, 2, 2, 4867, 4882, 9, 32, 2, 2, 4868, 4869, 7, 562, 2, 2,
	4869, 4882, 9, 32, 2, 2, 4870, 4871, 7, 561, 2, 2, 4871, 4872, 7, 24, 2,
	2, 4872, 4882, 7, 646, 2, 2, 4873, 4874, 7, 560, 2, 2, 4874, 4882, 9, 32,
	2, 2, 4875, 4876, 7, 559, 2, 2, 4876, 4882, 9, 32, 2, 2, 4877, 4878, 7,
	558, 2, 2, 4878, 4882, 9, 32, 2, 2, 4879, 4880, 7, 557, 2, 2, 4880, 4882,
	9, 32, 2, 2, 4881, 4860, 3, 2, 2, 2, 4881, 4862, 3, 2, 2, 2, 4881, 4864,
	3, 2, 2, 2, 4881, 4866, 3, 2, 2, 2, 4881, 4868, 3, 2, 2, 2, 4881, 4870,
	3, 2, 2, 2, 4881, 4873, 3, 2, 2, 2, 4881, 4875, 3, 2, 2, 2, 4881, 4877,
	3, 2, 2, 2, 4881, 4879, 3, 2, 2, 2, 4882, 681, 3, 2, 2, 2, 4883, 4884,
	7, 556, 2, 2, 4884, 4891, 9, 32, 2, 2, 4885, 4886, 7, 555, 2, 2, 4886,
	4891, 9, 32, 2, 2, 4887, 4888, 7, 554, 2, 2, 4888, 4889, 7, 24, 2, 2, 4889,
	4891, 9, 32, 2, 2, 4890, 4883, 3, 2, 2, 2, 4890, 4885, 3, 2, 2, 2, 4890,
	4887, 3, 2, 2, 2, 4891, 683, 3, 2, 2, 2, 4892, 4899, 7, 553, 2, 2, 4893,
	4899, 7, 552, 2, 2, 4894, 4899, 7, 551, 2, 2, 4895, 4899, 7, 550, 2, 2,
	4896, 4897, 7, 549, 2, 2, 4897, 4899, 9, 32, 2, 2, 4898, 4892, 3, 2, 2,
	2, 4898, 4893, 3, 2, 2, 2, 4898, 4894, 3, 2, 2, 2, 4898, 4895, 3, 2, 2,
	2, 4898, 4896, 3, 2, 2, 2, 4899, 685, 3, 2, 2, 2, 4900, 4901, 7, 547, 2,
	2, 4901, 4902, 7, 24, 2, 2, 4902, 4903, 7, 646, 2, 2, 4903, 4904, 9, 77,
	2, 2, 4904, 687, 3, 2, 2, 2, 4905, 4906, 7, 126, 2, 2, 4906, 4907, 7, 518,
	2, 2, 4907, 4909, 7, 646, 2, 2, 4908, 4910, 7, 548, 2, 2, 4909, 4908, 3,
	2, 2, 2, 4909, 4910, 3, 2, 2, 2, 4910, 4915, 3, 2, 2, 2, 4911, 4912, 7,
	126, 2, 2, 4912, 4915, 7, 545, 2, 2, 4913, 4915, 7, 546, 2, 2, 4914, 4905,
	3, 2, 2, 2, 4914, 4911, 3, 2, 2, 2, 4914, 4913, 3, 2, 2, 2, 4915, 689,
	3, 2, 2, 2, 4916, 4917, 7, 31, 2, 2, 4917, 4922, 5, 130, 66, 2, 4918, 4919,
	7, 37, 2, 2, 4919, 4921, 5, 130, 66, 2, 4920, 4918, 3, 2, 2, 2, 4921, 4924,
	3, 2, 2, 2, 4922, 4920, 3, 2, 2, 2, 4922, 4923, 3, 2, 2, 2, 4923, 4925,
	3, 2, 2, 2, 4924, 4922, 3, 2, 2, 2, 4925, 4926, 7, 32, 2, 2, 4926, 691,
	3, 2, 2, 2, 4927, 4928, 7, 31, 2, 2, 4928, 4933, 5, 694, 348, 2, 4929,
	4930, 7, 37, 2, 2, 4930, 4932, 5, 694, 348, 2, 4931, 4929, 3, 2, 2, 2,
	4932, 4935, 3, 2, 2, 2, 4933, 4931, 3, 2, 2, 2, 4933, 4934, 3, 2, 2, 2,
	4934, 4936, 3, 2, 2, 2, 4935, 4933, 3, 2, 2, 2, 4936, 4937, 7, 32, 2, 2,
	4937, 693, 3, 2, 2, 2, 4938, 4939, 7, 58, 2, 2, 4939, 4940, 7, 345, 2,
	2, 4940, 4945, 5, 130, 66, 2, 4941, 4942, 7, 53, 2, 2, 4942, 4943, 7, 345,
	2, 2, 4943, 4945, 5, 130, 66, 2, 4944, 4938, 3, 2, 2, 2, 4944, 4941, 3,
	2, 2, 2, 4945, 695, 3, 2, 2, 2, 4946, 4954, 5, 114, 58, 2, 4947, 4948,
	7, 639, 2, 2, 4948, 4954, 5, 258, 130, 2, 4949, 4950, 5, 114, 58, 2, 4950,
	4951, 7, 639, 2, 2, 4951, 4952, 5, 258, 130, 2, 4952, 4954, 3, 2, 2, 2,
	4953, 4946, 3, 2, 2, 2, 4953, 4947, 3, 2, 2, 2, 4953, 4949, 3, 2, 2, 2,
	4954, 697, 3, 2, 2, 2, 4955, 4961, 5, 278, 140, 2, 4956, 4961, 5, 290,
	146, 2, 4957, 4961, 5, 710, 356, 2, 4958, 4961, 5, 712, 357, 2, 4959, 4961,
	5, 714, 358, 2, 4960, 4955, 3, 2, 2, 2, 4960, 4956, 3, 2, 2, 2, 4960, 4957,
	3, 2, 2, 2, 4960, 4958, 3, 2, 2, 2, 4960, 4959, 3, 2, 2, 2, 4961, 699,
	3, 2, 2, 2, 4962, 4965, 5, 702, 352, 2, 4963, 4965, 5, 704, 353, 2, 4964,
	4962, 3, 2, 2, 2, 4964, 4963, 3, 2, 2, 2, 4965, 701, 3, 2, 2, 2, 4966,
	4967, 7, 51, 2, 2, 4967, 4968, 7, 60, 2, 2, 4968, 4970, 5, 126, 64, 2,
	4969, 4971, 5, 140, 71, 2, 4970, 4969, 3, 2, 2, 2, 4970, 4971, 3, 2, 2,
	2, 4971, 4972, 3, 2, 2, 2, 4972, 4973, 5, 706, 354, 2, 4973, 4974, 7, 96,
	2, 2, 4974, 4975, 5, 30, 16, 2, 4975, 4976, 5, 708, 355, 2, 4976, 703,
	3, 2, 2, 2, 4977, 4978, 7, 51, 2, 2, 4978, 4979, 7, 357, 2, 2, 4979, 4980,
	7, 60, 2, 2, 4980, 4981, 5, 126, 64, 2, 4981, 4982, 7, 211, 2, 2, 4982,
	4983, 7, 31, 2, 2, 4983, 4984, 5, 94, 48, 2, 4984, 4991, 7, 32, 2, 2, 4985,
	4986, 7, 77, 2, 2, 4986, 4987, 7, 31, 2, 2, 4987, 4988, 7, 643, 2, 2, 4988,
	4989, 7, 24, 2, 2, 4989, 4990, 7, 647, 2, 2, 4990, 4992, 7, 32, 2, 2, 4991,
	4985, 3, 2, 2, 2, 4991, 4992, 3, 2, 2, 2, 4992, 4993, 3, 2, 2, 2, 4993,
	4994, 7, 96, 2, 2, 4994, 4995, 5, 30, 16, 2, 4995, 705, 3, 2, 2, 2, 4996,
	4997, 7, 77, 2, 2, 4997, 4998, 7, 31, 2, 2, 4998, 5008, 5, 448, 225, 2,
	4999, 5000, 7, 37, 2, 2, 5000, 5005, 5, 436, 219, 2, 5001, 5002, 7, 37,
	2, 2, 5002, 5004, 5, 436, 219, 2, 5003, 5001, 3, 2, 2, 2, 5004, 5007, 3,
	2, 2, 2, 5005, 5003, 3, 2, 2, 2, 5005, 5006, 3, 2, 2, 2, 5006, 5009, 3,
	2, 2, 2, 5007, 5005, 3, 2, 2, 2, 5008, 4999, 3, 2, 2, 2, 5008, 5009, 3,
	2, 2, 2, 5009, 5010, 3, 2, 2, 2, 5010, 5011, 7, 32, 2, 2, 5011, 707, 3,
	2, 2, 2, 5012, 5013, 7, 229, 2, 2, 5013, 5014, 7, 31, 2, 2, 5014, 5019,
	5, 86, 44, 2, 5015, 5016, 7, 37, 2, 2, 5016, 5018, 5, 86, 44, 2, 5017,
	5015, 3, 2, 2, 2, 5018, 5021, 3, 2, 2, 2, 5019, 5017, 3, 2, 2, 2, 5019,
	5020, 3, 2, 2, 2, 5020, 5022, 3, 2, 2, 2, 5021, 5019, 3, 2, 2, 2, 5022,
	5023, 7, 32, 2, 2, 5023, 5025, 3, 2, 2, 2, 5024, 5012, 3, 2, 2, 2, 5024,
	5025, 3, 2, 2, 2, 5025, 709, 3, 2, 2, 2, 5026, 5030, 7, 56, 2, 2, 5027,
	5031, 5, 716, 359, 2, 5028, 5031, 5, 718, 360, 2, 5029, 5031, 5, 766, 384,
	2, 5030, 5027, 3, 2, 2, 2, 5030, 5028, 3, 2, 2, 2, 5030, 5029, 3, 2, 2,
	2, 5031, 711, 3, 2, 2, 2, 5032, 5039, 7, 57, 2, 2, 5033, 5035, 5, 720,
	361, 2, 5034, 5033, 3, 2, 2, 2, 5034, 5035, 3, 2, 2, 2, 5035, 5036, 3,
	2, 2, 2, 5036, 5040, 5, 716, 359, 2, 5037, 5040, 5, 718, 360, 2, 5038,
	5040, 5, 766, 384, 2, 5039, 5034, 3, 2, 2, 2, 5039, 5037, 3, 2, 2, 2, 5039,
	5038, 3, 2, 2, 2, 5040, 713, 3, 2, 2, 2, 5041, 5044, 7, 251, 2, 2, 5042,
	5045, 5, 716, 359, 2, 5043, 5045, 5, 718, 360, 2, 5044, 5042, 3, 2, 2,
	2, 5044, 5043, 3, 2, 2, 2, 5045, 715, 3, 2, 2, 2, 5046, 5049, 5, 722, 362,
	2, 5047, 5048, 7, 97, 2, 2, 5048, 5050, 5, 724, 363, 2, 5049, 5047, 3,
	2, 2, 2, 5049, 5050, 3, 2, 2, 2, 5050, 717, 3, 2, 2, 2, 5051, 5054, 5,
	726, 364, 2, 5052, 5053, 7, 97, 2, 2, 5053, 5055, 5, 728, 365, 2, 5054,
	5052, 3, 2, 2, 2, 5054, 5055, 3, 2, 2, 2, 5055, 719, 3, 2, 2, 2, 5056,
	5057, 7, 56, 2, 2, 5057, 5058, 7, 229, 2, 2, 5058, 5059, 7, 101, 2, 2,
	5059, 721, 3, 2, 2, 2, 5060, 5062, 5, 730, 366, 2, 5061, 5063, 5, 140,
	71, 2, 5062, 5061, 3, 2, 2, 2, 5062, 5063, 3, 2, 2, 2, 5063, 5071, 3, 2,
	2, 2, 5064, 5065, 7, 37, 2, 2, 5065, 5067, 5, 730, 366, 2, 5066, 5068,
	5, 140, 71, 2, 5067, 5066, 3, 2, 2, 2, 5067, 5068, 3, 2, 2, 2, 5068, 5070,
	3, 2, 2, 2, 5069, 5064, 3, 2, 2, 2, 5070, 5073, 3, 2, 2, 2, 5071, 5069,
	3, 2, 2, 2, 5071, 5072, 3, 2, 2, 2, 5072, 723, 3, 2, 2, 2, 5073, 5071,
	3, 2, 2, 2, 5074, 5076, 5, 762, 382, 2, 5075, 5074, 3, 2, 2, 2, 5075, 5076,
	3, 2, 2, 2, 5076, 5077, 3, 2, 2, 2, 5077, 5078, 5, 126, 64, 2, 5078, 725,
	3, 2, 2, 2, 5079, 5084, 5, 730, 366, 2, 5080, 5081, 7, 37, 2, 2, 5081,
	5083, 5, 730, 366, 2, 5082, 5080, 3, 2, 2, 2, 5083, 5086, 3, 2, 2, 2, 5084,
	5082, 3, 2, 2, 2, 5084, 5085, 3, 2, 2, 2, 5085, 727, 3, 2, 2, 2, 5086,
	5084, 3, 2, 2, 2, 5087, 5089, 5, 764, 383, 2, 5088, 5087, 3, 2, 2, 2, 5088,
	5089, 3, 2, 2, 2, 5089, 5090, 3, 2, 2, 2, 5090, 5091, 5, 126, 64, 2, 5091,
	729, 3, 2, 2, 2, 5092, 5094, 7, 113, 2, 2, 5093, 5095, 7, 230, 2, 2, 5094,
	5093, 3, 2, 2, 2, 5094, 5095, 3, 2, 2, 2, 5095, 5112, 3, 2, 2, 2, 5096,
	5112, 5, 732, 367, 2, 5097, 5112, 5, 734, 368, 2, 5098, 5112, 5, 736, 369,
	2, 5099, 5112, 5, 738, 370, 2, 5100, 5112, 5, 740, 371, 2, 5101, 5112,
	5, 742, 372, 2, 5102, 5112, 5, 744, 373, 2, 5103, 5112, 5, 746, 374, 2,
	5104, 5112, 5, 748, 375, 2, 5105, 5112, 5, 750, 376, 2, 5106, 5112, 5,
	752, 377, 2, 5107, 5112, 5, 754, 378, 2, 5108, 5112, 5, 756, 379, 2, 5109,
	5112, 5, 758, 380, 2, 5110, 5112, 5, 760, 381, 2, 5111, 5092, 3, 2, 2,
	2, 5111, 5096, 3, 2, 2, 2, 5111, 5097, 3, 2, 2, 2, 5111, 5098, 3, 2, 2,
	2, 5111, 5099, 3, 2, 2, 2, 5111, 5100, 3, 2, 2, 2, 5111, 5101, 3, 2, 2,
	2, 5111, 5102, 3, 2, 2, 2, 5111, 5103, 3, 2, 2, 2, 5111, 5104, 3, 2, 2,
	2, 5111, 5105, 3, 2, 2, 2, 5111, 5106, 3, 2, 2, 2, 5111, 5107, 3, 2, 2,
	2, 5111, 5108, 3, 2, 2, 2, 5111, 5109, 3, 2, 2, 2, 5111, 5110, 3, 2, 2,
	2, 5112, 731, 3, 2, 2, 2, 5113, 5115, 7, 304, 2, 2, 5114, 5116, 7, 313,
	2, 2, 5115, 5114, 3, 2, 2, 2, 5115, 5116, 3, 2, 2, 2, 5116, 5133, 3, 2,
	2, 2, 5117, 5118, 7, 306, 2, 2, 5118, 5133, 7, 307, 2, 2, 5119, 5133, 7,
	52, 2, 2, 5120, 5122, 7, 74, 2, 2, 5121, 5123, 7, 114, 2, 2, 5122, 5121,
	3, 2, 2, 2, 5122, 5123, 3, 2, 2, 2, 5123, 5124, 3, 2, 2, 2, 5124, 5133,
	7, 308, 2, 2, 5125, 5133, 7, 231, 2, 2, 5126, 5133, 7, 47, 2, 2, 5127,
	5133, 7, 48, 2, 2, 5128, 5133, 7, 49, 2, 2, 5129, 5133, 7, 50, 2, 2, 5130,
	5133, 7, 298, 2, 2, 5131, 5133, 7, 314, 2, 2, 5132, 5113, 3, 2, 2, 2, 5132,
	5117, 3, 2, 2, 2, 5132, 5119, 3, 2, 2, 2, 5132, 5120, 3, 2, 2, 2, 5132,
	5125, 3, 2, 2, 2, 5132, 5126, 3, 2, 2, 2, 5132, 5127, 3, 2, 2, 2, 5132,
	5128, 3, 2, 2, 2, 5132, 5129, 3, 2, 2, 2, 5132, 5130, 3, 2, 2, 2, 5132,
	5131, 3, 2, 2, 2, 5133, 733, 3, 2, 2, 2, 5134, 5135, 7, 74, 2, 2, 5135,
	5136, 7, 315, 2, 2, 5136, 5137, 7, 317, 2, 2, 5137, 735, 3, 2, 2, 2, 5138,
	5144, 7, 52, 2, 2, 5139, 5145, 7, 318, 2, 2, 5140, 5145, 7, 319, 2, 2,
	5141, 5145, 7, 316, 2, 2, 5142, 5143, 7, 313, 2, 2, 5143, 5145, 7, 320,
	2, 2, 5144, 5139, 3, 2, 2, 2, 5144, 5140, 3, 2, 2, 2, 5144, 5141, 3, 2,
	2, 2, 5144, 5142, 3, 2, 2, 2, 5145, 5214, 3, 2, 2, 2, 5146, 5147, 7, 52,
	2, 2, 5147, 5165, 7, 114, 2, 2, 5148, 5149, 7, 321, 2, 2, 5149, 5166, 7,
	117, 2, 2, 5150, 5166, 7, 302, 2, 2, 5151, 5166, 7, 322, 2, 2, 5152, 5166,
	7, 203, 2, 2, 5153, 5166, 7, 323, 2, 2, 5154, 5155, 7, 324, 2, 2, 5155,
	5166, 7, 325, 2, 2, 5156, 5157, 7, 324, 2, 2, 5157, 5166, 7, 300, 2, 2,
	5158, 5159, 7, 326, 2, 2, 5159, 5166, 7, 313, 2, 2, 5160, 5166, 7, 269,
	2, 2, 5161, 5162, 7, 313, 2, 2, 5162, 5166, 7, 327, 2, 2, 5163, 5164, 7,
	313, 2, 2, 5164, 5166, 7, 233, 2, 2, 5165, 5148, 3, 2, 2, 2, 5165, 5150,
	3, 2, 2, 2, 5165, 5151, 3, 2, 2, 2, 5165, 5152, 3, 2, 2, 2, 5165, 5153,
	3, 2, 2, 2, 5165, 5154, 3, 2, 2, 2, 5165, 5156, 3, 2, 2, 2, 5165, 5158,
	3, 2, 2, 2, 5165, 5160, 3, 2, 2, 2, 5165, 5161, 3, 2, 2, 2, 5165, 5163,
	3, 2, 2, 2, 5166, 5214, 3, 2, 2, 2, 5167, 5179, 7, 51, 2, 2, 5168, 5169,
	7, 321, 2, 2, 5169, 5180, 7, 117, 2, 2, 5170, 5171, 7, 328, 2, 2, 5171,
	5172, 7, 324, 2, 2, 5172, 5180, 7, 325, 2, 2, 5173, 5180, 7, 323, 2, 2,
	5174, 5175, 7, 313, 2, 2, 5175, 5180, 7, 233, 2, 2, 5176, 5177, 7, 316,
	2, 2, 5177, 5178, 7, 324, 2, 2, 5178, 5180, 7, 325, 2, 2, 5179, 5168, 3,
	2, 2, 2, 5179, 5170, 3, 2, 2, 2, 5179, 5173, 3, 2, 2, 2, 5179, 5174, 3,
	2, 2, 2, 5179, 5176, 3, 2, 2, 2, 5180, 5214, 3, 2, 2, 2, 5181, 5182, 7,
	51, 2, 2, 5182, 5183, 7, 114, 2, 2, 5183, 5214, 7, 203, 2, 2, 5184, 5185,
	7, 74, 2, 2, 5185, 5186, 7, 313, 2, 2, 5186, 5214, 7, 320, 2, 2, 5187,
	5188, 7, 74, 2, 2, 5188, 5189, 7, 114, 2, 2, 5189, 5214, 9, 78, 2, 2, 5190,
	5191, 7, 301, 2, 2, 5191, 5192, 7, 114, 2, 2, 5192, 5214, 7, 203, 2, 2,
	5193, 5194, 7, 301, 2, 2, 5194, 5214, 7, 163, 2, 2, 5195, 5196, 7, 330,
	2, 2, 5196, 5197, 7, 114, 2, 2, 5197, 5214, 7, 269, 2, 2, 5198, 5199, 7,
	47, 2, 2, 5199, 5200, 7, 113, 2, 2, 5200, 5201, 7, 232, 2, 2, 5201, 5214,
	7, 331, 2, 2, 5202, 5203, 7, 332, 2, 2, 5203, 5214, 7, 313, 2, 2, 5204,
	5205, 7, 333, 2, 2, 5205, 5206, 7, 334, 2, 2, 5206, 5214, 7, 310, 2, 2,
	5207, 5208, 7, 335, 2, 2, 5208, 5209, 7, 336, 2, 2, 5209, 5214, 7, 337,
	2, 2, 5210, 5211, 7, 338, 2, 2, 5211, 5214, 7, 310, 2, 2, 5212, 5214, 7,
	339, 2, 2, 5213, 5138, 3, 2, 2, 2, 5213, 5146, 3, 2, 2, 2, 5213, 5167,
	3, 2, 2, 2, 5213, 5181, 3, 2, 2, 2, 5213, 5184, 3, 2, 2, 2, 5213, 5187,
	3, 2, 2, 2, 5213, 5190, 3, 2, 2, 2, 5213, 5193, 3, 2, 2, 2, 5213, 5195,
	3, 2, 2, 2, 5213, 5198, 3, 2, 2, 2, 5213, 5202, 3, 2, 2, 2, 5213, 5204,
	3, 2, 2, 2, 5213, 5207, 3, 2, 2, 2, 5213, 5210, 3, 2, 2, 2, 5213, 5212,
	3, 2, 2, 2, 5214, 737, 3, 2, 2, 2, 5215, 5224, 7, 330, 2, 2, 5216, 5217,
	7, 52, 2, 2, 5217, 5221, 7, 114, 2, 2, 5218, 5222, 7, 269, 2, 2, 5219,
	5220, 7, 313, 2, 2, 5220, 5222, 7, 233, 2, 2, 5221, 5218, 3, 2, 2, 2, 5221,
	5219, 3, 2, 2, 2, 5222, 5224, 3, 2, 2, 2, 5223, 5215, 3, 2, 2, 2, 5223,
	5216, 3, 2, 2, 2, 5224, 739, 3, 2, 2, 2, 5225, 5226, 7, 52, 2, 2, 5226,
	5379, 7, 316, 2, 2, 5227, 5228, 7, 52, 2, 2, 5228, 5288, 7, 114, 2, 2,
	5229, 5239, 7, 203, 2, 2, 5230, 5240, 7, 327, 2, 2, 5231, 5232, 7, 328,
	2, 2, 5232, 5240, 7, 71, 2, 2, 5233, 5234, 7, 324, 2, 2, 5234, 5240, 7,
	325, 2, 2, 5235, 5236, 7, 324, 2, 2, 5236, 5240, 7, 300, 2, 2, 5237, 5238,
	7, 340, 2, 2, 5238, 5240, 7, 341, 2, 2, 5239, 5230, 3, 2, 2, 2, 5239, 5231,
	3, 2, 2, 2, 5239, 5233, 3, 2, 2, 2, 5239, 5235, 3, 2, 2, 2, 5239, 5237,
	3, 2, 2, 2, 5239, 5240, 3, 2, 2, 2, 5240, 5289, 3, 2, 2, 2, 5241, 5289,
	7, 342, 2, 2, 5242, 5289, 7, 55, 2, 2, 5243, 5245, 7, 343, 2, 2, 5244,
	5246, 7, 327, 2, 2, 5245, 5244, 3, 2, 2, 2, 5245, 5246, 3, 2, 2, 2, 5246,
	5289, 3, 2, 2, 2, 5247, 5289, 7, 232, 2, 2, 5248, 5250, 7, 309, 2, 2, 5249,
	5248, 3, 2, 2, 2, 5249, 5250, 3, 2, 2, 2, 5250, 5251, 3, 2, 2, 2, 5251,
	5289, 7, 233, 2, 2, 5252, 5289, 7, 344, 2, 2, 5253, 5289, 7, 345, 2, 2,
	5254, 5289, 7, 310, 2, 2, 5255, 5289, 7, 302, 2, 2, 5256, 5261, 7, 311,
	2, 2, 5257, 5261, 7, 312, 2, 2, 5258, 5259, 7, 61, 2, 2, 5259, 5261, 7,
	346, 2, 2, 5260, 5256, 3, 2, 2, 2, 5260, 5257, 3, 2, 2, 2, 5260, 5258,
	3, 2, 2, 2, 5261, 5262, 3, 2, 2, 2, 5262, 5289, 7, 67, 2, 2, 5263, 5264,
	7, 61, 2, 2, 5264, 5265, 7, 347, 2, 2, 5265, 5266, 7, 67, 2, 2, 5266, 5289,
	7, 308, 2, 2, 5267, 5273, 7, 333, 2, 2, 5268, 5269, 7, 348, 2, 2, 5269,
	5274, 7, 349, 2, 2, 5270, 5271, 7, 350, 2, 2, 5271, 5274, 7, 351, 2, 2,
	5272, 5274, 7, 352, 2, 2, 5273, 5268, 3, 2, 2, 2, 5273, 5270, 3, 2, 2,
	2, 5273, 5272, 3, 2, 2, 2, 5274, 5289, 3, 2, 2, 2, 5275, 5276, 7, 353,
	2, 2, 5276, 5289, 7, 303, 2, 2, 5277, 5289, 7, 354, 2, 2, 5278, 5279, 7,
	356, 2, 2, 5279, 5289, 7, 175, 2, 2, 5280, 5281, 7, 357, 2, 2, 5281, 5282,
	7, 343, 2, 2, 5282, 5289, 7, 358, 2, 2, 5283, 5289, 7, 359, 2, 2, 5284,
	5285, 7, 324, 2, 2, 5285, 5289, 7, 300, 2, 2, 5286, 5287, 7, 360, 2, 2,
	5287, 5289, 7, 361, 2, 2, 5288, 5229, 3, 2, 2, 2, 5288, 5241, 3, 2, 2,
	2, 5288, 5242, 3, 2, 2, 2, 5288, 5243, 3, 2, 2, 2, 5288, 5247, 3, 2, 2,
	2, 5288, 5249, 3, 2, 2, 2, 5288, 5252, 3, 2, 2, 2, 5288, 5253, 3, 2, 2,
	2, 5288, 5254, 3, 2, 2, 2, 5288, 5255, 3, 2, 2, 2, 5288, 5260, 3, 2, 2,
	2, 5288, 5263, 3, 2, 2, 2, 5288, 5267, 3, 2, 2, 2, 5288, 5275, 3, 2, 2,
	2, 5288, 5277, 3, 2, 2, 2, 5288, 5278, 3, 2, 2, 2, 5288, 5280, 3, 2, 2,
	2, 5288, 5283, 3, 2, 2, 2, 5288, 5284, 3, 2, 2, 2, 5288, 5286, 3, 2, 2,
	2, 5289, 5379, 3, 2, 2, 2, 5290, 5325, 7, 51, 2, 2, 5291, 5326, 7, 203,
	2, 2, 5292, 5293, 7, 203, 2, 2, 5293, 5294, 7, 328, 2, 2, 5294, 5295, 7,
	324, 2, 2, 5295, 5326, 7, 325, 2, 2, 5296, 5326, 7, 55, 2, 2, 5297, 5326,
	7, 60, 2, 2, 5298, 5326, 7, 74, 2, 2, 5299, 5326, 7, 343, 2, 2, 5300, 5326,
	7, 175, 2, 2, 5301, 5326, 7, 153, 2, 2, 5302, 5326, 7, 362, 2, 2, 5303,
	5326, 7, 310, 2, 2, 5304, 5305, 9, 79, 2, 2, 5305, 5326, 7, 67, 2, 2, 5306,
	5326, 7, 344, 2, 2, 5307, 5326, 7, 345, 2, 2, 5308, 5309, 7, 353, 2, 2,
	5309, 5326, 7, 303, 2, 2, 5310, 5326, 7, 70, 2, 2, 5311, 5312, 7, 356,
	2, 2, 5312, 5326, 7, 175, 2, 2, 5313, 5326, 7, 72, 2, 2, 5314, 5326, 7,
	363, 2, 2, 5315, 5316, 7, 357, 2, 2, 5316, 5317, 7, 343, 2, 2, 5317, 5326,
	7, 358, 2, 2, 5318, 5326, 7, 233, 2, 2, 5319, 5326, 7, 359, 2, 2, 5320,
	5326, 7, 364, 2, 2, 5321, 5326, 7, 365, 2, 2, 5322, 5323, 7, 329, 2, 2,
	5323, 5324, 7, 55, 2, 2, 5324, 5326, 7, 366, 2, 2, 5325, 5291, 3, 2, 2,
	2, 5325, 5292, 3, 2, 2, 2, 5325, 5296, 3, 2, 2, 2, 5325, 5297, 3, 2, 2,
	2, 5325, 5298, 3, 2, 2, 2, 5325, 5299, 3, 2, 2, 2, 5325, 5300, 3, 2, 2,
	2, 5325, 5301, 3, 2, 2, 2, 5325, 5302, 3, 2, 2, 2, 5325, 5303, 3, 2, 2,
	2, 5325, 5304, 3, 2, 2, 2, 5325, 5306, 3, 2, 2, 2, 5325, 5307, 3, 2, 2,
	2, 5325, 5308, 3, 2, 2, 2, 5325, 5310, 3, 2, 2, 2, 5325, 5311, 3, 2, 2,
	2, 5325, 5313, 3, 2, 2, 2, 5325, 5314, 3, 2, 2, 2, 5325, 5315, 3, 2, 2,
	2, 5325, 5318, 3, 2, 2, 2, 5325, 5319, 3, 2, 2, 2, 5325, 5320, 3, 2, 2,
	2, 5325, 5321, 3, 2, 2, 2, 5325, 5322, 3, 2, 2, 2, 5326, 5379, 3, 2, 2,
	2, 5327, 5328, 7, 51, 2, 2, 5328, 5332, 7, 114, 2, 2, 5329, 5333, 7, 203,
	2, 2, 5330, 5331, 7, 333, 2, 2, 5331, 5333, 7, 352, 2, 2, 5332, 5329, 3,
	2, 2, 2, 5332, 5330, 3, 2, 2, 2, 5333, 5379, 3, 2, 2, 2, 5334, 5340, 7,
	74, 2, 2, 5335, 5336, 9, 80, 2, 2, 5336, 5341, 7, 320, 2, 2, 5337, 5338,
	7, 328, 2, 2, 5338, 5339, 7, 324, 2, 2, 5339, 5341, 7, 325, 2, 2, 5340,
	5335, 3, 2, 2, 2, 5340, 5337, 3, 2, 2, 2, 5341, 5379, 3, 2, 2, 2, 5342,
	5343, 7, 74, 2, 2, 5343, 5349, 7, 114, 2, 2, 5344, 5345, 7, 61, 2, 2, 5345,
	5346, 9, 81, 2, 2, 5346, 5347, 7, 67, 2, 2, 5347, 5350, 7, 308, 2, 2, 5348,
	5350, 7, 308, 2, 2, 5349, 5344, 3, 2, 2, 2, 5349, 5348, 3, 2, 2, 2, 5350,
	5379, 3, 2, 2, 2, 5351, 5352, 7, 298, 2, 2, 5352, 5353, 7, 114, 2, 2, 5353,
	5354, 7, 333, 2, 2, 5354, 5379, 7, 367, 2, 2, 5355, 5357, 7, 301, 2, 2,
	5356, 5358, 7, 288, 2, 2, 5357, 5356, 3, 2, 2, 2, 5357, 5358, 3, 2, 2,
	2, 5358, 5379, 3, 2, 2, 2, 5359, 5360, 7, 368, 2, 2, 5360, 5361, 7, 203,
	2, 2, 5361, 5379, 7, 302, 2, 2, 5362, 5363, 7, 369, 2, 2, 5363, 5379, 9,
	82, 2, 2, 5364, 5366, 7, 332, 2, 2, 5365, 5367, 7, 313, 2, 2, 5366, 5365,
	3, 2, 2, 2, 5366, 5367, 3, 2, 2, 2, 5367, 5379, 3, 2, 2, 2, 5368, 5379,
	7, 371, 2, 2, 5369, 5370, 7, 372, 2, 2, 5370, 5371, 7, 373, 2, 2, 5371,
	5379, 7, 374, 2, 2, 5372, 5379, 7, 355, 2, 2, 5373, 5379, 7, 375, 2, 2,
	5374, 5375, 7, 335, 2, 2, 5375, 5376, 7, 203, 2, 2, 5376, 5377, 7, 336,
	2, 2, 5377, 5379, 7, 337, 2, 2, 5378, 5225, 3, 2, 2, 2, 5378, 5227, 3,
	2, 2, 2, 5378, 5290, 3, 2, 2, 2, 5378, 5327, 3, 2, 2, 2, 5378, 5334, 3,
	2, 2, 2, 5378, 5342, 3, 2, 2, 2, 5378, 5351, 3, 2, 2, 2, 5378, 5355, 3,
	2, 2, 2, 5378, 5359, 3, 2, 2, 2, 5378, 5362, 3, 2, 2, 2, 5378, 5364, 3,
	2, 2, 2, 5378, 5368, 3, 2, 2, 2, 5378, 5369, 3, 2, 2, 2, 5378, 5372, 3,
	2, 2, 2, 5378, 5373, 3, 2, 2, 2, 5378, 5374, 3, 2, 2, 2, 5379, 741, 3,
	2, 2, 2, 5380, 5391, 7, 330, 2, 2, 5381, 5382, 7, 52, 2, 2, 5382, 5388,
	7, 114, 2, 2, 5383, 5389, 7, 232, 2, 2, 5384, 5386, 7, 309, 2, 2, 5385,
	5384, 3, 2, 2, 2, 5385, 5386, 3, 2, 2, 2, 5386, 5387, 3, 2, 2, 2, 5387,
	5389, 7, 233, 2, 2, 5388, 5383, 3, 2, 2, 2, 5388, 5385, 3, 2, 2, 2, 5389,
	5391, 3, 2, 2, 2, 5390, 5380, 3, 2, 2, 2, 5390, 5381, 3, 2, 2, 2, 5391,
	743, 3, 2, 2, 2, 5392, 5393, 7, 52, 2, 2, 5393, 5394, 7, 114, 2, 2, 5394,
	5401, 7, 55, 2, 2, 5395, 5396, 7, 51, 2, 2, 5396, 5401, 7, 376, 2, 2, 5397,
	5398, 7, 74, 2, 2, 5398, 5399, 7, 315, 2, 2, 5399, 5401, 7, 317, 2, 2,
	5400, 5392, 3, 2, 2, 2, 5400, 5395, 3, 2, 2, 2, 5400, 5397, 3, 2, 2, 2,
	5401, 745, 3, 2, 2, 2, 5402, 5403, 7, 52, 2, 2, 5403, 5412, 7, 114, 2,
	2, 5404, 5413, 7, 345, 2, 2, 5405, 5406, 7, 356, 2, 2, 5406, 5413, 7, 175,
	2, 2, 5407, 5408, 7, 357, 2, 2, 5408, 5409, 7, 343, 2, 2, 5409, 5413, 7,
	358, 2, 2, 5410, 5413, 7, 359, 2, 2, 5411, 5413, 7, 343, 2, 2, 5412, 5404,
	3, 2, 2, 2, 5412, 5405, 3, 2, 2, 2, 5412, 5407, 3, 2, 2, 2, 5412, 5410,
	3, 2, 2, 2, 5412, 5411, 3, 2, 2, 2, 5413, 747, 3, 2, 2, 2, 5414, 5415,
	7, 52, 2, 2, 5415, 5416, 7, 114, 2, 2, 5416, 5417, 7, 323, 2, 2, 5417,
	749, 3, 2, 2, 2, 5418, 5419, 7, 52, 2, 2, 5419, 5420, 7, 114, 2, 2, 5420,
	5421, 7, 344, 2, 2, 5421, 751, 3, 2, 2, 2, 5422, 5423, 7, 52, 2, 2, 5423,
	5424, 7, 114, 2, 2, 5424, 5425, 7, 311, 2, 2, 5425, 5426, 7, 67, 2, 2,
	5426, 753, 3, 2, 2, 2, 5427, 5428, 7, 52, 2, 2, 5428, 5429, 7, 114, 2,
	2, 5429, 5430, 7, 312, 2, 2, 5430, 5431, 7, 67, 2, 2, 5431, 755, 3, 2,
	2, 2, 5432, 5433, 7, 52, 2, 2, 5433, 5434, 7, 114, 2, 2, 5434, 5435, 7,
	310, 2, 2, 5435, 757, 3, 2, 2, 2, 5436, 5437, 7, 52, 2, 2, 5437, 5438,
	7, 114, 2, 2, 5438, 5439, 7, 321, 2, 2, 5439, 5442, 7, 117, 2, 2, 5440,
	5442, 7, 301, 2, 2, 5441, 5436, 3, 2, 2, 2, 5441, 5440, 3, 2, 2, 2, 5442,
	759, 3, 2, 2, 2, 5443, 5444, 7, 52, 2, 2, 5444, 5445, 7, 114, 2, 2, 5445,
	5446, 7, 353, 2, 2, 5446, 5447, 7, 303, 2, 2, 5447, 761, 3, 2, 2, 2, 5448,
	5449, 7, 644, 2, 2, 5449, 5450, 7, 14, 2, 2, 5450, 5451, 7, 14, 2, 2, 5451,
	763, 3, 2, 2, 2, 5452, 5453, 9, 83, 2, 2, 5453, 5454, 7, 14, 2, 2, 5454,
	5455, 7, 14, 2, 2, 5455, 765, 3, 2, 2, 2, 5456, 5457, 5, 260, 131, 2, 5457,
	767, 3, 2, 2, 2, 5458, 5459, 7, 51, 2, 2, 5459, 5460, 7, 232, 2, 2, 5460,
	769, 3, 2, 2, 2, 5461, 5462, 7, 53, 2, 2, 5462, 5463, 7, 232, 2, 2, 5463,
	771, 3, 2, 2, 2, 5464, 5465, 7, 52, 2, 2, 5465, 5466, 7, 232, 2, 2, 5466,
	773, 3, 2, 2, 2, 5467, 5468, 7, 51, 2, 2, 5468, 5469, 7, 233, 2, 2, 5469,
	775, 3, 2, 2, 2, 5470, 5471, 7, 53, 2, 2, 5471, 5472, 7, 233, 2, 2, 5472,
	777, 3, 2, 2, 2, 5473, 5474, 7, 52, 2, 2, 5474, 5475, 7, 233, 2, 2, 5475,
	779, 3, 2, 2, 2, 5476, 5477, 7, 51, 2, 2, 5477, 5478, 7, 269, 2, 2, 5478,
	781, 3, 2, 2, 2, 5479, 5480, 7, 53, 2, 2, 5480, 5481, 7, 269, 2, 2, 5481,
	783, 3, 2, 2, 2, 5482, 5483, 7, 52, 2, 2, 5483, 5484, 7, 269, 2, 2, 5484,
	785, 3, 2, 2, 2, 5485, 5486, 7, 59, 2, 2, 5486, 5487, 7, 235, 2, 2, 5487,
	787, 3, 2, 2, 2, 5488, 5489, 7, 98, 2, 2, 5489, 5490, 7, 42, 2, 2, 5490,
	5491, 7, 42, 2, 2, 5491, 5492, 7, 296, 2, 2, 5492, 5493, 7, 26, 2, 2, 5493,
	5494, 7, 646, 2, 2, 5494, 5495, 7, 125, 2, 2, 5495, 5497, 7, 295, 2, 2,
	5496, 5488, 3, 2, 2, 2, 5496, 5497, 3, 2, 2, 2, 5497, 5498, 3, 2, 2, 2,
	5498, 5499, 7, 59, 2, 2, 5499, 5500, 7, 401, 2, 2, 5500, 5501, 5, 790,
	396, 2, 5501, 789, 3, 2, 2, 2, 5502, 5503, 9, 32, 2, 2, 5503, 791, 3, 2,
	2, 2, 5504, 5505, 7, 124, 2, 2, 5505, 5518, 9, 84, 2, 2, 5506, 5509, 5,
	268, 135, 2, 5507, 5509, 5, 270, 136, 2, 5508, 5506, 3, 2, 2, 2, 5508,
	5507, 3, 2, 2, 2, 5509, 5516, 3, 2, 2, 2, 5510, 5511, 7, 77, 2, 2, 5511,
	5514, 7, 535, 2, 2, 5512, 5515, 5, 94, 48, 2, 5513, 5515, 7, 652, 2, 2,
	5514, 5512, 3, 2, 2, 2, 5514, 5513, 3, 2, 2, 2, 5514, 5515, 3, 2, 2, 2,
	5515, 5517, 3, 2, 2, 2, 5516, 5510, 3, 2, 2, 2, 5516, 5517, 3, 2, 2, 2,
	5517, 5519, 3, 2, 2, 2, 5518, 5508, 3, 2, 2, 2, 5518, 5519, 3, 2, 2, 2,
	5519, 793, 3, 2, 2, 2, 5520, 5521, 7, 124, 2, 2, 5521, 5522, 7, 534, 2,
	2, 5522, 5525, 9, 84, 2, 2, 5523, 5526, 5, 268, 135, 2, 5524, 5526, 5,
	270, 136, 2, 5525, 5523, 3, 2, 2, 2, 5525, 5524, 3, 2, 2, 2, 5525, 5526,
	3, 2, 2, 2, 5526, 795, 3, 2, 2, 2, 5527, 5533, 7, 125, 2, 2, 5528, 5531,
	9, 84, 2, 2, 5529, 5532, 5, 268, 135, 2, 5530, 5532, 5, 270, 136, 2, 5531,
	5529, 3, 2, 2, 2, 5531, 5530, 3, 2, 2, 2, 5531, 5532, 3, 2, 2, 2, 5532,
	5534, 3, 2, 2, 2, 5533, 5528, 3, 2, 2, 2, 5533, 5534, 3, 2, 2, 2, 5534,
	5541, 3, 2, 2, 2, 5535, 5536, 7, 77, 2, 2, 5536, 5537, 7, 31, 2, 2, 5537,
	5538, 7, 638, 2, 2, 5538, 5539, 7, 24, 2, 2, 5539, 5540, 9, 32, 2, 2, 5540,
	5542, 7, 32, 2, 2, 5541, 5535, 3, 2, 2, 2, 5541, 5542, 3, 2, 2, 2, 5542,
	797, 3, 2, 2, 2, 5543, 5545, 7, 125, 2, 2, 5544, 5546, 7, 536, 2, 2, 5545,
	5544, 3, 2, 2, 2, 5545, 5546, 3, 2, 2, 2, 5546, 799, 3, 2, 2, 2, 5547,
	5548, 7, 126, 2, 2, 5548, 5553, 9, 84, 2, 2, 5549, 5554, 5, 268, 135, 2,
	5550, 5554, 5, 270, 136, 2, 5551, 5554, 5, 272, 137, 2, 5552, 5554, 5,
	274, 138, 2, 5553, 5549, 3, 2, 2, 2, 5553, 5550, 3, 2, 2, 2, 5553, 5551,
	3, 2, 2, 2, 5553, 5552, 3, 2, 2, 2, 5553, 5554, 3, 2, 2, 2, 5554, 801,
	3, 2, 2, 2, 5555, 5557, 7, 126, 2, 2, 5556, 5558, 7, 536, 2, 2, 5557, 5556,
	3, 2, 2, 2, 5557, 5558, 3, 2, 2, 2, 5558, 803, 3, 2, 2, 2, 5559, 5560,
	7, 291, 2, 2, 5560, 5563, 9, 84, 2, 2, 5561, 5564, 5, 272, 137, 2, 5562,
	5564, 5, 274, 138, 2, 5563, 5561, 3, 2, 2, 2, 5563, 5562, 3, 2, 2, 2, 5564,
	805, 3, 2, 2, 2, 5565, 5566, 7, 157, 2, 2, 5566, 807, 3, 2, 2, 2, 5567,
	5569, 7, 641, 2, 2, 5568, 5570, 7, 642, 2, 2, 5569, 5568, 3, 2, 2, 2, 5569,
	5570, 3, 2, 2, 2, 5570, 5571, 3, 2, 2, 2, 5571, 5572, 5, 810, 406, 2, 5572,
	809, 3, 2, 2, 2, 5573, 5579, 5, 30, 16, 2, 5574, 5579, 5, 4, 3, 2, 5575,
	5579, 5, 12, 7, 2, 5576, 5579, 5, 22, 12, 2, 5577, 5579, 5, 700, 351, 2,
	5578, 5573, 3, 2, 2, 2, 5578, 5574, 3, 2, 2, 2, 5578, 5575, 3, 2, 2, 2,
	5578, 5576, 3, 2, 2, 2, 5578, 5577, 3, 2, 2, 2, 5579, 811, 3, 2, 2, 2,
	633, 867, 870, 873, 877, 880, 884, 887, 892, 895, 898, 904, 907, 915, 919,
	922, 927, 931, 936, 940, 952, 956, 964, 971, 975, 978, 982, 986, 989, 992,
	996, 999, 1002, 1006, 1009, 1012, 1023, 1027, 1032, 1036, 1044, 1048, 1053,
	1058, 1062, 1065, 1068, 1071, 1074, 1080, 1086, 1092, 1095, 1098, 1101,
	1105, 1109, 1112, 1116, 1126, 1130, 1134, 1149, 1156, 1161, 1164, 1168,
	1172, 1178, 1181, 1184, 1190, 1193, 1197, 1202, 1204, 1210, 1222, 1238,
	1243, 1251, 1256, 1258, 1265, 1272, 1275, 1283, 1325, 1327, 1348, 1355,
	1411, 1422, 1427, 1438, 1450, 1461, 1468, 1473, 1478, 1485, 1492, 1499,
	1506, 1517, 1531, 1542, 1548, 1555, 1559, 1571, 1573, 1578, 1591, 1601,
	1603, 1618, 1633, 1635, 1642, 1649, 1658, 1665, 1674, 1680, 1683, 1718,
	1720, 1732, 1740, 1746, 1756, 1763, 1769, 1774, 1781, 1785, 1795, 1811,
	1816, 1827, 1831, 1838, 1845, 1849, 1854, 1857, 1873, 1882, 1894, 1896,
	1901, 1905, 1908, 1913, 1922, 1927, 1935, 1947, 1956, 1962, 1970, 1973,
	1976, 1987, 1995, 2004, 2012, 2020, 2024, 2037, 2039, 2048, 2069, 2074,
	2086, 2099, 2108, 2122, 2136, 2161, 2171, 2181, 2190, 2204, 2212, 2218,
	2226, 2237, 2244, 2254, 2259, 2292, 2301, 2304, 2311, 2318, 2325, 2334,
	2341, 2347, 2354, 2360, 2367, 2373, 2380, 2386, 2393, 2400, 2402, 2407,
	2414, 2425, 2435, 2447, 2452, 2461, 2468, 2473, 2488, 2498, 2509, 2512,
	2524, 2528, 2546, 2551, 2555, 2560, 2564, 2571, 2576, 2584, 2593, 2597,
	2601, 2604, 2607, 2610, 2624, 2629, 2634, 2652, 2654, 2665, 2673, 2678,
	2687, 2694, 2700, 2709, 2712, 2715, 2718, 2727, 2735, 2744, 2751, 2754,
	2762, 2764, 2767, 2777, 2782, 2787, 2791, 2794, 2798, 2801, 2806, 2814,
	2823, 2831, 2834, 2837, 2840, 2846, 2850, 2858, 2880, 2882, 2887, 2889,
	2896, 2898, 2902, 2910, 2924, 2933, 2948, 2954, 2958, 2965, 2985, 2994,
	2997, 3019, 3021, 3032, 3048, 3053, 3057, 3062, 3069, 3079, 3086, 3089,
	3100, 3104, 3109, 3115, 3120, 3123, 3134, 3143, 3147, 3162, 3169, 3181,
	3184, 3188, 3192, 3201, 3204, 3207, 3214, 3219, 3228, 3248, 3250, 3256,
	3263, 3268, 3275, 3279, 3285, 3291, 3296, 3302, 3309, 3315, 3324, 3331,
	3333, 3339, 3342, 3345, 3350, 3357, 3366, 3371, 3380, 3382, 3387, 3396,
	3398, 3401, 3419, 3421, 3431, 3441, 3444, 3448, 3456, 3459, 3463, 3470,
	3477, 3488, 3516, 3524, 3542, 3544, 3551, 3554, 3556, 3563, 3565, 3570,
	3577, 3582, 3585, 3589, 3598, 3601, 3609, 3613, 3617, 3622, 3627, 3631,
	3642, 3649, 3655, 3659, 3663, 3671, 3673, 3676, 3683, 3688, 3697, 3702,
	3710, 3717, 3725, 3734, 3746, 3762, 3765, 3767, 3770, 3773, 3776, 3779,
	3797, 3802, 3807, 3812, 3815, 3819, 3827, 3839, 3842, 3845, 3860, 3863,
	3866, 3870, 3874, 3884, 3887, 3890, 3901, 3906, 3912, 3916, 3919, 3930,
	3933, 3938, 3940, 3952, 3955, 3962, 3965, 3969, 3973, 3976, 3979, 3983,
	3994, 3997, 4004, 4007, 4011, 4018, 4023, 4034, 4039, 4041, 4054, 4065,
	4073, 4076, 4080, 4086, 4096, 4106, 4111, 4123, 4129, 4132, 4135, 4138,
	4141, 4144, 4147, 4151, 4156, 4163, 4170, 4183, 4195, 4201, 4210, 4213,
	4217, 4221, 4230, 4235, 4244, 4246, 4251, 4253, 4260, 4271, 4280, 4287,
	4289, 4298, 4303, 4310, 4317, 4335, 4340, 4344, 4371, 4374, 4383, 4408,
	4411, 4413, 4418, 4426, 4447, 4449, 4458, 4461, 4476, 4481, 4490, 4510,
	4513, 4517, 4529, 4531, 4544, 4546, 4556, 4601, 4607, 4616, 4631, 4635,
	4644, 4650, 4660, 4669, 4680, 4692, 4694, 4702, 4716, 4724, 4729, 4731,
	4740, 4746, 4767, 4774, 4782, 4787, 4789, 4830, 4835, 4850, 4858, 4881,
	4890, 4898, 4909, 4914, 4922, 4933, 4944, 4953, 4960, 4964, 4970, 4991,
	5005, 5008, 5019, 5024, 5030, 5034, 5039, 5044, 5049, 5054, 5062, 5067,
	5071, 5075, 5084, 5088, 5094, 5111, 5115, 5122, 5132, 5144, 5165, 5179,
	5213, 5221, 5223, 5239, 5245, 5249, 5260, 5273, 5288, 5325, 5332, 5340,
	5349, 5357, 5366, 5378, 5385, 5388, 5390, 5400, 5412, 5441, 5496, 5508,
	5514, 5516, 5518, 5525, 5531, 5533, 5541, 5545, 5553, 5557, 5563, 5569,
	5578,
}
var literalNames = []string{
	"", "'Default does not match anything'", "'&&'", "'||'", "'!'", "'~'",
	"'|'", "'&'", "'<<'", "'>>'", "'^'", "'%'", "':'", "'+'", "'-'", "'*'",
	"'/'", "'\\'", "'.'", "'.*'", "'<=>'", "'=='", "'='", "", "'>'", "'>='",
	"'<'", "'<='", "'#'", "'('", "')'", "'{'", "'}'", "'['", "']'", "','",
	"'\"'", "'''", "'`'", "'?'", "'@'", "';'", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'DO NOT MATCH ANY THING, JUST FOR GENERATOR'",
}
var symbolicNames = []string{
	"", "", "AND_", "OR_", "NOT_", "TILDE_", "VERTICAL_BAR_", "AMPERSAND_",
	"SIGNED_LEFT_SHIFT_", "SIGNED_RIGHT_SHIFT_", "CARET_", "MOD_", "COLON_",
	"PLUS_", "MINUS_", "ASTERISK_", "SLASH_", "BACKSLASH_", "DOT_", "DOT_ASTERISK_",
	"SAFE_EQ_", "DEQ_", "EQ_", "NEQ_", "GT_", "GTE_", "LT_", "LTE_", "POUND_",
	"LP_", "RP_", "LBE_", "RBE_", "LBT_", "RBT_", "COMMA_", "DQ_", "SQ_", "BQ_",
	"QUESTION_", "AT_", "SEMI_", "BLOCK_COMMENT", "INLINE_COMMENT", "WS", "SELECT",
	"INSERT", "UPDATE", "DELETE", "CREATE", "ALTER", "DROP", "TRUNCATE", "SCHEMA",
	"GRANT", "REVOKE", "ADD", "SET", "TABLE", "COLUMN", "INDEX", "CONSTRAINT",
	"PRIMARY", "UNIQUE", "FOREIGN", "KEY", "POSITION", "PRECISION", "FUNCTION",
	"TRIGGER", "PROCEDURE", "PROC", "VIEW", "INTO", "VALUES", "WITH", "UNION",
	"DISTINCT", "CASE", "WHEN", "CAST", "TRIM", "SUBSTRING", "FROM", "NATURAL",
	"JOIN", "FULL", "INNER", "OUTER", "LEFT", "RIGHT", "CROSS", "USING", "WHERE",
	"AS", "ON", "IF", "ELSE", "THEN", "FOR", "TO", "AND", "OR", "IS", "NOT",
	"NULL", "TRUE", "FALSE", "EXISTS", "BETWEEN", "IN", "ALL", "ANY", "LIKE",
	"ORDER", "GROUP", "BY", "ASC", "DESC", "HAVING", "LIMIT", "OFFSET", "BEGIN",
	"COMMIT", "ROLLBACK", "SAVEPOINT", "BOOLEAN", "DOUBLE", "CHAR", "CHARACTER",
	"ARRAY", "INTERVAL", "DATE", "TIME", "TIMESTAMP", "LOCALTIME", "LOCALTIMESTAMP",
	"YEAR", "QUARTER", "MONTH", "WEEK", "DAY", "HOUR", "MINUTE", "SECOND",
	"MICROSECOND", "MAX", "MIN", "SUM", "COUNT", "AVG", "DEFAULT", "CURRENT",
	"ENABLE", "DISABLE", "CALL", "INSTANCE", "PRESERVE", "DO", "DEFINER", "CURRENT_USER",
	"SQL", "CASCADED", "LOCAL", "CLOSE", "OPEN", "NEXT", "NAME", "COLLATION",
	"NAMES", "INTEGER", "REAL", "DECIMAL", "TYPE", "BIT", "SMALLINT", "INT",
	"TINYINT", "NUMERIC", "FLOAT", "BIGINT", "TEXT", "VARCHAR", "PERCENT",
	"TIES", "EXCEPT", "INTERSECT", "USE", "MERGE", "LOOP", "EXPAND", "VIEWS",
	"FAST", "FORCE", "KEEP", "PLAN", "OPTIMIZE", "SIMPLE", "FORCED", "HINT",
	"READ_ONLY", "DATABASE", "DECLARE", "CURSOR", "OF", "RETURNS", "DATEPART",
	"RETURN", "READONLY", "AT", "FOR_GENERATOR", "BINARY", "ESCAPE", "HIDDEN_",
	"MOD", "PARTITION", "PARTITIONS", "TOP", "ROW", "ROWS", "UNKNOWN", "XOR",
	"ALWAYS", "CASCADE", "CHECK", "GENERATED", "NO", "OPTION", "PRIVILEGES",
	"REFERENCES", "USER", "ROLE", "START", "TRANSACTION", "ACTION", "ALGORITHM",
	"AUTO", "BLOCKERS", "CLUSTERED", "NONCLUSTERED", "COLLATE", "COLUMNSTORE",
	"CONTENT", "CONVERT", "YEARS", "MONTHS", "WEEKS", "DAYS", "MINUTES", "DENY",
	"DETERMINISTIC", "DISTRIBUTION", "DOCUMENT", "DURABILITY", "ENCRYPTED",
	"END", "FILESTREAM", "FILETABLE", "FILLFACTOR", "FOLLOWING", "HASH", "HEAP",
	"IDENTITY", "INBOUND", "OUTBOUND", "UNBOUNDED", "INFINITE", "LOGIN", "MASKED",
	"MAXDOP", "MOVE", "NOCHECK", "NONE", "OBJECT", "OFF", "ONLINE", "OVER",
	"PAGE", "PAUSED", "PERIOD", "PERSISTED", "PRECEDING", "RANDOMIZED", "RANGE",
	"REBUILD", "REPLICATE", "REPLICATION", "RESUMABLE", "ROWGUIDCOL", "SAVE",
	"SELF", "SPARSE", "SWITCH", "TRAN", "TRANCOUNT", "ZONE", "EXECUTE", "EXEC",
	"SESSION", "CONNECT", "CONNECTION", "CATALOG", "CONTROL", "CONCAT", "TAKE",
	"OWNERSHIP", "DEFINITION", "APPLICATION", "ASSEMBLY", "SYMMETRIC", "ASYMMETRIC",
	"SERVER", "RECEIVE", "CHANGE", "TRACE", "TRACKING", "RESOURCES", "SETTINGS",
	"STATE", "AVAILABILITY", "CREDENTIAL", "ENDPOINT", "EVENT", "NOTIFICATION",
	"LINKED", "AUDIT", "DDL", "XML", "IMPERSONATE", "SECURABLES", "AUTHENTICATE",
	"EXTERNAL", "ACCESS", "ADMINISTER", "BULK", "OPERATIONS", "UNSAFE", "SHUTDOWN",
	"SCOPED", "CONFIGURATION", "DATASPACE", "SERVICE", "CERTIFICATE", "CONTRACT",
	"ENCRYPTION", "MASTER", "DATA", "SOURCE", "FILE", "FORMAT", "LIBRARY",
	"FULLTEXT", "MASK", "UNMASK", "MESSAGE", "REMOTE", "BINDING", "ROUTE",
	"SECURITY", "POLICY", "AGGREGATE", "QUEUE", "RULE", "SYNONYM", "COLLECTION",
	"SCRIPT", "KILL", "BACKUP", "LOG", "SHOWPLAN", "SUBSCRIBE", "QUERY", "NOTIFICATIONS",
	"CHECKPOINT", "SEQUENCE", "ABORT_AFTER_WAIT", "ALLOW_PAGE_LOCKS", "ALLOW_ROW_LOCKS",
	"ALL_SPARSE_COLUMNS", "BUCKET_COUNT", "COLUMNSTORE_ARCHIVE", "COLUMN_ENCRYPTION_KEY",
	"COLUMN_SET", "COMPRESSION_DELAY", "DATABASE_DEAULT", "DATA_COMPRESSION",
	"DATA_CONSISTENCY_CHECK", "ENCRYPTION_TYPE", "SYSTEM_TIME", "SYSTEM_VERSIONING",
	"TEXTIMAGE_ON", "WAIT_AT_LOW_PRIORITY", "STATISTICS_INCREMENTAL", "STATISTICS_NORECOMPUTE",
	"ROUND_ROBIN", "SCHEMA_AND_DATA", "SCHEMA_ONLY", "SORT_IN_TEMPDB", "IGNORE_DUP_KEY",
	"IMPLICIT_TRANSACTIONS", "MAX_DURATION", "MEMORY_OPTIMIZED", "MIGRATION_STATE",
	"PAD_INDEX", "REMOTE_DATA_ARCHIVE", "FILESTREAM_ON", "FILETABLE_COLLATE_FILENAME",
	"FILETABLE_DIRECTORY", "FILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME", "FILETABLE_PRIMARY_KEY_CONSTRAINT_NAME",
	"FILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME", "FILTER_PREDICATE", "HISTORY_RETENTION_PERIOD",
	"HISTORY_TABLE", "LOCK_ESCALATION", "DROP_EXISTING", "ROW_NUMBER", "FETCH",
	"FIRST", "ONLY", "MONEY", "SMALLMONEY", "DATETIMEOFFSET", "DATETIME", "DATETIME2",
	"SMALLDATETIME", "NCHAR", "NVARCHAR", "NTEXT", "VARBINARY", "IMAGE", "SQL_VARIANT",
	"UNIQUEIDENTIFIER", "HIERARCHYID", "GEOMETRY", "GEOGRAPHY", "OUTPUT", "INSERTED",
	"DELETED", "ASSUME_JOIN_PREDICATE_DEPENDS_ON_FILTERS", "ASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES",
	"DISABLE_BATCH_MODE_ADAPTIVE_JOINS", "DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK",
	"DISABLE_DEFERRED_COMPILATION_TV", "DISABLE_INTERLEAVED_EXECUTION_TVF",
	"DISABLE_OPTIMIZED_NESTED_LOOP", "DISABLE_OPTIMIZER_ROWGOAL", "DISABLE_PARAMETER_SNIFFING",
	"DISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK", "DISABLE_TSQL_SCALAR_UDF_INLINING",
	"DISALLOW_BATCH_MODE", "ENABLE_HIST_AMENDMENT_FOR_ASC_KEYS", "ENABLE_QUERY_OPTIMIZER_HOTFIXES",
	"FORCE_DEFAULT_CARDINALITY_ESTIMATION", "FORCE_LEGACY_CARDINALITY_ESTIMATION",
	"QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_n", "QUERY_PLAN_PROFILE", "EXTERNALPUSHDOWN",
	"SCALEOUTEXECUTION", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", "KEEPFIXED",
	"MAX_GRANT_PERCENT", "MIN_GRANT_PERCENT", "MAXRECURSION", "NO_PERFORMANCE_SPOOL",
	"PARAMETERIZATION", "QUERYTRACEON", "RECOMPILE", "ROBUST", "OPTIMIZE_FOR_SEQUENTIAL_KEY",
	"DATA_DELETION", "FILTER_COLUMN", "RETENTION_PERIOD", "CONTAINMENT", "PARTIAL",
	"FILENAME", "SIZE", "MAXSIZE", "FILEGROWTH", "UNLIMITED", "KB", "MB", "GB",
	"TB", "CONTAINS", "MEMORY_OPTIMIZED_DATA", "FILEGROUP", "NON_TRANSACTED_ACCESS",
	"DB_CHAINING", "TRUSTWORTHY", "FORWARD_ONLY", "SCROLL", "STATIC", "KEYSET",
	"DYNAMIC", "FAST_FORWARD", "SCROLL_LOCKS", "OPTIMISTIC", "TYPE_WARNING",
	"SCHEMABINDING", "CALLER", "INPUT", "CALLED", "VARYING", "OUT", "OWNER",
	"ATOMIC", "LANGUAGE", "LEVEL", "ISOLATION", "SNAPSHOT", "REPEATABLE", "READ",
	"SERIALIZABLE", "NATIVE_COMPILATION", "VIEW_METADATA", "AFTER", "INSTEAD",
	"APPEND", "INCREMENT", "CYCLE", "CACHE", "MINVALUE", "MAXVALUE", "RESTART",
	"LOB_COMPACTION", "COMPRESS_ALL_ROW_GROUPS", "REORGANIZE", "RESUME", "PAUSE",
	"ABORT", "INCLUDE", "DISTRIBUTED", "MARK", "WORK", "REMOVE", "AUTOGROW_SINGLE_FILE",
	"AUTOGROW_ALL_FILES", "READWRITE", "READ_WRITE", "MODIFY", "ACCELERATED_DATABASE_RECOVERY",
	"PERSISTENT_VERSION_STORE_FILEGROUP", "IMMEDIATE", "NO_WAIT", "TARGET_RECOVERY_TIME",
	"SECONDS", "HONOR_BROKER_PRIORITY", "ERROR_BROKER_CONVERSATIONS", "NEW_BROKER",
	"DISABLE_BROKER", "ENABLE_BROKER", "MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT",
	"READ_COMMITTED_SNAPSHOT", "ALLOW_SNAPSHOT_ISOLATION", "RECURSIVE_TRIGGERS",
	"QUOTED_IDENTIFIER", "NUMERIC_ROUNDABORT", "CONCAT_NULL_YIELDS_NULL", "COMPATIBILITY_LEVEL",
	"ARITHABORT", "ANSI_WARNINGS", "ANSI_PADDING", "ANSI_NULLS", "ANSI_NULL_DEFAULT",
	"PAGE_VERIFY", "CHECKSUM", "TORN_PAGE_DETECTION", "BULK_LOGGED", "RECOVERY",
	"TOTAL_EXECUTION_CPU_TIME_MS", "TOTAL_COMPILE_CPU_TIME_MS", "STALE_CAPTURE_POLICY_THRESHOLD",
	"EXECUTION_COUNT", "QUERY_CAPTURE_POLICY", "WAIT_STATS_CAPTURE_MODE", "MAX_PLANS_PER_QUERY",
	"QUERY_CAPTURE_MODE", "SIZE_BASED_CLEANUP_MODE", "INTERVAL_LENGTH_MINUTES",
	"MAX_STORAGE_SIZE_MB", "DATA_FLUSH_INTERVAL_SECONDS", "CLEANUP_POLICY",
	"CUSTOM", "STALE_QUERY_THRESHOLD_DAYS", "OPERATION_MODE", "QUERY_STORE",
	"CURSOR_DEFAULT", "GLOBAL", "CURSOR_CLOSE_ON_COMMIT", "HOURS", "CHANGE_RETENTION",
	"AUTO_CLEANUP", "CHANGE_TRACKING", "AUTOMATIC_TUNING", "FORCE_LAST_GOOD_PLAN",
	"AUTO_UPDATE_STATISTICS_ASYNC", "AUTO_UPDATE_STATISTICS", "AUTO_SHRINK",
	"AUTO_CREATE_STATISTICS", "INCREMENTAL", "AUTO_CLOSE", "DATA_RETENTION",
	"TEMPORAL_HISTORY_RETENTION", "EDITION", "MIXED_PAGE_ALLOCATION", "DISABLED",
	"ALLOWED", "HADR", "MULTI_USER", "RESTRICTED_USER", "SINGLE_USER", "OFFLINE",
	"EMERGENCY", "SUSPEND", "DATE_CORRELATION_OPTIMIZATION", "ELASTIC_POOL",
	"SERVICE_OBJECTIVE", "DATABASE_NAME", "ALLOW_CONNECTIONS", "GEO", "NAMED",
	"DATEFIRST", "BACKUP_STORAGE_REDUNDANCY", "FORCE_FAILOVER_ALLOW_DATA_LOSS",
	"SECONDARY", "FAILOVER", "DEFAULT_FULLTEXT_LANGUAGE", "DEFAULT_LANGUAGE",
	"INLINE", "NESTED_TRIGGERS", "TRANSFORM_NOISE_WORDS", "TWO_DIGIT_YEAR_CUTOFF",
	"PERSISTENT_LOG_BUFFER", "DIRECTORY_NAME", "DATEFORMAT", "DELAYED_DURABILITY",
	"AUTHORIZATION", "TRANSFER", "EXPLAIN", "WITH_RECOMMENDATIONS", "BATCH_SIZE",
	"IDENTIFIER_", "STRING_", "NUMBER_", "INT_NUM_", "FLOAT_NUM_", "DECIMAL_NUM_",
	"HEX_DIGIT_", "BIT_NUM_", "NCHAR_TEXT",
}

var ruleNames = []string{
	"execute", "insert", "insertDefaultValue", "insertValuesClause", "insertSelectClause",
	"update", "assignment", "setAssignmentsClause", "assignmentValues", "assignmentValue",
	"delete", "singleTableClause", "multipleTablesClause", "multipleTableNames",
	"select", "aggregationClause", "selectClause", "duplicateSpecification",
	"projections", "projection", "top", "topNum", "alias", "unqualifiedShorthand",
	"qualifiedShorthand", "fromClause", "tableReferences", "tableReference",
	"tableFactor", "joinedTable", "joinSpecification", "whereClause", "groupByClause",
	"havingClause", "subquery", "withClause", "cteClause", "outputClause",
	"outputWithColumns", "outputWithColumn", "outputWithAaterisk", "outputTableName",
	"queryHint", "useHitName", "parameterMarker", "literals", "stringLiterals",
	"numberLiterals", "dateTimeLiterals", "hexadecimalLiterals", "bitValueLiterals",
	"booleanLiterals", "nullValueLiterals", "identifier", "unreservedWord",
	"databaseName", "schemaName", "functionName", "procedureName", "viewName",
	"triggerName", "sequenceName", "tableName", "queueName", "contractName",
	"serviceName", "columnName", "owner", "name", "columnNames", "columnNamesWithSort",
	"tableNames", "indexName", "constraintName", "collationName", "dataTypeLength",
	"primaryKey", "expr", "andOperator", "orOperator", "notOperator", "booleanPrimary",
	"comparisonOperator", "predicate", "bitExpr", "simpleExpr", "functionCall",
	"aggregationFunction", "aggregationFunctionName", "distinct", "specialFunction",
	"castFunction", "charFunction", "regularFunction", "regularFunctionName",
	"caseExpression", "caseWhen", "caseElse", "privateExprOfDb", "orderByClause",
	"orderByItem", "dataType", "dataTypeName", "atTimeZoneExpr", "castExpr",
	"convertExpr", "windowedFunction", "overClause", "partitionByClause", "rowRangeClause",
	"windowFrameExtent", "windowFrameBetween", "windowFrameBound", "windowFramePreceding",
	"windowFrameFollowing", "columnNameWithSort", "indexOption", "compressionOption",
	"eqTime", "eqOnOffOption", "eqKey", "eqOnOff", "onPartitionClause", "partitionExpressions",
	"partitionExpression", "numberRange", "lowPriorityLockWait", "onLowPriorLockWait",
	"ignoredIdentifier", "ignoredIdentifiers", "matchNone", "variableName",
	"executeAsClause", "transactionName", "transactionVariableName", "savepointName",
	"savepointVariableName", "entityType", "createTable", "createTableClause",
	"createIndex", "createDatabase", "createFunction", "createProcedure", "createView",
	"createTrigger", "createSequence", "createService", "createSchema", "alterTable",
	"alterIndex", "alterDatabase", "alterProcedure", "alterFunction", "alterView",
	"alterTrigger", "alterSequence", "alterService", "alterSchema", "dropTable",
	"dropIndex", "dropDatabase", "dropFunction", "dropProcedure", "dropView",
	"dropTrigger", "dropSequence", "dropService", "dropSchema", "truncateTable",
	"fileTableClause", "createDefinitionClause", "createTableDefinitions",
	"createTableDefinition", "columnDefinition", "columnDefinitionOption",
	"encryptedOptions", "columnConstraint", "computedColumnConstraint", "computedColumnForeignKeyConstraint",
	"computedColumnForeignKeyOnAction", "primaryKeyConstraint", "diskTablePrimaryKeyConstraintOption",
	"clusterOption", "primaryKeyWithClause", "primaryKeyOnClause", "onSchemaColumn",
	"onFileGroup", "onString", "memoryTablePrimaryKeyConstraintOption", "withBucket",
	"columnForeignKeyConstraint", "foreignKeyOnAction", "foreignKeyOn", "checkConstraint",
	"columnIndex", "withIndexOption", "indexOnClause", "onDefault", "fileStreamOn",
	"columnConstraints", "computedColumnDefinition", "columnSetDefinition",
	"tableConstraint", "tablePrimaryConstraint", "primaryKeyUnique", "diskTablePrimaryConstraintOption",
	"memoryTablePrimaryConstraintOption", "hashWithBucket", "tableForeignKeyConstraint",
	"tableIndex", "indexNameOption", "indexOptions", "periodClause", "partitionScheme",
	"fileGroup", "tableOptions", "tableOption", "dataDelectionOption", "tableStretchOptions",
	"tableStretchOption", "migrationState_", "tableOperationOption", "distributionOption",
	"dataWareHouseTableOption", "dataWareHousePartitionOption", "createIndexSpecification",
	"alterDefinitionClause", "addColumnSpecification", "modifyColumnSpecification",
	"alterColumnOperation", "alterColumnAddOptions", "alterColumnAddOption",
	"constraintForColumn", "generatedColumnNamesClause", "generatedColumnNameClause",
	"generatedColumnName", "alterDrop", "alterTableDropConstraint", "dropConstraintName",
	"dropConstraintWithClause", "dropConstraintOption", "onOffOption", "dropColumnSpecification",
	"dropIndexSpecification", "alterCheckConstraint", "alterTableTrigger",
	"alterSwitch", "alterSet", "setFileStreamClause", "setSystemVersionClause",
	"alterSetOnClause", "dataConsistencyCheckClause", "historyRetentionPeriodClause",
	"historyRetentionPeriod", "alterTableTableIndex", "indexWithName", "indexNonClusterClause",
	"alterTableIndexOnClause", "indexClusterClause", "alterTableOption", "onHistoryTableClause",
	"ifExist", "createDatabaseClause", "fileDefinitionClause", "databaseOption",
	"fileStreamOption", "fileSpec", "databaseFileSpecOption", "databaseFileGroup",
	"databaseFileGroupContains", "databaseLogOns", "declareVariable", "variable",
	"tableVariable", "variTableTypeDefinition", "tableVariableClause", "variableTableColumnDefinition",
	"variableTableColumnConstraint", "variableTableConstraint", "setVariable",
	"setVariableClause", "cursorVariable", "cursorClause", "compoundOperation",
	"funcParameters", "funcReturns", "funcMutiReturn", "funcInlineReturn",
	"funcScalarReturn", "tableTypeDefinition", "compoundStatement", "functionOption",
	"validStatement", "procParameters", "procParameter", "createOrAlterProcClause",
	"withCreateProcOption", "procOption", "procAsClause", "procSetOption",
	"createOrAlterViewClause", "viewAttribute", "withCommonTableExpr", "commonTableExpr",
	"createTriggerClause", "dmlTriggerOption", "methodSpecifier", "triggerTarget",
	"createOrAlterSequenceClause", "createIndexClause", "filterPredicate",
	"conjunct", "alterIndexClause", "relationalIndexOption", "partitionNumberRange",
	"reorganizeOption", "setIndexOption", "resumableIndexOptions", "alterDatabaseClause",
	"addSecondaryOption", "editionOptions", "serviceObjective", "alterDatabaseOptionSpec",
	"fileAndFilegroupOptions", "addOrModifyFilegroups", "filegroupUpdatabilityOption",
	"addOrModifyFiles", "acceleratedDatabaseRecovery", "autoOption", "automaticTuningOption",
	"changeTrackingOption", "changeTrackingOptionList", "cursorOption", "externalAccessOption",
	"queryStoreOptions", "queryStoreOptionList", "queryCapturePolicyOptionList",
	"recoveryOption", "sqlOption", "snapshotOption", "serviceBrokerOption",
	"targetRecoveryTimeOption", "termination", "createServiceClause", "alterServiceClause",
	"alterServiceOptArg", "schemaNameClause", "schemaElement", "createTableAsSelectClause",
	"createTableAsSelect", "createRemoteTableAsSelect", "withDistributionOption",
	"optionQueryHintClause", "grant", "revoke", "deny", "classPrivilegesClause",
	"classTypePrivilegesClause", "optionForClause", "classPrivileges", "onClassClause",
	"classTypePrivileges", "onClassTypeClause", "privilegeType", "basicPermission",
	"objectPermission", "serverPermission", "serverPrincipalPermission", "databasePermission",
	"databasePrincipalPermission", "schemaPermission", "serviceBrokerPermission",
	"endpointPermission", "certificatePermission", "symmetricKeyPermission",
	"asymmetricKeyPermission", "assemblyPermission", "availabilityGroupPermission",
	"fullTextPermission", "class_", "classType", "roleClause", "createUser",
	"dropUser", "alterUser", "createRole", "dropRole", "alterRole", "createLogin",
	"dropLogin", "alterLogin", "setTransaction", "setImplicitTransactions",
	"implicitTransactionsValue", "beginTransaction", "beginDistributedTransaction",
	"commit", "commitWork", "rollback", "rollbackWork", "savepoint", "call",
	"explain", "explainableStatement",
}

type SQLServerStatementParser struct {
	*antlr.BaseParser
}

// NewSQLServerStatementParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *SQLServerStatementParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewSQLServerStatementParser(input antlr.TokenStream) *SQLServerStatementParser {
	this := new(SQLServerStatementParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SQLServerStatement.g4"

	return this
}

// SQLServerStatementParser tokens.
const (
	SQLServerStatementParserEOF                                         = antlr.TokenEOF
	SQLServerStatementParserT__0                                        = 1
	SQLServerStatementParserAND_                                        = 2
	SQLServerStatementParserOR_                                         = 3
	SQLServerStatementParserNOT_                                        = 4
	SQLServerStatementParserTILDE_                                      = 5
	SQLServerStatementParserVERTICAL_BAR_                               = 6
	SQLServerStatementParserAMPERSAND_                                  = 7
	SQLServerStatementParserSIGNED_LEFT_SHIFT_                          = 8
	SQLServerStatementParserSIGNED_RIGHT_SHIFT_                         = 9
	SQLServerStatementParserCARET_                                      = 10
	SQLServerStatementParserMOD_                                        = 11
	SQLServerStatementParserCOLON_                                      = 12
	SQLServerStatementParserPLUS_                                       = 13
	SQLServerStatementParserMINUS_                                      = 14
	SQLServerStatementParserASTERISK_                                   = 15
	SQLServerStatementParserSLASH_                                      = 16
	SQLServerStatementParserBACKSLASH_                                  = 17
	SQLServerStatementParserDOT_                                        = 18
	SQLServerStatementParserDOT_ASTERISK_                               = 19
	SQLServerStatementParserSAFE_EQ_                                    = 20
	SQLServerStatementParserDEQ_                                        = 21
	SQLServerStatementParserEQ_                                         = 22
	SQLServerStatementParserNEQ_                                        = 23
	SQLServerStatementParserGT_                                         = 24
	SQLServerStatementParserGTE_                                        = 25
	SQLServerStatementParserLT_                                         = 26
	SQLServerStatementParserLTE_                                        = 27
	SQLServerStatementParserPOUND_                                      = 28
	SQLServerStatementParserLP_                                         = 29
	SQLServerStatementParserRP_                                         = 30
	SQLServerStatementParserLBE_                                        = 31
	SQLServerStatementParserRBE_                                        = 32
	SQLServerStatementParserLBT_                                        = 33
	SQLServerStatementParserRBT_                                        = 34
	SQLServerStatementParserCOMMA_                                      = 35
	SQLServerStatementParserDQ_                                         = 36
	SQLServerStatementParserSQ_                                         = 37
	SQLServerStatementParserBQ_                                         = 38
	SQLServerStatementParserQUESTION_                                   = 39
	SQLServerStatementParserAT_                                         = 40
	SQLServerStatementParserSEMI_                                       = 41
	SQLServerStatementParserBLOCK_COMMENT                               = 42
	SQLServerStatementParserINLINE_COMMENT                              = 43
	SQLServerStatementParserWS                                          = 44
	SQLServerStatementParserSELECT                                      = 45
	SQLServerStatementParserINSERT                                      = 46
	SQLServerStatementParserUPDATE                                      = 47
	SQLServerStatementParserDELETE                                      = 48
	SQLServerStatementParserCREATE                                      = 49
	SQLServerStatementParserALTER                                       = 50
	SQLServerStatementParserDROP                                        = 51
	SQLServerStatementParserTRUNCATE                                    = 52
	SQLServerStatementParserSCHEMA                                      = 53
	SQLServerStatementParserGRANT                                       = 54
	SQLServerStatementParserREVOKE                                      = 55
	SQLServerStatementParserADD                                         = 56
	SQLServerStatementParserSET                                         = 57
	SQLServerStatementParserTABLE                                       = 58
	SQLServerStatementParserCOLUMN                                      = 59
	SQLServerStatementParserINDEX                                       = 60
	SQLServerStatementParserCONSTRAINT                                  = 61
	SQLServerStatementParserPRIMARY                                     = 62
	SQLServerStatementParserUNIQUE                                      = 63
	SQLServerStatementParserFOREIGN                                     = 64
	SQLServerStatementParserKEY                                         = 65
	SQLServerStatementParserPOSITION                                    = 66
	SQLServerStatementParserPRECISION                                   = 67
	SQLServerStatementParserFUNCTION                                    = 68
	SQLServerStatementParserTRIGGER                                     = 69
	SQLServerStatementParserPROCEDURE                                   = 70
	SQLServerStatementParserPROC                                        = 71
	SQLServerStatementParserVIEW                                        = 72
	SQLServerStatementParserINTO                                        = 73
	SQLServerStatementParserVALUES                                      = 74
	SQLServerStatementParserWITH                                        = 75
	SQLServerStatementParserUNION                                       = 76
	SQLServerStatementParserDISTINCT                                    = 77
	SQLServerStatementParserCASE                                        = 78
	SQLServerStatementParserWHEN                                        = 79
	SQLServerStatementParserCAST                                        = 80
	SQLServerStatementParserTRIM                                        = 81
	SQLServerStatementParserSUBSTRING                                   = 82
	SQLServerStatementParserFROM                                        = 83
	SQLServerStatementParserNATURAL                                     = 84
	SQLServerStatementParserJOIN                                        = 85
	SQLServerStatementParserFULL                                        = 86
	SQLServerStatementParserINNER                                       = 87
	SQLServerStatementParserOUTER                                       = 88
	SQLServerStatementParserLEFT                                        = 89
	SQLServerStatementParserRIGHT                                       = 90
	SQLServerStatementParserCROSS                                       = 91
	SQLServerStatementParserUSING                                       = 92
	SQLServerStatementParserWHERE                                       = 93
	SQLServerStatementParserAS                                          = 94
	SQLServerStatementParserON                                          = 95
	SQLServerStatementParserIF                                          = 96
	SQLServerStatementParserELSE                                        = 97
	SQLServerStatementParserTHEN                                        = 98
	SQLServerStatementParserFOR                                         = 99
	SQLServerStatementParserTO                                          = 100
	SQLServerStatementParserAND                                         = 101
	SQLServerStatementParserOR                                          = 102
	SQLServerStatementParserIS                                          = 103
	SQLServerStatementParserNOT                                         = 104
	SQLServerStatementParserNULL                                        = 105
	SQLServerStatementParserTRUE                                        = 106
	SQLServerStatementParserFALSE                                       = 107
	SQLServerStatementParserEXISTS                                      = 108
	SQLServerStatementParserBETWEEN                                     = 109
	SQLServerStatementParserIN                                          = 110
	SQLServerStatementParserALL                                         = 111
	SQLServerStatementParserANY                                         = 112
	SQLServerStatementParserLIKE                                        = 113
	SQLServerStatementParserORDER                                       = 114
	SQLServerStatementParserGROUP                                       = 115
	SQLServerStatementParserBY                                          = 116
	SQLServerStatementParserASC                                         = 117
	SQLServerStatementParserDESC                                        = 118
	SQLServerStatementParserHAVING                                      = 119
	SQLServerStatementParserLIMIT                                       = 120
	SQLServerStatementParserOFFSET                                      = 121
	SQLServerStatementParserBEGIN                                       = 122
	SQLServerStatementParserCOMMIT                                      = 123
	SQLServerStatementParserROLLBACK                                    = 124
	SQLServerStatementParserSAVEPOINT                                   = 125
	SQLServerStatementParserBOOLEAN                                     = 126
	SQLServerStatementParserDOUBLE                                      = 127
	SQLServerStatementParserCHAR                                        = 128
	SQLServerStatementParserCHARACTER                                   = 129
	SQLServerStatementParserARRAY                                       = 130
	SQLServerStatementParserINTERVAL                                    = 131
	SQLServerStatementParserDATE                                        = 132
	SQLServerStatementParserTIME                                        = 133
	SQLServerStatementParserTIMESTAMP                                   = 134
	SQLServerStatementParserLOCALTIME                                   = 135
	SQLServerStatementParserLOCALTIMESTAMP                              = 136
	SQLServerStatementParserYEAR                                        = 137
	SQLServerStatementParserQUARTER                                     = 138
	SQLServerStatementParserMONTH                                       = 139
	SQLServerStatementParserWEEK                                        = 140
	SQLServerStatementParserDAY                                         = 141
	SQLServerStatementParserHOUR                                        = 142
	SQLServerStatementParserMINUTE                                      = 143
	SQLServerStatementParserSECOND                                      = 144
	SQLServerStatementParserMICROSECOND                                 = 145
	SQLServerStatementParserMAX                                         = 146
	SQLServerStatementParserMIN                                         = 147
	SQLServerStatementParserSUM                                         = 148
	SQLServerStatementParserCOUNT                                       = 149
	SQLServerStatementParserAVG                                         = 150
	SQLServerStatementParserDEFAULT                                     = 151
	SQLServerStatementParserCURRENT                                     = 152
	SQLServerStatementParserENABLE                                      = 153
	SQLServerStatementParserDISABLE                                     = 154
	SQLServerStatementParserCALL                                        = 155
	SQLServerStatementParserINSTANCE                                    = 156
	SQLServerStatementParserPRESERVE                                    = 157
	SQLServerStatementParserDO                                          = 158
	SQLServerStatementParserDEFINER                                     = 159
	SQLServerStatementParserCURRENT_USER                                = 160
	SQLServerStatementParserSQL                                         = 161
	SQLServerStatementParserCASCADED                                    = 162
	SQLServerStatementParserLOCAL                                       = 163
	SQLServerStatementParserCLOSE                                       = 164
	SQLServerStatementParserOPEN                                        = 165
	SQLServerStatementParserNEXT                                        = 166
	SQLServerStatementParserNAME                                        = 167
	SQLServerStatementParserCOLLATION                                   = 168
	SQLServerStatementParserNAMES                                       = 169
	SQLServerStatementParserINTEGER                                     = 170
	SQLServerStatementParserREAL                                        = 171
	SQLServerStatementParserDECIMAL                                     = 172
	SQLServerStatementParserTYPE                                        = 173
	SQLServerStatementParserBIT                                         = 174
	SQLServerStatementParserSMALLINT                                    = 175
	SQLServerStatementParserINT                                         = 176
	SQLServerStatementParserTINYINT                                     = 177
	SQLServerStatementParserNUMERIC                                     = 178
	SQLServerStatementParserFLOAT                                       = 179
	SQLServerStatementParserBIGINT                                      = 180
	SQLServerStatementParserTEXT                                        = 181
	SQLServerStatementParserVARCHAR                                     = 182
	SQLServerStatementParserPERCENT                                     = 183
	SQLServerStatementParserTIES                                        = 184
	SQLServerStatementParserEXCEPT                                      = 185
	SQLServerStatementParserINTERSECT                                   = 186
	SQLServerStatementParserUSE                                         = 187
	SQLServerStatementParserMERGE                                       = 188
	SQLServerStatementParserLOOP                                        = 189
	SQLServerStatementParserEXPAND                                      = 190
	SQLServerStatementParserVIEWS                                       = 191
	SQLServerStatementParserFAST                                        = 192
	SQLServerStatementParserFORCE                                       = 193
	SQLServerStatementParserKEEP                                        = 194
	SQLServerStatementParserPLAN                                        = 195
	SQLServerStatementParserOPTIMIZE                                    = 196
	SQLServerStatementParserSIMPLE                                      = 197
	SQLServerStatementParserFORCED                                      = 198
	SQLServerStatementParserHINT                                        = 199
	SQLServerStatementParserREAD_ONLY                                   = 200
	SQLServerStatementParserDATABASE                                    = 201
	SQLServerStatementParserDECLARE                                     = 202
	SQLServerStatementParserCURSOR                                      = 203
	SQLServerStatementParserOF                                          = 204
	SQLServerStatementParserRETURNS                                     = 205
	SQLServerStatementParserDATEPART                                    = 206
	SQLServerStatementParserRETURN                                      = 207
	SQLServerStatementParserREADONLY                                    = 208
	SQLServerStatementParserAT                                          = 209
	SQLServerStatementParserFOR_GENERATOR                               = 210
	SQLServerStatementParserBINARY                                      = 211
	SQLServerStatementParserESCAPE                                      = 212
	SQLServerStatementParserHIDDEN_                                     = 213
	SQLServerStatementParserMOD                                         = 214
	SQLServerStatementParserPARTITION                                   = 215
	SQLServerStatementParserPARTITIONS                                  = 216
	SQLServerStatementParserTOP                                         = 217
	SQLServerStatementParserROW                                         = 218
	SQLServerStatementParserROWS                                        = 219
	SQLServerStatementParserUNKNOWN                                     = 220
	SQLServerStatementParserXOR                                         = 221
	SQLServerStatementParserALWAYS                                      = 222
	SQLServerStatementParserCASCADE                                     = 223
	SQLServerStatementParserCHECK                                       = 224
	SQLServerStatementParserGENERATED                                   = 225
	SQLServerStatementParserNO                                          = 226
	SQLServerStatementParserOPTION                                      = 227
	SQLServerStatementParserPRIVILEGES                                  = 228
	SQLServerStatementParserREFERENCES                                  = 229
	SQLServerStatementParserUSER                                        = 230
	SQLServerStatementParserROLE                                        = 231
	SQLServerStatementParserSTART                                       = 232
	SQLServerStatementParserTRANSACTION                                 = 233
	SQLServerStatementParserACTION                                      = 234
	SQLServerStatementParserALGORITHM                                   = 235
	SQLServerStatementParserAUTO                                        = 236
	SQLServerStatementParserBLOCKERS                                    = 237
	SQLServerStatementParserCLUSTERED                                   = 238
	SQLServerStatementParserNONCLUSTERED                                = 239
	SQLServerStatementParserCOLLATE                                     = 240
	SQLServerStatementParserCOLUMNSTORE                                 = 241
	SQLServerStatementParserCONTENT                                     = 242
	SQLServerStatementParserCONVERT                                     = 243
	SQLServerStatementParserYEARS                                       = 244
	SQLServerStatementParserMONTHS                                      = 245
	SQLServerStatementParserWEEKS                                       = 246
	SQLServerStatementParserDAYS                                        = 247
	SQLServerStatementParserMINUTES                                     = 248
	SQLServerStatementParserDENY                                        = 249
	SQLServerStatementParserDETERMINISTIC                               = 250
	SQLServerStatementParserDISTRIBUTION                                = 251
	SQLServerStatementParserDOCUMENT                                    = 252
	SQLServerStatementParserDURABILITY                                  = 253
	SQLServerStatementParserENCRYPTED                                   = 254
	SQLServerStatementParserEND                                         = 255
	SQLServerStatementParserFILESTREAM                                  = 256
	SQLServerStatementParserFILETABLE                                   = 257
	SQLServerStatementParserFILLFACTOR                                  = 258
	SQLServerStatementParserFOLLOWING                                   = 259
	SQLServerStatementParserHASH                                        = 260
	SQLServerStatementParserHEAP                                        = 261
	SQLServerStatementParserIDENTITY                                    = 262
	SQLServerStatementParserINBOUND                                     = 263
	SQLServerStatementParserOUTBOUND                                    = 264
	SQLServerStatementParserUNBOUNDED                                   = 265
	SQLServerStatementParserINFINITE                                    = 266
	SQLServerStatementParserLOGIN                                       = 267
	SQLServerStatementParserMASKED                                      = 268
	SQLServerStatementParserMAXDOP                                      = 269
	SQLServerStatementParserMOVE                                        = 270
	SQLServerStatementParserNOCHECK                                     = 271
	SQLServerStatementParserNONE                                        = 272
	SQLServerStatementParserOBJECT                                      = 273
	SQLServerStatementParserOFF                                         = 274
	SQLServerStatementParserONLINE                                      = 275
	SQLServerStatementParserOVER                                        = 276
	SQLServerStatementParserPAGE                                        = 277
	SQLServerStatementParserPAUSED                                      = 278
	SQLServerStatementParserPERIOD                                      = 279
	SQLServerStatementParserPERSISTED                                   = 280
	SQLServerStatementParserPRECEDING                                   = 281
	SQLServerStatementParserRANDOMIZED                                  = 282
	SQLServerStatementParserRANGE                                       = 283
	SQLServerStatementParserREBUILD                                     = 284
	SQLServerStatementParserREPLICATE                                   = 285
	SQLServerStatementParserREPLICATION                                 = 286
	SQLServerStatementParserRESUMABLE                                   = 287
	SQLServerStatementParserROWGUIDCOL                                  = 288
	SQLServerStatementParserSAVE                                        = 289
	SQLServerStatementParserSELF                                        = 290
	SQLServerStatementParserSPARSE                                      = 291
	SQLServerStatementParserSWITCH                                      = 292
	SQLServerStatementParserTRAN                                        = 293
	SQLServerStatementParserTRANCOUNT                                   = 294
	SQLServerStatementParserZONE                                        = 295
	SQLServerStatementParserEXECUTE                                     = 296
	SQLServerStatementParserEXEC                                        = 297
	SQLServerStatementParserSESSION                                     = 298
	SQLServerStatementParserCONNECT                                     = 299
	SQLServerStatementParserCONNECTION                                  = 300
	SQLServerStatementParserCATALOG                                     = 301
	SQLServerStatementParserCONTROL                                     = 302
	SQLServerStatementParserCONCAT                                      = 303
	SQLServerStatementParserTAKE                                        = 304
	SQLServerStatementParserOWNERSHIP                                   = 305
	SQLServerStatementParserDEFINITION                                  = 306
	SQLServerStatementParserAPPLICATION                                 = 307
	SQLServerStatementParserASSEMBLY                                    = 308
	SQLServerStatementParserSYMMETRIC                                   = 309
	SQLServerStatementParserASYMMETRIC                                  = 310
	SQLServerStatementParserSERVER                                      = 311
	SQLServerStatementParserRECEIVE                                     = 312
	SQLServerStatementParserCHANGE                                      = 313
	SQLServerStatementParserTRACE                                       = 314
	SQLServerStatementParserTRACKING                                    = 315
	SQLServerStatementParserRESOURCES                                   = 316
	SQLServerStatementParserSETTINGS                                    = 317
	SQLServerStatementParserSTATE                                       = 318
	SQLServerStatementParserAVAILABILITY                                = 319
	SQLServerStatementParserCREDENTIAL                                  = 320
	SQLServerStatementParserENDPOINT                                    = 321
	SQLServerStatementParserEVENT                                       = 322
	SQLServerStatementParserNOTIFICATION                                = 323
	SQLServerStatementParserLINKED                                      = 324
	SQLServerStatementParserAUDIT                                       = 325
	SQLServerStatementParserDDL                                         = 326
	SQLServerStatementParserXML                                         = 327
	SQLServerStatementParserIMPERSONATE                                 = 328
	SQLServerStatementParserSECURABLES                                  = 329
	SQLServerStatementParserAUTHENTICATE                                = 330
	SQLServerStatementParserEXTERNAL                                    = 331
	SQLServerStatementParserACCESS                                      = 332
	SQLServerStatementParserADMINISTER                                  = 333
	SQLServerStatementParserBULK                                        = 334
	SQLServerStatementParserOPERATIONS                                  = 335
	SQLServerStatementParserUNSAFE                                      = 336
	SQLServerStatementParserSHUTDOWN                                    = 337
	SQLServerStatementParserSCOPED                                      = 338
	SQLServerStatementParserCONFIGURATION                               = 339
	SQLServerStatementParserDATASPACE                                   = 340
	SQLServerStatementParserSERVICE                                     = 341
	SQLServerStatementParserCERTIFICATE                                 = 342
	SQLServerStatementParserCONTRACT                                    = 343
	SQLServerStatementParserENCRYPTION                                  = 344
	SQLServerStatementParserMASTER                                      = 345
	SQLServerStatementParserDATA                                        = 346
	SQLServerStatementParserSOURCE                                      = 347
	SQLServerStatementParserFILE                                        = 348
	SQLServerStatementParserFORMAT                                      = 349
	SQLServerStatementParserLIBRARY                                     = 350
	SQLServerStatementParserFULLTEXT                                    = 351
	SQLServerStatementParserMASK                                        = 352
	SQLServerStatementParserUNMASK                                      = 353
	SQLServerStatementParserMESSAGE                                     = 354
	SQLServerStatementParserREMOTE                                      = 355
	SQLServerStatementParserBINDING                                     = 356
	SQLServerStatementParserROUTE                                       = 357
	SQLServerStatementParserSECURITY                                    = 358
	SQLServerStatementParserPOLICY                                      = 359
	SQLServerStatementParserAGGREGATE                                   = 360
	SQLServerStatementParserQUEUE                                       = 361
	SQLServerStatementParserRULE                                        = 362
	SQLServerStatementParserSYNONYM                                     = 363
	SQLServerStatementParserCOLLECTION                                  = 364
	SQLServerStatementParserSCRIPT                                      = 365
	SQLServerStatementParserKILL                                        = 366
	SQLServerStatementParserBACKUP                                      = 367
	SQLServerStatementParserLOG                                         = 368
	SQLServerStatementParserSHOWPLAN                                    = 369
	SQLServerStatementParserSUBSCRIBE                                   = 370
	SQLServerStatementParserQUERY                                       = 371
	SQLServerStatementParserNOTIFICATIONS                               = 372
	SQLServerStatementParserCHECKPOINT                                  = 373
	SQLServerStatementParserSEQUENCE                                    = 374
	SQLServerStatementParserABORT_AFTER_WAIT                            = 375
	SQLServerStatementParserALLOW_PAGE_LOCKS                            = 376
	SQLServerStatementParserALLOW_ROW_LOCKS                             = 377
	SQLServerStatementParserALL_SPARSE_COLUMNS                          = 378
	SQLServerStatementParserBUCKET_COUNT                                = 379
	SQLServerStatementParserCOLUMNSTORE_ARCHIVE                         = 380
	SQLServerStatementParserCOLUMN_ENCRYPTION_KEY                       = 381
	SQLServerStatementParserCOLUMN_SET                                  = 382
	SQLServerStatementParserCOMPRESSION_DELAY                           = 383
	SQLServerStatementParserDATABASE_DEAULT                             = 384
	SQLServerStatementParserDATA_COMPRESSION                            = 385
	SQLServerStatementParserDATA_CONSISTENCY_CHECK                      = 386
	SQLServerStatementParserENCRYPTION_TYPE                             = 387
	SQLServerStatementParserSYSTEM_TIME                                 = 388
	SQLServerStatementParserSYSTEM_VERSIONING                           = 389
	SQLServerStatementParserTEXTIMAGE_ON                                = 390
	SQLServerStatementParserWAIT_AT_LOW_PRIORITY                        = 391
	SQLServerStatementParserSTATISTICS_INCREMENTAL                      = 392
	SQLServerStatementParserSTATISTICS_NORECOMPUTE                      = 393
	SQLServerStatementParserROUND_ROBIN                                 = 394
	SQLServerStatementParserSCHEMA_AND_DATA                             = 395
	SQLServerStatementParserSCHEMA_ONLY                                 = 396
	SQLServerStatementParserSORT_IN_TEMPDB                              = 397
	SQLServerStatementParserIGNORE_DUP_KEY                              = 398
	SQLServerStatementParserIMPLICIT_TRANSACTIONS                       = 399
	SQLServerStatementParserMAX_DURATION                                = 400
	SQLServerStatementParserMEMORY_OPTIMIZED                            = 401
	SQLServerStatementParserMIGRATION_STATE                             = 402
	SQLServerStatementParserPAD_INDEX                                   = 403
	SQLServerStatementParserREMOTE_DATA_ARCHIVE                         = 404
	SQLServerStatementParserFILESTREAM_ON                               = 405
	SQLServerStatementParserFILETABLE_COLLATE_FILENAME                  = 406
	SQLServerStatementParserFILETABLE_DIRECTORY                         = 407
	SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME   = 408
	SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME       = 409
	SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME   = 410
	SQLServerStatementParserFILTER_PREDICATE                            = 411
	SQLServerStatementParserHISTORY_RETENTION_PERIOD                    = 412
	SQLServerStatementParserHISTORY_TABLE                               = 413
	SQLServerStatementParserLOCK_ESCALATION                             = 414
	SQLServerStatementParserDROP_EXISTING                               = 415
	SQLServerStatementParserROW_NUMBER                                  = 416
	SQLServerStatementParserFETCH                                       = 417
	SQLServerStatementParserFIRST                                       = 418
	SQLServerStatementParserONLY                                        = 419
	SQLServerStatementParserMONEY                                       = 420
	SQLServerStatementParserSMALLMONEY                                  = 421
	SQLServerStatementParserDATETIMEOFFSET                              = 422
	SQLServerStatementParserDATETIME                                    = 423
	SQLServerStatementParserDATETIME2                                   = 424
	SQLServerStatementParserSMALLDATETIME                               = 425
	SQLServerStatementParserNCHAR                                       = 426
	SQLServerStatementParserNVARCHAR                                    = 427
	SQLServerStatementParserNTEXT                                       = 428
	SQLServerStatementParserVARBINARY                                   = 429
	SQLServerStatementParserIMAGE                                       = 430
	SQLServerStatementParserSQL_VARIANT                                 = 431
	SQLServerStatementParserUNIQUEIDENTIFIER                            = 432
	SQLServerStatementParserHIERARCHYID                                 = 433
	SQLServerStatementParserGEOMETRY                                    = 434
	SQLServerStatementParserGEOGRAPHY                                   = 435
	SQLServerStatementParserOUTPUT                                      = 436
	SQLServerStatementParserINSERTED                                    = 437
	SQLServerStatementParserDELETED                                     = 438
	SQLServerStatementParserASSUME_JOIN_PREDICATE_DEPENDS_ON_FILTERS    = 439
	SQLServerStatementParserASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES = 440
	SQLServerStatementParserDISABLE_BATCH_MODE_ADAPTIVE_JOINS           = 441
	SQLServerStatementParserDISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK    = 442
	SQLServerStatementParserDISABLE_DEFERRED_COMPILATION_TV             = 443
	SQLServerStatementParserDISABLE_INTERLEAVED_EXECUTION_TVF           = 444
	SQLServerStatementParserDISABLE_OPTIMIZED_NESTED_LOOP               = 445
	SQLServerStatementParserDISABLE_OPTIMIZER_ROWGOAL                   = 446
	SQLServerStatementParserDISABLE_PARAMETER_SNIFFING                  = 447
	SQLServerStatementParserDISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK      = 448
	SQLServerStatementParserDISABLE_TSQL_SCALAR_UDF_INLINING            = 449
	SQLServerStatementParserDISALLOW_BATCH_MODE                         = 450
	SQLServerStatementParserENABLE_HIST_AMENDMENT_FOR_ASC_KEYS          = 451
	SQLServerStatementParserENABLE_QUERY_OPTIMIZER_HOTFIXES             = 452
	SQLServerStatementParserFORCE_DEFAULT_CARDINALITY_ESTIMATION        = 453
	SQLServerStatementParserFORCE_LEGACY_CARDINALITY_ESTIMATION         = 454
	SQLServerStatementParserQUERY_OPTIMIZER_COMPATIBILITY_LEVEL_n       = 455
	SQLServerStatementParserQUERY_PLAN_PROFILE                          = 456
	SQLServerStatementParserEXTERNALPUSHDOWN                            = 457
	SQLServerStatementParserSCALEOUTEXECUTION                           = 458
	SQLServerStatementParserIGNORE_NONCLUSTERED_COLUMNSTORE_INDEX       = 459
	SQLServerStatementParserKEEPFIXED                                   = 460
	SQLServerStatementParserMAX_GRANT_PERCENT                           = 461
	SQLServerStatementParserMIN_GRANT_PERCENT                           = 462
	SQLServerStatementParserMAXRECURSION                                = 463
	SQLServerStatementParserNO_PERFORMANCE_SPOOL                        = 464
	SQLServerStatementParserPARAMETERIZATION                            = 465
	SQLServerStatementParserQUERYTRACEON                                = 466
	SQLServerStatementParserRECOMPILE                                   = 467
	SQLServerStatementParserROBUST                                      = 468
	SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY                 = 469
	SQLServerStatementParserDATA_DELETION                               = 470
	SQLServerStatementParserFILTER_COLUMN                               = 471
	SQLServerStatementParserRETENTION_PERIOD                            = 472
	SQLServerStatementParserCONTAINMENT                                 = 473
	SQLServerStatementParserPARTIAL                                     = 474
	SQLServerStatementParserFILENAME                                    = 475
	SQLServerStatementParserSIZE                                        = 476
	SQLServerStatementParserMAXSIZE                                     = 477
	SQLServerStatementParserFILEGROWTH                                  = 478
	SQLServerStatementParserUNLIMITED                                   = 479
	SQLServerStatementParserKB                                          = 480
	SQLServerStatementParserMB                                          = 481
	SQLServerStatementParserGB                                          = 482
	SQLServerStatementParserTB                                          = 483
	SQLServerStatementParserCONTAINS                                    = 484
	SQLServerStatementParserMEMORY_OPTIMIZED_DATA                       = 485
	SQLServerStatementParserFILEGROUP                                   = 486
	SQLServerStatementParserNON_TRANSACTED_ACCESS                       = 487
	SQLServerStatementParserDB_CHAINING                                 = 488
	SQLServerStatementParserTRUSTWORTHY                                 = 489
	SQLServerStatementParserFORWARD_ONLY                                = 490
	SQLServerStatementParserSCROLL                                      = 491
	SQLServerStatementParserSTATIC                                      = 492
	SQLServerStatementParserKEYSET                                      = 493
	SQLServerStatementParserDYNAMIC                                     = 494
	SQLServerStatementParserFAST_FORWARD                                = 495
	SQLServerStatementParserSCROLL_LOCKS                                = 496
	SQLServerStatementParserOPTIMISTIC                                  = 497
	SQLServerStatementParserTYPE_WARNING                                = 498
	SQLServerStatementParserSCHEMABINDING                               = 499
	SQLServerStatementParserCALLER                                      = 500
	SQLServerStatementParserINPUT                                       = 501
	SQLServerStatementParserCALLED                                      = 502
	SQLServerStatementParserVARYING                                     = 503
	SQLServerStatementParserOUT                                         = 504
	SQLServerStatementParserOWNER                                       = 505
	SQLServerStatementParserATOMIC                                      = 506
	SQLServerStatementParserLANGUAGE                                    = 507
	SQLServerStatementParserLEVEL                                       = 508
	SQLServerStatementParserISOLATION                                   = 509
	SQLServerStatementParserSNAPSHOT                                    = 510
	SQLServerStatementParserREPEATABLE                                  = 511
	SQLServerStatementParserREAD                                        = 512
	SQLServerStatementParserSERIALIZABLE                                = 513
	SQLServerStatementParserNATIVE_COMPILATION                          = 514
	SQLServerStatementParserVIEW_METADATA                               = 515
	SQLServerStatementParserAFTER                                       = 516
	SQLServerStatementParserINSTEAD                                     = 517
	SQLServerStatementParserAPPEND                                      = 518
	SQLServerStatementParserINCREMENT                                   = 519
	SQLServerStatementParserCYCLE                                       = 520
	SQLServerStatementParserCACHE                                       = 521
	SQLServerStatementParserMINVALUE                                    = 522
	SQLServerStatementParserMAXVALUE                                    = 523
	SQLServerStatementParserRESTART                                     = 524
	SQLServerStatementParserLOB_COMPACTION                              = 525
	SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS                     = 526
	SQLServerStatementParserREORGANIZE                                  = 527
	SQLServerStatementParserRESUME                                      = 528
	SQLServerStatementParserPAUSE                                       = 529
	SQLServerStatementParserABORT                                       = 530
	SQLServerStatementParserINCLUDE                                     = 531
	SQLServerStatementParserDISTRIBUTED                                 = 532
	SQLServerStatementParserMARK                                        = 533
	SQLServerStatementParserWORK                                        = 534
	SQLServerStatementParserREMOVE                                      = 535
	SQLServerStatementParserAUTOGROW_SINGLE_FILE                        = 536
	SQLServerStatementParserAUTOGROW_ALL_FILES                          = 537
	SQLServerStatementParserREADWRITE                                   = 538
	SQLServerStatementParserREAD_WRITE                                  = 539
	SQLServerStatementParserMODIFY                                      = 540
	SQLServerStatementParserACCELERATED_DATABASE_RECOVERY               = 541
	SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP          = 542
	SQLServerStatementParserIMMEDIATE                                   = 543
	SQLServerStatementParserNO_WAIT                                     = 544
	SQLServerStatementParserTARGET_RECOVERY_TIME                        = 545
	SQLServerStatementParserSECONDS                                     = 546
	SQLServerStatementParserHONOR_BROKER_PRIORITY                       = 547
	SQLServerStatementParserERROR_BROKER_CONVERSATIONS                  = 548
	SQLServerStatementParserNEW_BROKER                                  = 549
	SQLServerStatementParserDISABLE_BROKER                              = 550
	SQLServerStatementParserENABLE_BROKER                               = 551
	SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT        = 552
	SQLServerStatementParserREAD_COMMITTED_SNAPSHOT                     = 553
	SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION                    = 554
	SQLServerStatementParserRECURSIVE_TRIGGERS                          = 555
	SQLServerStatementParserQUOTED_IDENTIFIER                           = 556
	SQLServerStatementParserNUMERIC_ROUNDABORT                          = 557
	SQLServerStatementParserCONCAT_NULL_YIELDS_NULL                     = 558
	SQLServerStatementParserCOMPATIBILITY_LEVEL                         = 559
	SQLServerStatementParserARITHABORT                                  = 560
	SQLServerStatementParserANSI_WARNINGS                               = 561
	SQLServerStatementParserANSI_PADDING                                = 562
	SQLServerStatementParserANSI_NULLS                                  = 563
	SQLServerStatementParserANSI_NULL_DEFAULT                           = 564
	SQLServerStatementParserPAGE_VERIFY                                 = 565
	SQLServerStatementParserCHECKSUM                                    = 566
	SQLServerStatementParserTORN_PAGE_DETECTION                         = 567
	SQLServerStatementParserBULK_LOGGED                                 = 568
	SQLServerStatementParserRECOVERY                                    = 569
	SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS                 = 570
	SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS                   = 571
	SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD              = 572
	SQLServerStatementParserEXECUTION_COUNT                             = 573
	SQLServerStatementParserQUERY_CAPTURE_POLICY                        = 574
	SQLServerStatementParserWAIT_STATS_CAPTURE_MODE                     = 575
	SQLServerStatementParserMAX_PLANS_PER_QUERY                         = 576
	SQLServerStatementParserQUERY_CAPTURE_MODE                          = 577
	SQLServerStatementParserSIZE_BASED_CLEANUP_MODE                     = 578
	SQLServerStatementParserINTERVAL_LENGTH_MINUTES                     = 579
	SQLServerStatementParserMAX_STORAGE_SIZE_MB                         = 580
	SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS                 = 581
	SQLServerStatementParserCLEANUP_POLICY                              = 582
	SQLServerStatementParserCUSTOM                                      = 583
	SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS                  = 584
	SQLServerStatementParserOPERATION_MODE                              = 585
	SQLServerStatementParserQUERY_STORE                                 = 586
	SQLServerStatementParserCURSOR_DEFAULT                              = 587
	SQLServerStatementParserGLOBAL                                      = 588
	SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT                      = 589
	SQLServerStatementParserHOURS                                       = 590
	SQLServerStatementParserCHANGE_RETENTION                            = 591
	SQLServerStatementParserAUTO_CLEANUP                                = 592
	SQLServerStatementParserCHANGE_TRACKING                             = 593
	SQLServerStatementParserAUTOMATIC_TUNING                            = 594
	SQLServerStatementParserFORCE_LAST_GOOD_PLAN                        = 595
	SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC                = 596
	SQLServerStatementParserAUTO_UPDATE_STATISTICS                      = 597
	SQLServerStatementParserAUTO_SHRINK                                 = 598
	SQLServerStatementParserAUTO_CREATE_STATISTICS                      = 599
	SQLServerStatementParserINCREMENTAL                                 = 600
	SQLServerStatementParserAUTO_CLOSE                                  = 601
	SQLServerStatementParserDATA_RETENTION                              = 602
	SQLServerStatementParserTEMPORAL_HISTORY_RETENTION                  = 603
	SQLServerStatementParserEDITION                                     = 604
	SQLServerStatementParserMIXED_PAGE_ALLOCATION                       = 605
	SQLServerStatementParserDISABLED                                    = 606
	SQLServerStatementParserALLOWED                                     = 607
	SQLServerStatementParserHADR                                        = 608
	SQLServerStatementParserMULTI_USER                                  = 609
	SQLServerStatementParserRESTRICTED_USER                             = 610
	SQLServerStatementParserSINGLE_USER                                 = 611
	SQLServerStatementParserOFFLINE                                     = 612
	SQLServerStatementParserEMERGENCY                                   = 613
	SQLServerStatementParserSUSPEND                                     = 614
	SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION               = 615
	SQLServerStatementParserELASTIC_POOL                                = 616
	SQLServerStatementParserSERVICE_OBJECTIVE                           = 617
	SQLServerStatementParserDATABASE_NAME                               = 618
	SQLServerStatementParserALLOW_CONNECTIONS                           = 619
	SQLServerStatementParserGEO                                         = 620
	SQLServerStatementParserNAMED                                       = 621
	SQLServerStatementParserDATEFIRST                                   = 622
	SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY                   = 623
	SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS              = 624
	SQLServerStatementParserSECONDARY                                   = 625
	SQLServerStatementParserFAILOVER                                    = 626
	SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE                   = 627
	SQLServerStatementParserDEFAULT_LANGUAGE                            = 628
	SQLServerStatementParserINLINE                                      = 629
	SQLServerStatementParserNESTED_TRIGGERS                             = 630
	SQLServerStatementParserTRANSFORM_NOISE_WORDS                       = 631
	SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF                       = 632
	SQLServerStatementParserPERSISTENT_LOG_BUFFER                       = 633
	SQLServerStatementParserDIRECTORY_NAME                              = 634
	SQLServerStatementParserDATEFORMAT                                  = 635
	SQLServerStatementParserDELAYED_DURABILITY                          = 636
	SQLServerStatementParserAUTHORIZATION                               = 637
	SQLServerStatementParserTRANSFER                                    = 638
	SQLServerStatementParserEXPLAIN                                     = 639
	SQLServerStatementParserWITH_RECOMMENDATIONS                        = 640
	SQLServerStatementParserBATCH_SIZE                                  = 641
	SQLServerStatementParserIDENTIFIER_                                 = 642
	SQLServerStatementParserSTRING_                                     = 643
	SQLServerStatementParserNUMBER_                                     = 644
	SQLServerStatementParserINT_NUM_                                    = 645
	SQLServerStatementParserFLOAT_NUM_                                  = 646
	SQLServerStatementParserDECIMAL_NUM_                                = 647
	SQLServerStatementParserHEX_DIGIT_                                  = 648
	SQLServerStatementParserBIT_NUM_                                    = 649
	SQLServerStatementParserNCHAR_TEXT                                  = 650
)

// SQLServerStatementParser rules.
const (
	SQLServerStatementParserRULE_execute                               = 0
	SQLServerStatementParserRULE_insert                                = 1
	SQLServerStatementParserRULE_insertDefaultValue                    = 2
	SQLServerStatementParserRULE_insertValuesClause                    = 3
	SQLServerStatementParserRULE_insertSelectClause                    = 4
	SQLServerStatementParserRULE_update                                = 5
	SQLServerStatementParserRULE_assignment                            = 6
	SQLServerStatementParserRULE_setAssignmentsClause                  = 7
	SQLServerStatementParserRULE_assignmentValues                      = 8
	SQLServerStatementParserRULE_assignmentValue                       = 9
	SQLServerStatementParserRULE_delete                                = 10
	SQLServerStatementParserRULE_singleTableClause                     = 11
	SQLServerStatementParserRULE_multipleTablesClause                  = 12
	SQLServerStatementParserRULE_multipleTableNames                    = 13
	SQLServerStatementParserRULE_select                                = 14
	SQLServerStatementParserRULE_aggregationClause                     = 15
	SQLServerStatementParserRULE_selectClause                          = 16
	SQLServerStatementParserRULE_duplicateSpecification                = 17
	SQLServerStatementParserRULE_projections                           = 18
	SQLServerStatementParserRULE_projection                            = 19
	SQLServerStatementParserRULE_top                                   = 20
	SQLServerStatementParserRULE_topNum                                = 21
	SQLServerStatementParserRULE_alias                                 = 22
	SQLServerStatementParserRULE_unqualifiedShorthand                  = 23
	SQLServerStatementParserRULE_qualifiedShorthand                    = 24
	SQLServerStatementParserRULE_fromClause                            = 25
	SQLServerStatementParserRULE_tableReferences                       = 26
	SQLServerStatementParserRULE_tableReference                        = 27
	SQLServerStatementParserRULE_tableFactor                           = 28
	SQLServerStatementParserRULE_joinedTable                           = 29
	SQLServerStatementParserRULE_joinSpecification                     = 30
	SQLServerStatementParserRULE_whereClause                           = 31
	SQLServerStatementParserRULE_groupByClause                         = 32
	SQLServerStatementParserRULE_havingClause                          = 33
	SQLServerStatementParserRULE_subquery                              = 34
	SQLServerStatementParserRULE_withClause                            = 35
	SQLServerStatementParserRULE_cteClause                             = 36
	SQLServerStatementParserRULE_outputClause                          = 37
	SQLServerStatementParserRULE_outputWithColumns                     = 38
	SQLServerStatementParserRULE_outputWithColumn                      = 39
	SQLServerStatementParserRULE_outputWithAaterisk                    = 40
	SQLServerStatementParserRULE_outputTableName                       = 41
	SQLServerStatementParserRULE_queryHint                             = 42
	SQLServerStatementParserRULE_useHitName                            = 43
	SQLServerStatementParserRULE_parameterMarker                       = 44
	SQLServerStatementParserRULE_literals                              = 45
	SQLServerStatementParserRULE_stringLiterals                        = 46
	SQLServerStatementParserRULE_numberLiterals                        = 47
	SQLServerStatementParserRULE_dateTimeLiterals                      = 48
	SQLServerStatementParserRULE_hexadecimalLiterals                   = 49
	SQLServerStatementParserRULE_bitValueLiterals                      = 50
	SQLServerStatementParserRULE_booleanLiterals                       = 51
	SQLServerStatementParserRULE_nullValueLiterals                     = 52
	SQLServerStatementParserRULE_identifier                            = 53
	SQLServerStatementParserRULE_unreservedWord                        = 54
	SQLServerStatementParserRULE_databaseName                          = 55
	SQLServerStatementParserRULE_schemaName                            = 56
	SQLServerStatementParserRULE_functionName                          = 57
	SQLServerStatementParserRULE_procedureName                         = 58
	SQLServerStatementParserRULE_viewName                              = 59
	SQLServerStatementParserRULE_triggerName                           = 60
	SQLServerStatementParserRULE_sequenceName                          = 61
	SQLServerStatementParserRULE_tableName                             = 62
	SQLServerStatementParserRULE_queueName                             = 63
	SQLServerStatementParserRULE_contractName                          = 64
	SQLServerStatementParserRULE_serviceName                           = 65
	SQLServerStatementParserRULE_columnName                            = 66
	SQLServerStatementParserRULE_owner                                 = 67
	SQLServerStatementParserRULE_name                                  = 68
	SQLServerStatementParserRULE_columnNames                           = 69
	SQLServerStatementParserRULE_columnNamesWithSort                   = 70
	SQLServerStatementParserRULE_tableNames                            = 71
	SQLServerStatementParserRULE_indexName                             = 72
	SQLServerStatementParserRULE_constraintName                        = 73
	SQLServerStatementParserRULE_collationName                         = 74
	SQLServerStatementParserRULE_dataTypeLength                        = 75
	SQLServerStatementParserRULE_primaryKey                            = 76
	SQLServerStatementParserRULE_expr                                  = 77
	SQLServerStatementParserRULE_andOperator                           = 78
	SQLServerStatementParserRULE_orOperator                            = 79
	SQLServerStatementParserRULE_notOperator                           = 80
	SQLServerStatementParserRULE_booleanPrimary                        = 81
	SQLServerStatementParserRULE_comparisonOperator                    = 82
	SQLServerStatementParserRULE_predicate                             = 83
	SQLServerStatementParserRULE_bitExpr                               = 84
	SQLServerStatementParserRULE_simpleExpr                            = 85
	SQLServerStatementParserRULE_functionCall                          = 86
	SQLServerStatementParserRULE_aggregationFunction                   = 87
	SQLServerStatementParserRULE_aggregationFunctionName               = 88
	SQLServerStatementParserRULE_distinct                              = 89
	SQLServerStatementParserRULE_specialFunction                       = 90
	SQLServerStatementParserRULE_castFunction                          = 91
	SQLServerStatementParserRULE_charFunction                          = 92
	SQLServerStatementParserRULE_regularFunction                       = 93
	SQLServerStatementParserRULE_regularFunctionName                   = 94
	SQLServerStatementParserRULE_caseExpression                        = 95
	SQLServerStatementParserRULE_caseWhen                              = 96
	SQLServerStatementParserRULE_caseElse                              = 97
	SQLServerStatementParserRULE_privateExprOfDb                       = 98
	SQLServerStatementParserRULE_orderByClause                         = 99
	SQLServerStatementParserRULE_orderByItem                           = 100
	SQLServerStatementParserRULE_dataType                              = 101
	SQLServerStatementParserRULE_dataTypeName                          = 102
	SQLServerStatementParserRULE_atTimeZoneExpr                        = 103
	SQLServerStatementParserRULE_castExpr                              = 104
	SQLServerStatementParserRULE_convertExpr                           = 105
	SQLServerStatementParserRULE_windowedFunction                      = 106
	SQLServerStatementParserRULE_overClause                            = 107
	SQLServerStatementParserRULE_partitionByClause                     = 108
	SQLServerStatementParserRULE_rowRangeClause                        = 109
	SQLServerStatementParserRULE_windowFrameExtent                     = 110
	SQLServerStatementParserRULE_windowFrameBetween                    = 111
	SQLServerStatementParserRULE_windowFrameBound                      = 112
	SQLServerStatementParserRULE_windowFramePreceding                  = 113
	SQLServerStatementParserRULE_windowFrameFollowing                  = 114
	SQLServerStatementParserRULE_columnNameWithSort                    = 115
	SQLServerStatementParserRULE_indexOption                           = 116
	SQLServerStatementParserRULE_compressionOption                     = 117
	SQLServerStatementParserRULE_eqTime                                = 118
	SQLServerStatementParserRULE_eqOnOffOption                         = 119
	SQLServerStatementParserRULE_eqKey                                 = 120
	SQLServerStatementParserRULE_eqOnOff                               = 121
	SQLServerStatementParserRULE_onPartitionClause                     = 122
	SQLServerStatementParserRULE_partitionExpressions                  = 123
	SQLServerStatementParserRULE_partitionExpression                   = 124
	SQLServerStatementParserRULE_numberRange                           = 125
	SQLServerStatementParserRULE_lowPriorityLockWait                   = 126
	SQLServerStatementParserRULE_onLowPriorLockWait                    = 127
	SQLServerStatementParserRULE_ignoredIdentifier                     = 128
	SQLServerStatementParserRULE_ignoredIdentifiers                    = 129
	SQLServerStatementParserRULE_matchNone                             = 130
	SQLServerStatementParserRULE_variableName                          = 131
	SQLServerStatementParserRULE_executeAsClause                       = 132
	SQLServerStatementParserRULE_transactionName                       = 133
	SQLServerStatementParserRULE_transactionVariableName               = 134
	SQLServerStatementParserRULE_savepointName                         = 135
	SQLServerStatementParserRULE_savepointVariableName                 = 136
	SQLServerStatementParserRULE_entityType                            = 137
	SQLServerStatementParserRULE_createTable                           = 138
	SQLServerStatementParserRULE_createTableClause                     = 139
	SQLServerStatementParserRULE_createIndex                           = 140
	SQLServerStatementParserRULE_createDatabase                        = 141
	SQLServerStatementParserRULE_createFunction                        = 142
	SQLServerStatementParserRULE_createProcedure                       = 143
	SQLServerStatementParserRULE_createView                            = 144
	SQLServerStatementParserRULE_createTrigger                         = 145
	SQLServerStatementParserRULE_createSequence                        = 146
	SQLServerStatementParserRULE_createService                         = 147
	SQLServerStatementParserRULE_createSchema                          = 148
	SQLServerStatementParserRULE_alterTable                            = 149
	SQLServerStatementParserRULE_alterIndex                            = 150
	SQLServerStatementParserRULE_alterDatabase                         = 151
	SQLServerStatementParserRULE_alterProcedure                        = 152
	SQLServerStatementParserRULE_alterFunction                         = 153
	SQLServerStatementParserRULE_alterView                             = 154
	SQLServerStatementParserRULE_alterTrigger                          = 155
	SQLServerStatementParserRULE_alterSequence                         = 156
	SQLServerStatementParserRULE_alterService                          = 157
	SQLServerStatementParserRULE_alterSchema                           = 158
	SQLServerStatementParserRULE_dropTable                             = 159
	SQLServerStatementParserRULE_dropIndex                             = 160
	SQLServerStatementParserRULE_dropDatabase                          = 161
	SQLServerStatementParserRULE_dropFunction                          = 162
	SQLServerStatementParserRULE_dropProcedure                         = 163
	SQLServerStatementParserRULE_dropView                              = 164
	SQLServerStatementParserRULE_dropTrigger                           = 165
	SQLServerStatementParserRULE_dropSequence                          = 166
	SQLServerStatementParserRULE_dropService                           = 167
	SQLServerStatementParserRULE_dropSchema                            = 168
	SQLServerStatementParserRULE_truncateTable                         = 169
	SQLServerStatementParserRULE_fileTableClause                       = 170
	SQLServerStatementParserRULE_createDefinitionClause                = 171
	SQLServerStatementParserRULE_createTableDefinitions                = 172
	SQLServerStatementParserRULE_createTableDefinition                 = 173
	SQLServerStatementParserRULE_columnDefinition                      = 174
	SQLServerStatementParserRULE_columnDefinitionOption                = 175
	SQLServerStatementParserRULE_encryptedOptions                      = 176
	SQLServerStatementParserRULE_columnConstraint                      = 177
	SQLServerStatementParserRULE_computedColumnConstraint              = 178
	SQLServerStatementParserRULE_computedColumnForeignKeyConstraint    = 179
	SQLServerStatementParserRULE_computedColumnForeignKeyOnAction      = 180
	SQLServerStatementParserRULE_primaryKeyConstraint                  = 181
	SQLServerStatementParserRULE_diskTablePrimaryKeyConstraintOption   = 182
	SQLServerStatementParserRULE_clusterOption                         = 183
	SQLServerStatementParserRULE_primaryKeyWithClause                  = 184
	SQLServerStatementParserRULE_primaryKeyOnClause                    = 185
	SQLServerStatementParserRULE_onSchemaColumn                        = 186
	SQLServerStatementParserRULE_onFileGroup                           = 187
	SQLServerStatementParserRULE_onString                              = 188
	SQLServerStatementParserRULE_memoryTablePrimaryKeyConstraintOption = 189
	SQLServerStatementParserRULE_withBucket                            = 190
	SQLServerStatementParserRULE_columnForeignKeyConstraint            = 191
	SQLServerStatementParserRULE_foreignKeyOnAction                    = 192
	SQLServerStatementParserRULE_foreignKeyOn                          = 193
	SQLServerStatementParserRULE_checkConstraint                       = 194
	SQLServerStatementParserRULE_columnIndex                           = 195
	SQLServerStatementParserRULE_withIndexOption                       = 196
	SQLServerStatementParserRULE_indexOnClause                         = 197
	SQLServerStatementParserRULE_onDefault                             = 198
	SQLServerStatementParserRULE_fileStreamOn                          = 199
	SQLServerStatementParserRULE_columnConstraints                     = 200
	SQLServerStatementParserRULE_computedColumnDefinition              = 201
	SQLServerStatementParserRULE_columnSetDefinition                   = 202
	SQLServerStatementParserRULE_tableConstraint                       = 203
	SQLServerStatementParserRULE_tablePrimaryConstraint                = 204
	SQLServerStatementParserRULE_primaryKeyUnique                      = 205
	SQLServerStatementParserRULE_diskTablePrimaryConstraintOption      = 206
	SQLServerStatementParserRULE_memoryTablePrimaryConstraintOption    = 207
	SQLServerStatementParserRULE_hashWithBucket                        = 208
	SQLServerStatementParserRULE_tableForeignKeyConstraint             = 209
	SQLServerStatementParserRULE_tableIndex                            = 210
	SQLServerStatementParserRULE_indexNameOption                       = 211
	SQLServerStatementParserRULE_indexOptions                          = 212
	SQLServerStatementParserRULE_periodClause                          = 213
	SQLServerStatementParserRULE_partitionScheme                       = 214
	SQLServerStatementParserRULE_fileGroup                             = 215
	SQLServerStatementParserRULE_tableOptions                          = 216
	SQLServerStatementParserRULE_tableOption                           = 217
	SQLServerStatementParserRULE_dataDelectionOption                   = 218
	SQLServerStatementParserRULE_tableStretchOptions                   = 219
	SQLServerStatementParserRULE_tableStretchOption                    = 220
	SQLServerStatementParserRULE_migrationState_                       = 221
	SQLServerStatementParserRULE_tableOperationOption                  = 222
	SQLServerStatementParserRULE_distributionOption                    = 223
	SQLServerStatementParserRULE_dataWareHouseTableOption              = 224
	SQLServerStatementParserRULE_dataWareHousePartitionOption          = 225
	SQLServerStatementParserRULE_createIndexSpecification              = 226
	SQLServerStatementParserRULE_alterDefinitionClause                 = 227
	SQLServerStatementParserRULE_addColumnSpecification                = 228
	SQLServerStatementParserRULE_modifyColumnSpecification             = 229
	SQLServerStatementParserRULE_alterColumnOperation                  = 230
	SQLServerStatementParserRULE_alterColumnAddOptions                 = 231
	SQLServerStatementParserRULE_alterColumnAddOption                  = 232
	SQLServerStatementParserRULE_constraintForColumn                   = 233
	SQLServerStatementParserRULE_generatedColumnNamesClause            = 234
	SQLServerStatementParserRULE_generatedColumnNameClause             = 235
	SQLServerStatementParserRULE_generatedColumnName                   = 236
	SQLServerStatementParserRULE_alterDrop                             = 237
	SQLServerStatementParserRULE_alterTableDropConstraint              = 238
	SQLServerStatementParserRULE_dropConstraintName                    = 239
	SQLServerStatementParserRULE_dropConstraintWithClause              = 240
	SQLServerStatementParserRULE_dropConstraintOption                  = 241
	SQLServerStatementParserRULE_onOffOption                           = 242
	SQLServerStatementParserRULE_dropColumnSpecification               = 243
	SQLServerStatementParserRULE_dropIndexSpecification                = 244
	SQLServerStatementParserRULE_alterCheckConstraint                  = 245
	SQLServerStatementParserRULE_alterTableTrigger                     = 246
	SQLServerStatementParserRULE_alterSwitch                           = 247
	SQLServerStatementParserRULE_alterSet                              = 248
	SQLServerStatementParserRULE_setFileStreamClause                   = 249
	SQLServerStatementParserRULE_setSystemVersionClause                = 250
	SQLServerStatementParserRULE_alterSetOnClause                      = 251
	SQLServerStatementParserRULE_dataConsistencyCheckClause            = 252
	SQLServerStatementParserRULE_historyRetentionPeriodClause          = 253
	SQLServerStatementParserRULE_historyRetentionPeriod                = 254
	SQLServerStatementParserRULE_alterTableTableIndex                  = 255
	SQLServerStatementParserRULE_indexWithName                         = 256
	SQLServerStatementParserRULE_indexNonClusterClause                 = 257
	SQLServerStatementParserRULE_alterTableIndexOnClause               = 258
	SQLServerStatementParserRULE_indexClusterClause                    = 259
	SQLServerStatementParserRULE_alterTableOption                      = 260
	SQLServerStatementParserRULE_onHistoryTableClause                  = 261
	SQLServerStatementParserRULE_ifExist                               = 262
	SQLServerStatementParserRULE_createDatabaseClause                  = 263
	SQLServerStatementParserRULE_fileDefinitionClause                  = 264
	SQLServerStatementParserRULE_databaseOption                        = 265
	SQLServerStatementParserRULE_fileStreamOption                      = 266
	SQLServerStatementParserRULE_fileSpec                              = 267
	SQLServerStatementParserRULE_databaseFileSpecOption                = 268
	SQLServerStatementParserRULE_databaseFileGroup                     = 269
	SQLServerStatementParserRULE_databaseFileGroupContains             = 270
	SQLServerStatementParserRULE_databaseLogOns                        = 271
	SQLServerStatementParserRULE_declareVariable                       = 272
	SQLServerStatementParserRULE_variable                              = 273
	SQLServerStatementParserRULE_tableVariable                         = 274
	SQLServerStatementParserRULE_variTableTypeDefinition               = 275
	SQLServerStatementParserRULE_tableVariableClause                   = 276
	SQLServerStatementParserRULE_variableTableColumnDefinition         = 277
	SQLServerStatementParserRULE_variableTableColumnConstraint         = 278
	SQLServerStatementParserRULE_variableTableConstraint               = 279
	SQLServerStatementParserRULE_setVariable                           = 280
	SQLServerStatementParserRULE_setVariableClause                     = 281
	SQLServerStatementParserRULE_cursorVariable                        = 282
	SQLServerStatementParserRULE_cursorClause                          = 283
	SQLServerStatementParserRULE_compoundOperation                     = 284
	SQLServerStatementParserRULE_funcParameters                        = 285
	SQLServerStatementParserRULE_funcReturns                           = 286
	SQLServerStatementParserRULE_funcMutiReturn                        = 287
	SQLServerStatementParserRULE_funcInlineReturn                      = 288
	SQLServerStatementParserRULE_funcScalarReturn                      = 289
	SQLServerStatementParserRULE_tableTypeDefinition                   = 290
	SQLServerStatementParserRULE_compoundStatement                     = 291
	SQLServerStatementParserRULE_functionOption                        = 292
	SQLServerStatementParserRULE_validStatement                        = 293
	SQLServerStatementParserRULE_procParameters                        = 294
	SQLServerStatementParserRULE_procParameter                         = 295
	SQLServerStatementParserRULE_createOrAlterProcClause               = 296
	SQLServerStatementParserRULE_withCreateProcOption                  = 297
	SQLServerStatementParserRULE_procOption                            = 298
	SQLServerStatementParserRULE_procAsClause                          = 299
	SQLServerStatementParserRULE_procSetOption                         = 300
	SQLServerStatementParserRULE_createOrAlterViewClause               = 301
	SQLServerStatementParserRULE_viewAttribute                         = 302
	SQLServerStatementParserRULE_withCommonTableExpr                   = 303
	SQLServerStatementParserRULE_commonTableExpr                       = 304
	SQLServerStatementParserRULE_createTriggerClause                   = 305
	SQLServerStatementParserRULE_dmlTriggerOption                      = 306
	SQLServerStatementParserRULE_methodSpecifier                       = 307
	SQLServerStatementParserRULE_triggerTarget                         = 308
	SQLServerStatementParserRULE_createOrAlterSequenceClause           = 309
	SQLServerStatementParserRULE_createIndexClause                     = 310
	SQLServerStatementParserRULE_filterPredicate                       = 311
	SQLServerStatementParserRULE_conjunct                              = 312
	SQLServerStatementParserRULE_alterIndexClause                      = 313
	SQLServerStatementParserRULE_relationalIndexOption                 = 314
	SQLServerStatementParserRULE_partitionNumberRange                  = 315
	SQLServerStatementParserRULE_reorganizeOption                      = 316
	SQLServerStatementParserRULE_setIndexOption                        = 317
	SQLServerStatementParserRULE_resumableIndexOptions                 = 318
	SQLServerStatementParserRULE_alterDatabaseClause                   = 319
	SQLServerStatementParserRULE_addSecondaryOption                    = 320
	SQLServerStatementParserRULE_editionOptions                        = 321
	SQLServerStatementParserRULE_serviceObjective                      = 322
	SQLServerStatementParserRULE_alterDatabaseOptionSpec               = 323
	SQLServerStatementParserRULE_fileAndFilegroupOptions               = 324
	SQLServerStatementParserRULE_addOrModifyFilegroups                 = 325
	SQLServerStatementParserRULE_filegroupUpdatabilityOption           = 326
	SQLServerStatementParserRULE_addOrModifyFiles                      = 327
	SQLServerStatementParserRULE_acceleratedDatabaseRecovery           = 328
	SQLServerStatementParserRULE_autoOption                            = 329
	SQLServerStatementParserRULE_automaticTuningOption                 = 330
	SQLServerStatementParserRULE_changeTrackingOption                  = 331
	SQLServerStatementParserRULE_changeTrackingOptionList              = 332
	SQLServerStatementParserRULE_cursorOption                          = 333
	SQLServerStatementParserRULE_externalAccessOption                  = 334
	SQLServerStatementParserRULE_queryStoreOptions                     = 335
	SQLServerStatementParserRULE_queryStoreOptionList                  = 336
	SQLServerStatementParserRULE_queryCapturePolicyOptionList          = 337
	SQLServerStatementParserRULE_recoveryOption                        = 338
	SQLServerStatementParserRULE_sqlOption                             = 339
	SQLServerStatementParserRULE_snapshotOption                        = 340
	SQLServerStatementParserRULE_serviceBrokerOption                   = 341
	SQLServerStatementParserRULE_targetRecoveryTimeOption              = 342
	SQLServerStatementParserRULE_termination                           = 343
	SQLServerStatementParserRULE_createServiceClause                   = 344
	SQLServerStatementParserRULE_alterServiceClause                    = 345
	SQLServerStatementParserRULE_alterServiceOptArg                    = 346
	SQLServerStatementParserRULE_schemaNameClause                      = 347
	SQLServerStatementParserRULE_schemaElement                         = 348
	SQLServerStatementParserRULE_createTableAsSelectClause             = 349
	SQLServerStatementParserRULE_createTableAsSelect                   = 350
	SQLServerStatementParserRULE_createRemoteTableAsSelect             = 351
	SQLServerStatementParserRULE_withDistributionOption                = 352
	SQLServerStatementParserRULE_optionQueryHintClause                 = 353
	SQLServerStatementParserRULE_grant                                 = 354
	SQLServerStatementParserRULE_revoke                                = 355
	SQLServerStatementParserRULE_deny                                  = 356
	SQLServerStatementParserRULE_classPrivilegesClause                 = 357
	SQLServerStatementParserRULE_classTypePrivilegesClause             = 358
	SQLServerStatementParserRULE_optionForClause                       = 359
	SQLServerStatementParserRULE_classPrivileges                       = 360
	SQLServerStatementParserRULE_onClassClause                         = 361
	SQLServerStatementParserRULE_classTypePrivileges                   = 362
	SQLServerStatementParserRULE_onClassTypeClause                     = 363
	SQLServerStatementParserRULE_privilegeType                         = 364
	SQLServerStatementParserRULE_basicPermission                       = 365
	SQLServerStatementParserRULE_objectPermission                      = 366
	SQLServerStatementParserRULE_serverPermission                      = 367
	SQLServerStatementParserRULE_serverPrincipalPermission             = 368
	SQLServerStatementParserRULE_databasePermission                    = 369
	SQLServerStatementParserRULE_databasePrincipalPermission           = 370
	SQLServerStatementParserRULE_schemaPermission                      = 371
	SQLServerStatementParserRULE_serviceBrokerPermission               = 372
	SQLServerStatementParserRULE_endpointPermission                    = 373
	SQLServerStatementParserRULE_certificatePermission                 = 374
	SQLServerStatementParserRULE_symmetricKeyPermission                = 375
	SQLServerStatementParserRULE_asymmetricKeyPermission               = 376
	SQLServerStatementParserRULE_assemblyPermission                    = 377
	SQLServerStatementParserRULE_availabilityGroupPermission           = 378
	SQLServerStatementParserRULE_fullTextPermission                    = 379
	SQLServerStatementParserRULE_class_                                = 380
	SQLServerStatementParserRULE_classType                             = 381
	SQLServerStatementParserRULE_roleClause                            = 382
	SQLServerStatementParserRULE_createUser                            = 383
	SQLServerStatementParserRULE_dropUser                              = 384
	SQLServerStatementParserRULE_alterUser                             = 385
	SQLServerStatementParserRULE_createRole                            = 386
	SQLServerStatementParserRULE_dropRole                              = 387
	SQLServerStatementParserRULE_alterRole                             = 388
	SQLServerStatementParserRULE_createLogin                           = 389
	SQLServerStatementParserRULE_dropLogin                             = 390
	SQLServerStatementParserRULE_alterLogin                            = 391
	SQLServerStatementParserRULE_setTransaction                        = 392
	SQLServerStatementParserRULE_setImplicitTransactions               = 393
	SQLServerStatementParserRULE_implicitTransactionsValue             = 394
	SQLServerStatementParserRULE_beginTransaction                      = 395
	SQLServerStatementParserRULE_beginDistributedTransaction           = 396
	SQLServerStatementParserRULE_commit                                = 397
	SQLServerStatementParserRULE_commitWork                            = 398
	SQLServerStatementParserRULE_rollback                              = 399
	SQLServerStatementParserRULE_rollbackWork                          = 400
	SQLServerStatementParserRULE_savepoint                             = 401
	SQLServerStatementParserRULE_call                                  = 402
	SQLServerStatementParserRULE_explain                               = 403
	SQLServerStatementParserRULE_explainableStatement                  = 404
)

// IExecuteContext is an interface to support dynamic dispatch.
type IExecuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecuteContext differentiates from other interfaces.
	IsExecuteContext()
}

type ExecuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteContext() *ExecuteContext {
	var p = new(ExecuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_execute
	return p
}

func (*ExecuteContext) IsExecuteContext() {}

func NewExecuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteContext {
	var p = new(ExecuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_execute

	return p
}

func (s *ExecuteContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *ExecuteContext) Insert() IInsertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *ExecuteContext) Update() IUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *ExecuteContext) Delete() IDeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteContext)
}

func (s *ExecuteContext) CreateIndex() ICreateIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *ExecuteContext) AlterIndex() IAlterIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterIndexContext)
}

func (s *ExecuteContext) DropIndex() IDropIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *ExecuteContext) CreateTable() ICreateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *ExecuteContext) CreateDatabase() ICreateDatabaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDatabaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *ExecuteContext) CreateProcedure() ICreateProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *ExecuteContext) CreateView() ICreateViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateViewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *ExecuteContext) CreateTrigger() ICreateTriggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTriggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *ExecuteContext) CreateSequence() ICreateSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateSequenceContext)
}

func (s *ExecuteContext) CreateService() ICreateServiceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateServiceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateServiceContext)
}

func (s *ExecuteContext) CreateSchema() ICreateSchemaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateSchemaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateSchemaContext)
}

func (s *ExecuteContext) AlterTable() IAlterTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *ExecuteContext) AlterTrigger() IAlterTriggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTriggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTriggerContext)
}

func (s *ExecuteContext) AlterSequence() IAlterSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterSequenceContext)
}

func (s *ExecuteContext) AlterDatabase() IAlterDatabaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDatabaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *ExecuteContext) AlterService() IAlterServiceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterServiceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterServiceContext)
}

func (s *ExecuteContext) AlterSchema() IAlterSchemaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterSchemaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterSchemaContext)
}

func (s *ExecuteContext) DropTable() IDropTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *ExecuteContext) DropDatabase() IDropDatabaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropDatabaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *ExecuteContext) DropFunction() IDropFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *ExecuteContext) DropProcedure() IDropProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *ExecuteContext) DropView() IDropViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropViewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *ExecuteContext) DropTrigger() IDropTriggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropTriggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *ExecuteContext) DropSequence() IDropSequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropSequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropSequenceContext)
}

func (s *ExecuteContext) DropService() IDropServiceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropServiceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropServiceContext)
}

func (s *ExecuteContext) DropSchema() IDropSchemaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropSchemaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropSchemaContext)
}

func (s *ExecuteContext) TruncateTable() ITruncateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITruncateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *ExecuteContext) CreateFunction() ICreateFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *ExecuteContext) SetTransaction() ISetTransactionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTransactionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTransactionContext)
}

func (s *ExecuteContext) BeginTransaction() IBeginTransactionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBeginTransactionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBeginTransactionContext)
}

func (s *ExecuteContext) BeginDistributedTransaction() IBeginDistributedTransactionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBeginDistributedTransactionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBeginDistributedTransactionContext)
}

func (s *ExecuteContext) SetImplicitTransactions() ISetImplicitTransactionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetImplicitTransactionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetImplicitTransactionsContext)
}

func (s *ExecuteContext) Commit() ICommitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommitContext)
}

func (s *ExecuteContext) CommitWork() ICommitWorkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommitWorkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommitWorkContext)
}

func (s *ExecuteContext) Rollback() IRollbackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollbackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollbackContext)
}

func (s *ExecuteContext) RollbackWork() IRollbackWorkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollbackWorkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollbackWorkContext)
}

func (s *ExecuteContext) Savepoint() ISavepointContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepointContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepointContext)
}

func (s *ExecuteContext) Grant() IGrantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *ExecuteContext) Revoke() IRevokeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRevokeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *ExecuteContext) Deny() IDenyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDenyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDenyContext)
}

func (s *ExecuteContext) CreateUser() ICreateUserContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateUserContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *ExecuteContext) DropUser() IDropUserContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropUserContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *ExecuteContext) AlterUser() IAlterUserContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterUserContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *ExecuteContext) CreateRole() ICreateRoleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateRoleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *ExecuteContext) DropRole() IDropRoleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropRoleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *ExecuteContext) AlterRole() IAlterRoleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterRoleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterRoleContext)
}

func (s *ExecuteContext) CreateLogin() ICreateLoginContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateLoginContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateLoginContext)
}

func (s *ExecuteContext) DropLogin() IDropLoginContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropLoginContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropLoginContext)
}

func (s *ExecuteContext) AlterLogin() IAlterLoginContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterLoginContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterLoginContext)
}

func (s *ExecuteContext) Call() ICallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallContext)
}

func (s *ExecuteContext) Explain() IExplainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *ExecuteContext) SEMI_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEMI_, 0)
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExecute(s)
	}
}

func (s *ExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExecute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Execute() (localctx IExecuteContext) {
	this := p
	_ = this

	localctx = NewExecuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SQLServerStatementParserRULE_execute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(810)
			p.Select()
		}

	case 2:
		{
			p.SetState(811)
			p.Insert()
		}

	case 3:
		{
			p.SetState(812)
			p.Update()
		}

	case 4:
		{
			p.SetState(813)
			p.Delete()
		}

	case 5:
		{
			p.SetState(814)
			p.CreateIndex()
		}

	case 6:
		{
			p.SetState(815)
			p.AlterIndex()
		}

	case 7:
		{
			p.SetState(816)
			p.DropIndex()
		}

	case 8:
		{
			p.SetState(817)
			p.CreateTable()
		}

	case 9:
		{
			p.SetState(818)
			p.CreateDatabase()
		}

	case 10:
		{
			p.SetState(819)
			p.CreateProcedure()
		}

	case 11:
		{
			p.SetState(820)
			p.CreateView()
		}

	case 12:
		{
			p.SetState(821)
			p.CreateTrigger()
		}

	case 13:
		{
			p.SetState(822)
			p.CreateSequence()
		}

	case 14:
		{
			p.SetState(823)
			p.CreateService()
		}

	case 15:
		{
			p.SetState(824)
			p.CreateSchema()
		}

	case 16:
		{
			p.SetState(825)
			p.AlterTable()
		}

	case 17:
		{
			p.SetState(826)
			p.AlterTrigger()
		}

	case 18:
		{
			p.SetState(827)
			p.AlterSequence()
		}

	case 19:
		{
			p.SetState(828)
			p.AlterDatabase()
		}

	case 20:
		{
			p.SetState(829)
			p.AlterService()
		}

	case 21:
		{
			p.SetState(830)
			p.AlterSchema()
		}

	case 22:
		{
			p.SetState(831)
			p.DropTable()
		}

	case 23:
		{
			p.SetState(832)
			p.DropDatabase()
		}

	case 24:
		{
			p.SetState(833)
			p.DropFunction()
		}

	case 25:
		{
			p.SetState(834)
			p.DropProcedure()
		}

	case 26:
		{
			p.SetState(835)
			p.DropView()
		}

	case 27:
		{
			p.SetState(836)
			p.DropTrigger()
		}

	case 28:
		{
			p.SetState(837)
			p.DropSequence()
		}

	case 29:
		{
			p.SetState(838)
			p.DropService()
		}

	case 30:
		{
			p.SetState(839)
			p.DropSchema()
		}

	case 31:
		{
			p.SetState(840)
			p.TruncateTable()
		}

	case 32:
		{
			p.SetState(841)
			p.CreateFunction()
		}

	case 33:
		{
			p.SetState(842)
			p.SetTransaction()
		}

	case 34:
		{
			p.SetState(843)
			p.BeginTransaction()
		}

	case 35:
		{
			p.SetState(844)
			p.BeginDistributedTransaction()
		}

	case 36:
		{
			p.SetState(845)
			p.SetImplicitTransactions()
		}

	case 37:
		{
			p.SetState(846)
			p.Commit()
		}

	case 38:
		{
			p.SetState(847)
			p.CommitWork()
		}

	case 39:
		{
			p.SetState(848)
			p.Rollback()
		}

	case 40:
		{
			p.SetState(849)
			p.RollbackWork()
		}

	case 41:
		{
			p.SetState(850)
			p.Savepoint()
		}

	case 42:
		{
			p.SetState(851)
			p.Grant()
		}

	case 43:
		{
			p.SetState(852)
			p.Revoke()
		}

	case 44:
		{
			p.SetState(853)
			p.Deny()
		}

	case 45:
		{
			p.SetState(854)
			p.CreateUser()
		}

	case 46:
		{
			p.SetState(855)
			p.DropUser()
		}

	case 47:
		{
			p.SetState(856)
			p.AlterUser()
		}

	case 48:
		{
			p.SetState(857)
			p.CreateRole()
		}

	case 49:
		{
			p.SetState(858)
			p.DropRole()
		}

	case 50:
		{
			p.SetState(859)
			p.AlterRole()
		}

	case 51:
		{
			p.SetState(860)
			p.CreateLogin()
		}

	case 52:
		{
			p.SetState(861)
			p.DropLogin()
		}

	case 53:
		{
			p.SetState(862)
			p.AlterLogin()
		}

	case 54:
		{
			p.SetState(863)
			p.Call()
		}

	case 55:
		{
			p.SetState(864)
			p.Explain()
		}

	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserSEMI_ {
		{
			p.SetState(867)
			p.Match(SQLServerStatementParserSEMI_)
		}

	}

	return localctx
}

// IInsertContext is an interface to support dynamic dispatch.
type IInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertContext differentiates from other interfaces.
	IsInsertContext()
}

type InsertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertContext() *InsertContext {
	var p = new(InsertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_insert
	return p
}

func (*InsertContext) IsInsertContext() {}

func NewInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertContext {
	var p = new(InsertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_insert

	return p
}

func (s *InsertContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERT, 0)
}

func (s *InsertContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertContext) InsertDefaultValue() IInsertDefaultValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertDefaultValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertDefaultValueContext)
}

func (s *InsertContext) InsertValuesClause() IInsertValuesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertValuesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertValuesClauseContext)
}

func (s *InsertContext) InsertSelectClause() IInsertSelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertSelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertSelectClauseContext)
}

func (s *InsertContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *InsertContext) Top() ITopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopContext)
}

func (s *InsertContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTO, 0)
}

func (s *InsertContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *InsertContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *InsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterInsert(s)
	}
}

func (s *InsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitInsert(s)
	}
}

func (s *InsertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitInsert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Insert() (localctx IInsertContext) {
	this := p
	_ = this

	localctx = NewInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SQLServerStatementParserRULE_insert)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(870)
			p.WithClause()
		}

	}
	{
		p.SetState(873)
		p.Match(SQLServerStatementParserINSERT)
	}
	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(874)
			p.Top()
		}

	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserINTO {
		{
			p.SetState(877)
			p.Match(SQLServerStatementParserINTO)
		}

	}
	{
		p.SetState(880)
		p.TableName()
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		p.SetState(882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(881)
				p.Match(SQLServerStatementParserAS)
			}

		}
		{
			p.SetState(884)
			p.Alias()
		}

	}
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(887)
			p.InsertDefaultValue()
		}

	case 2:
		{
			p.SetState(888)
			p.InsertValuesClause()
		}

	case 3:
		{
			p.SetState(889)
			p.InsertSelectClause()
		}

	}

	return localctx
}

// IInsertDefaultValueContext is an interface to support dynamic dispatch.
type IInsertDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertDefaultValueContext differentiates from other interfaces.
	IsInsertDefaultValueContext()
}

type InsertDefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertDefaultValueContext() *InsertDefaultValueContext {
	var p = new(InsertDefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_insertDefaultValue
	return p
}

func (*InsertDefaultValueContext) IsInsertDefaultValueContext() {}

func NewInsertDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertDefaultValueContext {
	var p = new(InsertDefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_insertDefaultValue

	return p
}

func (s *InsertDefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertDefaultValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *InsertDefaultValueContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVALUES, 0)
}

func (s *InsertDefaultValueContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *InsertDefaultValueContext) OutputClause() IOutputClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputClauseContext)
}

func (s *InsertDefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertDefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertDefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterInsertDefaultValue(s)
	}
}

func (s *InsertDefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitInsertDefaultValue(s)
	}
}

func (s *InsertDefaultValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitInsertDefaultValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) InsertDefaultValue() (localctx IInsertDefaultValueContext) {
	this := p
	_ = this

	localctx = NewInsertDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SQLServerStatementParserRULE_insertDefaultValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(892)
			p.ColumnNames()
		}

	}
	p.SetState(896)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOUTPUT {
		{
			p.SetState(895)
			p.OutputClause()
		}

	}
	{
		p.SetState(898)
		p.Match(SQLServerStatementParserDEFAULT)
	}
	{
		p.SetState(899)
		p.Match(SQLServerStatementParserVALUES)
	}

	return localctx
}

// IInsertValuesClauseContext is an interface to support dynamic dispatch.
type IInsertValuesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertValuesClauseContext differentiates from other interfaces.
	IsInsertValuesClauseContext()
}

type InsertValuesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesClauseContext() *InsertValuesClauseContext {
	var p = new(InsertValuesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_insertValuesClause
	return p
}

func (*InsertValuesClauseContext) IsInsertValuesClauseContext() {}

func NewInsertValuesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesClauseContext {
	var p = new(InsertValuesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_insertValuesClause

	return p
}

func (s *InsertValuesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVALUES, 0)
}

func (s *InsertValuesClauseContext) AllAssignmentValues() []IAssignmentValuesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentValuesContext)(nil)).Elem())
	var tst = make([]IAssignmentValuesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentValuesContext)
		}
	}

	return tst
}

func (s *InsertValuesClauseContext) AssignmentValues(i int) IAssignmentValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValuesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValuesContext)
}

func (s *InsertValuesClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *InsertValuesClauseContext) OutputClause() IOutputClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputClauseContext)
}

func (s *InsertValuesClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *InsertValuesClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *InsertValuesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterInsertValuesClause(s)
	}
}

func (s *InsertValuesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitInsertValuesClause(s)
	}
}

func (s *InsertValuesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitInsertValuesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) InsertValuesClause() (localctx IInsertValuesClauseContext) {
	this := p
	_ = this

	localctx = NewInsertValuesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SQLServerStatementParserRULE_insertValuesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(901)
			p.ColumnNames()
		}

	}
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOUTPUT {
		{
			p.SetState(904)
			p.OutputClause()
		}

	}
	{
		p.SetState(907)
		p.Match(SQLServerStatementParserVALUES)
	}
	{
		p.SetState(908)
		p.AssignmentValues()
	}
	p.SetState(913)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(909)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(910)
			p.AssignmentValues()
		}

		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInsertSelectClauseContext is an interface to support dynamic dispatch.
type IInsertSelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertSelectClauseContext differentiates from other interfaces.
	IsInsertSelectClauseContext()
}

type InsertSelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertSelectClauseContext() *InsertSelectClauseContext {
	var p = new(InsertSelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_insertSelectClause
	return p
}

func (*InsertSelectClauseContext) IsInsertSelectClauseContext() {}

func NewInsertSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertSelectClauseContext {
	var p = new(InsertSelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_insertSelectClause

	return p
}

func (s *InsertSelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertSelectClauseContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *InsertSelectClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *InsertSelectClauseContext) OutputClause() IOutputClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputClauseContext)
}

func (s *InsertSelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertSelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertSelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterInsertSelectClause(s)
	}
}

func (s *InsertSelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitInsertSelectClause(s)
	}
}

func (s *InsertSelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitInsertSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) InsertSelectClause() (localctx IInsertSelectClauseContext) {
	this := p
	_ = this

	localctx = NewInsertSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SQLServerStatementParserRULE_insertSelectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(916)
			p.ColumnNames()
		}

	}
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOUTPUT {
		{
			p.SetState(919)
			p.OutputClause()
		}

	}
	{
		p.SetState(922)
		p.Select()
	}

	return localctx
}

// IUpdateContext is an interface to support dynamic dispatch.
type IUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdateContext differentiates from other interfaces.
	IsUpdateContext()
}

type UpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateContext() *UpdateContext {
	var p = new(UpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_update
	return p
}

func (*UpdateContext) IsUpdateContext() {}

func NewUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateContext {
	var p = new(UpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_update

	return p
}

func (s *UpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *UpdateContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *UpdateContext) SetAssignmentsClause() ISetAssignmentsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetAssignmentsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetAssignmentsClauseContext)
}

func (s *UpdateContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateContext) Top() ITopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTION, 0)
}

func (s *UpdateContext) QueryHint() IQueryHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryHintContext)
}

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitUpdate(s)
	}
}

func (s *UpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Update() (localctx IUpdateContext) {
	this := p
	_ = this

	localctx = NewUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SQLServerStatementParserRULE_update)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(924)
			p.WithClause()
		}

	}
	{
		p.SetState(927)
		p.Match(SQLServerStatementParserUPDATE)
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(928)
			p.Top()
		}

	}
	{
		p.SetState(931)
		p.TableReferences()
	}
	{
		p.SetState(932)
		p.SetAssignmentsClause()
	}
	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWHERE {
		{
			p.SetState(933)
			p.WhereClause()
		}

	}
	p.SetState(938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOPTION {
		{
			p.SetState(936)
			p.Match(SQLServerStatementParserOPTION)
		}
		{
			p.SetState(937)
			p.QueryHint()
		}

	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *AssignmentContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AssignmentContext) AssignmentValue() IAssignmentValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValueContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SQLServerStatementParserRULE_assignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(940)
		p.ColumnName()
	}
	{
		p.SetState(941)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(942)
		p.AssignmentValue()
	}

	return localctx
}

// ISetAssignmentsClauseContext is an interface to support dynamic dispatch.
type ISetAssignmentsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetAssignmentsClauseContext differentiates from other interfaces.
	IsSetAssignmentsClauseContext()
}

type SetAssignmentsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAssignmentsClauseContext() *SetAssignmentsClauseContext {
	var p = new(SetAssignmentsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setAssignmentsClause
	return p
}

func (*SetAssignmentsClauseContext) IsSetAssignmentsClauseContext() {}

func NewSetAssignmentsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAssignmentsClauseContext {
	var p = new(SetAssignmentsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setAssignmentsClause

	return p
}

func (s *SetAssignmentsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAssignmentsClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *SetAssignmentsClauseContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *SetAssignmentsClauseContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *SetAssignmentsClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *SetAssignmentsClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *SetAssignmentsClauseContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SetAssignmentsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAssignmentsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAssignmentsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetAssignmentsClause(s)
	}
}

func (s *SetAssignmentsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetAssignmentsClause(s)
	}
}

func (s *SetAssignmentsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetAssignmentsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetAssignmentsClause() (localctx ISetAssignmentsClauseContext) {
	this := p
	_ = this

	localctx = NewSetAssignmentsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SQLServerStatementParserRULE_setAssignmentsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(SQLServerStatementParserSET)
	}
	{
		p.SetState(945)
		p.Assignment()
	}
	p.SetState(950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(946)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(947)
			p.Assignment()
		}

		p.SetState(952)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFROM {
		{
			p.SetState(953)
			p.FromClause()
		}

	}

	return localctx
}

// IAssignmentValuesContext is an interface to support dynamic dispatch.
type IAssignmentValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentValuesContext differentiates from other interfaces.
	IsAssignmentValuesContext()
}

type AssignmentValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValuesContext() *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_assignmentValues
	return p
}

func (*AssignmentValuesContext) IsAssignmentValuesContext() {}

func NewAssignmentValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_assignmentValues

	return p
}

func (s *AssignmentValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValuesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AssignmentValuesContext) AllAssignmentValue() []IAssignmentValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem())
	var tst = make([]IAssignmentValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentValueContext)
		}
	}

	return tst
}

func (s *AssignmentValuesContext) AssignmentValue(i int) IAssignmentValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValueContext)
}

func (s *AssignmentValuesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AssignmentValuesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AssignmentValuesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AssignmentValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAssignmentValues(s)
	}
}

func (s *AssignmentValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAssignmentValues(s)
	}
}

func (s *AssignmentValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAssignmentValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AssignmentValues() (localctx IAssignmentValuesContext) {
	this := p
	_ = this

	localctx = NewAssignmentValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SQLServerStatementParserRULE_assignmentValues)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(957)
			p.AssignmentValue()
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(958)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(959)
				p.AssignmentValue()
			}

			p.SetState(964)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(965)
			p.Match(SQLServerStatementParserRP_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(967)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(968)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IAssignmentValueContext is an interface to support dynamic dispatch.
type IAssignmentValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentValueContext differentiates from other interfaces.
	IsAssignmentValueContext()
}

type AssignmentValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValueContext() *AssignmentValueContext {
	var p = new(AssignmentValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_assignmentValue
	return p
}

func (*AssignmentValueContext) IsAssignmentValueContext() {}

func NewAssignmentValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValueContext {
	var p = new(AssignmentValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_assignmentValue

	return p
}

func (s *AssignmentValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValueContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignmentValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *AssignmentValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAssignmentValue(s)
	}
}

func (s *AssignmentValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAssignmentValue(s)
	}
}

func (s *AssignmentValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAssignmentValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AssignmentValue() (localctx IAssignmentValueContext) {
	this := p
	_ = this

	localctx = NewAssignmentValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SQLServerStatementParserRULE_assignmentValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(973)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNOT_, SQLServerStatementParserTILDE_, SQLServerStatementParserPLUS_, SQLServerStatementParserMINUS_, SQLServerStatementParserLP_, SQLServerStatementParserLBE_, SQLServerStatementParserQUESTION_, SQLServerStatementParserAT_, SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCASE, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserTRUE, SQLServerStatementParserFALSE, SQLServerStatementParserEXISTS, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserCONVERT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_, SQLServerStatementParserNUMBER_, SQLServerStatementParserHEX_DIGIT_, SQLServerStatementParserBIT_NUM_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(971)
			p.expr(0)
		}

	case SQLServerStatementParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(972)
			p.Match(SQLServerStatementParserDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeleteContext is an interface to support dynamic dispatch.
type IDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteContext differentiates from other interfaces.
	IsDeleteContext()
}

type DeleteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteContext() *DeleteContext {
	var p = new(DeleteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_delete
	return p
}

func (*DeleteContext) IsDeleteContext() {}

func NewDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteContext {
	var p = new(DeleteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_delete

	return p
}

func (s *DeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETE, 0)
}

func (s *DeleteContext) SingleTableClause() ISingleTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleTableClauseContext)
}

func (s *DeleteContext) MultipleTablesClause() IMultipleTablesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleTablesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultipleTablesClauseContext)
}

func (s *DeleteContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteContext) Top() ITopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopContext)
}

func (s *DeleteContext) OutputClause() IOutputClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputClauseContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTION, 0)
}

func (s *DeleteContext) QueryHint() IQueryHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryHintContext)
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDelete(s)
	}
}

func (s *DeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Delete() (localctx IDeleteContext) {
	this := p
	_ = this

	localctx = NewDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SQLServerStatementParserRULE_delete)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(975)
			p.WithClause()
		}

	}
	{
		p.SetState(978)
		p.Match(SQLServerStatementParserDELETE)
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(979)
			p.Top()
		}

	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(982)
			p.SingleTableClause()
		}

	case 2:
		{
			p.SetState(983)
			p.MultipleTablesClause()
		}

	}
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOUTPUT {
		{
			p.SetState(986)
			p.OutputClause()
		}

	}
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWHERE {
		{
			p.SetState(989)
			p.WhereClause()
		}

	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOPTION {
		{
			p.SetState(992)
			p.Match(SQLServerStatementParserOPTION)
		}
		{
			p.SetState(993)
			p.QueryHint()
		}

	}

	return localctx
}

// ISingleTableClauseContext is an interface to support dynamic dispatch.
type ISingleTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleTableClauseContext differentiates from other interfaces.
	IsSingleTableClauseContext()
}

type SingleTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableClauseContext() *SingleTableClauseContext {
	var p = new(SingleTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_singleTableClause
	return p
}

func (*SingleTableClauseContext) IsSingleTableClauseContext() {}

func NewSingleTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableClauseContext {
	var p = new(SingleTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_singleTableClause

	return p
}

func (s *SingleTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleTableClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFROM, 0)
}

func (s *SingleTableClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *SingleTableClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *SingleTableClauseContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *SingleTableClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *SingleTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSingleTableClause(s)
	}
}

func (s *SingleTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSingleTableClause(s)
	}
}

func (s *SingleTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSingleTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SingleTableClause() (localctx ISingleTableClauseContext) {
	this := p
	_ = this

	localctx = NewSingleTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SQLServerStatementParserRULE_singleTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFROM {
		{
			p.SetState(996)
			p.Match(SQLServerStatementParserFROM)
		}

	}
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(999)
			p.Match(SQLServerStatementParserLP_)
		}

	}
	{
		p.SetState(1002)
		p.TableName()
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserRP_ {
		{
			p.SetState(1003)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		p.SetState(1007)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(1006)
				p.Match(SQLServerStatementParserAS)
			}

		}
		{
			p.SetState(1009)
			p.Alias()
		}

	}

	return localctx
}

// IMultipleTablesClauseContext is an interface to support dynamic dispatch.
type IMultipleTablesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleTablesClauseContext differentiates from other interfaces.
	IsMultipleTablesClauseContext()
}

type MultipleTablesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleTablesClauseContext() *MultipleTablesClauseContext {
	var p = new(MultipleTablesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_multipleTablesClause
	return p
}

func (*MultipleTablesClauseContext) IsMultipleTablesClauseContext() {}

func NewMultipleTablesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleTablesClauseContext {
	var p = new(MultipleTablesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_multipleTablesClause

	return p
}

func (s *MultipleTablesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleTablesClauseContext) MultipleTableNames() IMultipleTableNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultipleTableNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultipleTableNamesContext)
}

func (s *MultipleTablesClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFROM, 0)
}

func (s *MultipleTablesClauseContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *MultipleTablesClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSING, 0)
}

func (s *MultipleTablesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleTablesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleTablesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMultipleTablesClause(s)
	}
}

func (s *MultipleTablesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMultipleTablesClause(s)
	}
}

func (s *MultipleTablesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMultipleTablesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MultipleTablesClause() (localctx IMultipleTablesClauseContext) {
	this := p
	_ = this

	localctx = NewMultipleTablesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SQLServerStatementParserRULE_multipleTablesClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1012)
			p.MultipleTableNames()
		}
		{
			p.SetState(1013)
			p.Match(SQLServerStatementParserFROM)
		}
		{
			p.SetState(1014)
			p.TableReferences()
		}

	case SQLServerStatementParserFROM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1016)
			p.Match(SQLServerStatementParserFROM)
		}
		{
			p.SetState(1017)
			p.MultipleTableNames()
		}
		{
			p.SetState(1018)
			p.Match(SQLServerStatementParserUSING)
		}
		{
			p.SetState(1019)
			p.TableReferences()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMultipleTableNamesContext is an interface to support dynamic dispatch.
type IMultipleTableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleTableNamesContext differentiates from other interfaces.
	IsMultipleTableNamesContext()
}

type MultipleTableNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleTableNamesContext() *MultipleTableNamesContext {
	var p = new(MultipleTableNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_multipleTableNames
	return p
}

func (*MultipleTableNamesContext) IsMultipleTableNamesContext() {}

func NewMultipleTableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleTableNamesContext {
	var p = new(MultipleTableNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_multipleTableNames

	return p
}

func (s *MultipleTableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleTableNamesContext) AllTableName() []ITableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableNameContext)(nil)).Elem())
	var tst = make([]ITableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableNameContext)
		}
	}

	return tst
}

func (s *MultipleTableNamesContext) TableName(i int) ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MultipleTableNamesContext) AllDOT_ASTERISK_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDOT_ASTERISK_)
}

func (s *MultipleTableNamesContext) DOT_ASTERISK_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_ASTERISK_, i)
}

func (s *MultipleTableNamesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *MultipleTableNamesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *MultipleTableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleTableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleTableNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMultipleTableNames(s)
	}
}

func (s *MultipleTableNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMultipleTableNames(s)
	}
}

func (s *MultipleTableNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMultipleTableNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MultipleTableNames() (localctx IMultipleTableNamesContext) {
	this := p
	_ = this

	localctx = NewMultipleTableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SQLServerStatementParserRULE_multipleTableNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.TableName()
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserDOT_ASTERISK_ {
		{
			p.SetState(1024)
			p.Match(SQLServerStatementParserDOT_ASTERISK_)
		}

	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1027)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1028)
			p.TableName()
		}
		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserDOT_ASTERISK_ {
			{
				p.SetState(1029)
				p.Match(SQLServerStatementParserDOT_ASTERISK_)
			}

		}

		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectContext is an interface to support dynamic dispatch.
type ISelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectContext differentiates from other interfaces.
	IsSelectContext()
}

type SelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectContext() *SelectContext {
	var p = new(SelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_select
	return p
}

func (*SelectContext) IsSelectContext() {}

func NewSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectContext {
	var p = new(SelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_select

	return p
}

func (s *SelectContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectContext) AggregationClause() IAggregationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *SelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSelect(s)
	}
}

func (s *SelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSelect(s)
	}
}

func (s *SelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Select() (localctx ISelectContext) {
	this := p
	_ = this

	localctx = NewSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SQLServerStatementParserRULE_select)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1037)
		p.AggregationClause()
	}

	return localctx
}

// IAggregationClauseContext is an interface to support dynamic dispatch.
type IAggregationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregationClauseContext differentiates from other interfaces.
	IsAggregationClauseContext()
}

type AggregationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationClauseContext() *AggregationClauseContext {
	var p = new(AggregationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_aggregationClause
	return p
}

func (*AggregationClauseContext) IsAggregationClauseContext() {}

func NewAggregationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationClauseContext {
	var p = new(AggregationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_aggregationClause

	return p
}

func (s *AggregationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationClauseContext) AllSelectClause() []ISelectClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem())
	var tst = make([]ISelectClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectClauseContext)
		}
	}

	return tst
}

func (s *AggregationClauseContext) SelectClause(i int) ISelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *AggregationClauseContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserUNION)
}

func (s *AggregationClauseContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNION, i)
}

func (s *AggregationClauseContext) AllEXCEPT() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEXCEPT)
}

func (s *AggregationClauseContext) EXCEPT(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXCEPT, i)
}

func (s *AggregationClauseContext) AllINTERSECT() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserINTERSECT)
}

func (s *AggregationClauseContext) INTERSECT(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTERSECT, i)
}

func (s *AggregationClauseContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserALL)
}

func (s *AggregationClauseContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, i)
}

func (s *AggregationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAggregationClause(s)
	}
}

func (s *AggregationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAggregationClause(s)
	}
}

func (s *AggregationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAggregationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AggregationClause() (localctx IAggregationClauseContext) {
	this := p
	_ = this

	localctx = NewAggregationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SQLServerStatementParserRULE_aggregationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.SelectClause()
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserUNION || _la == SQLServerStatementParserEXCEPT || _la == SQLServerStatementParserINTERSECT {
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserUNION:
			{
				p.SetState(1040)
				p.Match(SQLServerStatementParserUNION)
			}
			p.SetState(1042)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserALL {
				{
					p.SetState(1041)
					p.Match(SQLServerStatementParserALL)
				}

			}

		case SQLServerStatementParserEXCEPT:
			{
				p.SetState(1044)
				p.Match(SQLServerStatementParserEXCEPT)
			}

		case SQLServerStatementParserINTERSECT:
			{
				p.SetState(1045)
				p.Match(SQLServerStatementParserINTERSECT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1048)
			p.SelectClause()
		}

		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELECT, 0)
}

func (s *SelectClauseContext) Projections() IProjectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProjectionsContext)
}

func (s *SelectClauseContext) DuplicateSpecification() IDuplicateSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDuplicateSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDuplicateSpecificationContext)
}

func (s *SelectClauseContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectClauseContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectClauseContext) GroupByClause() IGroupByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectClauseContext) HavingClause() IHavingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHavingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectClauseContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SelectClause() (localctx ISelectClauseContext) {
	this := p
	_ = this

	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SQLServerStatementParserRULE_selectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(SQLServerStatementParserSELECT)
	}
	p.SetState(1056)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserDISTINCT || _la == SQLServerStatementParserALL {
		{
			p.SetState(1055)
			p.DuplicateSpecification()
		}

	}
	{
		p.SetState(1058)
		p.Projections()
	}
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFROM {
		{
			p.SetState(1059)
			p.FromClause()
		}

	}
	p.SetState(1063)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWHERE {
		{
			p.SetState(1062)
			p.WhereClause()
		}

	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserGROUP {
		{
			p.SetState(1065)
			p.GroupByClause()
		}

	}
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserHAVING {
		{
			p.SetState(1068)
			p.HavingClause()
		}

	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserORDER {
		{
			p.SetState(1071)
			p.OrderByClause()
		}

	}

	return localctx
}

// IDuplicateSpecificationContext is an interface to support dynamic dispatch.
type IDuplicateSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDuplicateSpecificationContext differentiates from other interfaces.
	IsDuplicateSpecificationContext()
}

type DuplicateSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDuplicateSpecificationContext() *DuplicateSpecificationContext {
	var p = new(DuplicateSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_duplicateSpecification
	return p
}

func (*DuplicateSpecificationContext) IsDuplicateSpecificationContext() {}

func NewDuplicateSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DuplicateSpecificationContext {
	var p = new(DuplicateSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_duplicateSpecification

	return p
}

func (s *DuplicateSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DuplicateSpecificationContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *DuplicateSpecificationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISTINCT, 0)
}

func (s *DuplicateSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DuplicateSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DuplicateSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDuplicateSpecification(s)
	}
}

func (s *DuplicateSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDuplicateSpecification(s)
	}
}

func (s *DuplicateSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDuplicateSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DuplicateSpecification() (localctx IDuplicateSpecificationContext) {
	this := p
	_ = this

	localctx = NewDuplicateSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SQLServerStatementParserRULE_duplicateSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserDISTINCT || _la == SQLServerStatementParserALL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IProjectionsContext is an interface to support dynamic dispatch.
type IProjectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionsContext differentiates from other interfaces.
	IsProjectionsContext()
}

type ProjectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionsContext() *ProjectionsContext {
	var p = new(ProjectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_projections
	return p
}

func (*ProjectionsContext) IsProjectionsContext() {}

func NewProjectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionsContext {
	var p = new(ProjectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_projections

	return p
}

func (s *ProjectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionsContext) UnqualifiedShorthand() IUnqualifiedShorthandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualifiedShorthandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedShorthandContext)
}

func (s *ProjectionsContext) AllProjection() []IProjectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProjectionContext)(nil)).Elem())
	var tst = make([]IProjectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProjectionContext)
		}
	}

	return tst
}

func (s *ProjectionsContext) Projection(i int) IProjectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProjectionContext)
}

func (s *ProjectionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ProjectionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ProjectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProjections(s)
	}
}

func (s *ProjectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProjections(s)
	}
}

func (s *ProjectionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProjections(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Projections() (localctx IProjectionsContext) {
	this := p
	_ = this

	localctx = NewProjectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SQLServerStatementParserRULE_projections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserASTERISK_:
		{
			p.SetState(1076)
			p.UnqualifiedShorthand()
		}

	case SQLServerStatementParserNOT_, SQLServerStatementParserTILDE_, SQLServerStatementParserPLUS_, SQLServerStatementParserMINUS_, SQLServerStatementParserLP_, SQLServerStatementParserLBE_, SQLServerStatementParserQUESTION_, SQLServerStatementParserAT_, SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCASE, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserTRUE, SQLServerStatementParserFALSE, SQLServerStatementParserEXISTS, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserCONVERT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_, SQLServerStatementParserNUMBER_, SQLServerStatementParserHEX_DIGIT_, SQLServerStatementParserBIT_NUM_:
		{
			p.SetState(1077)
			p.Projection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1080)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1081)
			p.Projection()
		}

		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProjectionContext is an interface to support dynamic dispatch.
type IProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionContext differentiates from other interfaces.
	IsProjectionContext()
}

type ProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionContext() *ProjectionContext {
	var p = new(ProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_projection
	return p
}

func (*ProjectionContext) IsProjectionContext() {}

func NewProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionContext {
	var p = new(ProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_projection

	return p
}

func (s *ProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionContext) Top() ITopContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopContext)
}

func (s *ProjectionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ProjectionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ProjectionContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *ProjectionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *ProjectionContext) QualifiedShorthand() IQualifiedShorthandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedShorthandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedShorthandContext)
}

func (s *ProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProjection(s)
	}
}

func (s *ProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProjection(s)
	}
}

func (s *ProjectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProjection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Projection() (localctx IProjectionContext) {
	this := p
	_ = this

	localctx = NewProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SQLServerStatementParserRULE_projection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1087)
				p.Top()
			}

		case 2:
			{
				p.SetState(1088)
				p.ColumnName()
			}

		case 3:
			{
				p.SetState(1089)
				p.expr(0)
			}

		}
		p.SetState(1096)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			p.SetState(1093)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserAS {
				{
					p.SetState(1092)
					p.Match(SQLServerStatementParserAS)
				}

			}
			{
				p.SetState(1095)
				p.Alias()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.QualifiedShorthand()
		}

	}

	return localctx
}

// ITopContext is an interface to support dynamic dispatch.
type ITopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopContext differentiates from other interfaces.
	IsTopContext()
}

type TopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopContext() *TopContext {
	var p = new(TopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_top
	return p
}

func (*TopContext) IsTopContext() {}

func NewTopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopContext {
	var p = new(TopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_top

	return p
}

func (s *TopContext) GetParser() antlr.Parser { return s.parser }

func (s *TopContext) TOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOP, 0)
}

func (s *TopContext) TopNum() ITopNumContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopNumContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITopNumContext)
}

func (s *TopContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *TopContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *TopContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *TopContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *TopContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERCENT, 0)
}

func (s *TopContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *TopContext) TIES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTIES, 0)
}

func (s *TopContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW_NUMBER, 0)
}

func (s *TopContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOVER, 0)
}

func (s *TopContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *TopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTop(s)
	}
}

func (s *TopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTop(s)
	}
}

func (s *TopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Top() (localctx ITopContext) {
	this := p
	_ = this

	localctx = NewTopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SQLServerStatementParserRULE_top)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(SQLServerStatementParserTOP)
	}
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(1102)
			p.Match(SQLServerStatementParserLP_)
		}

	}
	{
		p.SetState(1105)
		p.TopNum()
	}
	p.SetState(1107)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1106)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	p.SetState(1110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPERCENT {
		{
			p.SetState(1109)
			p.Match(SQLServerStatementParserPERCENT)
		}

	}
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1112)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(1113)
			p.Match(SQLServerStatementParserTIES)
		}

	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1116)
			p.Match(SQLServerStatementParserROW_NUMBER)
		}
		{
			p.SetState(1117)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1118)
			p.Match(SQLServerStatementParserRP_)
		}
		{
			p.SetState(1119)
			p.Match(SQLServerStatementParserOVER)
		}
		{
			p.SetState(1120)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1121)
			p.OrderByClause()
		}
		{
			p.SetState(1122)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// ITopNumContext is an interface to support dynamic dispatch.
type ITopNumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopNumContext differentiates from other interfaces.
	IsTopNumContext()
}

type TopNumContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopNumContext() *TopNumContext {
	var p = new(TopNumContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_topNum
	return p
}

func (*TopNumContext) IsTopNumContext() {}

func NewTopNumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopNumContext {
	var p = new(TopNumContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_topNum

	return p
}

func (s *TopNumContext) GetParser() antlr.Parser { return s.parser }

func (s *TopNumContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *TopNumContext) ParameterMarker() IParameterMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterMarkerContext)
}

func (s *TopNumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopNumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopNumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTopNum(s)
	}
}

func (s *TopNumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTopNum(s)
	}
}

func (s *TopNumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTopNum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TopNum() (localctx ITopNumContext) {
	this := p
	_ = this

	localctx = NewTopNumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SQLServerStatementParserRULE_topNum)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1128)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserMINUS_, SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1126)
			p.NumberLiterals()
		}

	case SQLServerStatementParserQUESTION_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1127)
			p.ParameterMarker()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Alias() (localctx IAliasContext) {
	this := p
	_ = this

	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SQLServerStatementParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1132)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1130)
			p.Identifier()
		}

	case SQLServerStatementParserSTRING_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1131)
			p.Match(SQLServerStatementParserSTRING_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnqualifiedShorthandContext is an interface to support dynamic dispatch.
type IUnqualifiedShorthandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnqualifiedShorthandContext differentiates from other interfaces.
	IsUnqualifiedShorthandContext()
}

type UnqualifiedShorthandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualifiedShorthandContext() *UnqualifiedShorthandContext {
	var p = new(UnqualifiedShorthandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_unqualifiedShorthand
	return p
}

func (*UnqualifiedShorthandContext) IsUnqualifiedShorthandContext() {}

func NewUnqualifiedShorthandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnqualifiedShorthandContext {
	var p = new(UnqualifiedShorthandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_unqualifiedShorthand

	return p
}

func (s *UnqualifiedShorthandContext) GetParser() antlr.Parser { return s.parser }

func (s *UnqualifiedShorthandContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASTERISK_, 0)
}

func (s *UnqualifiedShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedShorthandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnqualifiedShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterUnqualifiedShorthand(s)
	}
}

func (s *UnqualifiedShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitUnqualifiedShorthand(s)
	}
}

func (s *UnqualifiedShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitUnqualifiedShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) UnqualifiedShorthand() (localctx IUnqualifiedShorthandContext) {
	this := p
	_ = this

	localctx = NewUnqualifiedShorthandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SQLServerStatementParserRULE_unqualifiedShorthand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Match(SQLServerStatementParserASTERISK_)
	}

	return localctx
}

// IQualifiedShorthandContext is an interface to support dynamic dispatch.
type IQualifiedShorthandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedShorthandContext differentiates from other interfaces.
	IsQualifiedShorthandContext()
}

type QualifiedShorthandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedShorthandContext() *QualifiedShorthandContext {
	var p = new(QualifiedShorthandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_qualifiedShorthand
	return p
}

func (*QualifiedShorthandContext) IsQualifiedShorthandContext() {}

func NewQualifiedShorthandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedShorthandContext {
	var p = new(QualifiedShorthandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_qualifiedShorthand

	return p
}

func (s *QualifiedShorthandContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedShorthandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedShorthandContext) DOT_ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_ASTERISK_, 0)
}

func (s *QualifiedShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedShorthandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQualifiedShorthand(s)
	}
}

func (s *QualifiedShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQualifiedShorthand(s)
	}
}

func (s *QualifiedShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQualifiedShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QualifiedShorthand() (localctx IQualifiedShorthandContext) {
	this := p
	_ = this

	localctx = NewQualifiedShorthandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SQLServerStatementParserRULE_qualifiedShorthand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Identifier()
	}
	{
		p.SetState(1137)
		p.Match(SQLServerStatementParserDOT_ASTERISK_)
	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFROM, 0)
}

func (s *FromClauseContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FromClause() (localctx IFromClauseContext) {
	this := p
	_ = this

	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SQLServerStatementParserRULE_fromClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.Match(SQLServerStatementParserFROM)
	}
	{
		p.SetState(1140)
		p.TableReferences()
	}

	return localctx
}

// ITableReferencesContext is an interface to support dynamic dispatch.
type ITableReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableReferencesContext differentiates from other interfaces.
	IsTableReferencesContext()
}

type TableReferencesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferencesContext() *TableReferencesContext {
	var p = new(TableReferencesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableReferences
	return p
}

func (*TableReferencesContext) IsTableReferencesContext() {}

func NewTableReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferencesContext {
	var p = new(TableReferencesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableReferences

	return p
}

func (s *TableReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferencesContext) AllTableReference() []ITableReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableReferenceContext)(nil)).Elem())
	var tst = make([]ITableReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableReferenceContext)
		}
	}

	return tst
}

func (s *TableReferencesContext) TableReference(i int) ITableReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *TableReferencesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *TableReferencesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *TableReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableReferences(s)
	}
}

func (s *TableReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableReferences(s)
	}
}

func (s *TableReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableReferences() (localctx ITableReferencesContext) {
	this := p
	_ = this

	localctx = NewTableReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SQLServerStatementParserRULE_tableReferences)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1142)
		p.TableReference()
	}
	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1143)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1144)
			p.TableReference()
		}

		p.SetState(1149)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableReference
	return p
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TableFactor() ITableFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *TableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinedTableContext)(nil)).Elem())
	var tst = make([]IJoinedTableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinedTableContext)
		}
	}

	return tst
}

func (s *TableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinedTableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (s *TableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableReference() (localctx ITableReferenceContext) {
	this := p
	_ = this

	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SQLServerStatementParserRULE_tableReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.TableFactor()
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(SQLServerStatementParserNATURAL-84))|(1<<(SQLServerStatementParserJOIN-84))|(1<<(SQLServerStatementParserFULL-84))|(1<<(SQLServerStatementParserINNER-84))|(1<<(SQLServerStatementParserLEFT-84))|(1<<(SQLServerStatementParserRIGHT-84))|(1<<(SQLServerStatementParserCROSS-84)))) != 0 {
		{
			p.SetState(1151)
			p.JoinedTable()
		}

		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableFactorContext is an interface to support dynamic dispatch.
type ITableFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableFactorContext differentiates from other interfaces.
	IsTableFactorContext()
}

type TableFactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFactorContext() *TableFactorContext {
	var p = new(TableFactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableFactor
	return p
}

func (*TableFactorContext) IsTableFactorContext() {}

func NewTableFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFactorContext {
	var p = new(TableFactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableFactor

	return p
}

func (s *TableFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFactorContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableFactorContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *TableFactorContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *TableFactorContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *TableFactorContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *TableFactorContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *TableFactorContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *TableFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableFactor(s)
	}
}

func (s *TableFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableFactor(s)
	}
}

func (s *TableFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableFactor() (localctx ITableFactorContext) {
	this := p
	_ = this

	localctx = NewTableFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SQLServerStatementParserRULE_tableFactor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1157)
			p.TableName()
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			p.SetState(1159)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserAS {
				{
					p.SetState(1158)
					p.Match(SQLServerStatementParserAS)
				}

			}
			{
				p.SetState(1161)
				p.Alias()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1164)
			p.Subquery()
		}
		p.SetState(1166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(1165)
				p.Match(SQLServerStatementParserAS)
			}

		}
		{
			p.SetState(1168)
			p.Alias()
		}
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(1169)
				p.ColumnNames()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1172)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1173)
			p.TableReferences()
		}
		{
			p.SetState(1174)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IJoinedTableContext is an interface to support dynamic dispatch.
type IJoinedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinedTableContext differentiates from other interfaces.
	IsJoinedTableContext()
}

type JoinedTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedTableContext() *JoinedTableContext {
	var p = new(JoinedTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_joinedTable
	return p
}

func (*JoinedTableContext) IsJoinedTableContext() {}

func NewJoinedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedTableContext {
	var p = new(JoinedTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_joinedTable

	return p
}

func (s *JoinedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedTableContext) TableFactor() ITableFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *JoinedTableContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserJOIN, 0)
}

func (s *JoinedTableContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNATURAL, 0)
}

func (s *JoinedTableContext) JoinSpecification() IJoinSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinSpecificationContext)
}

func (s *JoinedTableContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINNER, 0)
}

func (s *JoinedTableContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCROSS, 0)
}

func (s *JoinedTableContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLEFT, 0)
}

func (s *JoinedTableContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRIGHT, 0)
}

func (s *JoinedTableContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULL, 0)
}

func (s *JoinedTableContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTER, 0)
}

func (s *JoinedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterJoinedTable(s)
	}
}

func (s *JoinedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitJoinedTable(s)
	}
}

func (s *JoinedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitJoinedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) JoinedTable() (localctx IJoinedTableContext) {
	this := p
	_ = this

	localctx = NewJoinedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SQLServerStatementParserRULE_joinedTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1202)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNATURAL {
			{
				p.SetState(1178)
				p.Match(SQLServerStatementParserNATURAL)
			}

		}

		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserINNER || _la == SQLServerStatementParserCROSS {
			{
				p.SetState(1181)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserINNER || _la == SQLServerStatementParserCROSS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1184)
			p.Match(SQLServerStatementParserJOIN)
		}

		{
			p.SetState(1186)
			p.TableFactor()
		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserUSING || _la == SQLServerStatementParserON {
			{
				p.SetState(1187)
				p.JoinSpecification()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNATURAL {
			{
				p.SetState(1190)
				p.Match(SQLServerStatementParserNATURAL)
			}

		}
		{
			p.SetState(1193)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(SQLServerStatementParserFULL-86))|(1<<(SQLServerStatementParserLEFT-86))|(1<<(SQLServerStatementParserRIGHT-86)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserOUTER {
			{
				p.SetState(1194)
				p.Match(SQLServerStatementParserOUTER)
			}

		}
		{
			p.SetState(1197)
			p.Match(SQLServerStatementParserJOIN)
		}
		{
			p.SetState(1198)
			p.TableFactor()
		}
		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserUSING || _la == SQLServerStatementParserON {
			{
				p.SetState(1199)
				p.JoinSpecification()
			}

		}

	}

	return localctx
}

// IJoinSpecificationContext is an interface to support dynamic dispatch.
type IJoinSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinSpecificationContext differentiates from other interfaces.
	IsJoinSpecificationContext()
}

type JoinSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSpecificationContext() *JoinSpecificationContext {
	var p = new(JoinSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_joinSpecification
	return p
}

func (*JoinSpecificationContext) IsJoinSpecificationContext() {}

func NewJoinSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSpecificationContext {
	var p = new(JoinSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_joinSpecification

	return p
}

func (s *JoinSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSpecificationContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *JoinSpecificationContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JoinSpecificationContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSING, 0)
}

func (s *JoinSpecificationContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *JoinSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterJoinSpecification(s)
	}
}

func (s *JoinSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitJoinSpecification(s)
	}
}

func (s *JoinSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitJoinSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) JoinSpecification() (localctx IJoinSpecificationContext) {
	this := p
	_ = this

	localctx = NewJoinSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SQLServerStatementParserRULE_joinSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1208)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1204)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(1205)
			p.expr(0)
		}

	case SQLServerStatementParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1206)
			p.Match(SQLServerStatementParserUSING)
		}
		{
			p.SetState(1207)
			p.ColumnNames()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWHERE, 0)
}

func (s *WhereClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WhereClause() (localctx IWhereClauseContext) {
	this := p
	_ = this

	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SQLServerStatementParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		p.Match(SQLServerStatementParserWHERE)
	}
	{
		p.SetState(1211)
		p.expr(0)
	}

	return localctx
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_groupByClause
	return p
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBY, 0)
}

func (s *GroupByClauseContext) AllOrderByItem() []IOrderByItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem())
	var tst = make([]IOrderByItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByItemContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) OrderByItem(i int) IOrderByItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *GroupByClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) GroupByClause() (localctx IGroupByClauseContext) {
	this := p
	_ = this

	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SQLServerStatementParserRULE_groupByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1213)
		p.Match(SQLServerStatementParserGROUP)
	}
	{
		p.SetState(1214)
		p.Match(SQLServerStatementParserBY)
	}
	{
		p.SetState(1215)
		p.OrderByItem()
	}
	p.SetState(1220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1216)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1217)
			p.OrderByItem()
		}

		p.SetState(1222)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_havingClause
	return p
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHAVING, 0)
}

func (s *HavingClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) HavingClause() (localctx IHavingClauseContext) {
	this := p
	_ = this

	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SQLServerStatementParserRULE_havingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.Match(SQLServerStatementParserHAVING)
	}
	{
		p.SetState(1224)
		p.expr(0)
	}

	return localctx
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *SubqueryContext) AggregationClause() IAggregationClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationClauseContext)
}

func (s *SubqueryContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Subquery() (localctx ISubqueryContext) {
	this := p
	_ = this

	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SQLServerStatementParserRULE_subquery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1227)
		p.AggregationClause()
	}
	{
		p.SetState(1228)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithClauseContext) AllCteClause() []ICteClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICteClauseContext)(nil)).Elem())
	var tst = make([]ICteClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICteClauseContext)
		}
	}

	return tst
}

func (s *WithClauseContext) CteClause(i int) ICteClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICteClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICteClauseContext)
}

func (s *WithClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *WithClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithClause() (localctx IWithClauseContext) {
	this := p
	_ = this

	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SQLServerStatementParserRULE_withClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(1231)
		p.CteClause()
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1232)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1233)
			p.CteClause()
		}

		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICteClauseContext is an interface to support dynamic dispatch.
type ICteClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCteClauseContext differentiates from other interfaces.
	IsCteClauseContext()
}

type CteClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteClauseContext() *CteClauseContext {
	var p = new(CteClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_cteClause
	return p
}

func (*CteClauseContext) IsCteClauseContext() {}

func NewCteClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteClauseContext {
	var p = new(CteClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_cteClause

	return p
}

func (s *CteClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CteClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CteClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CteClauseContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *CteClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *CteClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCteClause(s)
	}
}

func (s *CteClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCteClause(s)
	}
}

func (s *CteClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCteClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CteClause() (localctx ICteClauseContext) {
	this := p
	_ = this

	localctx = NewCteClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SQLServerStatementParserRULE_cteClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1239)
		p.Identifier()
	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(1240)
			p.ColumnNames()
		}

	}
	{
		p.SetState(1243)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(1244)
		p.Subquery()
	}

	return localctx
}

// IOutputClauseContext is an interface to support dynamic dispatch.
type IOutputClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputClauseContext differentiates from other interfaces.
	IsOutputClauseContext()
}

type OutputClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputClauseContext() *OutputClauseContext {
	var p = new(OutputClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_outputClause
	return p
}

func (*OutputClauseContext) IsOutputClauseContext() {}

func NewOutputClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputClauseContext {
	var p = new(OutputClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_outputClause

	return p
}

func (s *OutputClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputClauseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTPUT, 0)
}

func (s *OutputClauseContext) OutputWithColumns() IOutputWithColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputWithColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputWithColumnsContext)
}

func (s *OutputClauseContext) OutputWithAaterisk() IOutputWithAateriskContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputWithAateriskContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputWithAateriskContext)
}

func (s *OutputClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTO, 0)
}

func (s *OutputClauseContext) OutputTableName() IOutputTableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputTableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOutputTableNameContext)
}

func (s *OutputClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *OutputClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOutputClause(s)
	}
}

func (s *OutputClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOutputClause(s)
	}
}

func (s *OutputClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOutputClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OutputClause() (localctx IOutputClauseContext) {
	this := p
	_ = this

	localctx = NewOutputClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SQLServerStatementParserRULE_outputClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Match(SQLServerStatementParserOUTPUT)
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1247)
			p.OutputWithColumns()
		}

	case 2:
		{
			p.SetState(1248)
			p.OutputWithAaterisk()
		}

	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserINTO {
		{
			p.SetState(1251)
			p.Match(SQLServerStatementParserINTO)
		}
		{
			p.SetState(1252)
			p.OutputTableName()
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(1253)
				p.ColumnNames()
			}

		}

	}

	return localctx
}

// IOutputWithColumnsContext is an interface to support dynamic dispatch.
type IOutputWithColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputWithColumnsContext differentiates from other interfaces.
	IsOutputWithColumnsContext()
}

type OutputWithColumnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputWithColumnsContext() *OutputWithColumnsContext {
	var p = new(OutputWithColumnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_outputWithColumns
	return p
}

func (*OutputWithColumnsContext) IsOutputWithColumnsContext() {}

func NewOutputWithColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputWithColumnsContext {
	var p = new(OutputWithColumnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_outputWithColumns

	return p
}

func (s *OutputWithColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputWithColumnsContext) AllOutputWithColumn() []IOutputWithColumnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOutputWithColumnContext)(nil)).Elem())
	var tst = make([]IOutputWithColumnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOutputWithColumnContext)
		}
	}

	return tst
}

func (s *OutputWithColumnsContext) OutputWithColumn(i int) IOutputWithColumnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOutputWithColumnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOutputWithColumnContext)
}

func (s *OutputWithColumnsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *OutputWithColumnsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *OutputWithColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputWithColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputWithColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOutputWithColumns(s)
	}
}

func (s *OutputWithColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOutputWithColumns(s)
	}
}

func (s *OutputWithColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOutputWithColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OutputWithColumns() (localctx IOutputWithColumnsContext) {
	this := p
	_ = this

	localctx = NewOutputWithColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SQLServerStatementParserRULE_outputWithColumns)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.OutputWithColumn()
	}
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1259)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1260)
			p.OutputWithColumn()
		}

		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOutputWithColumnContext is an interface to support dynamic dispatch.
type IOutputWithColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputWithColumnContext differentiates from other interfaces.
	IsOutputWithColumnContext()
}

type OutputWithColumnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputWithColumnContext() *OutputWithColumnContext {
	var p = new(OutputWithColumnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_outputWithColumn
	return p
}

func (*OutputWithColumnContext) IsOutputWithColumnContext() {}

func NewOutputWithColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputWithColumnContext {
	var p = new(OutputWithColumnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_outputWithColumn

	return p
}

func (s *OutputWithColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputWithColumnContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *OutputWithColumnContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *OutputWithColumnContext) INSERTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERTED, 0)
}

func (s *OutputWithColumnContext) DELETED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETED, 0)
}

func (s *OutputWithColumnContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *OutputWithColumnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *OutputWithColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputWithColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputWithColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOutputWithColumn(s)
	}
}

func (s *OutputWithColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOutputWithColumn(s)
	}
}

func (s *OutputWithColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOutputWithColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OutputWithColumn() (localctx IOutputWithColumnContext) {
	this := p
	_ = this

	localctx = NewOutputWithColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SQLServerStatementParserRULE_outputWithColumn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserINSERTED || _la == SQLServerStatementParserDELETED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1267)
		p.Match(SQLServerStatementParserDOT_)
	}
	{
		p.SetState(1268)
		p.Name()
	}
	p.SetState(1273)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		p.SetState(1270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(1269)
				p.Match(SQLServerStatementParserAS)
			}

		}
		{
			p.SetState(1272)
			p.Alias()
		}

	}

	return localctx
}

// IOutputWithAateriskContext is an interface to support dynamic dispatch.
type IOutputWithAateriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputWithAateriskContext differentiates from other interfaces.
	IsOutputWithAateriskContext()
}

type OutputWithAateriskContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputWithAateriskContext() *OutputWithAateriskContext {
	var p = new(OutputWithAateriskContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_outputWithAaterisk
	return p
}

func (*OutputWithAateriskContext) IsOutputWithAateriskContext() {}

func NewOutputWithAateriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputWithAateriskContext {
	var p = new(OutputWithAateriskContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_outputWithAaterisk

	return p
}

func (s *OutputWithAateriskContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputWithAateriskContext) DOT_ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_ASTERISK_, 0)
}

func (s *OutputWithAateriskContext) INSERTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERTED, 0)
}

func (s *OutputWithAateriskContext) DELETED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETED, 0)
}

func (s *OutputWithAateriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputWithAateriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputWithAateriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOutputWithAaterisk(s)
	}
}

func (s *OutputWithAateriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOutputWithAaterisk(s)
	}
}

func (s *OutputWithAateriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOutputWithAaterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OutputWithAaterisk() (localctx IOutputWithAateriskContext) {
	this := p
	_ = this

	localctx = NewOutputWithAateriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SQLServerStatementParserRULE_outputWithAaterisk)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1275)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserINSERTED || _la == SQLServerStatementParserDELETED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1276)
		p.Match(SQLServerStatementParserDOT_ASTERISK_)
	}

	return localctx
}

// IOutputTableNameContext is an interface to support dynamic dispatch.
type IOutputTableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOutputTableNameContext differentiates from other interfaces.
	IsOutputTableNameContext()
}

type OutputTableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOutputTableNameContext() *OutputTableNameContext {
	var p = new(OutputTableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_outputTableName
	return p
}

func (*OutputTableNameContext) IsOutputTableNameContext() {}

func NewOutputTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutputTableNameContext {
	var p = new(OutputTableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_outputTableName

	return p
}

func (s *OutputTableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OutputTableNameContext) AT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAT_, 0)
}

func (s *OutputTableNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *OutputTableNameContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *OutputTableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutputTableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutputTableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOutputTableName(s)
	}
}

func (s *OutputTableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOutputTableName(s)
	}
}

func (s *OutputTableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOutputTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OutputTableName() (localctx IOutputTableNameContext) {
	this := p
	_ = this

	localctx = NewOutputTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SQLServerStatementParserRULE_outputTableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1281)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserAT_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1278)
			p.Match(SQLServerStatementParserAT_)
		}
		{
			p.SetState(1279)
			p.Name()
		}

	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1280)
			p.TableName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryHintContext is an interface to support dynamic dispatch.
type IQueryHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryHintContext differentiates from other interfaces.
	IsQueryHintContext()
}

type QueryHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryHintContext() *QueryHintContext {
	var p = new(QueryHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_queryHint
	return p
}

func (*QueryHintContext) IsQueryHintContext() {}

func NewQueryHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryHintContext {
	var p = new(QueryHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_queryHint

	return p
}

func (s *QueryHintContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryHintContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGROUP, 0)
}

func (s *QueryHintContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHASH, 0)
}

func (s *QueryHintContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserORDER, 0)
}

func (s *QueryHintContext) UNION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNION, 0)
}

func (s *QueryHintContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONCAT, 0)
}

func (s *QueryHintContext) MERGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMERGE, 0)
}

func (s *QueryHintContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserJOIN, 0)
}

func (s *QueryHintContext) LOOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOOP, 0)
}

func (s *QueryHintContext) EXPAND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXPAND, 0)
}

func (s *QueryHintContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEWS, 0)
}

func (s *QueryHintContext) FAST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFAST, 0)
}

func (s *QueryHintContext) INT_NUM_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINT_NUM_, 0)
}

func (s *QueryHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE, 0)
}

func (s *QueryHintContext) EXTERNALPUSHDOWN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNALPUSHDOWN, 0)
}

func (s *QueryHintContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE, 0)
}

func (s *QueryHintContext) SCALEOUTEXECUTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCALEOUTEXECUTION, 0)
}

func (s *QueryHintContext) IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIGNORE_NONCLUSTERED_COLUMNSTORE_INDEX, 0)
}

func (s *QueryHintContext) KEEP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEEP, 0)
}

func (s *QueryHintContext) PLAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPLAN, 0)
}

func (s *QueryHintContext) KEEPFIXED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEEPFIXED, 0)
}

func (s *QueryHintContext) MAX_GRANT_PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_GRANT_PERCENT, 0)
}

func (s *QueryHintContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *QueryHintContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *QueryHintContext) DECIMAL_NUM_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDECIMAL_NUM_, 0)
}

func (s *QueryHintContext) MIN_GRANT_PERCENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIN_GRANT_PERCENT, 0)
}

func (s *QueryHintContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *QueryHintContext) MAXRECURSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXRECURSION, 0)
}

func (s *QueryHintContext) NO_PERFORMANCE_SPOOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO_PERFORMANCE_SPOOL, 0)
}

func (s *QueryHintContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMIZE, 0)
}

func (s *QueryHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *QueryHintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *QueryHintContext) AT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAT_, 0)
}

func (s *QueryHintContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *QueryHintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *QueryHintContext) AllUNKNOWN() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserUNKNOWN)
}

func (s *QueryHintContext) UNKNOWN(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNKNOWN, i)
}

func (s *QueryHintContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QueryHintContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QueryHintContext) PARAMETERIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARAMETERIZATION, 0)
}

func (s *QueryHintContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIMPLE, 0)
}

func (s *QueryHintContext) FORCED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCED, 0)
}

func (s *QueryHintContext) QUERYTRACEON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERYTRACEON, 0)
}

func (s *QueryHintContext) RECOMPILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECOMPILE, 0)
}

func (s *QueryHintContext) ROBUST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROBUST, 0)
}

func (s *QueryHintContext) USE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSE, 0)
}

func (s *QueryHintContext) HINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHINT, 0)
}

func (s *QueryHintContext) AllUseHitName() []IUseHitNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUseHitNameContext)(nil)).Elem())
	var tst = make([]IUseHitNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUseHitNameContext)
		}
	}

	return tst
}

func (s *QueryHintContext) UseHitName(i int) IUseHitNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseHitNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUseHitNameContext)
}

func (s *QueryHintContext) NCHAR_TEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNCHAR_TEXT, 0)
}

func (s *QueryHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQueryHint(s)
	}
}

func (s *QueryHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQueryHint(s)
	}
}

func (s *QueryHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQueryHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QueryHint() (localctx IQueryHintContext) {
	this := p
	_ = this

	localctx = NewQueryHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SQLServerStatementParserRULE_queryHint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1353)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1283)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserORDER || _la == SQLServerStatementParserHASH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1284)
			p.Match(SQLServerStatementParserGROUP)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1285)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserMERGE || _la == SQLServerStatementParserHASH || _la == SQLServerStatementParserCONCAT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1286)
			p.Match(SQLServerStatementParserUNION)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1287)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserMERGE || _la == SQLServerStatementParserLOOP || _la == SQLServerStatementParserHASH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1288)
			p.Match(SQLServerStatementParserJOIN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1289)
			p.Match(SQLServerStatementParserEXPAND)
		}
		{
			p.SetState(1290)
			p.Match(SQLServerStatementParserVIEWS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1291)
			p.Match(SQLServerStatementParserFAST)
		}
		{
			p.SetState(1292)
			p.Match(SQLServerStatementParserINT_NUM_)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1293)
			p.Match(SQLServerStatementParserFORCE)
		}
		{
			p.SetState(1294)
			p.Match(SQLServerStatementParserORDER)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1295)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDISABLE || _la == SQLServerStatementParserFORCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1296)
			p.Match(SQLServerStatementParserEXTERNALPUSHDOWN)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1297)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDISABLE || _la == SQLServerStatementParserFORCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1298)
			p.Match(SQLServerStatementParserSCALEOUTEXECUTION)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1299)
			p.Match(SQLServerStatementParserIGNORE_NONCLUSTERED_COLUMNSTORE_INDEX)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1300)
			p.Match(SQLServerStatementParserKEEP)
		}
		{
			p.SetState(1301)
			p.Match(SQLServerStatementParserPLAN)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1302)
			p.Match(SQLServerStatementParserKEEPFIXED)
		}
		{
			p.SetState(1303)
			p.Match(SQLServerStatementParserPLAN)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1304)
			p.Match(SQLServerStatementParserMAX_GRANT_PERCENT)
		}
		{
			p.SetState(1305)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(1306)
			p.Match(SQLServerStatementParserDECIMAL_NUM_)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1307)
			p.Match(SQLServerStatementParserMIN_GRANT_PERCENT)
		}
		{
			p.SetState(1308)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(1309)
			p.Match(SQLServerStatementParserDECIMAL_NUM_)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1310)
			p.Match(SQLServerStatementParserMAXDOP)
		}
		{
			p.SetState(1311)
			p.Match(SQLServerStatementParserINT_NUM_)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1312)
			p.Match(SQLServerStatementParserMAXRECURSION)
		}
		{
			p.SetState(1313)
			p.Match(SQLServerStatementParserINT_NUM_)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1314)
			p.Match(SQLServerStatementParserNO_PERFORMANCE_SPOOL)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1315)
			p.Match(SQLServerStatementParserOPTIMIZE)
		}
		{
			p.SetState(1316)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(1317)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1318)
			p.Match(SQLServerStatementParserAT_)
		}
		{
			p.SetState(1319)
			p.Name()
		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserEQ_ || _la == SQLServerStatementParserUNKNOWN {
			p.SetState(1323)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQLServerStatementParserUNKNOWN:
				{
					p.SetState(1320)
					p.Match(SQLServerStatementParserUNKNOWN)
				}

			case SQLServerStatementParserEQ_:
				{
					p.SetState(1321)
					p.Match(SQLServerStatementParserEQ_)
				}
				{
					p.SetState(1322)
					p.Identifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1327)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1328)
			p.Match(SQLServerStatementParserRP_)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1330)
			p.Match(SQLServerStatementParserOPTIMIZE)
		}
		{
			p.SetState(1331)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(1332)
			p.Match(SQLServerStatementParserUNKNOWN)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1333)
			p.Match(SQLServerStatementParserPARAMETERIZATION)
		}
		{
			p.SetState(1334)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSIMPLE || _la == SQLServerStatementParserFORCED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1335)
			p.Match(SQLServerStatementParserQUERYTRACEON)
		}
		{
			p.SetState(1336)
			p.Match(SQLServerStatementParserINT_NUM_)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1337)
			p.Match(SQLServerStatementParserRECOMPILE)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1338)
			p.Match(SQLServerStatementParserROBUST)
		}
		{
			p.SetState(1339)
			p.Match(SQLServerStatementParserPLAN)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1340)
			p.Match(SQLServerStatementParserUSE)
		}
		{
			p.SetState(1341)
			p.Match(SQLServerStatementParserHINT)
		}
		{
			p.SetState(1342)
			p.Match(SQLServerStatementParserLP_)
		}
		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserSQ_ {
			{
				p.SetState(1343)
				p.UseHitName()
			}

			p.SetState(1348)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1349)
			p.Match(SQLServerStatementParserRP_)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1350)
			p.Match(SQLServerStatementParserUSE)
		}
		{
			p.SetState(1351)
			p.Match(SQLServerStatementParserPLAN)
		}
		{
			p.SetState(1352)
			p.Match(SQLServerStatementParserNCHAR_TEXT)
		}

	}

	return localctx
}

// IUseHitNameContext is an interface to support dynamic dispatch.
type IUseHitNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseHitNameContext differentiates from other interfaces.
	IsUseHitNameContext()
}

type UseHitNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseHitNameContext() *UseHitNameContext {
	var p = new(UseHitNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_useHitName
	return p
}

func (*UseHitNameContext) IsUseHitNameContext() {}

func NewUseHitNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseHitNameContext {
	var p = new(UseHitNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_useHitName

	return p
}

func (s *UseHitNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UseHitNameContext) AllSQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserSQ_)
}

func (s *UseHitNameContext) SQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSQ_, i)
}

func (s *UseHitNameContext) ASSUME_JOIN_PREDICATE_DEPENDS_ON_FILTERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSUME_JOIN_PREDICATE_DEPENDS_ON_FILTERS, 0)
}

func (s *UseHitNameContext) ASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES, 0)
}

func (s *UseHitNameContext) DISABLE_BATCH_MODE_ADAPTIVE_JOINS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_BATCH_MODE_ADAPTIVE_JOINS, 0)
}

func (s *UseHitNameContext) DISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK, 0)
}

func (s *UseHitNameContext) DISABLE_DEFERRED_COMPILATION_TV() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_DEFERRED_COMPILATION_TV, 0)
}

func (s *UseHitNameContext) DISABLE_INTERLEAVED_EXECUTION_TVF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_INTERLEAVED_EXECUTION_TVF, 0)
}

func (s *UseHitNameContext) DISABLE_OPTIMIZED_NESTED_LOOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_OPTIMIZED_NESTED_LOOP, 0)
}

func (s *UseHitNameContext) DISABLE_OPTIMIZER_ROWGOAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_OPTIMIZER_ROWGOAL, 0)
}

func (s *UseHitNameContext) DISABLE_PARAMETER_SNIFFING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_PARAMETER_SNIFFING, 0)
}

func (s *UseHitNameContext) DISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK, 0)
}

func (s *UseHitNameContext) DISABLE_TSQL_SCALAR_UDF_INLINING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_TSQL_SCALAR_UDF_INLINING, 0)
}

func (s *UseHitNameContext) DISALLOW_BATCH_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISALLOW_BATCH_MODE, 0)
}

func (s *UseHitNameContext) ENABLE_HIST_AMENDMENT_FOR_ASC_KEYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE_HIST_AMENDMENT_FOR_ASC_KEYS, 0)
}

func (s *UseHitNameContext) ENABLE_QUERY_OPTIMIZER_HOTFIXES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE_QUERY_OPTIMIZER_HOTFIXES, 0)
}

func (s *UseHitNameContext) FORCE_DEFAULT_CARDINALITY_ESTIMATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_DEFAULT_CARDINALITY_ESTIMATION, 0)
}

func (s *UseHitNameContext) FORCE_LEGACY_CARDINALITY_ESTIMATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_LEGACY_CARDINALITY_ESTIMATION, 0)
}

func (s *UseHitNameContext) QUERY_OPTIMIZER_COMPATIBILITY_LEVEL_n() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_OPTIMIZER_COMPATIBILITY_LEVEL_n, 0)
}

func (s *UseHitNameContext) QUERY_PLAN_PROFILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_PLAN_PROFILE, 0)
}

func (s *UseHitNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseHitNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseHitNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterUseHitName(s)
	}
}

func (s *UseHitNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitUseHitName(s)
	}
}

func (s *UseHitNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitUseHitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) UseHitName() (localctx IUseHitNameContext) {
	this := p
	_ = this

	localctx = NewUseHitNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SQLServerStatementParserRULE_useHitName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1355)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1356)
			p.Match(SQLServerStatementParserASSUME_JOIN_PREDICATE_DEPENDS_ON_FILTERS)
		}
		{
			p.SetState(1357)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1358)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1359)
			p.Match(SQLServerStatementParserASSUME_MIN_SELECTIVITY_FOR_FILTER_ESTIMATES)
		}
		{
			p.SetState(1360)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1361)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1362)
			p.Match(SQLServerStatementParserDISABLE_BATCH_MODE_ADAPTIVE_JOINS)
		}
		{
			p.SetState(1363)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1364)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1365)
			p.Match(SQLServerStatementParserDISABLE_BATCH_MODE_MEMORY_GRANT_FEEDBACK)
		}
		{
			p.SetState(1366)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1367)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1368)
			p.Match(SQLServerStatementParserDISABLE_DEFERRED_COMPILATION_TV)
		}
		{
			p.SetState(1369)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1370)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1371)
			p.Match(SQLServerStatementParserDISABLE_INTERLEAVED_EXECUTION_TVF)
		}
		{
			p.SetState(1372)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1373)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1374)
			p.Match(SQLServerStatementParserDISABLE_OPTIMIZED_NESTED_LOOP)
		}
		{
			p.SetState(1375)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1376)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1377)
			p.Match(SQLServerStatementParserDISABLE_OPTIMIZER_ROWGOAL)
		}
		{
			p.SetState(1378)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1379)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1380)
			p.Match(SQLServerStatementParserDISABLE_PARAMETER_SNIFFING)
		}
		{
			p.SetState(1381)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1382)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1383)
			p.Match(SQLServerStatementParserDISABLE_ROW_MODE_MEMORY_GRANT_FEEDBACK)
		}
		{
			p.SetState(1384)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1385)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1386)
			p.Match(SQLServerStatementParserDISABLE_TSQL_SCALAR_UDF_INLINING)
		}
		{
			p.SetState(1387)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1388)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1389)
			p.Match(SQLServerStatementParserDISALLOW_BATCH_MODE)
		}
		{
			p.SetState(1390)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1391)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1392)
			p.Match(SQLServerStatementParserENABLE_HIST_AMENDMENT_FOR_ASC_KEYS)
		}
		{
			p.SetState(1393)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1394)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1395)
			p.Match(SQLServerStatementParserENABLE_QUERY_OPTIMIZER_HOTFIXES)
		}
		{
			p.SetState(1396)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1397)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1398)
			p.Match(SQLServerStatementParserFORCE_DEFAULT_CARDINALITY_ESTIMATION)
		}
		{
			p.SetState(1399)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1400)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1401)
			p.Match(SQLServerStatementParserFORCE_LEGACY_CARDINALITY_ESTIMATION)
		}
		{
			p.SetState(1402)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1403)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1404)
			p.Match(SQLServerStatementParserQUERY_OPTIMIZER_COMPATIBILITY_LEVEL_n)
		}
		{
			p.SetState(1405)
			p.Match(SQLServerStatementParserSQ_)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1406)
			p.Match(SQLServerStatementParserSQ_)
		}
		{
			p.SetState(1407)
			p.Match(SQLServerStatementParserQUERY_PLAN_PROFILE)
		}
		{
			p.SetState(1408)
			p.Match(SQLServerStatementParserSQ_)
		}

	}

	return localctx
}

// IParameterMarkerContext is an interface to support dynamic dispatch.
type IParameterMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterMarkerContext differentiates from other interfaces.
	IsParameterMarkerContext()
}

type ParameterMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterMarkerContext() *ParameterMarkerContext {
	var p = new(ParameterMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_parameterMarker
	return p
}

func (*ParameterMarkerContext) IsParameterMarkerContext() {}

func NewParameterMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterMarkerContext {
	var p = new(ParameterMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_parameterMarker

	return p
}

func (s *ParameterMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterMarkerContext) QUESTION_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUESTION_, 0)
}

func (s *ParameterMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterParameterMarker(s)
	}
}

func (s *ParameterMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitParameterMarker(s)
	}
}

func (s *ParameterMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitParameterMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ParameterMarker() (localctx IParameterMarkerContext) {
	this := p
	_ = this

	localctx = NewParameterMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SQLServerStatementParserRULE_parameterMarker)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		p.Match(SQLServerStatementParserQUESTION_)
	}

	return localctx
}

// ILiteralsContext is an interface to support dynamic dispatch.
type ILiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralsContext differentiates from other interfaces.
	IsLiteralsContext()
}

type LiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralsContext() *LiteralsContext {
	var p = new(LiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_literals
	return p
}

func (*LiteralsContext) IsLiteralsContext() {}

func NewLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralsContext {
	var p = new(LiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_literals

	return p
}

func (s *LiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralsContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *LiteralsContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *LiteralsContext) DateTimeLiterals() IDateTimeLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateTimeLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateTimeLiteralsContext)
}

func (s *LiteralsContext) HexadecimalLiterals() IHexadecimalLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexadecimalLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralsContext)
}

func (s *LiteralsContext) BitValueLiterals() IBitValueLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitValueLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitValueLiteralsContext)
}

func (s *LiteralsContext) BooleanLiterals() IBooleanLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralsContext)
}

func (s *LiteralsContext) NullValueLiterals() INullValueLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullValueLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullValueLiteralsContext)
}

func (s *LiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterLiterals(s)
	}
}

func (s *LiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitLiterals(s)
	}
}

func (s *LiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Literals() (localctx ILiteralsContext) {
	this := p
	_ = this

	localctx = NewLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SQLServerStatementParserRULE_literals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1420)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserSTRING_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1413)
			p.StringLiterals()
		}

	case SQLServerStatementParserMINUS_, SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1414)
			p.NumberLiterals()
		}

	case SQLServerStatementParserLBE_, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1415)
			p.DateTimeLiterals()
		}

	case SQLServerStatementParserHEX_DIGIT_:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1416)
			p.HexadecimalLiterals()
		}

	case SQLServerStatementParserBIT_NUM_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1417)
			p.BitValueLiterals()
		}

	case SQLServerStatementParserTRUE, SQLServerStatementParserFALSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1418)
			p.BooleanLiterals()
		}

	case SQLServerStatementParserNULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1419)
			p.NullValueLiterals()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringLiteralsContext is an interface to support dynamic dispatch.
type IStringLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralsContext differentiates from other interfaces.
	IsStringLiteralsContext()
}

type StringLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralsContext() *StringLiteralsContext {
	var p = new(StringLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_stringLiterals
	return p
}

func (*StringLiteralsContext) IsStringLiteralsContext() {}

func NewStringLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralsContext {
	var p = new(StringLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_stringLiterals

	return p
}

func (s *StringLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *StringLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterStringLiterals(s)
	}
}

func (s *StringLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitStringLiterals(s)
	}
}

func (s *StringLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitStringLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) StringLiterals() (localctx IStringLiteralsContext) {
	this := p
	_ = this

	localctx = NewStringLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SQLServerStatementParserRULE_stringLiterals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Match(SQLServerStatementParserSTRING_)
	}

	return localctx
}

// INumberLiteralsContext is an interface to support dynamic dispatch.
type INumberLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralsContext differentiates from other interfaces.
	IsNumberLiteralsContext()
}

type NumberLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralsContext() *NumberLiteralsContext {
	var p = new(NumberLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_numberLiterals
	return p
}

func (*NumberLiteralsContext) IsNumberLiteralsContext() {}

func NewNumberLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralsContext {
	var p = new(NumberLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_numberLiterals

	return p
}

func (s *NumberLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralsContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *NumberLiteralsContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUS_, 0)
}

func (s *NumberLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterNumberLiterals(s)
	}
}

func (s *NumberLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitNumberLiterals(s)
	}
}

func (s *NumberLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitNumberLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) NumberLiterals() (localctx INumberLiteralsContext) {
	this := p
	_ = this

	localctx = NewNumberLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SQLServerStatementParserRULE_numberLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserMINUS_ {
		{
			p.SetState(1424)
			p.Match(SQLServerStatementParserMINUS_)
		}

	}
	{
		p.SetState(1427)
		p.Match(SQLServerStatementParserNUMBER_)
	}

	return localctx
}

// IDateTimeLiteralsContext is an interface to support dynamic dispatch.
type IDateTimeLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateTimeLiteralsContext differentiates from other interfaces.
	IsDateTimeLiteralsContext()
}

type DateTimeLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeLiteralsContext() *DateTimeLiteralsContext {
	var p = new(DateTimeLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dateTimeLiterals
	return p
}

func (*DateTimeLiteralsContext) IsDateTimeLiteralsContext() {}

func NewDateTimeLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeLiteralsContext {
	var p = new(DateTimeLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dateTimeLiterals

	return p
}

func (s *DateTimeLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeLiteralsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *DateTimeLiteralsContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATE, 0)
}

func (s *DateTimeLiteralsContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTIME, 0)
}

func (s *DateTimeLiteralsContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTIMESTAMP, 0)
}

func (s *DateTimeLiteralsContext) LBE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLBE_, 0)
}

func (s *DateTimeLiteralsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DateTimeLiteralsContext) RBE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRBE_, 0)
}

func (s *DateTimeLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDateTimeLiterals(s)
	}
}

func (s *DateTimeLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDateTimeLiterals(s)
	}
}

func (s *DateTimeLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDateTimeLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DateTimeLiterals() (localctx IDateTimeLiteralsContext) {
	this := p
	_ = this

	localctx = NewDateTimeLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SQLServerStatementParserRULE_dateTimeLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1436)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-132)&-(0x1f+1)) == 0 && ((1<<uint((_la-132)))&((1<<(SQLServerStatementParserDATE-132))|(1<<(SQLServerStatementParserTIME-132))|(1<<(SQLServerStatementParserTIMESTAMP-132)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1430)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case SQLServerStatementParserLBE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1431)
			p.Match(SQLServerStatementParserLBE_)
		}
		{
			p.SetState(1432)
			p.Identifier()
		}
		{
			p.SetState(1433)
			p.Match(SQLServerStatementParserSTRING_)
		}
		{
			p.SetState(1434)
			p.Match(SQLServerStatementParserRBE_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHexadecimalLiteralsContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralsContext differentiates from other interfaces.
	IsHexadecimalLiteralsContext()
}

type HexadecimalLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralsContext() *HexadecimalLiteralsContext {
	var p = new(HexadecimalLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_hexadecimalLiterals
	return p
}

func (*HexadecimalLiteralsContext) IsHexadecimalLiteralsContext() {}

func NewHexadecimalLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralsContext {
	var p = new(HexadecimalLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_hexadecimalLiterals

	return p
}

func (s *HexadecimalLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralsContext) HEX_DIGIT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHEX_DIGIT_, 0)
}

func (s *HexadecimalLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterHexadecimalLiterals(s)
	}
}

func (s *HexadecimalLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitHexadecimalLiterals(s)
	}
}

func (s *HexadecimalLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitHexadecimalLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) HexadecimalLiterals() (localctx IHexadecimalLiteralsContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SQLServerStatementParserRULE_hexadecimalLiterals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1438)
		p.Match(SQLServerStatementParserHEX_DIGIT_)
	}

	return localctx
}

// IBitValueLiteralsContext is an interface to support dynamic dispatch.
type IBitValueLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitValueLiteralsContext differentiates from other interfaces.
	IsBitValueLiteralsContext()
}

type BitValueLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitValueLiteralsContext() *BitValueLiteralsContext {
	var p = new(BitValueLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_bitValueLiterals
	return p
}

func (*BitValueLiteralsContext) IsBitValueLiteralsContext() {}

func NewBitValueLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitValueLiteralsContext {
	var p = new(BitValueLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_bitValueLiterals

	return p
}

func (s *BitValueLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *BitValueLiteralsContext) BIT_NUM_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBIT_NUM_, 0)
}

func (s *BitValueLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitValueLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitValueLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBitValueLiterals(s)
	}
}

func (s *BitValueLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBitValueLiterals(s)
	}
}

func (s *BitValueLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBitValueLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BitValueLiterals() (localctx IBitValueLiteralsContext) {
	this := p
	_ = this

	localctx = NewBitValueLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SQLServerStatementParserRULE_bitValueLiterals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1440)
		p.Match(SQLServerStatementParserBIT_NUM_)
	}

	return localctx
}

// IBooleanLiteralsContext is an interface to support dynamic dispatch.
type IBooleanLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralsContext differentiates from other interfaces.
	IsBooleanLiteralsContext()
}

type BooleanLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralsContext() *BooleanLiteralsContext {
	var p = new(BooleanLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_booleanLiterals
	return p
}

func (*BooleanLiteralsContext) IsBooleanLiteralsContext() {}

func NewBooleanLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralsContext {
	var p = new(BooleanLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_booleanLiterals

	return p
}

func (s *BooleanLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralsContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUE, 0)
}

func (s *BooleanLiteralsContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFALSE, 0)
}

func (s *BooleanLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBooleanLiterals(s)
	}
}

func (s *BooleanLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBooleanLiterals(s)
	}
}

func (s *BooleanLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBooleanLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BooleanLiterals() (localctx IBooleanLiteralsContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SQLServerStatementParserRULE_booleanLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1442)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTRUE || _la == SQLServerStatementParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INullValueLiteralsContext is an interface to support dynamic dispatch.
type INullValueLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullValueLiteralsContext differentiates from other interfaces.
	IsNullValueLiteralsContext()
}

type NullValueLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullValueLiteralsContext() *NullValueLiteralsContext {
	var p = new(NullValueLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_nullValueLiterals
	return p
}

func (*NullValueLiteralsContext) IsNullValueLiteralsContext() {}

func NewNullValueLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullValueLiteralsContext {
	var p = new(NullValueLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_nullValueLiterals

	return p
}

func (s *NullValueLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *NullValueLiteralsContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *NullValueLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullValueLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullValueLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterNullValueLiterals(s)
	}
}

func (s *NullValueLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitNullValueLiterals(s)
	}
}

func (s *NullValueLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitNullValueLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) NullValueLiterals() (localctx INullValueLiteralsContext) {
	this := p
	_ = this

	localctx = NewNullValueLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SQLServerStatementParserRULE_nullValueLiterals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1444)
		p.Match(SQLServerStatementParserNULL)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *IdentifierContext) UnreservedWord() IUnreservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnreservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnreservedWordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SQLServerStatementParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1448)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1446)
			p.Match(SQLServerStatementParserIDENTIFIER_)
		}

	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1447)
			p.UnreservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnreservedWordContext is an interface to support dynamic dispatch.
type IUnreservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnreservedWordContext differentiates from other interfaces.
	IsUnreservedWordContext()
}

type UnreservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnreservedWordContext() *UnreservedWordContext {
	var p = new(UnreservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_unreservedWord
	return p
}

func (*UnreservedWordContext) IsUnreservedWordContext() {}

func NewUnreservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnreservedWordContext {
	var p = new(UnreservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_unreservedWord

	return p
}

func (s *UnreservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *UnreservedWordContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUNCATE, 0)
}

func (s *UnreservedWordContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *UnreservedWordContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *UnreservedWordContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLIMIT, 0)
}

func (s *UnreservedWordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFFSET, 0)
}

func (s *UnreservedWordContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSAVEPOINT, 0)
}

func (s *UnreservedWordContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBOOLEAN, 0)
}

func (s *UnreservedWordContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserARRAY, 0)
}

func (s *UnreservedWordContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCALTIME, 0)
}

func (s *UnreservedWordContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCALTIMESTAMP, 0)
}

func (s *UnreservedWordContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUARTER, 0)
}

func (s *UnreservedWordContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWEEK, 0)
}

func (s *UnreservedWordContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMICROSECOND, 0)
}

func (s *UnreservedWordContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE, 0)
}

func (s *UnreservedWordContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE, 0)
}

func (s *UnreservedWordContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINARY, 0)
}

func (s *UnreservedWordContext) HIDDEN_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHIDDEN_, 0)
}

func (s *UnreservedWordContext) MOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOD, 0)
}

func (s *UnreservedWordContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITION, 0)
}

func (s *UnreservedWordContext) TOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOP, 0)
}

func (s *UnreservedWordContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *UnreservedWordContext) XOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserXOR, 0)
}

func (s *UnreservedWordContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALWAYS, 0)
}

func (s *UnreservedWordContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *UnreservedWordContext) START() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTART, 0)
}

func (s *UnreservedWordContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALGORITHM, 0)
}

func (s *UnreservedWordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO, 0)
}

func (s *UnreservedWordContext) BLOCKERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBLOCKERS, 0)
}

func (s *UnreservedWordContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLUSTERED, 0)
}

func (s *UnreservedWordContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *UnreservedWordContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTENT, 0)
}

func (s *UnreservedWordContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONCAT, 0)
}

func (s *UnreservedWordContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *UnreservedWordContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAYS, 0)
}

func (s *UnreservedWordContext) DENY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDENY, 0)
}

func (s *UnreservedWordContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDETERMINISTIC, 0)
}

func (s *UnreservedWordContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISTRIBUTION, 0)
}

func (s *UnreservedWordContext) DOCUMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOCUMENT, 0)
}

func (s *UnreservedWordContext) DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDURABILITY, 0)
}

func (s *UnreservedWordContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTED, 0)
}

func (s *UnreservedWordContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *UnreservedWordContext) FILETABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE, 0)
}

func (s *UnreservedWordContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOLLOWING, 0)
}

func (s *UnreservedWordContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHASH, 0)
}

func (s *UnreservedWordContext) HEAP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHEAP, 0)
}

func (s *UnreservedWordContext) INBOUND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINBOUND, 0)
}

func (s *UnreservedWordContext) INFINITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINFINITE, 0)
}

func (s *UnreservedWordContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *UnreservedWordContext) MASKED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASKED, 0)
}

func (s *UnreservedWordContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *UnreservedWordContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *UnreservedWordContext) MONTHS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMONTHS, 0)
}

func (s *UnreservedWordContext) MOVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOVE, 0)
}

func (s *UnreservedWordContext) NOCHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOCHECK, 0)
}

func (s *UnreservedWordContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *UnreservedWordContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOBJECT, 0)
}

func (s *UnreservedWordContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *UnreservedWordContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLINE, 0)
}

func (s *UnreservedWordContext) OUTBOUND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTBOUND, 0)
}

func (s *UnreservedWordContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOVER, 0)
}

func (s *UnreservedWordContext) PAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE, 0)
}

func (s *UnreservedWordContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITIONS, 0)
}

func (s *UnreservedWordContext) PAUSED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAUSED, 0)
}

func (s *UnreservedWordContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERIOD, 0)
}

func (s *UnreservedWordContext) PERSISTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTED, 0)
}

func (s *UnreservedWordContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRECEDING, 0)
}

func (s *UnreservedWordContext) RANDOMIZED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRANDOMIZED, 0)
}

func (s *UnreservedWordContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRANGE, 0)
}

func (s *UnreservedWordContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREBUILD, 0)
}

func (s *UnreservedWordContext) REPLICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATE, 0)
}

func (s *UnreservedWordContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *UnreservedWordContext) RESUMABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUMABLE, 0)
}

func (s *UnreservedWordContext) ROWGUIDCOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWGUIDCOL, 0)
}

func (s *UnreservedWordContext) SAVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSAVE, 0)
}

func (s *UnreservedWordContext) SELF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELF, 0)
}

func (s *UnreservedWordContext) SPARSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSPARSE, 0)
}

func (s *UnreservedWordContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSWITCH, 0)
}

func (s *UnreservedWordContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *UnreservedWordContext) TRANCOUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANCOUNT, 0)
}

func (s *UnreservedWordContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNBOUNDED, 0)
}

func (s *UnreservedWordContext) YEARS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserYEARS, 0)
}

func (s *UnreservedWordContext) WEEKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWEEKS, 0)
}

func (s *UnreservedWordContext) ABORT_AFTER_WAIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserABORT_AFTER_WAIT, 0)
}

func (s *UnreservedWordContext) ALLOW_PAGE_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_PAGE_LOCKS, 0)
}

func (s *UnreservedWordContext) ALLOW_ROW_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_ROW_LOCKS, 0)
}

func (s *UnreservedWordContext) ALL_SPARSE_COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL_SPARSE_COLUMNS, 0)
}

func (s *UnreservedWordContext) BUCKET_COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBUCKET_COUNT, 0)
}

func (s *UnreservedWordContext) COLUMNSTORE_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE_ARCHIVE, 0)
}

func (s *UnreservedWordContext) COLUMN_ENCRYPTION_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, 0)
}

func (s *UnreservedWordContext) COLUMN_SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN_SET, 0)
}

func (s *UnreservedWordContext) COMPRESSION_DELAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESSION_DELAY, 0)
}

func (s *UnreservedWordContext) DATABASE_DEAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE_DEAULT, 0)
}

func (s *UnreservedWordContext) DATA_COMPRESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_COMPRESSION, 0)
}

func (s *UnreservedWordContext) DATA_CONSISTENCY_CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_CONSISTENCY_CHECK, 0)
}

func (s *UnreservedWordContext) ENCRYPTION_TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION_TYPE, 0)
}

func (s *UnreservedWordContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_TIME, 0)
}

func (s *UnreservedWordContext) SYSTEM_VERSIONING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_VERSIONING, 0)
}

func (s *UnreservedWordContext) TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTEXTIMAGE_ON, 0)
}

func (s *UnreservedWordContext) WAIT_AT_LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWAIT_AT_LOW_PRIORITY, 0)
}

func (s *UnreservedWordContext) STATISTICS_INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_INCREMENTAL, 0)
}

func (s *UnreservedWordContext) STATISTICS_NORECOMPUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_NORECOMPUTE, 0)
}

func (s *UnreservedWordContext) ROUND_ROBIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROUND_ROBIN, 0)
}

func (s *UnreservedWordContext) SCHEMA_AND_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_AND_DATA, 0)
}

func (s *UnreservedWordContext) SCHEMA_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_ONLY, 0)
}

func (s *UnreservedWordContext) SORT_IN_TEMPDB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSORT_IN_TEMPDB, 0)
}

func (s *UnreservedWordContext) IGNORE_DUP_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIGNORE_DUP_KEY, 0)
}

func (s *UnreservedWordContext) IMPLICIT_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPLICIT_TRANSACTIONS, 0)
}

func (s *UnreservedWordContext) MAX_DURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_DURATION, 0)
}

func (s *UnreservedWordContext) MEMORY_OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED, 0)
}

func (s *UnreservedWordContext) MIGRATION_STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIGRATION_STATE, 0)
}

func (s *UnreservedWordContext) PAD_INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAD_INDEX, 0)
}

func (s *UnreservedWordContext) REMOTE_DATA_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE_DATA_ARCHIVE, 0)
}

func (s *UnreservedWordContext) FILESTREAM_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM_ON, 0)
}

func (s *UnreservedWordContext) FILETABLE_COLLATE_FILENAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_COLLATE_FILENAME, 0)
}

func (s *UnreservedWordContext) FILETABLE_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_DIRECTORY, 0)
}

func (s *UnreservedWordContext) FILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, 0)
}

func (s *UnreservedWordContext) FILETABLE_PRIMARY_KEY_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, 0)
}

func (s *UnreservedWordContext) FILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, 0)
}

func (s *UnreservedWordContext) FILLFACTOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILLFACTOR, 0)
}

func (s *UnreservedWordContext) FILTER_PREDICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILTER_PREDICATE, 0)
}

func (s *UnreservedWordContext) HISTORY_RETENTION_PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHISTORY_RETENTION_PERIOD, 0)
}

func (s *UnreservedWordContext) HISTORY_TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHISTORY_TABLE, 0)
}

func (s *UnreservedWordContext) LOCK_ESCALATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCK_ESCALATION, 0)
}

func (s *UnreservedWordContext) DROP_EXISTING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP_EXISTING, 0)
}

func (s *UnreservedWordContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW_NUMBER, 0)
}

func (s *UnreservedWordContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTROL, 0)
}

func (s *UnreservedWordContext) TAKE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTAKE, 0)
}

func (s *UnreservedWordContext) OWNERSHIP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOWNERSHIP, 0)
}

func (s *UnreservedWordContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFINITION, 0)
}

func (s *UnreservedWordContext) APPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAPPLICATION, 0)
}

func (s *UnreservedWordContext) ASSEMBLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSEMBLY, 0)
}

func (s *UnreservedWordContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYMMETRIC, 0)
}

func (s *UnreservedWordContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASYMMETRIC, 0)
}

func (s *UnreservedWordContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *UnreservedWordContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECEIVE, 0)
}

func (s *UnreservedWordContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE, 0)
}

func (s *UnreservedWordContext) TRACE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACE, 0)
}

func (s *UnreservedWordContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACKING, 0)
}

func (s *UnreservedWordContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESOURCES, 0)
}

func (s *UnreservedWordContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSETTINGS, 0)
}

func (s *UnreservedWordContext) STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATE, 0)
}

func (s *UnreservedWordContext) AVAILABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAVAILABILITY, 0)
}

func (s *UnreservedWordContext) CREDENTIAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREDENTIAL, 0)
}

func (s *UnreservedWordContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENDPOINT, 0)
}

func (s *UnreservedWordContext) EVENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEVENT, 0)
}

func (s *UnreservedWordContext) NOTIFICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOTIFICATION, 0)
}

func (s *UnreservedWordContext) LINKED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLINKED, 0)
}

func (s *UnreservedWordContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUDIT, 0)
}

func (s *UnreservedWordContext) DDL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDDL, 0)
}

func (s *UnreservedWordContext) SQL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSQL, 0)
}

func (s *UnreservedWordContext) XML() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserXML, 0)
}

func (s *UnreservedWordContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPERSONATE, 0)
}

func (s *UnreservedWordContext) SECURABLES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECURABLES, 0)
}

func (s *UnreservedWordContext) AUTHENTICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTHENTICATE, 0)
}

func (s *UnreservedWordContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNAL, 0)
}

func (s *UnreservedWordContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACCESS, 0)
}

func (s *UnreservedWordContext) ADMINISTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADMINISTER, 0)
}

func (s *UnreservedWordContext) BULK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBULK, 0)
}

func (s *UnreservedWordContext) OPERATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPERATIONS, 0)
}

func (s *UnreservedWordContext) UNSAFE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNSAFE, 0)
}

func (s *UnreservedWordContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSHUTDOWN, 0)
}

func (s *UnreservedWordContext) SCOPED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCOPED, 0)
}

func (s *UnreservedWordContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONFIGURATION, 0)
}

func (s *UnreservedWordContext) DATASPACE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATASPACE, 0)
}

func (s *UnreservedWordContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *UnreservedWordContext) CERTIFICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCERTIFICATE, 0)
}

func (s *UnreservedWordContext) CONTRACT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTRACT, 0)
}

func (s *UnreservedWordContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *UnreservedWordContext) MASTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASTER, 0)
}

func (s *UnreservedWordContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA, 0)
}

func (s *UnreservedWordContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSOURCE, 0)
}

func (s *UnreservedWordContext) FILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILE, 0)
}

func (s *UnreservedWordContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORMAT, 0)
}

func (s *UnreservedWordContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLIBRARY, 0)
}

func (s *UnreservedWordContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULLTEXT, 0)
}

func (s *UnreservedWordContext) MASK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASK, 0)
}

func (s *UnreservedWordContext) UNMASK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNMASK, 0)
}

func (s *UnreservedWordContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMESSAGE, 0)
}

func (s *UnreservedWordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE, 0)
}

func (s *UnreservedWordContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE, 0)
}

func (s *UnreservedWordContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINDING, 0)
}

func (s *UnreservedWordContext) ROUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROUTE, 0)
}

func (s *UnreservedWordContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECURITY, 0)
}

func (s *UnreservedWordContext) POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPOLICY, 0)
}

func (s *UnreservedWordContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAGGREGATE, 0)
}

func (s *UnreservedWordContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUEUE, 0)
}

func (s *UnreservedWordContext) RULE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRULE, 0)
}

func (s *UnreservedWordContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYNONYM, 0)
}

func (s *UnreservedWordContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLECTION, 0)
}

func (s *UnreservedWordContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCRIPT, 0)
}

func (s *UnreservedWordContext) KILL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKILL, 0)
}

func (s *UnreservedWordContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBACKUP, 0)
}

func (s *UnreservedWordContext) LOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOG, 0)
}

func (s *UnreservedWordContext) SHOWPLAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSHOWPLAN, 0)
}

func (s *UnreservedWordContext) SUBSCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUBSCRIBE, 0)
}

func (s *UnreservedWordContext) QUERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY, 0)
}

func (s *UnreservedWordContext) NOTIFICATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOTIFICATIONS, 0)
}

func (s *UnreservedWordContext) CHECKPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECKPOINT, 0)
}

func (s *UnreservedWordContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEQUENCE, 0)
}

func (s *UnreservedWordContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSTANCE, 0)
}

func (s *UnreservedWordContext) DO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDO, 0)
}

func (s *UnreservedWordContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFINER, 0)
}

func (s *UnreservedWordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCAL, 0)
}

func (s *UnreservedWordContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCASCADED, 0)
}

func (s *UnreservedWordContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNEXT, 0)
}

func (s *UnreservedWordContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *UnreservedWordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTEGER, 0)
}

func (s *UnreservedWordContext) MAX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX, 0)
}

func (s *UnreservedWordContext) MIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIN, 0)
}

func (s *UnreservedWordContext) SUM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUM, 0)
}

func (s *UnreservedWordContext) COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOUNT, 0)
}

func (s *UnreservedWordContext) AVG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAVG, 0)
}

func (s *UnreservedWordContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFIRST, 0)
}

func (s *UnreservedWordContext) DATETIME2() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATETIME2, 0)
}

func (s *UnreservedWordContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTPUT, 0)
}

func (s *UnreservedWordContext) INSERTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERTED, 0)
}

func (s *UnreservedWordContext) DELETED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETED, 0)
}

func (s *UnreservedWordContext) KB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKB, 0)
}

func (s *UnreservedWordContext) MB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMB, 0)
}

func (s *UnreservedWordContext) GB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGB, 0)
}

func (s *UnreservedWordContext) TB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTB, 0)
}

func (s *UnreservedWordContext) FILENAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILENAME, 0)
}

func (s *UnreservedWordContext) MAXSIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXSIZE, 0)
}

func (s *UnreservedWordContext) FILEGROWTH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROWTH, 0)
}

func (s *UnreservedWordContext) UNLIMITED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNLIMITED, 0)
}

func (s *UnreservedWordContext) MEMORY_OPTIMIZED_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED_DATA, 0)
}

func (s *UnreservedWordContext) FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROUP, 0)
}

func (s *UnreservedWordContext) NON_TRANSACTED_ACCESS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNON_TRANSACTED_ACCESS, 0)
}

func (s *UnreservedWordContext) DB_CHAINING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDB_CHAINING, 0)
}

func (s *UnreservedWordContext) TRUSTWORTHY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUSTWORTHY, 0)
}

func (s *UnreservedWordContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGROUP, 0)
}

func (s *UnreservedWordContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWS, 0)
}

func (s *UnreservedWordContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATE, 0)
}

func (s *UnreservedWordContext) DATEPART() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATEPART, 0)
}

func (s *UnreservedWordContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCAST, 0)
}

func (s *UnreservedWordContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAY, 0)
}

func (s *UnreservedWordContext) FORWARD_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORWARD_ONLY, 0)
}

func (s *UnreservedWordContext) KEYSET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEYSET, 0)
}

func (s *UnreservedWordContext) FAST_FORWARD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFAST_FORWARD, 0)
}

func (s *UnreservedWordContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *UnreservedWordContext) SCROLL_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCROLL_LOCKS, 0)
}

func (s *UnreservedWordContext) OPTIMISTIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMISTIC, 0)
}

func (s *UnreservedWordContext) TYPE_WARNING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE_WARNING, 0)
}

func (s *UnreservedWordContext) SCHEMABINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMABINDING, 0)
}

func (s *UnreservedWordContext) CALLER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCALLER, 0)
}

func (s *UnreservedWordContext) OWNER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOWNER, 0)
}

func (s *UnreservedWordContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSNAPSHOT, 0)
}

func (s *UnreservedWordContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPEATABLE, 0)
}

func (s *UnreservedWordContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERIALIZABLE, 0)
}

func (s *UnreservedWordContext) NATIVE_COMPILATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNATIVE_COMPILATION, 0)
}

func (s *UnreservedWordContext) VIEW_METADATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW_METADATA, 0)
}

func (s *UnreservedWordContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSTEAD, 0)
}

func (s *UnreservedWordContext) APPEND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAPPEND, 0)
}

func (s *UnreservedWordContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINCREMENT, 0)
}

func (s *UnreservedWordContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCACHE, 0)
}

func (s *UnreservedWordContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINVALUE, 0)
}

func (s *UnreservedWordContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXVALUE, 0)
}

func (s *UnreservedWordContext) RESTART() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESTART, 0)
}

func (s *UnreservedWordContext) LOB_COMPACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOB_COMPACTION, 0)
}

func (s *UnreservedWordContext) COMPRESS_ALL_ROW_GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, 0)
}

func (s *UnreservedWordContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREORGANIZE, 0)
}

func (s *UnreservedWordContext) RESUME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUME, 0)
}

func (s *UnreservedWordContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAUSE, 0)
}

func (s *UnreservedWordContext) ABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserABORT, 0)
}

func (s *UnreservedWordContext) ACCELERATED_DATABASE_RECOVERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, 0)
}

func (s *UnreservedWordContext) PERSISTENT_VERSION_STORE_FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, 0)
}

func (s *UnreservedWordContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMMEDIATE, 0)
}

func (s *UnreservedWordContext) NO_WAIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO_WAIT, 0)
}

func (s *UnreservedWordContext) TARGET_RECOVERY_TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTARGET_RECOVERY_TIME, 0)
}

func (s *UnreservedWordContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECONDS, 0)
}

func (s *UnreservedWordContext) HONOR_BROKER_PRIORITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHONOR_BROKER_PRIORITY, 0)
}

func (s *UnreservedWordContext) ERROR_BROKER_CONVERSATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserERROR_BROKER_CONVERSATIONS, 0)
}

func (s *UnreservedWordContext) NEW_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNEW_BROKER, 0)
}

func (s *UnreservedWordContext) DISABLE_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_BROKER, 0)
}

func (s *UnreservedWordContext) ENABLE_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE_BROKER, 0)
}

func (s *UnreservedWordContext) MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, 0)
}

func (s *UnreservedWordContext) READ_COMMITTED_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, 0)
}

func (s *UnreservedWordContext) ALLOW_SNAPSHOT_ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, 0)
}

func (s *UnreservedWordContext) RECURSIVE_TRIGGERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECURSIVE_TRIGGERS, 0)
}

func (s *UnreservedWordContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUOTED_IDENTIFIER, 0)
}

func (s *UnreservedWordContext) NUMERIC_ROUNDABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMERIC_ROUNDABORT, 0)
}

func (s *UnreservedWordContext) CONCAT_NULL_YIELDS_NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, 0)
}

func (s *UnreservedWordContext) COMPATIBILITY_LEVEL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPATIBILITY_LEVEL, 0)
}

func (s *UnreservedWordContext) ARITHABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserARITHABORT, 0)
}

func (s *UnreservedWordContext) ANSI_WARNINGS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_WARNINGS, 0)
}

func (s *UnreservedWordContext) ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_PADDING, 0)
}

func (s *UnreservedWordContext) ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_NULLS, 0)
}

func (s *UnreservedWordContext) ANSI_NULL_DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_NULL_DEFAULT, 0)
}

func (s *UnreservedWordContext) PAGE_VERIFY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE_VERIFY, 0)
}

func (s *UnreservedWordContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECKSUM, 0)
}

func (s *UnreservedWordContext) TORN_PAGE_DETECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTORN_PAGE_DETECTION, 0)
}

func (s *UnreservedWordContext) BULK_LOGGED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBULK_LOGGED, 0)
}

func (s *UnreservedWordContext) RECOVERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECOVERY, 0)
}

func (s *UnreservedWordContext) TOTAL_EXECUTION_CPU_TIME_MS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, 0)
}

func (s *UnreservedWordContext) TOTAL_COMPILE_CPU_TIME_MS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, 0)
}

func (s *UnreservedWordContext) STALE_CAPTURE_POLICY_THRESHOLD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, 0)
}

func (s *UnreservedWordContext) EXECUTION_COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXECUTION_COUNT, 0)
}

func (s *UnreservedWordContext) QUERY_CAPTURE_POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_CAPTURE_POLICY, 0)
}

func (s *UnreservedWordContext) WAIT_STATS_CAPTURE_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, 0)
}

func (s *UnreservedWordContext) MAX_PLANS_PER_QUERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_PLANS_PER_QUERY, 0)
}

func (s *UnreservedWordContext) QUERY_CAPTURE_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_CAPTURE_MODE, 0)
}

func (s *UnreservedWordContext) SIZE_BASED_CLEANUP_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, 0)
}

func (s *UnreservedWordContext) INTERVAL_LENGTH_MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTERVAL_LENGTH_MINUTES, 0)
}

func (s *UnreservedWordContext) MAX_STORAGE_SIZE_MB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_STORAGE_SIZE_MB, 0)
}

func (s *UnreservedWordContext) DATA_FLUSH_INTERVAL_SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, 0)
}

func (s *UnreservedWordContext) CLEANUP_POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLEANUP_POLICY, 0)
}

func (s *UnreservedWordContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCUSTOM, 0)
}

func (s *UnreservedWordContext) STALE_QUERY_THRESHOLD_DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, 0)
}

func (s *UnreservedWordContext) OPERATION_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPERATION_MODE, 0)
}

func (s *UnreservedWordContext) QUERY_STORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_STORE, 0)
}

func (s *UnreservedWordContext) CURSOR_DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR_DEFAULT, 0)
}

func (s *UnreservedWordContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGLOBAL, 0)
}

func (s *UnreservedWordContext) CURSOR_CLOSE_ON_COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, 0)
}

func (s *UnreservedWordContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHOURS, 0)
}

func (s *UnreservedWordContext) CHANGE_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE_RETENTION, 0)
}

func (s *UnreservedWordContext) AUTO_CLEANUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CLEANUP, 0)
}

func (s *UnreservedWordContext) CHANGE_TRACKING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE_TRACKING, 0)
}

func (s *UnreservedWordContext) AUTOMATIC_TUNING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTOMATIC_TUNING, 0)
}

func (s *UnreservedWordContext) FORCE_LAST_GOOD_PLAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_LAST_GOOD_PLAN, 0)
}

func (s *UnreservedWordContext) AUTO_UPDATE_STATISTICS_ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, 0)
}

func (s *UnreservedWordContext) AUTO_UPDATE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_UPDATE_STATISTICS, 0)
}

func (s *UnreservedWordContext) AUTO_SHRINK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_SHRINK, 0)
}

func (s *UnreservedWordContext) AUTO_CREATE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CREATE_STATISTICS, 0)
}

func (s *UnreservedWordContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINCREMENTAL, 0)
}

func (s *UnreservedWordContext) AUTO_CLOSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CLOSE, 0)
}

func (s *UnreservedWordContext) DATA_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_RETENTION, 0)
}

func (s *UnreservedWordContext) TEMPORAL_HISTORY_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, 0)
}

func (s *UnreservedWordContext) EDITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEDITION, 0)
}

func (s *UnreservedWordContext) MIXED_PAGE_ALLOCATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIXED_PAGE_ALLOCATION, 0)
}

func (s *UnreservedWordContext) DISABLED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLED, 0)
}

func (s *UnreservedWordContext) ALLOWED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOWED, 0)
}

func (s *UnreservedWordContext) HADR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHADR, 0)
}

func (s *UnreservedWordContext) MULTI_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMULTI_USER, 0)
}

func (s *UnreservedWordContext) RESTRICTED_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESTRICTED_USER, 0)
}

func (s *UnreservedWordContext) SINGLE_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSINGLE_USER, 0)
}

func (s *UnreservedWordContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFFLINE, 0)
}

func (s *UnreservedWordContext) EMERGENCY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEMERGENCY, 0)
}

func (s *UnreservedWordContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUSPEND, 0)
}

func (s *UnreservedWordContext) DATE_CORRELATION_OPTIMIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, 0)
}

func (s *UnreservedWordContext) ELASTIC_POOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserELASTIC_POOL, 0)
}

func (s *UnreservedWordContext) SERVICE_OBJECTIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE_OBJECTIVE, 0)
}

func (s *UnreservedWordContext) DATABASE_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE_NAME, 0)
}

func (s *UnreservedWordContext) ALLOW_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_CONNECTIONS, 0)
}

func (s *UnreservedWordContext) GEO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGEO, 0)
}

func (s *UnreservedWordContext) NAMED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAMED, 0)
}

func (s *UnreservedWordContext) DATEFIRST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATEFIRST, 0)
}

func (s *UnreservedWordContext) BACKUP_STORAGE_REDUNDANCY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, 0)
}

func (s *UnreservedWordContext) FORCE_FAILOVER_ALLOW_DATA_LOSS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, 0)
}

func (s *UnreservedWordContext) SECONDARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECONDARY, 0)
}

func (s *UnreservedWordContext) FAILOVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFAILOVER, 0)
}

func (s *UnreservedWordContext) DEFAULT_FULLTEXT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, 0)
}

func (s *UnreservedWordContext) DEFAULT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_LANGUAGE, 0)
}

func (s *UnreservedWordContext) INLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINLINE, 0)
}

func (s *UnreservedWordContext) NESTED_TRIGGERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNESTED_TRIGGERS, 0)
}

func (s *UnreservedWordContext) TRANSFORM_NOISE_WORDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSFORM_NOISE_WORDS, 0)
}

func (s *UnreservedWordContext) TWO_DIGIT_YEAR_CUTOFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, 0)
}

func (s *UnreservedWordContext) PERSISTENT_LOG_BUFFER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTENT_LOG_BUFFER, 0)
}

func (s *UnreservedWordContext) DIRECTORY_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDIRECTORY_NAME, 0)
}

func (s *UnreservedWordContext) DATEFORMAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATEFORMAT, 0)
}

func (s *UnreservedWordContext) DELAYED_DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELAYED_DURABILITY, 0)
}

func (s *UnreservedWordContext) TRANSFER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSFER, 0)
}

func (s *UnreservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnreservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnreservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterUnreservedWord(s)
	}
}

func (s *UnreservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitUnreservedWord(s)
	}
}

func (s *UnreservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitUnreservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) UnreservedWord() (localctx IUnreservedWordContext) {
	this := p
	_ = this

	localctx = NewUnreservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SQLServerStatementParserRULE_unreservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1450)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(SQLServerStatementParserTRUNCATE-52))|(1<<(SQLServerStatementParserFUNCTION-52))|(1<<(SQLServerStatementParserTRIGGER-52))|(1<<(SQLServerStatementParserCAST-52)))) != 0) || (((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SQLServerStatementParserGROUP-115))|(1<<(SQLServerStatementParserLIMIT-115))|(1<<(SQLServerStatementParserOFFSET-115))|(1<<(SQLServerStatementParserSAVEPOINT-115))|(1<<(SQLServerStatementParserBOOLEAN-115))|(1<<(SQLServerStatementParserARRAY-115))|(1<<(SQLServerStatementParserDATE-115))|(1<<(SQLServerStatementParserLOCALTIME-115))|(1<<(SQLServerStatementParserLOCALTIMESTAMP-115))|(1<<(SQLServerStatementParserQUARTER-115))|(1<<(SQLServerStatementParserWEEK-115))|(1<<(SQLServerStatementParserDAY-115))|(1<<(SQLServerStatementParserMICROSECOND-115))|(1<<(SQLServerStatementParserMAX-115)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SQLServerStatementParserMIN-147))|(1<<(SQLServerStatementParserSUM-147))|(1<<(SQLServerStatementParserCOUNT-147))|(1<<(SQLServerStatementParserAVG-147))|(1<<(SQLServerStatementParserENABLE-147))|(1<<(SQLServerStatementParserDISABLE-147))|(1<<(SQLServerStatementParserINSTANCE-147))|(1<<(SQLServerStatementParserDO-147))|(1<<(SQLServerStatementParserDEFINER-147))|(1<<(SQLServerStatementParserSQL-147))|(1<<(SQLServerStatementParserCASCADED-147))|(1<<(SQLServerStatementParserLOCAL-147))|(1<<(SQLServerStatementParserNEXT-147))|(1<<(SQLServerStatementParserNAME-147))|(1<<(SQLServerStatementParserINTEGER-147))|(1<<(SQLServerStatementParserTYPE-147)))) != 0) || (((_la-200)&-(0x1f+1)) == 0 && ((1<<uint((_la-200)))&((1<<(SQLServerStatementParserREAD_ONLY-200))|(1<<(SQLServerStatementParserDATABASE-200))|(1<<(SQLServerStatementParserDATEPART-200))|(1<<(SQLServerStatementParserBINARY-200))|(1<<(SQLServerStatementParserHIDDEN_-200))|(1<<(SQLServerStatementParserMOD-200))|(1<<(SQLServerStatementParserPARTITION-200))|(1<<(SQLServerStatementParserPARTITIONS-200))|(1<<(SQLServerStatementParserTOP-200))|(1<<(SQLServerStatementParserROW-200))|(1<<(SQLServerStatementParserROWS-200))|(1<<(SQLServerStatementParserXOR-200))|(1<<(SQLServerStatementParserALWAYS-200))|(1<<(SQLServerStatementParserROLE-200)))) != 0) || (((_la-232)&-(0x1f+1)) == 0 && ((1<<uint((_la-232)))&((1<<(SQLServerStatementParserSTART-232))|(1<<(SQLServerStatementParserALGORITHM-232))|(1<<(SQLServerStatementParserAUTO-232))|(1<<(SQLServerStatementParserBLOCKERS-232))|(1<<(SQLServerStatementParserCLUSTERED-232))|(1<<(SQLServerStatementParserNONCLUSTERED-232))|(1<<(SQLServerStatementParserCOLUMNSTORE-232))|(1<<(SQLServerStatementParserCONTENT-232))|(1<<(SQLServerStatementParserYEARS-232))|(1<<(SQLServerStatementParserMONTHS-232))|(1<<(SQLServerStatementParserWEEKS-232))|(1<<(SQLServerStatementParserDAYS-232))|(1<<(SQLServerStatementParserMINUTES-232))|(1<<(SQLServerStatementParserDENY-232))|(1<<(SQLServerStatementParserDETERMINISTIC-232))|(1<<(SQLServerStatementParserDISTRIBUTION-232))|(1<<(SQLServerStatementParserDOCUMENT-232))|(1<<(SQLServerStatementParserDURABILITY-232))|(1<<(SQLServerStatementParserENCRYPTED-232))|(1<<(SQLServerStatementParserFILESTREAM-232))|(1<<(SQLServerStatementParserFILETABLE-232))|(1<<(SQLServerStatementParserFILLFACTOR-232))|(1<<(SQLServerStatementParserFOLLOWING-232))|(1<<(SQLServerStatementParserHASH-232))|(1<<(SQLServerStatementParserHEAP-232))|(1<<(SQLServerStatementParserINBOUND-232)))) != 0) || (((_la-264)&-(0x1f+1)) == 0 && ((1<<uint((_la-264)))&((1<<(SQLServerStatementParserOUTBOUND-264))|(1<<(SQLServerStatementParserUNBOUNDED-264))|(1<<(SQLServerStatementParserINFINITE-264))|(1<<(SQLServerStatementParserLOGIN-264))|(1<<(SQLServerStatementParserMASKED-264))|(1<<(SQLServerStatementParserMAXDOP-264))|(1<<(SQLServerStatementParserMOVE-264))|(1<<(SQLServerStatementParserNOCHECK-264))|(1<<(SQLServerStatementParserOBJECT-264))|(1<<(SQLServerStatementParserOFF-264))|(1<<(SQLServerStatementParserONLINE-264))|(1<<(SQLServerStatementParserOVER-264))|(1<<(SQLServerStatementParserPAGE-264))|(1<<(SQLServerStatementParserPAUSED-264))|(1<<(SQLServerStatementParserPERIOD-264))|(1<<(SQLServerStatementParserPERSISTED-264))|(1<<(SQLServerStatementParserPRECEDING-264))|(1<<(SQLServerStatementParserRANDOMIZED-264))|(1<<(SQLServerStatementParserRANGE-264))|(1<<(SQLServerStatementParserREBUILD-264))|(1<<(SQLServerStatementParserREPLICATE-264))|(1<<(SQLServerStatementParserREPLICATION-264))|(1<<(SQLServerStatementParserRESUMABLE-264))|(1<<(SQLServerStatementParserROWGUIDCOL-264))|(1<<(SQLServerStatementParserSAVE-264))|(1<<(SQLServerStatementParserSELF-264))|(1<<(SQLServerStatementParserSPARSE-264))|(1<<(SQLServerStatementParserSWITCH-264))|(1<<(SQLServerStatementParserTRAN-264))|(1<<(SQLServerStatementParserTRANCOUNT-264)))) != 0) || (((_la-302)&-(0x1f+1)) == 0 && ((1<<uint((_la-302)))&((1<<(SQLServerStatementParserCONTROL-302))|(1<<(SQLServerStatementParserCONCAT-302))|(1<<(SQLServerStatementParserTAKE-302))|(1<<(SQLServerStatementParserOWNERSHIP-302))|(1<<(SQLServerStatementParserDEFINITION-302))|(1<<(SQLServerStatementParserAPPLICATION-302))|(1<<(SQLServerStatementParserASSEMBLY-302))|(1<<(SQLServerStatementParserSYMMETRIC-302))|(1<<(SQLServerStatementParserASYMMETRIC-302))|(1<<(SQLServerStatementParserSERVER-302))|(1<<(SQLServerStatementParserRECEIVE-302))|(1<<(SQLServerStatementParserCHANGE-302))|(1<<(SQLServerStatementParserTRACE-302))|(1<<(SQLServerStatementParserTRACKING-302))|(1<<(SQLServerStatementParserRESOURCES-302))|(1<<(SQLServerStatementParserSETTINGS-302))|(1<<(SQLServerStatementParserSTATE-302))|(1<<(SQLServerStatementParserAVAILABILITY-302))|(1<<(SQLServerStatementParserCREDENTIAL-302))|(1<<(SQLServerStatementParserENDPOINT-302))|(1<<(SQLServerStatementParserEVENT-302))|(1<<(SQLServerStatementParserNOTIFICATION-302))|(1<<(SQLServerStatementParserLINKED-302))|(1<<(SQLServerStatementParserAUDIT-302))|(1<<(SQLServerStatementParserDDL-302))|(1<<(SQLServerStatementParserXML-302))|(1<<(SQLServerStatementParserIMPERSONATE-302))|(1<<(SQLServerStatementParserSECURABLES-302))|(1<<(SQLServerStatementParserAUTHENTICATE-302))|(1<<(SQLServerStatementParserEXTERNAL-302))|(1<<(SQLServerStatementParserACCESS-302))|(1<<(SQLServerStatementParserADMINISTER-302)))) != 0) || (((_la-334)&-(0x1f+1)) == 0 && ((1<<uint((_la-334)))&((1<<(SQLServerStatementParserBULK-334))|(1<<(SQLServerStatementParserOPERATIONS-334))|(1<<(SQLServerStatementParserUNSAFE-334))|(1<<(SQLServerStatementParserSHUTDOWN-334))|(1<<(SQLServerStatementParserSCOPED-334))|(1<<(SQLServerStatementParserCONFIGURATION-334))|(1<<(SQLServerStatementParserDATASPACE-334))|(1<<(SQLServerStatementParserSERVICE-334))|(1<<(SQLServerStatementParserCERTIFICATE-334))|(1<<(SQLServerStatementParserCONTRACT-334))|(1<<(SQLServerStatementParserENCRYPTION-334))|(1<<(SQLServerStatementParserMASTER-334))|(1<<(SQLServerStatementParserDATA-334))|(1<<(SQLServerStatementParserSOURCE-334))|(1<<(SQLServerStatementParserFILE-334))|(1<<(SQLServerStatementParserFORMAT-334))|(1<<(SQLServerStatementParserLIBRARY-334))|(1<<(SQLServerStatementParserFULLTEXT-334))|(1<<(SQLServerStatementParserMASK-334))|(1<<(SQLServerStatementParserUNMASK-334))|(1<<(SQLServerStatementParserMESSAGE-334))|(1<<(SQLServerStatementParserREMOTE-334))|(1<<(SQLServerStatementParserBINDING-334))|(1<<(SQLServerStatementParserROUTE-334))|(1<<(SQLServerStatementParserSECURITY-334))|(1<<(SQLServerStatementParserPOLICY-334))|(1<<(SQLServerStatementParserAGGREGATE-334))|(1<<(SQLServerStatementParserQUEUE-334))|(1<<(SQLServerStatementParserRULE-334))|(1<<(SQLServerStatementParserSYNONYM-334))|(1<<(SQLServerStatementParserCOLLECTION-334))|(1<<(SQLServerStatementParserSCRIPT-334)))) != 0) || (((_la-366)&-(0x1f+1)) == 0 && ((1<<uint((_la-366)))&((1<<(SQLServerStatementParserKILL-366))|(1<<(SQLServerStatementParserBACKUP-366))|(1<<(SQLServerStatementParserLOG-366))|(1<<(SQLServerStatementParserSHOWPLAN-366))|(1<<(SQLServerStatementParserSUBSCRIBE-366))|(1<<(SQLServerStatementParserQUERY-366))|(1<<(SQLServerStatementParserNOTIFICATIONS-366))|(1<<(SQLServerStatementParserCHECKPOINT-366))|(1<<(SQLServerStatementParserSEQUENCE-366))|(1<<(SQLServerStatementParserABORT_AFTER_WAIT-366))|(1<<(SQLServerStatementParserALLOW_PAGE_LOCKS-366))|(1<<(SQLServerStatementParserALLOW_ROW_LOCKS-366))|(1<<(SQLServerStatementParserALL_SPARSE_COLUMNS-366))|(1<<(SQLServerStatementParserBUCKET_COUNT-366))|(1<<(SQLServerStatementParserCOLUMNSTORE_ARCHIVE-366))|(1<<(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY-366))|(1<<(SQLServerStatementParserCOLUMN_SET-366))|(1<<(SQLServerStatementParserCOMPRESSION_DELAY-366))|(1<<(SQLServerStatementParserDATABASE_DEAULT-366))|(1<<(SQLServerStatementParserDATA_COMPRESSION-366))|(1<<(SQLServerStatementParserDATA_CONSISTENCY_CHECK-366))|(1<<(SQLServerStatementParserENCRYPTION_TYPE-366))|(1<<(SQLServerStatementParserSYSTEM_TIME-366))|(1<<(SQLServerStatementParserSYSTEM_VERSIONING-366))|(1<<(SQLServerStatementParserTEXTIMAGE_ON-366))|(1<<(SQLServerStatementParserWAIT_AT_LOW_PRIORITY-366))|(1<<(SQLServerStatementParserSTATISTICS_INCREMENTAL-366))|(1<<(SQLServerStatementParserSTATISTICS_NORECOMPUTE-366))|(1<<(SQLServerStatementParserROUND_ROBIN-366))|(1<<(SQLServerStatementParserSCHEMA_AND_DATA-366))|(1<<(SQLServerStatementParserSCHEMA_ONLY-366))|(1<<(SQLServerStatementParserSORT_IN_TEMPDB-366)))) != 0) || (((_la-398)&-(0x1f+1)) == 0 && ((1<<uint((_la-398)))&((1<<(SQLServerStatementParserIGNORE_DUP_KEY-398))|(1<<(SQLServerStatementParserIMPLICIT_TRANSACTIONS-398))|(1<<(SQLServerStatementParserMAX_DURATION-398))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED-398))|(1<<(SQLServerStatementParserMIGRATION_STATE-398))|(1<<(SQLServerStatementParserPAD_INDEX-398))|(1<<(SQLServerStatementParserREMOTE_DATA_ARCHIVE-398))|(1<<(SQLServerStatementParserFILESTREAM_ON-398))|(1<<(SQLServerStatementParserFILETABLE_COLLATE_FILENAME-398))|(1<<(SQLServerStatementParserFILETABLE_DIRECTORY-398))|(1<<(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILTER_PREDICATE-398))|(1<<(SQLServerStatementParserHISTORY_RETENTION_PERIOD-398))|(1<<(SQLServerStatementParserHISTORY_TABLE-398))|(1<<(SQLServerStatementParserLOCK_ESCALATION-398))|(1<<(SQLServerStatementParserDROP_EXISTING-398))|(1<<(SQLServerStatementParserROW_NUMBER-398))|(1<<(SQLServerStatementParserFIRST-398))|(1<<(SQLServerStatementParserDATETIME2-398)))) != 0) || (((_la-436)&-(0x1f+1)) == 0 && ((1<<uint((_la-436)))&((1<<(SQLServerStatementParserOUTPUT-436))|(1<<(SQLServerStatementParserINSERTED-436))|(1<<(SQLServerStatementParserDELETED-436)))) != 0) || (((_la-475)&-(0x1f+1)) == 0 && ((1<<uint((_la-475)))&((1<<(SQLServerStatementParserFILENAME-475))|(1<<(SQLServerStatementParserMAXSIZE-475))|(1<<(SQLServerStatementParserFILEGROWTH-475))|(1<<(SQLServerStatementParserUNLIMITED-475))|(1<<(SQLServerStatementParserKB-475))|(1<<(SQLServerStatementParserMB-475))|(1<<(SQLServerStatementParserGB-475))|(1<<(SQLServerStatementParserTB-475))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_DATA-475))|(1<<(SQLServerStatementParserFILEGROUP-475))|(1<<(SQLServerStatementParserNON_TRANSACTED_ACCESS-475))|(1<<(SQLServerStatementParserDB_CHAINING-475))|(1<<(SQLServerStatementParserTRUSTWORTHY-475))|(1<<(SQLServerStatementParserFORWARD_ONLY-475))|(1<<(SQLServerStatementParserKEYSET-475))|(1<<(SQLServerStatementParserFAST_FORWARD-475))|(1<<(SQLServerStatementParserSCROLL_LOCKS-475))|(1<<(SQLServerStatementParserOPTIMISTIC-475))|(1<<(SQLServerStatementParserTYPE_WARNING-475))|(1<<(SQLServerStatementParserSCHEMABINDING-475))|(1<<(SQLServerStatementParserCALLER-475))|(1<<(SQLServerStatementParserOWNER-475)))) != 0) || (((_la-510)&-(0x1f+1)) == 0 && ((1<<uint((_la-510)))&((1<<(SQLServerStatementParserSNAPSHOT-510))|(1<<(SQLServerStatementParserREPEATABLE-510))|(1<<(SQLServerStatementParserSERIALIZABLE-510))|(1<<(SQLServerStatementParserNATIVE_COMPILATION-510))|(1<<(SQLServerStatementParserVIEW_METADATA-510))|(1<<(SQLServerStatementParserINSTEAD-510))|(1<<(SQLServerStatementParserAPPEND-510))|(1<<(SQLServerStatementParserINCREMENT-510))|(1<<(SQLServerStatementParserCACHE-510))|(1<<(SQLServerStatementParserMINVALUE-510))|(1<<(SQLServerStatementParserMAXVALUE-510))|(1<<(SQLServerStatementParserRESTART-510))|(1<<(SQLServerStatementParserLOB_COMPACTION-510))|(1<<(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS-510))|(1<<(SQLServerStatementParserREORGANIZE-510))|(1<<(SQLServerStatementParserRESUME-510))|(1<<(SQLServerStatementParserPAUSE-510))|(1<<(SQLServerStatementParserABORT-510))|(1<<(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY-510)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP-542))|(1<<(SQLServerStatementParserIMMEDIATE-542))|(1<<(SQLServerStatementParserNO_WAIT-542))|(1<<(SQLServerStatementParserTARGET_RECOVERY_TIME-542))|(1<<(SQLServerStatementParserSECONDS-542))|(1<<(SQLServerStatementParserHONOR_BROKER_PRIORITY-542))|(1<<(SQLServerStatementParserERROR_BROKER_CONVERSATIONS-542))|(1<<(SQLServerStatementParserNEW_BROKER-542))|(1<<(SQLServerStatementParserDISABLE_BROKER-542))|(1<<(SQLServerStatementParserENABLE_BROKER-542))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT-542))|(1<<(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT-542))|(1<<(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION-542))|(1<<(SQLServerStatementParserRECURSIVE_TRIGGERS-542))|(1<<(SQLServerStatementParserQUOTED_IDENTIFIER-542))|(1<<(SQLServerStatementParserNUMERIC_ROUNDABORT-542))|(1<<(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL-542))|(1<<(SQLServerStatementParserCOMPATIBILITY_LEVEL-542))|(1<<(SQLServerStatementParserARITHABORT-542))|(1<<(SQLServerStatementParserANSI_WARNINGS-542))|(1<<(SQLServerStatementParserANSI_PADDING-542))|(1<<(SQLServerStatementParserANSI_NULLS-542))|(1<<(SQLServerStatementParserANSI_NULL_DEFAULT-542))|(1<<(SQLServerStatementParserPAGE_VERIFY-542))|(1<<(SQLServerStatementParserCHECKSUM-542))|(1<<(SQLServerStatementParserTORN_PAGE_DETECTION-542))|(1<<(SQLServerStatementParserBULK_LOGGED-542))|(1<<(SQLServerStatementParserRECOVERY-542))|(1<<(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD-542))|(1<<(SQLServerStatementParserEXECUTION_COUNT-542)))) != 0) || (((_la-574)&-(0x1f+1)) == 0 && ((1<<uint((_la-574)))&((1<<(SQLServerStatementParserQUERY_CAPTURE_POLICY-574))|(1<<(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserMAX_PLANS_PER_QUERY-574))|(1<<(SQLServerStatementParserQUERY_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE-574))|(1<<(SQLServerStatementParserINTERVAL_LENGTH_MINUTES-574))|(1<<(SQLServerStatementParserMAX_STORAGE_SIZE_MB-574))|(1<<(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS-574))|(1<<(SQLServerStatementParserCLEANUP_POLICY-574))|(1<<(SQLServerStatementParserCUSTOM-574))|(1<<(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS-574))|(1<<(SQLServerStatementParserOPERATION_MODE-574))|(1<<(SQLServerStatementParserQUERY_STORE-574))|(1<<(SQLServerStatementParserCURSOR_DEFAULT-574))|(1<<(SQLServerStatementParserGLOBAL-574))|(1<<(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT-574))|(1<<(SQLServerStatementParserHOURS-574))|(1<<(SQLServerStatementParserCHANGE_RETENTION-574))|(1<<(SQLServerStatementParserAUTO_CLEANUP-574))|(1<<(SQLServerStatementParserCHANGE_TRACKING-574))|(1<<(SQLServerStatementParserAUTOMATIC_TUNING-574))|(1<<(SQLServerStatementParserFORCE_LAST_GOOD_PLAN-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS-574))|(1<<(SQLServerStatementParserAUTO_SHRINK-574))|(1<<(SQLServerStatementParserAUTO_CREATE_STATISTICS-574))|(1<<(SQLServerStatementParserINCREMENTAL-574))|(1<<(SQLServerStatementParserAUTO_CLOSE-574))|(1<<(SQLServerStatementParserDATA_RETENTION-574))|(1<<(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION-574))|(1<<(SQLServerStatementParserEDITION-574))|(1<<(SQLServerStatementParserMIXED_PAGE_ALLOCATION-574)))) != 0) || (((_la-606)&-(0x1f+1)) == 0 && ((1<<uint((_la-606)))&((1<<(SQLServerStatementParserDISABLED-606))|(1<<(SQLServerStatementParserALLOWED-606))|(1<<(SQLServerStatementParserHADR-606))|(1<<(SQLServerStatementParserMULTI_USER-606))|(1<<(SQLServerStatementParserRESTRICTED_USER-606))|(1<<(SQLServerStatementParserSINGLE_USER-606))|(1<<(SQLServerStatementParserOFFLINE-606))|(1<<(SQLServerStatementParserEMERGENCY-606))|(1<<(SQLServerStatementParserSUSPEND-606))|(1<<(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION-606))|(1<<(SQLServerStatementParserELASTIC_POOL-606))|(1<<(SQLServerStatementParserSERVICE_OBJECTIVE-606))|(1<<(SQLServerStatementParserDATABASE_NAME-606))|(1<<(SQLServerStatementParserALLOW_CONNECTIONS-606))|(1<<(SQLServerStatementParserGEO-606))|(1<<(SQLServerStatementParserNAMED-606))|(1<<(SQLServerStatementParserDATEFIRST-606))|(1<<(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY-606))|(1<<(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS-606))|(1<<(SQLServerStatementParserSECONDARY-606))|(1<<(SQLServerStatementParserFAILOVER-606))|(1<<(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE-606))|(1<<(SQLServerStatementParserDEFAULT_LANGUAGE-606))|(1<<(SQLServerStatementParserINLINE-606))|(1<<(SQLServerStatementParserNESTED_TRIGGERS-606))|(1<<(SQLServerStatementParserTRANSFORM_NOISE_WORDS-606))|(1<<(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF-606))|(1<<(SQLServerStatementParserPERSISTENT_LOG_BUFFER-606))|(1<<(SQLServerStatementParserDIRECTORY_NAME-606))|(1<<(SQLServerStatementParserDATEFORMAT-606))|(1<<(SQLServerStatementParserDELAYED_DURABILITY-606)))) != 0) || _la == SQLServerStatementParserTRANSFER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDatabaseNameContext is an interface to support dynamic dispatch.
type IDatabaseNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseNameContext differentiates from other interfaces.
	IsDatabaseNameContext()
}

type DatabaseNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseNameContext() *DatabaseNameContext {
	var p = new(DatabaseNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseName
	return p
}

func (*DatabaseNameContext) IsDatabaseNameContext() {}

func NewDatabaseNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseNameContext {
	var p = new(DatabaseNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseName

	return p
}

func (s *DatabaseNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseName(s)
	}
}

func (s *DatabaseNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseName(s)
	}
}

func (s *DatabaseNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseName() (localctx IDatabaseNameContext) {
	this := p
	_ = this

	localctx = NewDatabaseNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SQLServerStatementParserRULE_databaseName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.Identifier()
	}

	return localctx
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_schemaName
	return p
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (s *SchemaNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSchemaName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SchemaName() (localctx ISchemaNameContext) {
	this := p
	_ = this

	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SQLServerStatementParserRULE_schemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Identifier()
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *FunctionNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *FunctionNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FunctionName() (localctx IFunctionNameContext) {
	this := p
	_ = this

	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SQLServerStatementParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1456)
			p.Owner()
		}
		{
			p.SetState(1457)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1461)
		p.Name()
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ProcedureNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ProcedureNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *ProcedureNameContext) SEMI_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEMI_, 0)
}

func (s *ProcedureNameContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcedureName() (localctx IProcedureNameContext) {
	this := p
	_ = this

	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SQLServerStatementParserRULE_procedureName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1463)
			p.Owner()
		}
		{
			p.SetState(1464)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1468)
		p.Name()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1469)
			p.Match(SQLServerStatementParserSEMI_)
		}
		{
			p.SetState(1470)
			p.NumberLiterals()
		}

	}

	return localctx
}

// IViewNameContext is an interface to support dynamic dispatch.
type IViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsViewNameContext differentiates from other interfaces.
	IsViewNameContext()
}

type ViewNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewNameContext() *ViewNameContext {
	var p = new(ViewNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_viewName
	return p
}

func (*ViewNameContext) IsViewNameContext() {}

func NewViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewNameContext {
	var p = new(ViewNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_viewName

	return p
}

func (s *ViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ViewNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ViewNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *ViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterViewName(s)
	}
}

func (s *ViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitViewName(s)
	}
}

func (s *ViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitViewName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ViewName() (localctx IViewNameContext) {
	this := p
	_ = this

	localctx = NewViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SQLServerStatementParserRULE_viewName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1476)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1473)
			p.Owner()
		}
		{
			p.SetState(1474)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1478)
		p.Name()
	}

	return localctx
}

// ITriggerNameContext is an interface to support dynamic dispatch.
type ITriggerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTriggerNameContext differentiates from other interfaces.
	IsTriggerNameContext()
}

type TriggerNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerNameContext() *TriggerNameContext {
	var p = new(TriggerNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_triggerName
	return p
}

func (*TriggerNameContext) IsTriggerNameContext() {}

func NewTriggerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerNameContext {
	var p = new(TriggerNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_triggerName

	return p
}

func (s *TriggerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TriggerNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *TriggerNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *TriggerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTriggerName(s)
	}
}

func (s *TriggerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTriggerName(s)
	}
}

func (s *TriggerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTriggerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TriggerName() (localctx ITriggerNameContext) {
	this := p
	_ = this

	localctx = NewTriggerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SQLServerStatementParserRULE_triggerName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1480)
			p.SchemaName()
		}
		{
			p.SetState(1481)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1485)
		p.Name()
	}

	return localctx
}

// ISequenceNameContext is an interface to support dynamic dispatch.
type ISequenceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequenceNameContext differentiates from other interfaces.
	IsSequenceNameContext()
}

type SequenceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceNameContext() *SequenceNameContext {
	var p = new(SequenceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_sequenceName
	return p
}

func (*SequenceNameContext) IsSequenceNameContext() {}

func NewSequenceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceNameContext {
	var p = new(SequenceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_sequenceName

	return p
}

func (s *SequenceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *SequenceNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *SequenceNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *SequenceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSequenceName(s)
	}
}

func (s *SequenceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSequenceName(s)
	}
}

func (s *SequenceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSequenceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SequenceName() (localctx ISequenceNameContext) {
	this := p
	_ = this

	localctx = NewSequenceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SQLServerStatementParserRULE_sequenceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1487)
			p.SchemaName()
		}
		{
			p.SetState(1488)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1492)
		p.Name()
	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TableNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *TableNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SQLServerStatementParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1494)
			p.Owner()
		}
		{
			p.SetState(1495)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1499)
		p.Name()
	}

	return localctx
}

// IQueueNameContext is an interface to support dynamic dispatch.
type IQueueNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueueNameContext differentiates from other interfaces.
	IsQueueNameContext()
}

type QueueNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueueNameContext() *QueueNameContext {
	var p = new(QueueNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_queueName
	return p
}

func (*QueueNameContext) IsQueueNameContext() {}

func NewQueueNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueueNameContext {
	var p = new(QueueNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_queueName

	return p
}

func (s *QueueNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QueueNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *QueueNameContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *QueueNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *QueueNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueueNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueueNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQueueName(s)
	}
}

func (s *QueueNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQueueName(s)
	}
}

func (s *QueueNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQueueName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QueueName() (localctx IQueueNameContext) {
	this := p
	_ = this

	localctx = NewQueueNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SQLServerStatementParserRULE_queueName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1504)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1501)
			p.SchemaName()
		}
		{
			p.SetState(1502)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1506)
		p.Name()
	}

	return localctx
}

// IContractNameContext is an interface to support dynamic dispatch.
type IContractNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContractNameContext differentiates from other interfaces.
	IsContractNameContext()
}

type ContractNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContractNameContext() *ContractNameContext {
	var p = new(ContractNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_contractName
	return p
}

func (*ContractNameContext) IsContractNameContext() {}

func NewContractNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContractNameContext {
	var p = new(ContractNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_contractName

	return p
}

func (s *ContractNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ContractNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ContractNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContractNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContractNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterContractName(s)
	}
}

func (s *ContractNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitContractName(s)
	}
}

func (s *ContractNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitContractName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ContractName() (localctx IContractNameContext) {
	this := p
	_ = this

	localctx = NewContractNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SQLServerStatementParserRULE_contractName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1508)
		p.Name()
	}

	return localctx
}

// IServiceNameContext is an interface to support dynamic dispatch.
type IServiceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServiceNameContext differentiates from other interfaces.
	IsServiceNameContext()
}

type ServiceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceNameContext() *ServiceNameContext {
	var p = new(ServiceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serviceName
	return p
}

func (*ServiceNameContext) IsServiceNameContext() {}

func NewServiceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceNameContext {
	var p = new(ServiceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serviceName

	return p
}

func (s *ServiceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ServiceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServiceName(s)
	}
}

func (s *ServiceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServiceName(s)
	}
}

func (s *ServiceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServiceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServiceName() (localctx IServiceNameContext) {
	this := p
	_ = this

	localctx = NewServiceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, SQLServerStatementParserRULE_serviceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.Name()
	}

	return localctx
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnName
	return p
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ColumnNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ColumnNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnName() (localctx IColumnNameContext) {
	this := p
	_ = this

	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, SQLServerStatementParserRULE_columnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1512)
			p.Owner()
		}
		{
			p.SetState(1513)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1517)
		p.Name()
	}

	return localctx
}

// IOwnerContext is an interface to support dynamic dispatch.
type IOwnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOwnerContext differentiates from other interfaces.
	IsOwnerContext()
}

type OwnerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerContext() *OwnerContext {
	var p = new(OwnerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_owner
	return p
}

func (*OwnerContext) IsOwnerContext() {}

func NewOwnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerContext {
	var p = new(OwnerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_owner

	return p
}

func (s *OwnerContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OwnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OwnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOwner(s)
	}
}

func (s *OwnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOwner(s)
	}
}

func (s *OwnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOwner(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Owner() (localctx IOwnerContext) {
	this := p
	_ = this

	localctx = NewOwnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SQLServerStatementParserRULE_owner)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Identifier()
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SQLServerStatementParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Identifier()
	}

	return localctx
}

// IColumnNamesContext is an interface to support dynamic dispatch.
type IColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNamesContext differentiates from other interfaces.
	IsColumnNamesContext()
}

type ColumnNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNamesContext() *ColumnNamesContext {
	var p = new(ColumnNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnNames
	return p
}

func (*ColumnNamesContext) IsColumnNamesContext() {}

func NewColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNamesContext {
	var p = new(ColumnNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnNames

	return p
}

func (s *ColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNamesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ColumnNamesContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *ColumnNamesContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnNamesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ColumnNamesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ColumnNamesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnNames(s)
	}
}

func (s *ColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnNames(s)
	}
}

func (s *ColumnNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnNames() (localctx IColumnNamesContext) {
	this := p
	_ = this

	localctx = NewColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SQLServerStatementParserRULE_columnNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1523)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1524)
		p.ColumnName()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1525)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1526)
			p.ColumnName()
		}

		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1532)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IColumnNamesWithSortContext is an interface to support dynamic dispatch.
type IColumnNamesWithSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNamesWithSortContext differentiates from other interfaces.
	IsColumnNamesWithSortContext()
}

type ColumnNamesWithSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNamesWithSortContext() *ColumnNamesWithSortContext {
	var p = new(ColumnNamesWithSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnNamesWithSort
	return p
}

func (*ColumnNamesWithSortContext) IsColumnNamesWithSortContext() {}

func NewColumnNamesWithSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNamesWithSortContext {
	var p = new(ColumnNamesWithSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnNamesWithSort

	return p
}

func (s *ColumnNamesWithSortContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNamesWithSortContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ColumnNamesWithSortContext) AllColumnNameWithSort() []IColumnNameWithSortContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameWithSortContext)(nil)).Elem())
	var tst = make([]IColumnNameWithSortContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameWithSortContext)
		}
	}

	return tst
}

func (s *ColumnNamesWithSortContext) ColumnNameWithSort(i int) IColumnNameWithSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameWithSortContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithSortContext)
}

func (s *ColumnNamesWithSortContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ColumnNamesWithSortContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ColumnNamesWithSortContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ColumnNamesWithSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNamesWithSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNamesWithSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnNamesWithSort(s)
	}
}

func (s *ColumnNamesWithSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnNamesWithSort(s)
	}
}

func (s *ColumnNamesWithSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnNamesWithSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnNamesWithSort() (localctx IColumnNamesWithSortContext) {
	this := p
	_ = this

	localctx = NewColumnNamesWithSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SQLServerStatementParserRULE_columnNamesWithSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1535)
		p.ColumnNameWithSort()
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1536)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1537)
			p.ColumnNameWithSort()
		}

		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1543)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ITableNamesContext is an interface to support dynamic dispatch.
type ITableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNamesContext differentiates from other interfaces.
	IsTableNamesContext()
}

type TableNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNamesContext() *TableNamesContext {
	var p = new(TableNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableNames
	return p
}

func (*TableNamesContext) IsTableNamesContext() {}

func NewTableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNamesContext {
	var p = new(TableNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableNames

	return p
}

func (s *TableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNamesContext) AllTableName() []ITableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableNameContext)(nil)).Elem())
	var tst = make([]ITableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableNameContext)
		}
	}

	return tst
}

func (s *TableNamesContext) TableName(i int) ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableNamesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *TableNamesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *TableNamesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *TableNamesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *TableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableNames(s)
	}
}

func (s *TableNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableNames(s)
	}
}

func (s *TableNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableNames() (localctx ITableNamesContext) {
	this := p
	_ = this

	localctx = NewTableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SQLServerStatementParserRULE_tableNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(1545)
			p.Match(SQLServerStatementParserLP_)
		}

	}
	{
		p.SetState(1548)
		p.TableName()
	}
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1549)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1550)
			p.TableName()
		}

		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserRP_ {
		{
			p.SetState(1556)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexName
	return p
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexName() (localctx IIndexNameContext) {
	this := p
	_ = this

	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SQLServerStatementParserRULE_indexName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		p.Identifier()
	}

	return localctx
}

// IConstraintNameContext is an interface to support dynamic dispatch.
type IConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintNameContext differentiates from other interfaces.
	IsConstraintNameContext()
}

type ConstraintNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintNameContext() *ConstraintNameContext {
	var p = new(ConstraintNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_constraintName
	return p
}

func (*ConstraintNameContext) IsConstraintNameContext() {}

func NewConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintNameContext {
	var p = new(ConstraintNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_constraintName

	return p
}

func (s *ConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterConstraintName(s)
	}
}

func (s *ConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitConstraintName(s)
	}
}

func (s *ConstraintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitConstraintName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ConstraintName() (localctx IConstraintNameContext) {
	this := p
	_ = this

	localctx = NewConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SQLServerStatementParserRULE_constraintName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		p.Identifier()
	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *CollationNameContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CollationName() (localctx ICollationNameContext) {
	this := p
	_ = this

	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SQLServerStatementParserRULE_collationName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserIDENTIFIER_ || _la == SQLServerStatementParserSTRING_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeLengthContext is an interface to support dynamic dispatch.
type IDataTypeLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeLengthContext differentiates from other interfaces.
	IsDataTypeLengthContext()
}

type DataTypeLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeLengthContext() *DataTypeLengthContext {
	var p = new(DataTypeLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataTypeLength
	return p
}

func (*DataTypeLengthContext) IsDataTypeLengthContext() {}

func NewDataTypeLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeLengthContext {
	var p = new(DataTypeLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataTypeLength

	return p
}

func (s *DataTypeLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeLengthContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DataTypeLengthContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DataTypeLengthContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNUMBER_)
}

func (s *DataTypeLengthContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, i)
}

func (s *DataTypeLengthContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *DataTypeLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataTypeLength(s)
	}
}

func (s *DataTypeLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataTypeLength(s)
	}
}

func (s *DataTypeLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataTypeLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataTypeLength() (localctx IDataTypeLengthContext) {
	this := p
	_ = this

	localctx = NewDataTypeLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SQLServerStatementParserRULE_dataTypeLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserNUMBER_ {
		{
			p.SetState(1566)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		p.SetState(1569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(1567)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(1568)
				p.Match(SQLServerStatementParserNUMBER_)
			}

		}

	}
	{
		p.SetState(1573)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IPrimaryKeyContext is an interface to support dynamic dispatch.
type IPrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyContext differentiates from other interfaces.
	IsPrimaryKeyContext()
}

type PrimaryKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyContext() *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_primaryKey
	return p
}

func (*PrimaryKeyContext) IsPrimaryKeyContext() {}

func NewPrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_primaryKey

	return p
}

func (s *PrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *PrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRIMARY, 0)
}

func (s *PrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrimaryKey(s)
	}
}

func (s *PrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrimaryKey(s)
	}
}

func (s *PrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrimaryKey() (localctx IPrimaryKeyContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SQLServerStatementParserRULE_primaryKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPRIMARY {
		{
			p.SetState(1575)
			p.Match(SQLServerStatementParserPRIMARY)
		}

	}
	{
		p.SetState(1578)
		p.Match(SQLServerStatementParserKEY)
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) NotOperator() INotOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOperatorContext)
}

func (s *ExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ExprContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ExprContext) BooleanPrimary() IBooleanPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanPrimaryContext)
}

func (s *ExprContext) AndOperator() IAndOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAndOperatorContext)
}

func (s *ExprContext) OrOperator() IOrOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrOperatorContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *SQLServerStatementParser) expr(_p int) (localctx IExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 154
	p.EnterRecursionRule(localctx, 154, SQLServerStatementParserRULE_expr, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1581)
			p.NotOperator()
		}
		{
			p.SetState(1582)
			p.expr(3)
		}

	case 2:
		{
			p.SetState(1584)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1585)
			p.expr(0)
		}
		{
			p.SetState(1586)
			p.Match(SQLServerStatementParserRP_)
		}

	case 3:
		{
			p.SetState(1588)
			p.booleanPrimary(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1601)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1599)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_expr)
				p.SetState(1591)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1592)
					p.AndOperator()
				}
				{
					p.SetState(1593)
					p.expr(6)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_expr)
				p.SetState(1595)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1596)
					p.OrOperator()
				}
				{
					p.SetState(1597)
					p.expr(5)
				}

			}

		}
		p.SetState(1603)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// IAndOperatorContext is an interface to support dynamic dispatch.
type IAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndOperatorContext differentiates from other interfaces.
	IsAndOperatorContext()
}

type AndOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndOperatorContext() *AndOperatorContext {
	var p = new(AndOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_andOperator
	return p
}

func (*AndOperatorContext) IsAndOperatorContext() {}

func NewAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndOperatorContext {
	var p = new(AndOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_andOperator

	return p
}

func (s *AndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AndOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAND, 0)
}

func (s *AndOperatorContext) AND_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAND_, 0)
}

func (s *AndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAndOperator(s)
	}
}

func (s *AndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAndOperator(s)
	}
}

func (s *AndOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAndOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AndOperator() (localctx IAndOperatorContext) {
	this := p
	_ = this

	localctx = NewAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SQLServerStatementParserRULE_andOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserAND_ || _la == SQLServerStatementParserAND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOrOperatorContext is an interface to support dynamic dispatch.
type IOrOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrOperatorContext differentiates from other interfaces.
	IsOrOperatorContext()
}

type OrOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrOperatorContext() *OrOperatorContext {
	var p = new(OrOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_orOperator
	return p
}

func (*OrOperatorContext) IsOrOperatorContext() {}

func NewOrOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrOperatorContext {
	var p = new(OrOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_orOperator

	return p
}

func (s *OrOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *OrOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR, 0)
}

func (s *OrOperatorContext) OR_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR_, 0)
}

func (s *OrOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOrOperator(s)
	}
}

func (s *OrOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOrOperator(s)
	}
}

func (s *OrOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOrOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OrOperator() (localctx IOrOperatorContext) {
	this := p
	_ = this

	localctx = NewOrOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SQLServerStatementParserRULE_orOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1606)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserOR_ || _la == SQLServerStatementParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INotOperatorContext is an interface to support dynamic dispatch.
type INotOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOperatorContext differentiates from other interfaces.
	IsNotOperatorContext()
}

type NotOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOperatorContext() *NotOperatorContext {
	var p = new(NotOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_notOperator
	return p
}

func (*NotOperatorContext) IsNotOperatorContext() {}

func NewNotOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOperatorContext {
	var p = new(NotOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_notOperator

	return p
}

func (s *NotOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *NotOperatorContext) NOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT_, 0)
}

func (s *NotOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterNotOperator(s)
	}
}

func (s *NotOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitNotOperator(s)
	}
}

func (s *NotOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitNotOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) NotOperator() (localctx INotOperatorContext) {
	this := p
	_ = this

	localctx = NewNotOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SQLServerStatementParserRULE_notOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserNOT_ || _la == SQLServerStatementParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanPrimaryContext is an interface to support dynamic dispatch.
type IBooleanPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanPrimaryContext differentiates from other interfaces.
	IsBooleanPrimaryContext()
}

type BooleanPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanPrimaryContext() *BooleanPrimaryContext {
	var p = new(BooleanPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_booleanPrimary
	return p
}

func (*BooleanPrimaryContext) IsBooleanPrimaryContext() {}

func NewBooleanPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanPrimaryContext {
	var p = new(BooleanPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_booleanPrimary

	return p
}

func (s *BooleanPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanPrimaryContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanPrimaryContext) BooleanPrimary() IBooleanPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanPrimaryContext)
}

func (s *BooleanPrimaryContext) IS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIS, 0)
}

func (s *BooleanPrimaryContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUE, 0)
}

func (s *BooleanPrimaryContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFALSE, 0)
}

func (s *BooleanPrimaryContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNKNOWN, 0)
}

func (s *BooleanPrimaryContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *BooleanPrimaryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *BooleanPrimaryContext) SAFE_EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSAFE_EQ_, 0)
}

func (s *BooleanPrimaryContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BooleanPrimaryContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *BooleanPrimaryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *BooleanPrimaryContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *BooleanPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBooleanPrimary(s)
	}
}

func (s *BooleanPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBooleanPrimary(s)
	}
}

func (s *BooleanPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBooleanPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BooleanPrimary() (localctx IBooleanPrimaryContext) {
	return p.booleanPrimary(0)
}

func (p *SQLServerStatementParser) booleanPrimary(_p int) (localctx IBooleanPrimaryContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 162
	p.EnterRecursionRule(localctx, 162, SQLServerStatementParserRULE_booleanPrimary, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1633)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1631)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_booleanPrimary)
				p.SetState(1613)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1614)
					p.Match(SQLServerStatementParserIS)
				}
				p.SetState(1616)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SQLServerStatementParserNOT {
					{
						p.SetState(1615)
						p.Match(SQLServerStatementParserNOT)
					}

				}
				{
					p.SetState(1618)
					_la = p.GetTokenStream().LA(1)

					if !((((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(SQLServerStatementParserNULL-105))|(1<<(SQLServerStatementParserTRUE-105))|(1<<(SQLServerStatementParserFALSE-105)))) != 0) || _la == SQLServerStatementParserUNKNOWN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 2:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_booleanPrimary)
				p.SetState(1619)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1620)
					p.Match(SQLServerStatementParserSAFE_EQ_)
				}
				{
					p.SetState(1621)
					p.Predicate()
				}

			case 3:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_booleanPrimary)
				p.SetState(1622)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1623)
					p.ComparisonOperator()
				}
				{
					p.SetState(1624)
					p.Predicate()
				}

			case 4:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_booleanPrimary)
				p.SetState(1626)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1627)
					p.ComparisonOperator()
				}
				{
					p.SetState(1628)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SQLServerStatementParserALL || _la == SQLServerStatementParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1629)
					p.Subquery()
				}

			}

		}
		p.SetState(1635)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ComparisonOperatorContext) GTE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGTE_, 0)
}

func (s *ComparisonOperatorContext) GT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGT_, 0)
}

func (s *ComparisonOperatorContext) LTE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLTE_, 0)
}

func (s *ComparisonOperatorContext) LT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLT_, 0)
}

func (s *ComparisonOperatorContext) NEQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNEQ_, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SQLServerStatementParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1636)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLServerStatementParserEQ_)|(1<<SQLServerStatementParserNEQ_)|(1<<SQLServerStatementParserGT_)|(1<<SQLServerStatementParserGTE_)|(1<<SQLServerStatementParserLT_)|(1<<SQLServerStatementParserLTE_))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) AllBitExpr() []IBitExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitExprContext)(nil)).Elem())
	var tst = make([]IBitExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) BitExpr(i int) IBitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIN, 0)
}

func (s *PredicateContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *PredicateContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *PredicateContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *PredicateContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *PredicateContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBETWEEN, 0)
}

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAND, 0)
}

func (s *PredicateContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLIKE, 0)
}

func (s *PredicateContext) AllSimpleExpr() []ISimpleExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem())
	var tst = make([]ISimpleExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) SimpleExpr(i int) ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *PredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserESCAPE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Predicate() (localctx IPredicateContext) {
	this := p
	_ = this

	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SQLServerStatementParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1638)
			p.bitExpr(0)
		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(1639)
				p.Match(SQLServerStatementParserNOT)
			}

		}
		{
			p.SetState(1642)
			p.Match(SQLServerStatementParserIN)
		}
		{
			p.SetState(1643)
			p.Subquery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1645)
			p.bitExpr(0)
		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(1646)
				p.Match(SQLServerStatementParserNOT)
			}

		}
		{
			p.SetState(1649)
			p.Match(SQLServerStatementParserIN)
		}
		{
			p.SetState(1650)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1651)
			p.expr(0)
		}
		p.SetState(1656)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(1652)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(1653)
				p.expr(0)
			}

			p.SetState(1658)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1659)
			p.Match(SQLServerStatementParserRP_)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1661)
			p.bitExpr(0)
		}
		p.SetState(1663)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(1662)
				p.Match(SQLServerStatementParserNOT)
			}

		}
		{
			p.SetState(1665)
			p.Match(SQLServerStatementParserBETWEEN)
		}
		{
			p.SetState(1666)
			p.bitExpr(0)
		}
		{
			p.SetState(1667)
			p.Match(SQLServerStatementParserAND)
		}
		{
			p.SetState(1668)
			p.Predicate()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1670)
			p.bitExpr(0)
		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(1671)
				p.Match(SQLServerStatementParserNOT)
			}

		}
		{
			p.SetState(1674)
			p.Match(SQLServerStatementParserLIKE)
		}
		{
			p.SetState(1675)
			p.simpleExpr(0)
		}
		p.SetState(1678)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1676)
				p.Match(SQLServerStatementParserESCAPE)
			}
			{
				p.SetState(1677)
				p.simpleExpr(0)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1680)
			p.bitExpr(0)
		}

	}

	return localctx
}

// IBitExprContext is an interface to support dynamic dispatch.
type IBitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitExprContext differentiates from other interfaces.
	IsBitExprContext()
}

type BitExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitExprContext() *BitExprContext {
	var p = new(BitExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_bitExpr
	return p
}

func (*BitExprContext) IsBitExprContext() {}

func NewBitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitExprContext {
	var p = new(BitExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_bitExpr

	return p
}

func (s *BitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitExprContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *BitExprContext) AllBitExpr() []IBitExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitExprContext)(nil)).Elem())
	var tst = make([]IBitExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitExprContext)
		}
	}

	return tst
}

func (s *BitExprContext) BitExpr(i int) IBitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *BitExprContext) VERTICAL_BAR_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVERTICAL_BAR_, 0)
}

func (s *BitExprContext) AMPERSAND_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAMPERSAND_, 0)
}

func (s *BitExprContext) SIGNED_LEFT_SHIFT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIGNED_LEFT_SHIFT_, 0)
}

func (s *BitExprContext) SIGNED_RIGHT_SHIFT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIGNED_RIGHT_SHIFT_, 0)
}

func (s *BitExprContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPLUS_, 0)
}

func (s *BitExprContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUS_, 0)
}

func (s *BitExprContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASTERISK_, 0)
}

func (s *BitExprContext) SLASH_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSLASH_, 0)
}

func (s *BitExprContext) MOD_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOD_, 0)
}

func (s *BitExprContext) CARET_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCARET_, 0)
}

func (s *BitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBitExpr(s)
	}
}

func (s *BitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBitExpr(s)
	}
}

func (s *BitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BitExpr() (localctx IBitExprContext) {
	return p.bitExpr(0)
}

func (p *SQLServerStatementParser) bitExpr(_p int) (localctx IBitExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBitExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 168
	p.EnterRecursionRule(localctx, 168, SQLServerStatementParserRULE_bitExpr, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1684)
		p.simpleExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1716)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1686)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1687)
					p.Match(SQLServerStatementParserVERTICAL_BAR_)
				}
				{
					p.SetState(1688)
					p.bitExpr(12)
				}

			case 2:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1689)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1690)
					p.Match(SQLServerStatementParserAMPERSAND_)
				}
				{
					p.SetState(1691)
					p.bitExpr(11)
				}

			case 3:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1692)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1693)
					p.Match(SQLServerStatementParserSIGNED_LEFT_SHIFT_)
				}
				{
					p.SetState(1694)
					p.bitExpr(10)
				}

			case 4:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1695)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1696)
					p.Match(SQLServerStatementParserSIGNED_RIGHT_SHIFT_)
				}
				{
					p.SetState(1697)
					p.bitExpr(9)
				}

			case 5:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1698)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1699)
					p.Match(SQLServerStatementParserPLUS_)
				}
				{
					p.SetState(1700)
					p.bitExpr(8)
				}

			case 6:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1701)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1702)
					p.Match(SQLServerStatementParserMINUS_)
				}
				{
					p.SetState(1703)
					p.bitExpr(7)
				}

			case 7:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1704)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1705)
					p.Match(SQLServerStatementParserASTERISK_)
				}
				{
					p.SetState(1706)
					p.bitExpr(6)
				}

			case 8:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1707)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1708)
					p.Match(SQLServerStatementParserSLASH_)
				}
				{
					p.SetState(1709)
					p.bitExpr(5)
				}

			case 9:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1710)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1711)
					p.Match(SQLServerStatementParserMOD_)
				}
				{
					p.SetState(1712)
					p.bitExpr(4)
				}

			case 10:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_bitExpr)
				p.SetState(1713)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1714)
					p.Match(SQLServerStatementParserCARET_)
				}
				{
					p.SetState(1715)
					p.bitExpr(3)
				}

			}

		}
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleExprContext is an interface to support dynamic dispatch.
type ISimpleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleExprContext differentiates from other interfaces.
	IsSimpleExprContext()
}

type SimpleExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprContext() *SimpleExprContext {
	var p = new(SimpleExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_simpleExpr
	return p
}

func (*SimpleExprContext) IsSimpleExprContext() {}

func NewSimpleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprContext {
	var p = new(SimpleExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_simpleExpr

	return p
}

func (s *SimpleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SimpleExprContext) ParameterMarker() IParameterMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterMarkerContext)
}

func (s *SimpleExprContext) Literals() ILiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralsContext)
}

func (s *SimpleExprContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *SimpleExprContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *SimpleExprContext) AllSimpleExpr() []ISimpleExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem())
	var tst = make([]ISimpleExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleExprContext)
		}
	}

	return tst
}

func (s *SimpleExprContext) SimpleExpr(i int) ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPLUS_, 0)
}

func (s *SimpleExprContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUS_, 0)
}

func (s *SimpleExprContext) TILDE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTILDE_, 0)
}

func (s *SimpleExprContext) NOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT_, 0)
}

func (s *SimpleExprContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINARY, 0)
}

func (s *SimpleExprContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *SimpleExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *SimpleExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *SimpleExprContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *SimpleExprContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *SimpleExprContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *SimpleExprContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SimpleExprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXISTS, 0)
}

func (s *SimpleExprContext) LBE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLBE_, 0)
}

func (s *SimpleExprContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleExprContext) RBE_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRBE_, 0)
}

func (s *SimpleExprContext) CaseExpression() ICaseExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *SimpleExprContext) PrivateExprOfDb() IPrivateExprOfDbContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivateExprOfDbContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivateExprOfDbContext)
}

func (s *SimpleExprContext) OR_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR_, 0)
}

func (s *SimpleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSimpleExpr(s)
	}
}

func (s *SimpleExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSimpleExpr(s)
	}
}

func (s *SimpleExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSimpleExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SimpleExpr() (localctx ISimpleExprContext) {
	return p.simpleExpr(0)
}

func (p *SQLServerStatementParser) simpleExpr(_p int) (localctx ISimpleExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSimpleExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 170
	p.EnterRecursionRule(localctx, 170, SQLServerStatementParserRULE_simpleExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1722)
			p.FunctionCall()
		}

	case 2:
		{
			p.SetState(1723)
			p.ParameterMarker()
		}

	case 3:
		{
			p.SetState(1724)
			p.Literals()
		}

	case 4:
		{
			p.SetState(1725)
			p.ColumnName()
		}

	case 5:
		{
			p.SetState(1726)
			p.VariableName()
		}

	case 6:
		{
			p.SetState(1727)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLServerStatementParserNOT_)|(1<<SQLServerStatementParserTILDE_)|(1<<SQLServerStatementParserPLUS_)|(1<<SQLServerStatementParserMINUS_))) != 0) || _la == SQLServerStatementParserBINARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1728)
			p.simpleExpr(6)
		}

	case 7:
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserROW {
			{
				p.SetState(1729)
				p.Match(SQLServerStatementParserROW)
			}

		}
		{
			p.SetState(1732)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1733)
			p.expr(0)
		}
		p.SetState(1738)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(1734)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(1735)
				p.expr(0)
			}

			p.SetState(1740)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1741)
			p.Match(SQLServerStatementParserRP_)
		}

	case 8:
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEXISTS {
			{
				p.SetState(1743)
				p.Match(SQLServerStatementParserEXISTS)
			}

		}
		{
			p.SetState(1746)
			p.Subquery()
		}

	case 9:
		{
			p.SetState(1747)
			p.Match(SQLServerStatementParserLBE_)
		}
		{
			p.SetState(1748)
			p.Identifier()
		}
		{
			p.SetState(1749)
			p.expr(0)
		}
		{
			p.SetState(1750)
			p.Match(SQLServerStatementParserRBE_)
		}

	case 10:
		{
			p.SetState(1752)
			p.CaseExpression()
		}

	case 11:
		{
			p.SetState(1753)
			p.PrivateExprOfDb()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSimpleExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SQLServerStatementParserRULE_simpleExpr)
			p.SetState(1756)

			if !(p.Precpred(p.GetParserRuleContext(), 7)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
			}
			{
				p.SetState(1757)
				p.Match(SQLServerStatementParserOR_)
			}
			{
				p.SetState(1758)
				p.simpleExpr(8)
			}

		}
		p.SetState(1763)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext())
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *FunctionCallContext) SpecialFunction() ISpecialFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionContext)
}

func (s *FunctionCallContext) RegularFunction() IRegularFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularFunctionContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SQLServerStatementParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1767)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1764)
			p.AggregationFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1765)
			p.SpecialFunction()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1766)
			p.RegularFunction()
		}

	}

	return localctx
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_aggregationFunction
	return p
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AggregationFunctionName() IAggregationFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionNameContext)
}

func (s *AggregationFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AggregationFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AggregationFunctionContext) Distinct() IDistinctContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistinctContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistinctContext)
}

func (s *AggregationFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AggregationFunctionContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASTERISK_, 0)
}

func (s *AggregationFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AggregationFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	this := p
	_ = this

	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SQLServerStatementParserRULE_aggregationFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1769)
		p.AggregationFunctionName()
	}
	{
		p.SetState(1770)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserDISTINCT {
		{
			p.SetState(1771)
			p.Distinct()
		}

	}
	p.SetState(1783)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNOT_, SQLServerStatementParserTILDE_, SQLServerStatementParserPLUS_, SQLServerStatementParserMINUS_, SQLServerStatementParserLP_, SQLServerStatementParserLBE_, SQLServerStatementParserQUESTION_, SQLServerStatementParserAT_, SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCASE, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserTRUE, SQLServerStatementParserFALSE, SQLServerStatementParserEXISTS, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserCONVERT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_, SQLServerStatementParserNUMBER_, SQLServerStatementParserHEX_DIGIT_, SQLServerStatementParserBIT_NUM_:
		{
			p.SetState(1774)
			p.expr(0)
		}
		p.SetState(1779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(1775)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(1776)
				p.expr(0)
			}

			p.SetState(1781)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SQLServerStatementParserASTERISK_:
		{
			p.SetState(1782)
			p.Match(SQLServerStatementParserASTERISK_)
		}

	case SQLServerStatementParserRP_:

	default:
	}
	{
		p.SetState(1785)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IAggregationFunctionNameContext is an interface to support dynamic dispatch.
type IAggregationFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregationFunctionNameContext differentiates from other interfaces.
	IsAggregationFunctionNameContext()
}

type AggregationFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionNameContext() *AggregationFunctionNameContext {
	var p = new(AggregationFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_aggregationFunctionName
	return p
}

func (*AggregationFunctionNameContext) IsAggregationFunctionNameContext() {}

func NewAggregationFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionNameContext {
	var p = new(AggregationFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_aggregationFunctionName

	return p
}

func (s *AggregationFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionNameContext) MAX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX, 0)
}

func (s *AggregationFunctionNameContext) MIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIN, 0)
}

func (s *AggregationFunctionNameContext) SUM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUM, 0)
}

func (s *AggregationFunctionNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOUNT, 0)
}

func (s *AggregationFunctionNameContext) AVG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAVG, 0)
}

func (s *AggregationFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAggregationFunctionName(s)
	}
}

func (s *AggregationFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAggregationFunctionName(s)
	}
}

func (s *AggregationFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAggregationFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AggregationFunctionName() (localctx IAggregationFunctionNameContext) {
	this := p
	_ = this

	localctx = NewAggregationFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SQLServerStatementParserRULE_aggregationFunctionName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1787)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-146)&-(0x1f+1)) == 0 && ((1<<uint((_la-146)))&((1<<(SQLServerStatementParserMAX-146))|(1<<(SQLServerStatementParserMIN-146))|(1<<(SQLServerStatementParserSUM-146))|(1<<(SQLServerStatementParserCOUNT-146))|(1<<(SQLServerStatementParserAVG-146)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDistinctContext is an interface to support dynamic dispatch.
type IDistinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDistinctContext differentiates from other interfaces.
	IsDistinctContext()
}

type DistinctContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctContext() *DistinctContext {
	var p = new(DistinctContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_distinct
	return p
}

func (*DistinctContext) IsDistinctContext() {}

func NewDistinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctContext {
	var p = new(DistinctContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_distinct

	return p
}

func (s *DistinctContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISTINCT, 0)
}

func (s *DistinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDistinct(s)
	}
}

func (s *DistinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDistinct(s)
	}
}

func (s *DistinctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDistinct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Distinct() (localctx IDistinctContext) {
	this := p
	_ = this

	localctx = NewDistinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SQLServerStatementParserRULE_distinct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.Match(SQLServerStatementParserDISTINCT)
	}

	return localctx
}

// ISpecialFunctionContext is an interface to support dynamic dispatch.
type ISpecialFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialFunctionContext differentiates from other interfaces.
	IsSpecialFunctionContext()
}

type SpecialFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionContext() *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_specialFunction
	return p
}

func (*SpecialFunctionContext) IsSpecialFunctionContext() {}

func NewSpecialFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_specialFunction

	return p
}

func (s *SpecialFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionContext) CastFunction() ICastFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastFunctionContext)
}

func (s *SpecialFunctionContext) CharFunction() ICharFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharFunctionContext)
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSpecialFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SpecialFunction() (localctx ISpecialFunctionContext) {
	this := p
	_ = this

	localctx = NewSpecialFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SQLServerStatementParserRULE_specialFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1793)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCAST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1791)
			p.CastFunction()
		}

	case SQLServerStatementParserCHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1792)
			p.CharFunction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICastFunctionContext is an interface to support dynamic dispatch.
type ICastFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastFunctionContext differentiates from other interfaces.
	IsCastFunctionContext()
}

type CastFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastFunctionContext() *CastFunctionContext {
	var p = new(CastFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_castFunction
	return p
}

func (*CastFunctionContext) IsCastFunctionContext() {}

func NewCastFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastFunctionContext {
	var p = new(CastFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_castFunction

	return p
}

func (s *CastFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastFunctionContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCAST, 0)
}

func (s *CastFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CastFunctionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CastFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CastFunctionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CastFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCastFunction(s)
	}
}

func (s *CastFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCastFunction(s)
	}
}

func (s *CastFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCastFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CastFunction() (localctx ICastFunctionContext) {
	this := p
	_ = this

	localctx = NewCastFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SQLServerStatementParserRULE_castFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1795)
		p.Match(SQLServerStatementParserCAST)
	}
	{
		p.SetState(1796)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1797)
		p.expr(0)
	}
	{
		p.SetState(1798)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(1799)
		p.DataType()
	}
	{
		p.SetState(1800)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ICharFunctionContext is an interface to support dynamic dispatch.
type ICharFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharFunctionContext differentiates from other interfaces.
	IsCharFunctionContext()
}

type CharFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharFunctionContext() *CharFunctionContext {
	var p = new(CharFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_charFunction
	return p
}

func (*CharFunctionContext) IsCharFunctionContext() {}

func NewCharFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharFunctionContext {
	var p = new(CharFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_charFunction

	return p
}

func (s *CharFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharFunctionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHAR, 0)
}

func (s *CharFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CharFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *CharFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CharFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CharFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CharFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CharFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSING, 0)
}

func (s *CharFunctionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *CharFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCharFunction(s)
	}
}

func (s *CharFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCharFunction(s)
	}
}

func (s *CharFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCharFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CharFunction() (localctx ICharFunctionContext) {
	this := p
	_ = this

	localctx = NewCharFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SQLServerStatementParserRULE_charFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1802)
		p.Match(SQLServerStatementParserCHAR)
	}
	{
		p.SetState(1803)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1804)
		p.expr(0)
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1805)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1806)
			p.expr(0)
		}

		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1814)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserUSING {
		{
			p.SetState(1812)
			p.Match(SQLServerStatementParserUSING)
		}
		{
			p.SetState(1813)
			p.IgnoredIdentifier()
		}

	}
	{
		p.SetState(1816)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IRegularFunctionContext is an interface to support dynamic dispatch.
type IRegularFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularFunctionContext differentiates from other interfaces.
	IsRegularFunctionContext()
}

type RegularFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularFunctionContext() *RegularFunctionContext {
	var p = new(RegularFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_regularFunction
	return p
}

func (*RegularFunctionContext) IsRegularFunctionContext() {}

func NewRegularFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularFunctionContext {
	var p = new(RegularFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_regularFunction

	return p
}

func (s *RegularFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularFunctionContext) RegularFunctionName() IRegularFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularFunctionNameContext)
}

func (s *RegularFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *RegularFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *RegularFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *RegularFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RegularFunctionContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASTERISK_, 0)
}

func (s *RegularFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *RegularFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *RegularFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRegularFunction(s)
	}
}

func (s *RegularFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRegularFunction(s)
	}
}

func (s *RegularFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRegularFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RegularFunction() (localctx IRegularFunctionContext) {
	this := p
	_ = this

	localctx = NewRegularFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SQLServerStatementParserRULE_regularFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1818)
		p.RegularFunctionName()
	}
	{
		p.SetState(1819)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(1829)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNOT_, SQLServerStatementParserTILDE_, SQLServerStatementParserPLUS_, SQLServerStatementParserMINUS_, SQLServerStatementParserLP_, SQLServerStatementParserLBE_, SQLServerStatementParserQUESTION_, SQLServerStatementParserAT_, SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCASE, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserTRUE, SQLServerStatementParserFALSE, SQLServerStatementParserEXISTS, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserCONVERT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_, SQLServerStatementParserNUMBER_, SQLServerStatementParserHEX_DIGIT_, SQLServerStatementParserBIT_NUM_:
		{
			p.SetState(1820)
			p.expr(0)
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(1821)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(1822)
				p.expr(0)
			}

			p.SetState(1827)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SQLServerStatementParserASTERISK_:
		{
			p.SetState(1828)
			p.Match(SQLServerStatementParserASTERISK_)
		}

	case SQLServerStatementParserRP_:

	default:
	}
	{
		p.SetState(1831)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IRegularFunctionNameContext is an interface to support dynamic dispatch.
type IRegularFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularFunctionNameContext differentiates from other interfaces.
	IsRegularFunctionNameContext()
}

type RegularFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularFunctionNameContext() *RegularFunctionNameContext {
	var p = new(RegularFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_regularFunctionName
	return p
}

func (*RegularFunctionNameContext) IsRegularFunctionNameContext() {}

func NewRegularFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularFunctionNameContext {
	var p = new(RegularFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_regularFunctionName

	return p
}

func (s *RegularFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularFunctionNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegularFunctionNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *RegularFunctionNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *RegularFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIF, 0)
}

func (s *RegularFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCALTIME, 0)
}

func (s *RegularFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCALTIMESTAMP, 0)
}

func (s *RegularFunctionNameContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTERVAL, 0)
}

func (s *RegularFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRegularFunctionName(s)
	}
}

func (s *RegularFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRegularFunctionName(s)
	}
}

func (s *RegularFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRegularFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RegularFunctionName() (localctx IRegularFunctionNameContext) {
	this := p
	_ = this

	localctx = NewRegularFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SQLServerStatementParserRULE_regularFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1843)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1836)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1833)
				p.Owner()
			}
			{
				p.SetState(1834)
				p.Match(SQLServerStatementParserDOT_)
			}

		}
		{
			p.SetState(1838)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1839)
			p.Match(SQLServerStatementParserIF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1840)
			p.Match(SQLServerStatementParserLOCALTIME)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1841)
			p.Match(SQLServerStatementParserLOCALTIMESTAMP)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1842)
			p.Match(SQLServerStatementParserINTERVAL)
		}

	}

	return localctx
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_caseExpression
	return p
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCASE, 0)
}

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEND, 0)
}

func (s *CaseExpressionContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *CaseExpressionContext) AllCaseWhen() []ICaseWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseWhenContext)(nil)).Elem())
	var tst = make([]ICaseWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseWhenContext)
		}
	}

	return tst
}

func (s *CaseExpressionContext) CaseWhen(i int) ICaseWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseWhenContext)
}

func (s *CaseExpressionContext) CaseElse() ICaseElseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseElseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseElseContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CaseExpression() (localctx ICaseExpressionContext) {
	this := p
	_ = this

	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SQLServerStatementParserRULE_caseExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1845)
		p.Match(SQLServerStatementParserCASE)
	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQLServerStatementParserNOT_)|(1<<SQLServerStatementParserTILDE_)|(1<<SQLServerStatementParserPLUS_)|(1<<SQLServerStatementParserMINUS_)|(1<<SQLServerStatementParserLP_)|(1<<SQLServerStatementParserLBE_))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(SQLServerStatementParserQUESTION_-39))|(1<<(SQLServerStatementParserAT_-39))|(1<<(SQLServerStatementParserTRUNCATE-39))|(1<<(SQLServerStatementParserFUNCTION-39))|(1<<(SQLServerStatementParserTRIGGER-39)))) != 0) || (((_la-78)&-(0x1f+1)) == 0 && ((1<<uint((_la-78)))&((1<<(SQLServerStatementParserCASE-78))|(1<<(SQLServerStatementParserCAST-78))|(1<<(SQLServerStatementParserIF-78))|(1<<(SQLServerStatementParserNULL-78))|(1<<(SQLServerStatementParserTRUE-78))|(1<<(SQLServerStatementParserFALSE-78))|(1<<(SQLServerStatementParserEXISTS-78)))) != 0) || (((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SQLServerStatementParserGROUP-115))|(1<<(SQLServerStatementParserLIMIT-115))|(1<<(SQLServerStatementParserOFFSET-115))|(1<<(SQLServerStatementParserSAVEPOINT-115))|(1<<(SQLServerStatementParserBOOLEAN-115))|(1<<(SQLServerStatementParserCHAR-115))|(1<<(SQLServerStatementParserARRAY-115))|(1<<(SQLServerStatementParserINTERVAL-115))|(1<<(SQLServerStatementParserDATE-115))|(1<<(SQLServerStatementParserTIME-115))|(1<<(SQLServerStatementParserTIMESTAMP-115))|(1<<(SQLServerStatementParserLOCALTIME-115))|(1<<(SQLServerStatementParserLOCALTIMESTAMP-115))|(1<<(SQLServerStatementParserQUARTER-115))|(1<<(SQLServerStatementParserWEEK-115))|(1<<(SQLServerStatementParserDAY-115))|(1<<(SQLServerStatementParserMICROSECOND-115))|(1<<(SQLServerStatementParserMAX-115)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SQLServerStatementParserMIN-147))|(1<<(SQLServerStatementParserSUM-147))|(1<<(SQLServerStatementParserCOUNT-147))|(1<<(SQLServerStatementParserAVG-147))|(1<<(SQLServerStatementParserENABLE-147))|(1<<(SQLServerStatementParserDISABLE-147))|(1<<(SQLServerStatementParserINSTANCE-147))|(1<<(SQLServerStatementParserDO-147))|(1<<(SQLServerStatementParserDEFINER-147))|(1<<(SQLServerStatementParserSQL-147))|(1<<(SQLServerStatementParserCASCADED-147))|(1<<(SQLServerStatementParserLOCAL-147))|(1<<(SQLServerStatementParserNEXT-147))|(1<<(SQLServerStatementParserNAME-147))|(1<<(SQLServerStatementParserINTEGER-147))|(1<<(SQLServerStatementParserTYPE-147)))) != 0) || (((_la-200)&-(0x1f+1)) == 0 && ((1<<uint((_la-200)))&((1<<(SQLServerStatementParserREAD_ONLY-200))|(1<<(SQLServerStatementParserDATABASE-200))|(1<<(SQLServerStatementParserDATEPART-200))|(1<<(SQLServerStatementParserBINARY-200))|(1<<(SQLServerStatementParserHIDDEN_-200))|(1<<(SQLServerStatementParserMOD-200))|(1<<(SQLServerStatementParserPARTITION-200))|(1<<(SQLServerStatementParserPARTITIONS-200))|(1<<(SQLServerStatementParserTOP-200))|(1<<(SQLServerStatementParserROW-200))|(1<<(SQLServerStatementParserROWS-200))|(1<<(SQLServerStatementParserXOR-200))|(1<<(SQLServerStatementParserALWAYS-200))|(1<<(SQLServerStatementParserROLE-200)))) != 0) || (((_la-232)&-(0x1f+1)) == 0 && ((1<<uint((_la-232)))&((1<<(SQLServerStatementParserSTART-232))|(1<<(SQLServerStatementParserALGORITHM-232))|(1<<(SQLServerStatementParserAUTO-232))|(1<<(SQLServerStatementParserBLOCKERS-232))|(1<<(SQLServerStatementParserCLUSTERED-232))|(1<<(SQLServerStatementParserNONCLUSTERED-232))|(1<<(SQLServerStatementParserCOLUMNSTORE-232))|(1<<(SQLServerStatementParserCONTENT-232))|(1<<(SQLServerStatementParserCONVERT-232))|(1<<(SQLServerStatementParserYEARS-232))|(1<<(SQLServerStatementParserMONTHS-232))|(1<<(SQLServerStatementParserWEEKS-232))|(1<<(SQLServerStatementParserDAYS-232))|(1<<(SQLServerStatementParserMINUTES-232))|(1<<(SQLServerStatementParserDENY-232))|(1<<(SQLServerStatementParserDETERMINISTIC-232))|(1<<(SQLServerStatementParserDISTRIBUTION-232))|(1<<(SQLServerStatementParserDOCUMENT-232))|(1<<(SQLServerStatementParserDURABILITY-232))|(1<<(SQLServerStatementParserENCRYPTED-232))|(1<<(SQLServerStatementParserFILESTREAM-232))|(1<<(SQLServerStatementParserFILETABLE-232))|(1<<(SQLServerStatementParserFILLFACTOR-232))|(1<<(SQLServerStatementParserFOLLOWING-232))|(1<<(SQLServerStatementParserHASH-232))|(1<<(SQLServerStatementParserHEAP-232))|(1<<(SQLServerStatementParserINBOUND-232)))) != 0) || (((_la-264)&-(0x1f+1)) == 0 && ((1<<uint((_la-264)))&((1<<(SQLServerStatementParserOUTBOUND-264))|(1<<(SQLServerStatementParserUNBOUNDED-264))|(1<<(SQLServerStatementParserINFINITE-264))|(1<<(SQLServerStatementParserLOGIN-264))|(1<<(SQLServerStatementParserMASKED-264))|(1<<(SQLServerStatementParserMAXDOP-264))|(1<<(SQLServerStatementParserMOVE-264))|(1<<(SQLServerStatementParserNOCHECK-264))|(1<<(SQLServerStatementParserOBJECT-264))|(1<<(SQLServerStatementParserOFF-264))|(1<<(SQLServerStatementParserONLINE-264))|(1<<(SQLServerStatementParserOVER-264))|(1<<(SQLServerStatementParserPAGE-264))|(1<<(SQLServerStatementParserPAUSED-264))|(1<<(SQLServerStatementParserPERIOD-264))|(1<<(SQLServerStatementParserPERSISTED-264))|(1<<(SQLServerStatementParserPRECEDING-264))|(1<<(SQLServerStatementParserRANDOMIZED-264))|(1<<(SQLServerStatementParserRANGE-264))|(1<<(SQLServerStatementParserREBUILD-264))|(1<<(SQLServerStatementParserREPLICATE-264))|(1<<(SQLServerStatementParserREPLICATION-264))|(1<<(SQLServerStatementParserRESUMABLE-264))|(1<<(SQLServerStatementParserROWGUIDCOL-264))|(1<<(SQLServerStatementParserSAVE-264))|(1<<(SQLServerStatementParserSELF-264))|(1<<(SQLServerStatementParserSPARSE-264))|(1<<(SQLServerStatementParserSWITCH-264))|(1<<(SQLServerStatementParserTRAN-264))|(1<<(SQLServerStatementParserTRANCOUNT-264)))) != 0) || (((_la-302)&-(0x1f+1)) == 0 && ((1<<uint((_la-302)))&((1<<(SQLServerStatementParserCONTROL-302))|(1<<(SQLServerStatementParserCONCAT-302))|(1<<(SQLServerStatementParserTAKE-302))|(1<<(SQLServerStatementParserOWNERSHIP-302))|(1<<(SQLServerStatementParserDEFINITION-302))|(1<<(SQLServerStatementParserAPPLICATION-302))|(1<<(SQLServerStatementParserASSEMBLY-302))|(1<<(SQLServerStatementParserSYMMETRIC-302))|(1<<(SQLServerStatementParserASYMMETRIC-302))|(1<<(SQLServerStatementParserSERVER-302))|(1<<(SQLServerStatementParserRECEIVE-302))|(1<<(SQLServerStatementParserCHANGE-302))|(1<<(SQLServerStatementParserTRACE-302))|(1<<(SQLServerStatementParserTRACKING-302))|(1<<(SQLServerStatementParserRESOURCES-302))|(1<<(SQLServerStatementParserSETTINGS-302))|(1<<(SQLServerStatementParserSTATE-302))|(1<<(SQLServerStatementParserAVAILABILITY-302))|(1<<(SQLServerStatementParserCREDENTIAL-302))|(1<<(SQLServerStatementParserENDPOINT-302))|(1<<(SQLServerStatementParserEVENT-302))|(1<<(SQLServerStatementParserNOTIFICATION-302))|(1<<(SQLServerStatementParserLINKED-302))|(1<<(SQLServerStatementParserAUDIT-302))|(1<<(SQLServerStatementParserDDL-302))|(1<<(SQLServerStatementParserXML-302))|(1<<(SQLServerStatementParserIMPERSONATE-302))|(1<<(SQLServerStatementParserSECURABLES-302))|(1<<(SQLServerStatementParserAUTHENTICATE-302))|(1<<(SQLServerStatementParserEXTERNAL-302))|(1<<(SQLServerStatementParserACCESS-302))|(1<<(SQLServerStatementParserADMINISTER-302)))) != 0) || (((_la-334)&-(0x1f+1)) == 0 && ((1<<uint((_la-334)))&((1<<(SQLServerStatementParserBULK-334))|(1<<(SQLServerStatementParserOPERATIONS-334))|(1<<(SQLServerStatementParserUNSAFE-334))|(1<<(SQLServerStatementParserSHUTDOWN-334))|(1<<(SQLServerStatementParserSCOPED-334))|(1<<(SQLServerStatementParserCONFIGURATION-334))|(1<<(SQLServerStatementParserDATASPACE-334))|(1<<(SQLServerStatementParserSERVICE-334))|(1<<(SQLServerStatementParserCERTIFICATE-334))|(1<<(SQLServerStatementParserCONTRACT-334))|(1<<(SQLServerStatementParserENCRYPTION-334))|(1<<(SQLServerStatementParserMASTER-334))|(1<<(SQLServerStatementParserDATA-334))|(1<<(SQLServerStatementParserSOURCE-334))|(1<<(SQLServerStatementParserFILE-334))|(1<<(SQLServerStatementParserFORMAT-334))|(1<<(SQLServerStatementParserLIBRARY-334))|(1<<(SQLServerStatementParserFULLTEXT-334))|(1<<(SQLServerStatementParserMASK-334))|(1<<(SQLServerStatementParserUNMASK-334))|(1<<(SQLServerStatementParserMESSAGE-334))|(1<<(SQLServerStatementParserREMOTE-334))|(1<<(SQLServerStatementParserBINDING-334))|(1<<(SQLServerStatementParserROUTE-334))|(1<<(SQLServerStatementParserSECURITY-334))|(1<<(SQLServerStatementParserPOLICY-334))|(1<<(SQLServerStatementParserAGGREGATE-334))|(1<<(SQLServerStatementParserQUEUE-334))|(1<<(SQLServerStatementParserRULE-334))|(1<<(SQLServerStatementParserSYNONYM-334))|(1<<(SQLServerStatementParserCOLLECTION-334))|(1<<(SQLServerStatementParserSCRIPT-334)))) != 0) || (((_la-366)&-(0x1f+1)) == 0 && ((1<<uint((_la-366)))&((1<<(SQLServerStatementParserKILL-366))|(1<<(SQLServerStatementParserBACKUP-366))|(1<<(SQLServerStatementParserLOG-366))|(1<<(SQLServerStatementParserSHOWPLAN-366))|(1<<(SQLServerStatementParserSUBSCRIBE-366))|(1<<(SQLServerStatementParserQUERY-366))|(1<<(SQLServerStatementParserNOTIFICATIONS-366))|(1<<(SQLServerStatementParserCHECKPOINT-366))|(1<<(SQLServerStatementParserSEQUENCE-366))|(1<<(SQLServerStatementParserABORT_AFTER_WAIT-366))|(1<<(SQLServerStatementParserALLOW_PAGE_LOCKS-366))|(1<<(SQLServerStatementParserALLOW_ROW_LOCKS-366))|(1<<(SQLServerStatementParserALL_SPARSE_COLUMNS-366))|(1<<(SQLServerStatementParserBUCKET_COUNT-366))|(1<<(SQLServerStatementParserCOLUMNSTORE_ARCHIVE-366))|(1<<(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY-366))|(1<<(SQLServerStatementParserCOLUMN_SET-366))|(1<<(SQLServerStatementParserCOMPRESSION_DELAY-366))|(1<<(SQLServerStatementParserDATABASE_DEAULT-366))|(1<<(SQLServerStatementParserDATA_COMPRESSION-366))|(1<<(SQLServerStatementParserDATA_CONSISTENCY_CHECK-366))|(1<<(SQLServerStatementParserENCRYPTION_TYPE-366))|(1<<(SQLServerStatementParserSYSTEM_TIME-366))|(1<<(SQLServerStatementParserSYSTEM_VERSIONING-366))|(1<<(SQLServerStatementParserTEXTIMAGE_ON-366))|(1<<(SQLServerStatementParserWAIT_AT_LOW_PRIORITY-366))|(1<<(SQLServerStatementParserSTATISTICS_INCREMENTAL-366))|(1<<(SQLServerStatementParserSTATISTICS_NORECOMPUTE-366))|(1<<(SQLServerStatementParserROUND_ROBIN-366))|(1<<(SQLServerStatementParserSCHEMA_AND_DATA-366))|(1<<(SQLServerStatementParserSCHEMA_ONLY-366))|(1<<(SQLServerStatementParserSORT_IN_TEMPDB-366)))) != 0) || (((_la-398)&-(0x1f+1)) == 0 && ((1<<uint((_la-398)))&((1<<(SQLServerStatementParserIGNORE_DUP_KEY-398))|(1<<(SQLServerStatementParserIMPLICIT_TRANSACTIONS-398))|(1<<(SQLServerStatementParserMAX_DURATION-398))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED-398))|(1<<(SQLServerStatementParserMIGRATION_STATE-398))|(1<<(SQLServerStatementParserPAD_INDEX-398))|(1<<(SQLServerStatementParserREMOTE_DATA_ARCHIVE-398))|(1<<(SQLServerStatementParserFILESTREAM_ON-398))|(1<<(SQLServerStatementParserFILETABLE_COLLATE_FILENAME-398))|(1<<(SQLServerStatementParserFILETABLE_DIRECTORY-398))|(1<<(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILTER_PREDICATE-398))|(1<<(SQLServerStatementParserHISTORY_RETENTION_PERIOD-398))|(1<<(SQLServerStatementParserHISTORY_TABLE-398))|(1<<(SQLServerStatementParserLOCK_ESCALATION-398))|(1<<(SQLServerStatementParserDROP_EXISTING-398))|(1<<(SQLServerStatementParserROW_NUMBER-398))|(1<<(SQLServerStatementParserFIRST-398))|(1<<(SQLServerStatementParserDATETIME2-398)))) != 0) || (((_la-436)&-(0x1f+1)) == 0 && ((1<<uint((_la-436)))&((1<<(SQLServerStatementParserOUTPUT-436))|(1<<(SQLServerStatementParserINSERTED-436))|(1<<(SQLServerStatementParserDELETED-436)))) != 0) || (((_la-475)&-(0x1f+1)) == 0 && ((1<<uint((_la-475)))&((1<<(SQLServerStatementParserFILENAME-475))|(1<<(SQLServerStatementParserMAXSIZE-475))|(1<<(SQLServerStatementParserFILEGROWTH-475))|(1<<(SQLServerStatementParserUNLIMITED-475))|(1<<(SQLServerStatementParserKB-475))|(1<<(SQLServerStatementParserMB-475))|(1<<(SQLServerStatementParserGB-475))|(1<<(SQLServerStatementParserTB-475))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_DATA-475))|(1<<(SQLServerStatementParserFILEGROUP-475))|(1<<(SQLServerStatementParserNON_TRANSACTED_ACCESS-475))|(1<<(SQLServerStatementParserDB_CHAINING-475))|(1<<(SQLServerStatementParserTRUSTWORTHY-475))|(1<<(SQLServerStatementParserFORWARD_ONLY-475))|(1<<(SQLServerStatementParserKEYSET-475))|(1<<(SQLServerStatementParserFAST_FORWARD-475))|(1<<(SQLServerStatementParserSCROLL_LOCKS-475))|(1<<(SQLServerStatementParserOPTIMISTIC-475))|(1<<(SQLServerStatementParserTYPE_WARNING-475))|(1<<(SQLServerStatementParserSCHEMABINDING-475))|(1<<(SQLServerStatementParserCALLER-475))|(1<<(SQLServerStatementParserOWNER-475)))) != 0) || (((_la-510)&-(0x1f+1)) == 0 && ((1<<uint((_la-510)))&((1<<(SQLServerStatementParserSNAPSHOT-510))|(1<<(SQLServerStatementParserREPEATABLE-510))|(1<<(SQLServerStatementParserSERIALIZABLE-510))|(1<<(SQLServerStatementParserNATIVE_COMPILATION-510))|(1<<(SQLServerStatementParserVIEW_METADATA-510))|(1<<(SQLServerStatementParserINSTEAD-510))|(1<<(SQLServerStatementParserAPPEND-510))|(1<<(SQLServerStatementParserINCREMENT-510))|(1<<(SQLServerStatementParserCACHE-510))|(1<<(SQLServerStatementParserMINVALUE-510))|(1<<(SQLServerStatementParserMAXVALUE-510))|(1<<(SQLServerStatementParserRESTART-510))|(1<<(SQLServerStatementParserLOB_COMPACTION-510))|(1<<(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS-510))|(1<<(SQLServerStatementParserREORGANIZE-510))|(1<<(SQLServerStatementParserRESUME-510))|(1<<(SQLServerStatementParserPAUSE-510))|(1<<(SQLServerStatementParserABORT-510))|(1<<(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY-510)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP-542))|(1<<(SQLServerStatementParserIMMEDIATE-542))|(1<<(SQLServerStatementParserNO_WAIT-542))|(1<<(SQLServerStatementParserTARGET_RECOVERY_TIME-542))|(1<<(SQLServerStatementParserSECONDS-542))|(1<<(SQLServerStatementParserHONOR_BROKER_PRIORITY-542))|(1<<(SQLServerStatementParserERROR_BROKER_CONVERSATIONS-542))|(1<<(SQLServerStatementParserNEW_BROKER-542))|(1<<(SQLServerStatementParserDISABLE_BROKER-542))|(1<<(SQLServerStatementParserENABLE_BROKER-542))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT-542))|(1<<(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT-542))|(1<<(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION-542))|(1<<(SQLServerStatementParserRECURSIVE_TRIGGERS-542))|(1<<(SQLServerStatementParserQUOTED_IDENTIFIER-542))|(1<<(SQLServerStatementParserNUMERIC_ROUNDABORT-542))|(1<<(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL-542))|(1<<(SQLServerStatementParserCOMPATIBILITY_LEVEL-542))|(1<<(SQLServerStatementParserARITHABORT-542))|(1<<(SQLServerStatementParserANSI_WARNINGS-542))|(1<<(SQLServerStatementParserANSI_PADDING-542))|(1<<(SQLServerStatementParserANSI_NULLS-542))|(1<<(SQLServerStatementParserANSI_NULL_DEFAULT-542))|(1<<(SQLServerStatementParserPAGE_VERIFY-542))|(1<<(SQLServerStatementParserCHECKSUM-542))|(1<<(SQLServerStatementParserTORN_PAGE_DETECTION-542))|(1<<(SQLServerStatementParserBULK_LOGGED-542))|(1<<(SQLServerStatementParserRECOVERY-542))|(1<<(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD-542))|(1<<(SQLServerStatementParserEXECUTION_COUNT-542)))) != 0) || (((_la-574)&-(0x1f+1)) == 0 && ((1<<uint((_la-574)))&((1<<(SQLServerStatementParserQUERY_CAPTURE_POLICY-574))|(1<<(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserMAX_PLANS_PER_QUERY-574))|(1<<(SQLServerStatementParserQUERY_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE-574))|(1<<(SQLServerStatementParserINTERVAL_LENGTH_MINUTES-574))|(1<<(SQLServerStatementParserMAX_STORAGE_SIZE_MB-574))|(1<<(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS-574))|(1<<(SQLServerStatementParserCLEANUP_POLICY-574))|(1<<(SQLServerStatementParserCUSTOM-574))|(1<<(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS-574))|(1<<(SQLServerStatementParserOPERATION_MODE-574))|(1<<(SQLServerStatementParserQUERY_STORE-574))|(1<<(SQLServerStatementParserCURSOR_DEFAULT-574))|(1<<(SQLServerStatementParserGLOBAL-574))|(1<<(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT-574))|(1<<(SQLServerStatementParserHOURS-574))|(1<<(SQLServerStatementParserCHANGE_RETENTION-574))|(1<<(SQLServerStatementParserAUTO_CLEANUP-574))|(1<<(SQLServerStatementParserCHANGE_TRACKING-574))|(1<<(SQLServerStatementParserAUTOMATIC_TUNING-574))|(1<<(SQLServerStatementParserFORCE_LAST_GOOD_PLAN-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS-574))|(1<<(SQLServerStatementParserAUTO_SHRINK-574))|(1<<(SQLServerStatementParserAUTO_CREATE_STATISTICS-574))|(1<<(SQLServerStatementParserINCREMENTAL-574))|(1<<(SQLServerStatementParserAUTO_CLOSE-574))|(1<<(SQLServerStatementParserDATA_RETENTION-574))|(1<<(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION-574))|(1<<(SQLServerStatementParserEDITION-574))|(1<<(SQLServerStatementParserMIXED_PAGE_ALLOCATION-574)))) != 0) || (((_la-606)&-(0x1f+1)) == 0 && ((1<<uint((_la-606)))&((1<<(SQLServerStatementParserDISABLED-606))|(1<<(SQLServerStatementParserALLOWED-606))|(1<<(SQLServerStatementParserHADR-606))|(1<<(SQLServerStatementParserMULTI_USER-606))|(1<<(SQLServerStatementParserRESTRICTED_USER-606))|(1<<(SQLServerStatementParserSINGLE_USER-606))|(1<<(SQLServerStatementParserOFFLINE-606))|(1<<(SQLServerStatementParserEMERGENCY-606))|(1<<(SQLServerStatementParserSUSPEND-606))|(1<<(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION-606))|(1<<(SQLServerStatementParserELASTIC_POOL-606))|(1<<(SQLServerStatementParserSERVICE_OBJECTIVE-606))|(1<<(SQLServerStatementParserDATABASE_NAME-606))|(1<<(SQLServerStatementParserALLOW_CONNECTIONS-606))|(1<<(SQLServerStatementParserGEO-606))|(1<<(SQLServerStatementParserNAMED-606))|(1<<(SQLServerStatementParserDATEFIRST-606))|(1<<(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY-606))|(1<<(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS-606))|(1<<(SQLServerStatementParserSECONDARY-606))|(1<<(SQLServerStatementParserFAILOVER-606))|(1<<(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE-606))|(1<<(SQLServerStatementParserDEFAULT_LANGUAGE-606))|(1<<(SQLServerStatementParserINLINE-606))|(1<<(SQLServerStatementParserNESTED_TRIGGERS-606))|(1<<(SQLServerStatementParserTRANSFORM_NOISE_WORDS-606))|(1<<(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF-606))|(1<<(SQLServerStatementParserPERSISTENT_LOG_BUFFER-606))|(1<<(SQLServerStatementParserDIRECTORY_NAME-606))|(1<<(SQLServerStatementParserDATEFORMAT-606))|(1<<(SQLServerStatementParserDELAYED_DURABILITY-606)))) != 0) || (((_la-638)&-(0x1f+1)) == 0 && ((1<<uint((_la-638)))&((1<<(SQLServerStatementParserTRANSFER-638))|(1<<(SQLServerStatementParserIDENTIFIER_-638))|(1<<(SQLServerStatementParserSTRING_-638))|(1<<(SQLServerStatementParserNUMBER_-638))|(1<<(SQLServerStatementParserHEX_DIGIT_-638))|(1<<(SQLServerStatementParserBIT_NUM_-638)))) != 0) {
		{
			p.SetState(1846)
			p.simpleExpr(0)
		}

	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SQLServerStatementParserWHEN {
		{
			p.SetState(1849)
			p.CaseWhen()
		}

		p.SetState(1852)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserELSE {
		{
			p.SetState(1854)
			p.CaseElse()
		}

	}
	{
		p.SetState(1857)
		p.Match(SQLServerStatementParserEND)
	}

	return localctx
}

// ICaseWhenContext is an interface to support dynamic dispatch.
type ICaseWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseWhenContext differentiates from other interfaces.
	IsCaseWhenContext()
}

type CaseWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseWhenContext() *CaseWhenContext {
	var p = new(CaseWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_caseWhen
	return p
}

func (*CaseWhenContext) IsCaseWhenContext() {}

func NewCaseWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseWhenContext {
	var p = new(CaseWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_caseWhen

	return p
}

func (s *CaseWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWHEN, 0)
}

func (s *CaseWhenContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *CaseWhenContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseWhenContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTHEN, 0)
}

func (s *CaseWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCaseWhen(s)
	}
}

func (s *CaseWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCaseWhen(s)
	}
}

func (s *CaseWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCaseWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CaseWhen() (localctx ICaseWhenContext) {
	this := p
	_ = this

	localctx = NewCaseWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SQLServerStatementParserRULE_caseWhen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1859)
		p.Match(SQLServerStatementParserWHEN)
	}
	{
		p.SetState(1860)
		p.expr(0)
	}
	{
		p.SetState(1861)
		p.Match(SQLServerStatementParserTHEN)
	}
	{
		p.SetState(1862)
		p.expr(0)
	}

	return localctx
}

// ICaseElseContext is an interface to support dynamic dispatch.
type ICaseElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseElseContext differentiates from other interfaces.
	IsCaseElseContext()
}

type CaseElseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseElseContext() *CaseElseContext {
	var p = new(CaseElseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_caseElse
	return p
}

func (*CaseElseContext) IsCaseElseContext() {}

func NewCaseElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseElseContext {
	var p = new(CaseElseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_caseElse

	return p
}

func (s *CaseElseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserELSE, 0)
}

func (s *CaseElseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCaseElse(s)
	}
}

func (s *CaseElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCaseElse(s)
	}
}

func (s *CaseElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCaseElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CaseElse() (localctx ICaseElseContext) {
	this := p
	_ = this

	localctx = NewCaseElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SQLServerStatementParserRULE_caseElse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Match(SQLServerStatementParserELSE)
	}
	{
		p.SetState(1865)
		p.expr(0)
	}

	return localctx
}

// IPrivateExprOfDbContext is an interface to support dynamic dispatch.
type IPrivateExprOfDbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivateExprOfDbContext differentiates from other interfaces.
	IsPrivateExprOfDbContext()
}

type PrivateExprOfDbContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivateExprOfDbContext() *PrivateExprOfDbContext {
	var p = new(PrivateExprOfDbContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_privateExprOfDb
	return p
}

func (*PrivateExprOfDbContext) IsPrivateExprOfDbContext() {}

func NewPrivateExprOfDbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivateExprOfDbContext {
	var p = new(PrivateExprOfDbContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_privateExprOfDb

	return p
}

func (s *PrivateExprOfDbContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivateExprOfDbContext) WindowedFunction() IWindowedFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowedFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowedFunctionContext)
}

func (s *PrivateExprOfDbContext) AtTimeZoneExpr() IAtTimeZoneExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtTimeZoneExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtTimeZoneExprContext)
}

func (s *PrivateExprOfDbContext) CastExpr() ICastExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastExprContext)
}

func (s *PrivateExprOfDbContext) ConvertExpr() IConvertExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConvertExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConvertExprContext)
}

func (s *PrivateExprOfDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivateExprOfDbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivateExprOfDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrivateExprOfDb(s)
	}
}

func (s *PrivateExprOfDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrivateExprOfDb(s)
	}
}

func (s *PrivateExprOfDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrivateExprOfDb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrivateExprOfDb() (localctx IPrivateExprOfDbContext) {
	this := p
	_ = this

	localctx = NewPrivateExprOfDbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SQLServerStatementParserRULE_privateExprOfDb)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1867)
			p.WindowedFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1868)
			p.AtTimeZoneExpr()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1869)
			p.CastExpr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1870)
			p.ConvertExpr()
		}

	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByItem() []IOrderByItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem())
	var tst = make([]IOrderByItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByItemContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByItem(i int) IOrderByItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByItemContext)
}

func (s *OrderByClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *OrderByClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *OrderByClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFFSET, 0)
}

func (s *OrderByClauseContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OrderByClauseContext) AllROW() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserROW)
}

func (s *OrderByClauseContext) ROW(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, i)
}

func (s *OrderByClauseContext) AllROWS() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserROWS)
}

func (s *OrderByClauseContext) ROWS(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWS, i)
}

func (s *OrderByClauseContext) FETCH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFETCH, 0)
}

func (s *OrderByClauseContext) ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLY, 0)
}

func (s *OrderByClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFIRST, 0)
}

func (s *OrderByClauseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNEXT, 0)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OrderByClause() (localctx IOrderByClauseContext) {
	this := p
	_ = this

	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SQLServerStatementParserRULE_orderByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		p.Match(SQLServerStatementParserORDER)
	}
	{
		p.SetState(1874)
		p.Match(SQLServerStatementParserBY)
	}
	{
		p.SetState(1875)
		p.OrderByItem()
	}
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1876)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1877)
			p.OrderByItem()
		}

		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOFFSET {
		{
			p.SetState(1883)
			p.Match(SQLServerStatementParserOFFSET)
		}
		{
			p.SetState(1884)
			p.expr(0)
		}
		{
			p.SetState(1885)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserROW || _la == SQLServerStatementParserROWS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserFETCH {
			{
				p.SetState(1886)
				p.Match(SQLServerStatementParserFETCH)
			}
			{
				p.SetState(1887)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserNEXT || _la == SQLServerStatementParserFIRST) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1888)
				p.expr(0)
			}
			{
				p.SetState(1889)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserROW || _la == SQLServerStatementParserROWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1890)
				p.Match(SQLServerStatementParserONLY)
			}

		}

	}

	return localctx
}

// IOrderByItemContext is an interface to support dynamic dispatch.
type IOrderByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByItemContext differentiates from other interfaces.
	IsOrderByItemContext()
}

type OrderByItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByItemContext() *OrderByItemContext {
	var p = new(OrderByItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_orderByItem
	return p
}

func (*OrderByItemContext) IsOrderByItemContext() {}

func NewOrderByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByItemContext {
	var p = new(OrderByItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_orderByItem

	return p
}

func (s *OrderByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByItemContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *OrderByItemContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *OrderByItemContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OrderByItemContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *OrderByItemContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OrderByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASC, 0)
}

func (s *OrderByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDESC, 0)
}

func (s *OrderByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOrderByItem(s)
	}
}

func (s *OrderByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOrderByItem(s)
	}
}

func (s *OrderByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOrderByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OrderByItem() (localctx IOrderByItemContext) {
	this := p
	_ = this

	localctx = NewOrderByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SQLServerStatementParserRULE_orderByItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1896)
			p.ColumnName()
		}

	case 2:
		{
			p.SetState(1897)
			p.NumberLiterals()
		}

	case 3:
		{
			p.SetState(1898)
			p.expr(0)
		}

	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOLLATE {
		{
			p.SetState(1901)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(1902)
			p.Identifier()
		}

	}
	p.SetState(1906)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC {
		{
			p.SetState(1905)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) DataTypeName() IDataTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *DataTypeContext) AllIgnoredIdentifier() []IIgnoredIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem())
	var tst = make([]IIgnoredIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIgnoredIdentifierContext)
		}
	}

	return tst
}

func (s *DataTypeContext) IgnoredIdentifier(i int) IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *DataTypeContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, 0)
}

func (s *DataTypeContext) DataTypeLength() IDataTypeLengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeLengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeLengthContext)
}

func (s *DataTypeContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DataTypeContext) MAX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX, 0)
}

func (s *DataTypeContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DataTypeContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTENT, 0)
}

func (s *DataTypeContext) DOCUMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOCUMENT, 0)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataType() (localctx IDataTypeContext) {
	this := p
	_ = this

	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SQLServerStatementParserRULE_dataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1908)
			p.IgnoredIdentifier()
		}
		{
			p.SetState(1909)
			p.Match(SQLServerStatementParserDOT_)
		}

	}
	{
		p.SetState(1913)
		p.DataTypeName()
	}
	p.SetState(1925)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1914)
			p.DataTypeLength()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1915)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1916)
			p.Match(SQLServerStatementParserMAX)
		}
		{
			p.SetState(1917)
			p.Match(SQLServerStatementParserRP_)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1918)
			p.Match(SQLServerStatementParserLP_)
		}
		p.SetState(1920)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserCONTENT || _la == SQLServerStatementParserDOCUMENT {
			{
				p.SetState(1919)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserCONTENT || _la == SQLServerStatementParserDOCUMENT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1922)
			p.IgnoredIdentifier()
		}
		{
			p.SetState(1923)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IDataTypeNameContext is an interface to support dynamic dispatch.
type IDataTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeNameContext differentiates from other interfaces.
	IsDataTypeNameContext()
}

type DataTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeNameContext() *DataTypeNameContext {
	var p = new(DataTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataTypeName
	return p
}

func (*DataTypeNameContext) IsDataTypeNameContext() {}

func NewDataTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeNameContext {
	var p = new(DataTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataTypeName

	return p
}

func (s *DataTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeNameContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBIGINT, 0)
}

func (s *DataTypeNameContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMERIC, 0)
}

func (s *DataTypeNameContext) BIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBIT, 0)
}

func (s *DataTypeNameContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSMALLINT, 0)
}

func (s *DataTypeNameContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDECIMAL, 0)
}

func (s *DataTypeNameContext) SMALLMONEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSMALLMONEY, 0)
}

func (s *DataTypeNameContext) INT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINT, 0)
}

func (s *DataTypeNameContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTINYINT, 0)
}

func (s *DataTypeNameContext) MONEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMONEY, 0)
}

func (s *DataTypeNameContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFLOAT, 0)
}

func (s *DataTypeNameContext) REAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAL, 0)
}

func (s *DataTypeNameContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATE, 0)
}

func (s *DataTypeNameContext) DATETIMEOFFSET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATETIMEOFFSET, 0)
}

func (s *DataTypeNameContext) SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSMALLDATETIME, 0)
}

func (s *DataTypeNameContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATETIME, 0)
}

func (s *DataTypeNameContext) DATETIME2() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATETIME2, 0)
}

func (s *DataTypeNameContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTIME, 0)
}

func (s *DataTypeNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHAR, 0)
}

func (s *DataTypeNameContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVARCHAR, 0)
}

func (s *DataTypeNameContext) TEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTEXT, 0)
}

func (s *DataTypeNameContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNCHAR, 0)
}

func (s *DataTypeNameContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNVARCHAR, 0)
}

func (s *DataTypeNameContext) NTEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNTEXT, 0)
}

func (s *DataTypeNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINARY, 0)
}

func (s *DataTypeNameContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVARBINARY, 0)
}

func (s *DataTypeNameContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMAGE, 0)
}

func (s *DataTypeNameContext) SQL_VARIANT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSQL_VARIANT, 0)
}

func (s *DataTypeNameContext) XML() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserXML, 0)
}

func (s *DataTypeNameContext) UNIQUEIDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUEIDENTIFIER, 0)
}

func (s *DataTypeNameContext) HIERARCHYID() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHIERARCHYID, 0)
}

func (s *DataTypeNameContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGEOMETRY, 0)
}

func (s *DataTypeNameContext) GEOGRAPHY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGEOGRAPHY, 0)
}

func (s *DataTypeNameContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *DataTypeNameContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTEGER, 0)
}

func (s *DataTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataTypeName(s)
	}
}

func (s *DataTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataTypeName(s)
	}
}

func (s *DataTypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataTypeName() (localctx IDataTypeNameContext) {
	this := p
	_ = this

	localctx = NewDataTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SQLServerStatementParserRULE_dataTypeName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1927)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SQLServerStatementParserCHAR-128))|(1<<(SQLServerStatementParserDATE-128))|(1<<(SQLServerStatementParserTIME-128)))) != 0) || (((_la-170)&-(0x1f+1)) == 0 && ((1<<uint((_la-170)))&((1<<(SQLServerStatementParserINTEGER-170))|(1<<(SQLServerStatementParserREAL-170))|(1<<(SQLServerStatementParserDECIMAL-170))|(1<<(SQLServerStatementParserBIT-170))|(1<<(SQLServerStatementParserSMALLINT-170))|(1<<(SQLServerStatementParserINT-170))|(1<<(SQLServerStatementParserTINYINT-170))|(1<<(SQLServerStatementParserNUMERIC-170))|(1<<(SQLServerStatementParserFLOAT-170))|(1<<(SQLServerStatementParserBIGINT-170))|(1<<(SQLServerStatementParserTEXT-170))|(1<<(SQLServerStatementParserVARCHAR-170)))) != 0) || _la == SQLServerStatementParserBINARY || _la == SQLServerStatementParserXML || (((_la-420)&-(0x1f+1)) == 0 && ((1<<uint((_la-420)))&((1<<(SQLServerStatementParserMONEY-420))|(1<<(SQLServerStatementParserSMALLMONEY-420))|(1<<(SQLServerStatementParserDATETIMEOFFSET-420))|(1<<(SQLServerStatementParserDATETIME-420))|(1<<(SQLServerStatementParserDATETIME2-420))|(1<<(SQLServerStatementParserSMALLDATETIME-420))|(1<<(SQLServerStatementParserNCHAR-420))|(1<<(SQLServerStatementParserNVARCHAR-420))|(1<<(SQLServerStatementParserNTEXT-420))|(1<<(SQLServerStatementParserVARBINARY-420))|(1<<(SQLServerStatementParserIMAGE-420))|(1<<(SQLServerStatementParserSQL_VARIANT-420))|(1<<(SQLServerStatementParserUNIQUEIDENTIFIER-420))|(1<<(SQLServerStatementParserHIERARCHYID-420))|(1<<(SQLServerStatementParserGEOMETRY-420))|(1<<(SQLServerStatementParserGEOGRAPHY-420)))) != 0) || _la == SQLServerStatementParserIDENTIFIER_) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAtTimeZoneExprContext is an interface to support dynamic dispatch.
type IAtTimeZoneExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtTimeZoneExprContext differentiates from other interfaces.
	IsAtTimeZoneExprContext()
}

type AtTimeZoneExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtTimeZoneExprContext() *AtTimeZoneExprContext {
	var p = new(AtTimeZoneExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_atTimeZoneExpr
	return p
}

func (*AtTimeZoneExprContext) IsAtTimeZoneExprContext() {}

func NewAtTimeZoneExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtTimeZoneExprContext {
	var p = new(AtTimeZoneExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_atTimeZoneExpr

	return p
}

func (s *AtTimeZoneExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AtTimeZoneExprContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *AtTimeZoneExprContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *AtTimeZoneExprContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AtTimeZoneExprContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTIME, 0)
}

func (s *AtTimeZoneExprContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserZONE, 0)
}

func (s *AtTimeZoneExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtTimeZoneExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAtTimeZoneExpr(s)
	}
}

func (s *AtTimeZoneExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAtTimeZoneExpr(s)
	}
}

func (s *AtTimeZoneExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAtTimeZoneExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AtTimeZoneExpr() (localctx IAtTimeZoneExprContext) {
	this := p
	_ = this

	localctx = NewAtTimeZoneExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SQLServerStatementParserRULE_atTimeZoneExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1929)
		p.Match(SQLServerStatementParserIDENTIFIER_)
	}
	p.SetState(1933)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(1930)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(1931)
			p.Match(SQLServerStatementParserTIME)
		}
		{
			p.SetState(1932)
			p.Match(SQLServerStatementParserZONE)
		}

	}
	{
		p.SetState(1935)
		p.Match(SQLServerStatementParserSTRING_)
	}

	return localctx
}

// ICastExprContext is an interface to support dynamic dispatch.
type ICastExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastExprContext differentiates from other interfaces.
	IsCastExprContext()
}

type CastExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExprContext() *CastExprContext {
	var p = new(CastExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_castExpr
	return p
}

func (*CastExprContext) IsCastExprContext() {}

func NewCastExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExprContext {
	var p = new(CastExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_castExpr

	return p
}

func (s *CastExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExprContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCAST, 0)
}

func (s *CastExprContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *CastExprContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *CastExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CastExprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CastExprContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastExprContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *CastExprContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *CastExprContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *CastExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCastExpr(s)
	}
}

func (s *CastExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCastExpr(s)
	}
}

func (s *CastExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCastExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CastExpr() (localctx ICastExprContext) {
	this := p
	_ = this

	localctx = NewCastExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SQLServerStatementParserRULE_castExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1937)
		p.Match(SQLServerStatementParserCAST)
	}
	{
		p.SetState(1938)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(1939)
		p.expr(0)
	}
	{
		p.SetState(1940)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(1941)
		p.DataType()
	}
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(1942)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1943)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(1944)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	{
		p.SetState(1947)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IConvertExprContext is an interface to support dynamic dispatch.
type IConvertExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConvertExprContext differentiates from other interfaces.
	IsConvertExprContext()
}

type ConvertExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertExprContext() *ConvertExprContext {
	var p = new(ConvertExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_convertExpr
	return p
}

func (*ConvertExprContext) IsConvertExprContext() {}

func NewConvertExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertExprContext {
	var p = new(ConvertExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_convertExpr

	return p
}

func (s *ConvertExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertExprContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONVERT, 0)
}

func (s *ConvertExprContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ConvertExprContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ConvertExprContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ConvertExprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ConvertExprContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ConvertExprContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNUMBER_)
}

func (s *ConvertExprContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, i)
}

func (s *ConvertExprContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ConvertExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterConvertExpr(s)
	}
}

func (s *ConvertExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitConvertExpr(s)
	}
}

func (s *ConvertExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitConvertExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ConvertExpr() (localctx IConvertExprContext) {
	this := p
	_ = this

	localctx = NewConvertExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SQLServerStatementParserRULE_convertExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1949)
		p.Match(SQLServerStatementParserCONVERT)
	}

	{
		p.SetState(1950)
		p.DataType()
	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(1951)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(1952)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(1953)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	{
		p.SetState(1956)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(1957)
		p.expr(0)
	}
	p.SetState(1960)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1958)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1959)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	}

	return localctx
}

// IWindowedFunctionContext is an interface to support dynamic dispatch.
type IWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowedFunctionContext differentiates from other interfaces.
	IsWindowedFunctionContext()
}

type WindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowedFunctionContext() *WindowedFunctionContext {
	var p = new(WindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowedFunction
	return p
}

func (*WindowedFunctionContext) IsWindowedFunctionContext() {}

func NewWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowedFunctionContext {
	var p = new(WindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowedFunction

	return p
}

func (s *WindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowedFunctionContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *WindowedFunctionContext) OverClause() IOverClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOverClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOverClauseContext)
}

func (s *WindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowedFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowedFunction(s)
	}
}

func (s *WindowedFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowedFunction(s)
	}
}

func (s *WindowedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowedFunction() (localctx IWindowedFunctionContext) {
	this := p
	_ = this

	localctx = NewWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SQLServerStatementParserRULE_windowedFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1962)
		p.FunctionCall()
	}
	{
		p.SetState(1963)
		p.OverClause()
	}

	return localctx
}

// IOverClauseContext is an interface to support dynamic dispatch.
type IOverClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOverClauseContext differentiates from other interfaces.
	IsOverClauseContext()
}

type OverClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOverClauseContext() *OverClauseContext {
	var p = new(OverClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_overClause
	return p
}

func (*OverClauseContext) IsOverClauseContext() {}

func NewOverClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverClauseContext {
	var p = new(OverClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_overClause

	return p
}

func (s *OverClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OverClauseContext) OVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOVER, 0)
}

func (s *OverClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OverClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OverClauseContext) PartitionByClause() IPartitionByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionByClauseContext)
}

func (s *OverClauseContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *OverClauseContext) RowRangeClause() IRowRangeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRowRangeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRowRangeClauseContext)
}

func (s *OverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOverClause(s)
	}
}

func (s *OverClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOverClause(s)
	}
}

func (s *OverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OverClause() (localctx IOverClauseContext) {
	this := p
	_ = this

	localctx = NewOverClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SQLServerStatementParserRULE_overClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1965)
		p.Match(SQLServerStatementParserOVER)
	}
	{
		p.SetState(1966)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(1968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPARTITION {
		{
			p.SetState(1967)
			p.PartitionByClause()
		}

	}
	p.SetState(1971)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserORDER {
		{
			p.SetState(1970)
			p.OrderByClause()
		}

	}
	p.SetState(1974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserROWS || _la == SQLServerStatementParserRANGE {
		{
			p.SetState(1973)
			p.RowRangeClause()
		}

	}
	{
		p.SetState(1976)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IPartitionByClauseContext is an interface to support dynamic dispatch.
type IPartitionByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionByClauseContext differentiates from other interfaces.
	IsPartitionByClauseContext()
}

type PartitionByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByClauseContext() *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_partitionByClause
	return p
}

func (*PartitionByClauseContext) IsPartitionByClauseContext() {}

func NewPartitionByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByClauseContext {
	var p = new(PartitionByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_partitionByClause

	return p
}

func (s *PartitionByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITION, 0)
}

func (s *PartitionByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBY, 0)
}

func (s *PartitionByClauseContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PartitionByClauseContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PartitionByClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *PartitionByClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *PartitionByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPartitionByClause(s)
	}
}

func (s *PartitionByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPartitionByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PartitionByClause() (localctx IPartitionByClauseContext) {
	this := p
	_ = this

	localctx = NewPartitionByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SQLServerStatementParserRULE_partitionByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1978)
		p.Match(SQLServerStatementParserPARTITION)
	}
	{
		p.SetState(1979)
		p.Match(SQLServerStatementParserBY)
	}
	{
		p.SetState(1980)
		p.expr(0)
	}
	p.SetState(1985)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(1981)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(1982)
			p.expr(0)
		}

		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRowRangeClauseContext is an interface to support dynamic dispatch.
type IRowRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRowRangeClauseContext differentiates from other interfaces.
	IsRowRangeClauseContext()
}

type RowRangeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowRangeClauseContext() *RowRangeClauseContext {
	var p = new(RowRangeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_rowRangeClause
	return p
}

func (*RowRangeClauseContext) IsRowRangeClauseContext() {}

func NewRowRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowRangeClauseContext {
	var p = new(RowRangeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_rowRangeClause

	return p
}

func (s *RowRangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RowRangeClauseContext) WindowFrameExtent() IWindowFrameExtentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameExtentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameExtentContext)
}

func (s *RowRangeClauseContext) ROWS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWS, 0)
}

func (s *RowRangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRANGE, 0)
}

func (s *RowRangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowRangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowRangeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRowRangeClause(s)
	}
}

func (s *RowRangeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRowRangeClause(s)
	}
}

func (s *RowRangeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRowRangeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RowRangeClause() (localctx IRowRangeClauseContext) {
	this := p
	_ = this

	localctx = NewRowRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SQLServerStatementParserRULE_rowRangeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserROWS || _la == SQLServerStatementParserRANGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1989)
		p.WindowFrameExtent()
	}

	return localctx
}

// IWindowFrameExtentContext is an interface to support dynamic dispatch.
type IWindowFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowFrameExtentContext differentiates from other interfaces.
	IsWindowFrameExtentContext()
}

type WindowFrameExtentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameExtentContext() *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameExtent
	return p
}

func (*WindowFrameExtentContext) IsWindowFrameExtentContext() {}

func NewWindowFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameExtent

	return p
}

func (s *WindowFrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameExtentContext) WindowFramePreceding() IWindowFramePrecedingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFramePrecedingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFramePrecedingContext)
}

func (s *WindowFrameExtentContext) WindowFrameBetween() IWindowFrameBetweenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameBetweenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBetweenContext)
}

func (s *WindowFrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowFrameExtent() (localctx IWindowFrameExtentContext) {
	this := p
	_ = this

	localctx = NewWindowFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SQLServerStatementParserRULE_windowFrameExtent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1993)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCURRENT, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1991)
			p.WindowFramePreceding()
		}

	case SQLServerStatementParserBETWEEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1992)
			p.WindowFrameBetween()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWindowFrameBetweenContext is an interface to support dynamic dispatch.
type IWindowFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowFrameBetweenContext differentiates from other interfaces.
	IsWindowFrameBetweenContext()
}

type WindowFrameBetweenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBetweenContext() *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameBetween
	return p
}

func (*WindowFrameBetweenContext) IsWindowFrameBetweenContext() {}

func NewWindowFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameBetween

	return p
}

func (s *WindowFrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBETWEEN, 0)
}

func (s *WindowFrameBetweenContext) AllWindowFrameBound() []IWindowFrameBoundContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindowFrameBoundContext)(nil)).Elem())
	var tst = make([]IWindowFrameBoundContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindowFrameBoundContext)
		}
	}

	return tst
}

func (s *WindowFrameBetweenContext) WindowFrameBound(i int) IWindowFrameBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameBoundContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBoundContext)
}

func (s *WindowFrameBetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAND, 0)
}

func (s *WindowFrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowFrameBetween() (localctx IWindowFrameBetweenContext) {
	this := p
	_ = this

	localctx = NewWindowFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SQLServerStatementParserRULE_windowFrameBetween)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1995)
		p.Match(SQLServerStatementParserBETWEEN)
	}
	{
		p.SetState(1996)
		p.WindowFrameBound()
	}
	{
		p.SetState(1997)
		p.Match(SQLServerStatementParserAND)
	}
	{
		p.SetState(1998)
		p.WindowFrameBound()
	}

	return localctx
}

// IWindowFrameBoundContext is an interface to support dynamic dispatch.
type IWindowFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowFrameBoundContext differentiates from other interfaces.
	IsWindowFrameBoundContext()
}

type WindowFrameBoundContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBoundContext() *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameBound
	return p
}

func (*WindowFrameBoundContext) IsWindowFrameBoundContext() {}

func NewWindowFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameBound

	return p
}

func (s *WindowFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBoundContext) WindowFramePreceding() IWindowFramePrecedingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFramePrecedingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFramePrecedingContext)
}

func (s *WindowFrameBoundContext) WindowFrameFollowing() IWindowFrameFollowingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowFrameFollowingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowFrameFollowingContext)
}

func (s *WindowFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowFrameBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowFrameBound() (localctx IWindowFrameBoundContext) {
	this := p
	_ = this

	localctx = NewWindowFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SQLServerStatementParserRULE_windowFrameBound)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2000)
			p.WindowFramePreceding()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2001)
			p.WindowFrameFollowing()
		}

	}

	return localctx
}

// IWindowFramePrecedingContext is an interface to support dynamic dispatch.
type IWindowFramePrecedingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowFramePrecedingContext differentiates from other interfaces.
	IsWindowFramePrecedingContext()
}

type WindowFramePrecedingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFramePrecedingContext() *WindowFramePrecedingContext {
	var p = new(WindowFramePrecedingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowFramePreceding
	return p
}

func (*WindowFramePrecedingContext) IsWindowFramePrecedingContext() {}

func NewWindowFramePrecedingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFramePrecedingContext {
	var p = new(WindowFramePrecedingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowFramePreceding

	return p
}

func (s *WindowFramePrecedingContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFramePrecedingContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNBOUNDED, 0)
}

func (s *WindowFramePrecedingContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRECEDING, 0)
}

func (s *WindowFramePrecedingContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *WindowFramePrecedingContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURRENT, 0)
}

func (s *WindowFramePrecedingContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *WindowFramePrecedingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFramePrecedingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFramePrecedingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowFramePreceding(s)
	}
}

func (s *WindowFramePrecedingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowFramePreceding(s)
	}
}

func (s *WindowFramePrecedingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowFramePreceding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowFramePreceding() (localctx IWindowFramePrecedingContext) {
	this := p
	_ = this

	localctx = NewWindowFramePrecedingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SQLServerStatementParserRULE_windowFramePreceding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2010)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2004)
			p.Match(SQLServerStatementParserUNBOUNDED)
		}
		{
			p.SetState(2005)
			p.Match(SQLServerStatementParserPRECEDING)
		}

	case SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2006)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(2007)
			p.Match(SQLServerStatementParserPRECEDING)
		}

	case SQLServerStatementParserCURRENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2008)
			p.Match(SQLServerStatementParserCURRENT)
		}
		{
			p.SetState(2009)
			p.Match(SQLServerStatementParserROW)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWindowFrameFollowingContext is an interface to support dynamic dispatch.
type IWindowFrameFollowingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowFrameFollowingContext differentiates from other interfaces.
	IsWindowFrameFollowingContext()
}

type WindowFrameFollowingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameFollowingContext() *WindowFrameFollowingContext {
	var p = new(WindowFrameFollowingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameFollowing
	return p
}

func (*WindowFrameFollowingContext) IsWindowFrameFollowingContext() {}

func NewWindowFrameFollowingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameFollowingContext {
	var p = new(WindowFrameFollowingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_windowFrameFollowing

	return p
}

func (s *WindowFrameFollowingContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameFollowingContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNBOUNDED, 0)
}

func (s *WindowFrameFollowingContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOLLOWING, 0)
}

func (s *WindowFrameFollowingContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *WindowFrameFollowingContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURRENT, 0)
}

func (s *WindowFrameFollowingContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *WindowFrameFollowingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameFollowingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameFollowingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWindowFrameFollowing(s)
	}
}

func (s *WindowFrameFollowingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWindowFrameFollowing(s)
	}
}

func (s *WindowFrameFollowingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWindowFrameFollowing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WindowFrameFollowing() (localctx IWindowFrameFollowingContext) {
	this := p
	_ = this

	localctx = NewWindowFrameFollowingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SQLServerStatementParserRULE_windowFrameFollowing)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2012)
			p.Match(SQLServerStatementParserUNBOUNDED)
		}
		{
			p.SetState(2013)
			p.Match(SQLServerStatementParserFOLLOWING)
		}

	case SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2014)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(2015)
			p.Match(SQLServerStatementParserFOLLOWING)
		}

	case SQLServerStatementParserCURRENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2016)
			p.Match(SQLServerStatementParserCURRENT)
		}
		{
			p.SetState(2017)
			p.Match(SQLServerStatementParserROW)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IColumnNameWithSortContext is an interface to support dynamic dispatch.
type IColumnNameWithSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNameWithSortContext differentiates from other interfaces.
	IsColumnNameWithSortContext()
}

type ColumnNameWithSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameWithSortContext() *ColumnNameWithSortContext {
	var p = new(ColumnNameWithSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnNameWithSort
	return p
}

func (*ColumnNameWithSortContext) IsColumnNameWithSortContext() {}

func NewColumnNameWithSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameWithSortContext {
	var p = new(ColumnNameWithSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnNameWithSort

	return p
}

func (s *ColumnNameWithSortContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameWithSortContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnNameWithSortContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASC, 0)
}

func (s *ColumnNameWithSortContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDESC, 0)
}

func (s *ColumnNameWithSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameWithSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameWithSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnNameWithSort(s)
	}
}

func (s *ColumnNameWithSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnNameWithSort(s)
	}
}

func (s *ColumnNameWithSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnNameWithSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnNameWithSort() (localctx IColumnNameWithSortContext) {
	this := p
	_ = this

	localctx = NewColumnNameWithSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SQLServerStatementParserRULE_columnNameWithSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2020)
		p.ColumnName()
	}
	p.SetState(2022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC {
		{
			p.SetState(2021)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexOption
	return p
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) FILLFACTOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILLFACTOR, 0)
}

func (s *IndexOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *IndexOptionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *IndexOptionContext) EqOnOffOption() IEqOnOffOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqOnOffOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqOnOffOptionContext)
}

func (s *IndexOptionContext) EqTime() IEqTimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqTimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqTimeContext)
}

func (s *IndexOptionContext) COMPRESSION_DELAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESSION_DELAY, 0)
}

func (s *IndexOptionContext) MAX_DURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_DURATION, 0)
}

func (s *IndexOptionContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *IndexOptionContext) CompressionOption() ICompressionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompressionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompressionOptionContext)
}

func (s *IndexOptionContext) OnPartitionClause() IOnPartitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnPartitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnPartitionClauseContext)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexOption() (localctx IIndexOptionContext) {
	this := p
	_ = this

	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SQLServerStatementParserRULE_indexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2037)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2024)
			p.Match(SQLServerStatementParserFILLFACTOR)
		}
		{
			p.SetState(2025)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2026)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2027)
			p.EqOnOffOption()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2028)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserCOMPRESSION_DELAY || _la == SQLServerStatementParserMAX_DURATION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2029)
			p.EqTime()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2030)
			p.Match(SQLServerStatementParserMAXDOP)
		}
		{
			p.SetState(2031)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2032)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2033)
			p.CompressionOption()
		}
		p.SetState(2035)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserON {
			{
				p.SetState(2034)
				p.OnPartitionClause()
			}

		}

	}

	return localctx
}

// ICompressionOptionContext is an interface to support dynamic dispatch.
type ICompressionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompressionOptionContext differentiates from other interfaces.
	IsCompressionOptionContext()
}

type CompressionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompressionOptionContext() *CompressionOptionContext {
	var p = new(CompressionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_compressionOption
	return p
}

func (*CompressionOptionContext) IsCompressionOptionContext() {}

func NewCompressionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompressionOptionContext {
	var p = new(CompressionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_compressionOption

	return p
}

func (s *CompressionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CompressionOptionContext) DATA_COMPRESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_COMPRESSION, 0)
}

func (s *CompressionOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *CompressionOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *CompressionOptionContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *CompressionOptionContext) PAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE, 0)
}

func (s *CompressionOptionContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *CompressionOptionContext) COLUMNSTORE_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE_ARCHIVE, 0)
}

func (s *CompressionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompressionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompressionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCompressionOption(s)
	}
}

func (s *CompressionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCompressionOption(s)
	}
}

func (s *CompressionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCompressionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CompressionOption() (localctx ICompressionOptionContext) {
	this := p
	_ = this

	localctx = NewCompressionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SQLServerStatementParserRULE_compressionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		p.Match(SQLServerStatementParserDATA_COMPRESSION)
	}
	{
		p.SetState(2040)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2041)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserROW || _la == SQLServerStatementParserCOLUMNSTORE || _la == SQLServerStatementParserNONE || _la == SQLServerStatementParserPAGE || _la == SQLServerStatementParserCOLUMNSTORE_ARCHIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEqTimeContext is an interface to support dynamic dispatch.
type IEqTimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqTimeContext differentiates from other interfaces.
	IsEqTimeContext()
}

type EqTimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqTimeContext() *EqTimeContext {
	var p = new(EqTimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_eqTime
	return p
}

func (*EqTimeContext) IsEqTimeContext() {}

func NewEqTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqTimeContext {
	var p = new(EqTimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_eqTime

	return p
}

func (s *EqTimeContext) GetParser() antlr.Parser { return s.parser }

func (s *EqTimeContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *EqTimeContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *EqTimeContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *EqTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqTimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEqTime(s)
	}
}

func (s *EqTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEqTime(s)
	}
}

func (s *EqTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEqTime(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EqTime() (localctx IEqTimeContext) {
	this := p
	_ = this

	localctx = NewEqTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SQLServerStatementParserRULE_eqTime)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2043)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2044)
		p.Match(SQLServerStatementParserNUMBER_)
	}
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserMINUTES {
		{
			p.SetState(2045)
			p.Match(SQLServerStatementParserMINUTES)
		}

	}

	return localctx
}

// IEqOnOffOptionContext is an interface to support dynamic dispatch.
type IEqOnOffOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqOnOffOptionContext differentiates from other interfaces.
	IsEqOnOffOptionContext()
}

type EqOnOffOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqOnOffOptionContext() *EqOnOffOptionContext {
	var p = new(EqOnOffOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_eqOnOffOption
	return p
}

func (*EqOnOffOptionContext) IsEqOnOffOptionContext() {}

func NewEqOnOffOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqOnOffOptionContext {
	var p = new(EqOnOffOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_eqOnOffOption

	return p
}

func (s *EqOnOffOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqOnOffOptionContext) EqKey() IEqKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqKeyContext)
}

func (s *EqOnOffOptionContext) EqOnOff() IEqOnOffContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqOnOffContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqOnOffContext)
}

func (s *EqOnOffOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqOnOffOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqOnOffOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEqOnOffOption(s)
	}
}

func (s *EqOnOffOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEqOnOffOption(s)
	}
}

func (s *EqOnOffOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEqOnOffOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EqOnOffOption() (localctx IEqOnOffOptionContext) {
	this := p
	_ = this

	localctx = NewEqOnOffOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SQLServerStatementParserRULE_eqOnOffOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2048)
		p.EqKey()
	}
	{
		p.SetState(2049)
		p.EqOnOff()
	}

	return localctx
}

// IEqKeyContext is an interface to support dynamic dispatch.
type IEqKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqKeyContext differentiates from other interfaces.
	IsEqKeyContext()
}

type EqKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqKeyContext() *EqKeyContext {
	var p = new(EqKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_eqKey
	return p
}

func (*EqKeyContext) IsEqKeyContext() {}

func NewEqKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqKeyContext {
	var p = new(EqKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_eqKey

	return p
}

func (s *EqKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *EqKeyContext) PAD_INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAD_INDEX, 0)
}

func (s *EqKeyContext) SORT_IN_TEMPDB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSORT_IN_TEMPDB, 0)
}

func (s *EqKeyContext) IGNORE_DUP_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIGNORE_DUP_KEY, 0)
}

func (s *EqKeyContext) STATISTICS_NORECOMPUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_NORECOMPUTE, 0)
}

func (s *EqKeyContext) STATISTICS_INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_INCREMENTAL, 0)
}

func (s *EqKeyContext) DROP_EXISTING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP_EXISTING, 0)
}

func (s *EqKeyContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLINE, 0)
}

func (s *EqKeyContext) RESUMABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUMABLE, 0)
}

func (s *EqKeyContext) ALLOW_ROW_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_ROW_LOCKS, 0)
}

func (s *EqKeyContext) ALLOW_PAGE_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_PAGE_LOCKS, 0)
}

func (s *EqKeyContext) COMPRESSION_DELAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESSION_DELAY, 0)
}

func (s *EqKeyContext) OPTIMIZE_FOR_SEQUENTIAL_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY, 0)
}

func (s *EqKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEqKey(s)
	}
}

func (s *EqKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEqKey(s)
	}
}

func (s *EqKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEqKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EqKey() (localctx IEqKeyContext) {
	this := p
	_ = this

	localctx = NewEqKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SQLServerStatementParserRULE_eqKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2051)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserONLINE || _la == SQLServerStatementParserRESUMABLE || (((_la-376)&-(0x1f+1)) == 0 && ((1<<uint((_la-376)))&((1<<(SQLServerStatementParserALLOW_PAGE_LOCKS-376))|(1<<(SQLServerStatementParserALLOW_ROW_LOCKS-376))|(1<<(SQLServerStatementParserCOMPRESSION_DELAY-376))|(1<<(SQLServerStatementParserSTATISTICS_INCREMENTAL-376))|(1<<(SQLServerStatementParserSTATISTICS_NORECOMPUTE-376))|(1<<(SQLServerStatementParserSORT_IN_TEMPDB-376))|(1<<(SQLServerStatementParserIGNORE_DUP_KEY-376))|(1<<(SQLServerStatementParserPAD_INDEX-376)))) != 0) || _la == SQLServerStatementParserDROP_EXISTING || _la == SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IEqOnOffContext is an interface to support dynamic dispatch.
type IEqOnOffContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqOnOffContext differentiates from other interfaces.
	IsEqOnOffContext()
}

type EqOnOffContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqOnOffContext() *EqOnOffContext {
	var p = new(EqOnOffContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_eqOnOff
	return p
}

func (*EqOnOffContext) IsEqOnOffContext() {}

func NewEqOnOffContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqOnOffContext {
	var p = new(EqOnOffContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_eqOnOff

	return p
}

func (s *EqOnOffContext) GetParser() antlr.Parser { return s.parser }

func (s *EqOnOffContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *EqOnOffContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *EqOnOffContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *EqOnOffContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqOnOffContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqOnOffContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEqOnOff(s)
	}
}

func (s *EqOnOffContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEqOnOff(s)
	}
}

func (s *EqOnOffContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEqOnOff(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EqOnOff() (localctx IEqOnOffContext) {
	this := p
	_ = this

	localctx = NewEqOnOffContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SQLServerStatementParserRULE_eqOnOff)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2053)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2054)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOnPartitionClauseContext is an interface to support dynamic dispatch.
type IOnPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnPartitionClauseContext differentiates from other interfaces.
	IsOnPartitionClauseContext()
}

type OnPartitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnPartitionClauseContext() *OnPartitionClauseContext {
	var p = new(OnPartitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onPartitionClause
	return p
}

func (*OnPartitionClauseContext) IsOnPartitionClauseContext() {}

func NewOnPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnPartitionClauseContext {
	var p = new(OnPartitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onPartitionClause

	return p
}

func (s *OnPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnPartitionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITIONS, 0)
}

func (s *OnPartitionClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OnPartitionClauseContext) PartitionExpressions() IPartitionExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionExpressionsContext)
}

func (s *OnPartitionClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OnPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnPartitionClause(s)
	}
}

func (s *OnPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnPartitionClause(s)
	}
}

func (s *OnPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnPartitionClause() (localctx IOnPartitionClauseContext) {
	this := p
	_ = this

	localctx = NewOnPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SQLServerStatementParserRULE_onPartitionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2056)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2057)
		p.Match(SQLServerStatementParserPARTITIONS)
	}
	{
		p.SetState(2058)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2059)
		p.PartitionExpressions()
	}
	{
		p.SetState(2060)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IPartitionExpressionsContext is an interface to support dynamic dispatch.
type IPartitionExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionExpressionsContext differentiates from other interfaces.
	IsPartitionExpressionsContext()
}

type PartitionExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExpressionsContext() *PartitionExpressionsContext {
	var p = new(PartitionExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_partitionExpressions
	return p
}

func (*PartitionExpressionsContext) IsPartitionExpressionsContext() {}

func NewPartitionExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExpressionsContext {
	var p = new(PartitionExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_partitionExpressions

	return p
}

func (s *PartitionExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExpressionsContext) AllPartitionExpression() []IPartitionExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartitionExpressionContext)(nil)).Elem())
	var tst = make([]IPartitionExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartitionExpressionContext)
		}
	}

	return tst
}

func (s *PartitionExpressionsContext) PartitionExpression(i int) IPartitionExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartitionExpressionContext)
}

func (s *PartitionExpressionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *PartitionExpressionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *PartitionExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPartitionExpressions(s)
	}
}

func (s *PartitionExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPartitionExpressions(s)
	}
}

func (s *PartitionExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPartitionExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PartitionExpressions() (localctx IPartitionExpressionsContext) {
	this := p
	_ = this

	localctx = NewPartitionExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SQLServerStatementParserRULE_partitionExpressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2062)
		p.PartitionExpression()
	}
	p.SetState(2067)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2063)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2064)
			p.PartitionExpression()
		}

		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPartitionExpressionContext is an interface to support dynamic dispatch.
type IPartitionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionExpressionContext differentiates from other interfaces.
	IsPartitionExpressionContext()
}

type PartitionExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExpressionContext() *PartitionExpressionContext {
	var p = new(PartitionExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_partitionExpression
	return p
}

func (*PartitionExpressionContext) IsPartitionExpressionContext() {}

func NewPartitionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExpressionContext {
	var p = new(PartitionExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_partitionExpression

	return p
}

func (s *PartitionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExpressionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *PartitionExpressionContext) NumberRange() INumberRangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberRangeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberRangeContext)
}

func (s *PartitionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPartitionExpression(s)
	}
}

func (s *PartitionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPartitionExpression(s)
	}
}

func (s *PartitionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPartitionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PartitionExpression() (localctx IPartitionExpressionContext) {
	this := p
	_ = this

	localctx = NewPartitionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SQLServerStatementParserRULE_partitionExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2070)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2071)
			p.NumberRange()
		}

	}

	return localctx
}

// INumberRangeContext is an interface to support dynamic dispatch.
type INumberRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberRangeContext differentiates from other interfaces.
	IsNumberRangeContext()
}

type NumberRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberRangeContext() *NumberRangeContext {
	var p = new(NumberRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_numberRange
	return p
}

func (*NumberRangeContext) IsNumberRangeContext() {}

func NewNumberRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberRangeContext {
	var p = new(NumberRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_numberRange

	return p
}

func (s *NumberRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberRangeContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNUMBER_)
}

func (s *NumberRangeContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, i)
}

func (s *NumberRangeContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTO, 0)
}

func (s *NumberRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterNumberRange(s)
	}
}

func (s *NumberRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitNumberRange(s)
	}
}

func (s *NumberRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitNumberRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) NumberRange() (localctx INumberRangeContext) {
	this := p
	_ = this

	localctx = NewNumberRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SQLServerStatementParserRULE_numberRange)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2074)
		p.Match(SQLServerStatementParserNUMBER_)
	}
	{
		p.SetState(2075)
		p.Match(SQLServerStatementParserTO)
	}
	{
		p.SetState(2076)
		p.Match(SQLServerStatementParserNUMBER_)
	}

	return localctx
}

// ILowPriorityLockWaitContext is an interface to support dynamic dispatch.
type ILowPriorityLockWaitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLowPriorityLockWaitContext differentiates from other interfaces.
	IsLowPriorityLockWaitContext()
}

type LowPriorityLockWaitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLowPriorityLockWaitContext() *LowPriorityLockWaitContext {
	var p = new(LowPriorityLockWaitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_lowPriorityLockWait
	return p
}

func (*LowPriorityLockWaitContext) IsLowPriorityLockWaitContext() {}

func NewLowPriorityLockWaitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LowPriorityLockWaitContext {
	var p = new(LowPriorityLockWaitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_lowPriorityLockWait

	return p
}

func (s *LowPriorityLockWaitContext) GetParser() antlr.Parser { return s.parser }

func (s *LowPriorityLockWaitContext) WAIT_AT_LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWAIT_AT_LOW_PRIORITY, 0)
}

func (s *LowPriorityLockWaitContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *LowPriorityLockWaitContext) MAX_DURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_DURATION, 0)
}

func (s *LowPriorityLockWaitContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *LowPriorityLockWaitContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *LowPriorityLockWaitContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *LowPriorityLockWaitContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *LowPriorityLockWaitContext) ABORT_AFTER_WAIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserABORT_AFTER_WAIT, 0)
}

func (s *LowPriorityLockWaitContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *LowPriorityLockWaitContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *LowPriorityLockWaitContext) SELF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELF, 0)
}

func (s *LowPriorityLockWaitContext) BLOCKERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBLOCKERS, 0)
}

func (s *LowPriorityLockWaitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *LowPriorityLockWaitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LowPriorityLockWaitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LowPriorityLockWaitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterLowPriorityLockWait(s)
	}
}

func (s *LowPriorityLockWaitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitLowPriorityLockWait(s)
	}
}

func (s *LowPriorityLockWaitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitLowPriorityLockWait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) LowPriorityLockWait() (localctx ILowPriorityLockWaitContext) {
	this := p
	_ = this

	localctx = NewLowPriorityLockWaitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SQLServerStatementParserRULE_lowPriorityLockWait)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		p.Match(SQLServerStatementParserWAIT_AT_LOW_PRIORITY)
	}
	{
		p.SetState(2079)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2080)
		p.Match(SQLServerStatementParserMAX_DURATION)
	}
	{
		p.SetState(2081)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2082)
		p.Match(SQLServerStatementParserNUMBER_)
	}
	p.SetState(2084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserMINUTES {
		{
			p.SetState(2083)
			p.Match(SQLServerStatementParserMINUTES)
		}

	}
	{
		p.SetState(2086)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(2087)
		p.Match(SQLServerStatementParserABORT_AFTER_WAIT)
	}
	{
		p.SetState(2088)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2089)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserBLOCKERS || _la == SQLServerStatementParserNONE || _la == SQLServerStatementParserSELF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2090)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IOnLowPriorLockWaitContext is an interface to support dynamic dispatch.
type IOnLowPriorLockWaitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnLowPriorLockWaitContext differentiates from other interfaces.
	IsOnLowPriorLockWaitContext()
}

type OnLowPriorLockWaitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnLowPriorLockWaitContext() *OnLowPriorLockWaitContext {
	var p = new(OnLowPriorLockWaitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onLowPriorLockWait
	return p
}

func (*OnLowPriorLockWaitContext) IsOnLowPriorLockWaitContext() {}

func NewOnLowPriorLockWaitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnLowPriorLockWaitContext {
	var p = new(OnLowPriorLockWaitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onLowPriorLockWait

	return p
}

func (s *OnLowPriorLockWaitContext) GetParser() antlr.Parser { return s.parser }

func (s *OnLowPriorLockWaitContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnLowPriorLockWaitContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OnLowPriorLockWaitContext) LowPriorityLockWait() ILowPriorityLockWaitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILowPriorityLockWaitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILowPriorityLockWaitContext)
}

func (s *OnLowPriorLockWaitContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OnLowPriorLockWaitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnLowPriorLockWaitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnLowPriorLockWaitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnLowPriorLockWait(s)
	}
}

func (s *OnLowPriorLockWaitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnLowPriorLockWait(s)
	}
}

func (s *OnLowPriorLockWaitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnLowPriorLockWait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnLowPriorLockWait() (localctx IOnLowPriorLockWaitContext) {
	this := p
	_ = this

	localctx = NewOnLowPriorLockWaitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SQLServerStatementParserRULE_onLowPriorLockWait)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2092)
		p.Match(SQLServerStatementParserON)
	}
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(2093)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(2094)
			p.LowPriorityLockWait()
		}
		{
			p.SetState(2095)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IIgnoredIdentifierContext is an interface to support dynamic dispatch.
type IIgnoredIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIgnoredIdentifierContext differentiates from other interfaces.
	IsIgnoredIdentifierContext()
}

type IgnoredIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoredIdentifierContext() *IgnoredIdentifierContext {
	var p = new(IgnoredIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_ignoredIdentifier
	return p
}

func (*IgnoredIdentifierContext) IsIgnoredIdentifierContext() {}

func NewIgnoredIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoredIdentifierContext {
	var p = new(IgnoredIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_ignoredIdentifier

	return p
}

func (s *IgnoredIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoredIdentifierContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *IgnoredIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoredIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoredIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIgnoredIdentifier(s)
	}
}

func (s *IgnoredIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIgnoredIdentifier(s)
	}
}

func (s *IgnoredIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIgnoredIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IgnoredIdentifier() (localctx IIgnoredIdentifierContext) {
	this := p
	_ = this

	localctx = NewIgnoredIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SQLServerStatementParserRULE_ignoredIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2099)
		p.Match(SQLServerStatementParserIDENTIFIER_)
	}

	return localctx
}

// IIgnoredIdentifiersContext is an interface to support dynamic dispatch.
type IIgnoredIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIgnoredIdentifiersContext differentiates from other interfaces.
	IsIgnoredIdentifiersContext()
}

type IgnoredIdentifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoredIdentifiersContext() *IgnoredIdentifiersContext {
	var p = new(IgnoredIdentifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_ignoredIdentifiers
	return p
}

func (*IgnoredIdentifiersContext) IsIgnoredIdentifiersContext() {}

func NewIgnoredIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoredIdentifiersContext {
	var p = new(IgnoredIdentifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_ignoredIdentifiers

	return p
}

func (s *IgnoredIdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoredIdentifiersContext) AllIgnoredIdentifier() []IIgnoredIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem())
	var tst = make([]IIgnoredIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIgnoredIdentifierContext)
		}
	}

	return tst
}

func (s *IgnoredIdentifiersContext) IgnoredIdentifier(i int) IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *IgnoredIdentifiersContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *IgnoredIdentifiersContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *IgnoredIdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoredIdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoredIdentifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIgnoredIdentifiers(s)
	}
}

func (s *IgnoredIdentifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIgnoredIdentifiers(s)
	}
}

func (s *IgnoredIdentifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIgnoredIdentifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IgnoredIdentifiers() (localctx IIgnoredIdentifiersContext) {
	this := p
	_ = this

	localctx = NewIgnoredIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SQLServerStatementParserRULE_ignoredIdentifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2101)
		p.IgnoredIdentifier()
	}
	p.SetState(2106)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2102)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(2103)
				p.IgnoredIdentifier()
			}

		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext())
	}

	return localctx
}

// IMatchNoneContext is an interface to support dynamic dispatch.
type IMatchNoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchNoneContext differentiates from other interfaces.
	IsMatchNoneContext()
}

type MatchNoneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchNoneContext() *MatchNoneContext {
	var p = new(MatchNoneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_matchNone
	return p
}

func (*MatchNoneContext) IsMatchNoneContext() {}

func NewMatchNoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchNoneContext {
	var p = new(MatchNoneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_matchNone

	return p
}

func (s *MatchNoneContext) GetParser() antlr.Parser { return s.parser }
func (s *MatchNoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchNoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchNoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMatchNone(s)
	}
}

func (s *MatchNoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMatchNone(s)
	}
}

func (s *MatchNoneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMatchNone(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MatchNone() (localctx IMatchNoneContext) {
	this := p
	_ = this

	localctx = NewMatchNoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SQLServerStatementParserRULE_matchNone)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2109)
		p.Match(SQLServerStatementParserT__0)
	}

	return localctx
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variableName
	return p
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) AT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAT_, 0)
}

func (s *VariableNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (s *VariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) VariableName() (localctx IVariableNameContext) {
	this := p
	_ = this

	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SQLServerStatementParserRULE_variableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.Match(SQLServerStatementParserAT_)
	}
	{
		p.SetState(2112)
		p.Identifier()
	}

	return localctx
}

// IExecuteAsClauseContext is an interface to support dynamic dispatch.
type IExecuteAsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecuteAsClauseContext differentiates from other interfaces.
	IsExecuteAsClauseContext()
}

type ExecuteAsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteAsClauseContext() *ExecuteAsClauseContext {
	var p = new(ExecuteAsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_executeAsClause
	return p
}

func (*ExecuteAsClauseContext) IsExecuteAsClauseContext() {}

func NewExecuteAsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteAsClauseContext {
	var p = new(ExecuteAsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_executeAsClause

	return p
}

func (s *ExecuteAsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteAsClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *ExecuteAsClauseContext) EXEC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXEC, 0)
}

func (s *ExecuteAsClauseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXECUTE, 0)
}

func (s *ExecuteAsClauseContext) CALLER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCALLER, 0)
}

func (s *ExecuteAsClauseContext) SELF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELF, 0)
}

func (s *ExecuteAsClauseContext) OWNER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOWNER, 0)
}

func (s *ExecuteAsClauseContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *ExecuteAsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteAsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteAsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExecuteAsClause(s)
	}
}

func (s *ExecuteAsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExecuteAsClause(s)
	}
}

func (s *ExecuteAsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExecuteAsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ExecuteAsClause() (localctx IExecuteAsClauseContext) {
	this := p
	_ = this

	localctx = NewExecuteAsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SQLServerStatementParserRULE_executeAsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2114)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserEXECUTE || _la == SQLServerStatementParserEXEC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2115)
		p.Match(SQLServerStatementParserAS)
	}
	p.SetState(2120)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCALLER:
		{
			p.SetState(2116)
			p.Match(SQLServerStatementParserCALLER)
		}

	case SQLServerStatementParserSELF:
		{
			p.SetState(2117)
			p.Match(SQLServerStatementParserSELF)
		}

	case SQLServerStatementParserOWNER:
		{
			p.SetState(2118)
			p.Match(SQLServerStatementParserOWNER)
		}

	case SQLServerStatementParserSTRING_:
		{
			p.SetState(2119)
			p.StringLiterals()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITransactionNameContext is an interface to support dynamic dispatch.
type ITransactionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionNameContext differentiates from other interfaces.
	IsTransactionNameContext()
}

type TransactionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionNameContext() *TransactionNameContext {
	var p = new(TransactionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_transactionName
	return p
}

func (*TransactionNameContext) IsTransactionNameContext() {}

func NewTransactionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionNameContext {
	var p = new(TransactionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_transactionName

	return p
}

func (s *TransactionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TransactionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTransactionName(s)
	}
}

func (s *TransactionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTransactionName(s)
	}
}

func (s *TransactionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTransactionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TransactionName() (localctx ITransactionNameContext) {
	this := p
	_ = this

	localctx = NewTransactionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SQLServerStatementParserRULE_transactionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2122)
		p.Identifier()
	}

	return localctx
}

// ITransactionVariableNameContext is an interface to support dynamic dispatch.
type ITransactionVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionVariableNameContext differentiates from other interfaces.
	IsTransactionVariableNameContext()
}

type TransactionVariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionVariableNameContext() *TransactionVariableNameContext {
	var p = new(TransactionVariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_transactionVariableName
	return p
}

func (*TransactionVariableNameContext) IsTransactionVariableNameContext() {}

func NewTransactionVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionVariableNameContext {
	var p = new(TransactionVariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_transactionVariableName

	return p
}

func (s *TransactionVariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionVariableNameContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *TransactionVariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionVariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionVariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTransactionVariableName(s)
	}
}

func (s *TransactionVariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTransactionVariableName(s)
	}
}

func (s *TransactionVariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTransactionVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TransactionVariableName() (localctx ITransactionVariableNameContext) {
	this := p
	_ = this

	localctx = NewTransactionVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SQLServerStatementParserRULE_transactionVariableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2124)
		p.VariableName()
	}

	return localctx
}

// ISavepointNameContext is an interface to support dynamic dispatch.
type ISavepointNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepointNameContext differentiates from other interfaces.
	IsSavepointNameContext()
}

type SavepointNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointNameContext() *SavepointNameContext {
	var p = new(SavepointNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_savepointName
	return p
}

func (*SavepointNameContext) IsSavepointNameContext() {}

func NewSavepointNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointNameContext {
	var p = new(SavepointNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_savepointName

	return p
}

func (s *SavepointNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SavepointNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSavepointName(s)
	}
}

func (s *SavepointNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSavepointName(s)
	}
}

func (s *SavepointNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSavepointName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SavepointName() (localctx ISavepointNameContext) {
	this := p
	_ = this

	localctx = NewSavepointNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SQLServerStatementParserRULE_savepointName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)
		p.Identifier()
	}

	return localctx
}

// ISavepointVariableNameContext is an interface to support dynamic dispatch.
type ISavepointVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepointVariableNameContext differentiates from other interfaces.
	IsSavepointVariableNameContext()
}

type SavepointVariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointVariableNameContext() *SavepointVariableNameContext {
	var p = new(SavepointVariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_savepointVariableName
	return p
}

func (*SavepointVariableNameContext) IsSavepointVariableNameContext() {}

func NewSavepointVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointVariableNameContext {
	var p = new(SavepointVariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_savepointVariableName

	return p
}

func (s *SavepointVariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointVariableNameContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *SavepointVariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointVariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointVariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSavepointVariableName(s)
	}
}

func (s *SavepointVariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSavepointVariableName(s)
	}
}

func (s *SavepointVariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSavepointVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SavepointVariableName() (localctx ISavepointVariableNameContext) {
	this := p
	_ = this

	localctx = NewSavepointVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SQLServerStatementParserRULE_savepointVariableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2128)
		p.VariableName()
	}

	return localctx
}

// IEntityTypeContext is an interface to support dynamic dispatch.
type IEntityTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntityTypeContext differentiates from other interfaces.
	IsEntityTypeContext()
}

type EntityTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntityTypeContext() *EntityTypeContext {
	var p = new(EntityTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_entityType
	return p
}

func (*EntityTypeContext) IsEntityTypeContext() {}

func NewEntityTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntityTypeContext {
	var p = new(EntityTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_entityType

	return p
}

func (s *EntityTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *EntityTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOBJECT, 0)
}

func (s *EntityTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE, 0)
}

func (s *EntityTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntityTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntityTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEntityType(s)
	}
}

func (s *EntityTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEntityType(s)
	}
}

func (s *EntityTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEntityType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EntityType() (localctx IEntityTypeContext) {
	this := p
	_ = this

	localctx = NewEntityTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SQLServerStatementParserRULE_entityType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2130)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTYPE || _la == SQLServerStatementParserOBJECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTable
	return p
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CreateTableClause() ICreateTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableClauseContext)
}

func (s *CreateTableContext) CreateTableAsSelectClause() ICreateTableAsSelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableAsSelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectClauseContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTable() (localctx ICreateTableContext) {
	this := p
	_ = this

	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, SQLServerStatementParserRULE_createTable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2132)
			p.CreateTableClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2133)
			p.CreateTableAsSelectClause()
		}

	}

	return localctx
}

// ICreateTableClauseContext is an interface to support dynamic dispatch.
type ICreateTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableClauseContext differentiates from other interfaces.
	IsCreateTableClauseContext()
}

type CreateTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableClauseContext() *CreateTableClauseContext {
	var p = new(CreateTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTableClause
	return p
}

func (*CreateTableClauseContext) IsCreateTableClauseContext() {}

func NewCreateTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableClauseContext {
	var p = new(CreateTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTableClause

	return p
}

func (s *CreateTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *CreateTableClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableClauseContext) FileTableClause() IFileTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileTableClauseContext)
}

func (s *CreateTableClauseContext) CreateDefinitionClause() ICreateDefinitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDefinitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionClauseContext)
}

func (s *CreateTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTableClause(s)
	}
}

func (s *CreateTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTableClause(s)
	}
}

func (s *CreateTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTableClause() (localctx ICreateTableClauseContext) {
	this := p
	_ = this

	localctx = NewCreateTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, SQLServerStatementParserRULE_createTableClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2137)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(2138)
		p.TableName()
	}
	{
		p.SetState(2139)
		p.FileTableClause()
	}
	{
		p.SetState(2140)
		p.CreateDefinitionClause()
	}

	return localctx
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createIndex
	return p
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateIndexContext) CreateIndexSpecification() ICreateIndexSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateIndexSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateIndexSpecificationContext)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *CreateIndexContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CreateIndexContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateIndexContext) ColumnNamesWithSort() IColumnNamesWithSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesWithSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesWithSortContext)
}

func (s *CreateIndexContext) CreateIndexClause() ICreateIndexClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateIndexClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateIndexClauseContext)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateIndex() (localctx ICreateIndexContext) {
	this := p
	_ = this

	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, SQLServerStatementParserRULE_createIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2142)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2143)
		p.CreateIndexSpecification()
	}
	{
		p.SetState(2144)
		p.Match(SQLServerStatementParserINDEX)
	}
	{
		p.SetState(2145)
		p.IndexName()
	}
	{
		p.SetState(2146)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2147)
		p.TableName()
	}
	{
		p.SetState(2148)
		p.ColumnNamesWithSort()
	}
	{
		p.SetState(2149)
		p.CreateIndexClause()
	}

	return localctx
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createDatabase
	return p
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *CreateDatabaseContext) DatabaseName() IDatabaseNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *CreateDatabaseContext) CreateDatabaseClause() ICreateDatabaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDatabaseClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseClauseContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, SQLServerStatementParserRULE_createDatabase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2151)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2152)
		p.Match(SQLServerStatementParserDATABASE)
	}
	{
		p.SetState(2153)
		p.DatabaseName()
	}
	{
		p.SetState(2154)
		p.CreateDatabaseClause()
	}

	return localctx
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createFunction
	return p
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *CreateFunctionContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *CreateFunctionContext) FuncParameters() IFuncParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncParametersContext)
}

func (s *CreateFunctionContext) FuncReturns() IFuncReturnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncReturnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncReturnsContext)
}

func (s *CreateFunctionContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR, 0)
}

func (s *CreateFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateFunction() (localctx ICreateFunctionContext) {
	this := p
	_ = this

	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, SQLServerStatementParserRULE_createFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2156)
		p.Match(SQLServerStatementParserCREATE)
	}
	p.SetState(2159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOR {
		{
			p.SetState(2157)
			p.Match(SQLServerStatementParserOR)
		}
		{
			p.SetState(2158)
			p.Match(SQLServerStatementParserALTER)
		}

	}
	{
		p.SetState(2161)
		p.Match(SQLServerStatementParserFUNCTION)
	}
	{
		p.SetState(2162)
		p.FunctionName()
	}
	{
		p.SetState(2163)
		p.FuncParameters()
	}
	{
		p.SetState(2164)
		p.FuncReturns()
	}

	return localctx
}

// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createProcedure
	return p
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateProcedureContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *CreateProcedureContext) ProcParameters() IProcParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcParametersContext)
}

func (s *CreateProcedureContext) CreateOrAlterProcClause() ICreateOrAlterProcClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterProcClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterProcClauseContext)
}

func (s *CreateProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROC, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR, 0)
}

func (s *CreateProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateProcedure() (localctx ICreateProcedureContext) {
	this := p
	_ = this

	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, SQLServerStatementParserRULE_createProcedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2166)
		p.Match(SQLServerStatementParserCREATE)
	}
	p.SetState(2169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOR {
		{
			p.SetState(2167)
			p.Match(SQLServerStatementParserOR)
		}
		{
			p.SetState(2168)
			p.Match(SQLServerStatementParserALTER)
		}

	}
	{
		p.SetState(2171)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserPROCEDURE || _la == SQLServerStatementParserPROC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2172)
		p.ProcedureName()
	}
	{
		p.SetState(2173)
		p.ProcParameters()
	}
	{
		p.SetState(2174)
		p.CreateOrAlterProcClause()
	}

	return localctx
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createView
	return p
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *CreateViewContext) ViewName() IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *CreateViewContext) CreateOrAlterViewClause() ICreateOrAlterViewClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterViewClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterViewClauseContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR, 0)
}

func (s *CreateViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateView() (localctx ICreateViewContext) {
	this := p
	_ = this

	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, SQLServerStatementParserRULE_createView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(SQLServerStatementParserCREATE)
	}
	p.SetState(2179)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOR {
		{
			p.SetState(2177)
			p.Match(SQLServerStatementParserOR)
		}
		{
			p.SetState(2178)
			p.Match(SQLServerStatementParserALTER)
		}

	}
	{
		p.SetState(2181)
		p.Match(SQLServerStatementParserVIEW)
	}
	{
		p.SetState(2182)
		p.ViewName()
	}
	{
		p.SetState(2183)
		p.CreateOrAlterViewClause()
	}

	return localctx
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTrigger
	return p
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *CreateTriggerContext) TriggerName() ITriggerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerNameContext)
}

func (s *CreateTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CreateTriggerContext) TriggerTarget() ITriggerTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerTargetContext)
}

func (s *CreateTriggerContext) CreateTriggerClause() ICreateTriggerClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTriggerClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerClauseContext)
}

func (s *CreateTriggerContext) OR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOR, 0)
}

func (s *CreateTriggerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTrigger() (localctx ICreateTriggerContext) {
	this := p
	_ = this

	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, SQLServerStatementParserRULE_createTrigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2185)
		p.Match(SQLServerStatementParserCREATE)
	}
	p.SetState(2188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOR {
		{
			p.SetState(2186)
			p.Match(SQLServerStatementParserOR)
		}
		{
			p.SetState(2187)
			p.Match(SQLServerStatementParserALTER)
		}

	}
	{
		p.SetState(2190)
		p.Match(SQLServerStatementParserTRIGGER)
	}
	{
		p.SetState(2191)
		p.TriggerName()
	}
	{
		p.SetState(2192)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2193)
		p.TriggerTarget()
	}
	{
		p.SetState(2194)
		p.CreateTriggerClause()
	}

	return localctx
}

// ICreateSequenceContext is an interface to support dynamic dispatch.
type ICreateSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateSequenceContext differentiates from other interfaces.
	IsCreateSequenceContext()
}

type CreateSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSequenceContext() *CreateSequenceContext {
	var p = new(CreateSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createSequence
	return p
}

func (*CreateSequenceContext) IsCreateSequenceContext() {}

func NewCreateSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSequenceContext {
	var p = new(CreateSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createSequence

	return p
}

func (s *CreateSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSequenceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEQUENCE, 0)
}

func (s *CreateSequenceContext) SequenceName() ISequenceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceNameContext)
}

func (s *CreateSequenceContext) AllCreateOrAlterSequenceClause() []ICreateOrAlterSequenceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICreateOrAlterSequenceClauseContext)(nil)).Elem())
	var tst = make([]ICreateOrAlterSequenceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICreateOrAlterSequenceClauseContext)
		}
	}

	return tst
}

func (s *CreateSequenceContext) CreateOrAlterSequenceClause(i int) ICreateOrAlterSequenceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterSequenceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterSequenceClauseContext)
}

func (s *CreateSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateSequence(s)
	}
}

func (s *CreateSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateSequence(s)
	}
}

func (s *CreateSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateSequence() (localctx ICreateSequenceContext) {
	this := p
	_ = this

	localctx = NewCreateSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, SQLServerStatementParserRULE_createSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2197)
		p.Match(SQLServerStatementParserSEQUENCE)
	}
	{
		p.SetState(2198)
		p.SequenceName()
	}
	p.SetState(2202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserAS || _la == SQLServerStatementParserNO || _la == SQLServerStatementParserSTART || (((_la-519)&-(0x1f+1)) == 0 && ((1<<uint((_la-519)))&((1<<(SQLServerStatementParserINCREMENT-519))|(1<<(SQLServerStatementParserCYCLE-519))|(1<<(SQLServerStatementParserCACHE-519))|(1<<(SQLServerStatementParserMINVALUE-519))|(1<<(SQLServerStatementParserMAXVALUE-519))|(1<<(SQLServerStatementParserRESTART-519)))) != 0) {
		{
			p.SetState(2199)
			p.CreateOrAlterSequenceClause()
		}

		p.SetState(2204)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICreateServiceContext is an interface to support dynamic dispatch.
type ICreateServiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateServiceContext differentiates from other interfaces.
	IsCreateServiceContext()
}

type CreateServiceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateServiceContext() *CreateServiceContext {
	var p = new(CreateServiceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createService
	return p
}

func (*CreateServiceContext) IsCreateServiceContext() {}

func NewCreateServiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServiceContext {
	var p = new(CreateServiceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createService

	return p
}

func (s *CreateServiceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServiceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateServiceContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *CreateServiceContext) ServiceName() IServiceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceNameContext)
}

func (s *CreateServiceContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CreateServiceContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUEUE, 0)
}

func (s *CreateServiceContext) QueueName() IQueueNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueueNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueueNameContext)
}

func (s *CreateServiceContext) AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTHORIZATION, 0)
}

func (s *CreateServiceContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *CreateServiceContext) CreateServiceClause() ICreateServiceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateServiceClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateServiceClauseContext)
}

func (s *CreateServiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateService(s)
	}
}

func (s *CreateServiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateService(s)
	}
}

func (s *CreateServiceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateService(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateService() (localctx ICreateServiceContext) {
	this := p
	_ = this

	localctx = NewCreateServiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, SQLServerStatementParserRULE_createService)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2205)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2206)
		p.Match(SQLServerStatementParserSERVICE)
	}
	{
		p.SetState(2207)
		p.ServiceName()
	}
	p.SetState(2210)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAUTHORIZATION {
		{
			p.SetState(2208)
			p.Match(SQLServerStatementParserAUTHORIZATION)
		}
		{
			p.SetState(2209)
			p.Match(SQLServerStatementParserSTRING_)
		}

	}
	{
		p.SetState(2212)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2213)
		p.Match(SQLServerStatementParserQUEUE)
	}
	{
		p.SetState(2214)
		p.QueueName()
	}
	p.SetState(2216)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(2215)
			p.CreateServiceClause()
		}

	}

	return localctx
}

// ICreateSchemaContext is an interface to support dynamic dispatch.
type ICreateSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateSchemaContext differentiates from other interfaces.
	IsCreateSchemaContext()
}

type CreateSchemaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSchemaContext() *CreateSchemaContext {
	var p = new(CreateSchemaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createSchema
	return p
}

func (*CreateSchemaContext) IsCreateSchemaContext() {}

func NewCreateSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSchemaContext {
	var p = new(CreateSchemaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createSchema

	return p
}

func (s *CreateSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSchemaContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *CreateSchemaContext) SchemaNameClause() ISchemaNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameClauseContext)
}

func (s *CreateSchemaContext) AllSchemaElement() []ISchemaElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISchemaElementContext)(nil)).Elem())
	var tst = make([]ISchemaElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISchemaElementContext)
		}
	}

	return tst
}

func (s *CreateSchemaContext) SchemaElement(i int) ISchemaElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISchemaElementContext)
}

func (s *CreateSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateSchema(s)
	}
}

func (s *CreateSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateSchema(s)
	}
}

func (s *CreateSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateSchema() (localctx ICreateSchemaContext) {
	this := p
	_ = this

	localctx = NewCreateSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, SQLServerStatementParserRULE_createSchema)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2218)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(2219)
		p.Match(SQLServerStatementParserSCHEMA)
	}
	{
		p.SetState(2220)
		p.SchemaNameClause()
	}
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-49)&-(0x1f+1)) == 0 && ((1<<uint((_la-49)))&((1<<(SQLServerStatementParserCREATE-49))|(1<<(SQLServerStatementParserGRANT-49))|(1<<(SQLServerStatementParserREVOKE-49)))) != 0) || _la == SQLServerStatementParserDENY {
		{
			p.SetState(2221)
			p.SchemaElement()
		}

		p.SetState(2226)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTable
	return p
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) AllAlterDefinitionClause() []IAlterDefinitionClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterDefinitionClauseContext)(nil)).Elem())
	var tst = make([]IAlterDefinitionClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterDefinitionClauseContext)
		}
	}

	return tst
}

func (s *AlterTableContext) AlterDefinitionClause(i int) IAlterDefinitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDefinitionClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterDefinitionClauseContext)
}

func (s *AlterTableContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterTableContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTable() (localctx IAlterTableContext) {
	this := p
	_ = this

	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, SQLServerStatementParserRULE_alterTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2227)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2228)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(2229)
		p.TableName()
	}
	{
		p.SetState(2230)
		p.AlterDefinitionClause()
	}
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2231)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2232)
			p.AlterDefinitionClause()
		}

		p.SetState(2237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterIndexContext is an interface to support dynamic dispatch.
type IAlterIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterIndexContext differentiates from other interfaces.
	IsAlterIndexContext()
}

type AlterIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterIndexContext() *AlterIndexContext {
	var p = new(AlterIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterIndex
	return p
}

func (*AlterIndexContext) IsAlterIndexContext() {}

func NewAlterIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterIndexContext {
	var p = new(AlterIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterIndex

	return p
}

func (s *AlterIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterIndexContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *AlterIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterIndexContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterIndexContext) AlterIndexClause() IAlterIndexClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterIndexClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterIndexClauseContext)
}

func (s *AlterIndexContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *AlterIndexContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *AlterIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterIndex(s)
	}
}

func (s *AlterIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterIndex(s)
	}
}

func (s *AlterIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterIndex() (localctx IAlterIndexContext) {
	this := p
	_ = this

	localctx = NewAlterIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, SQLServerStatementParserRULE_alterIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2238)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2239)
		p.Match(SQLServerStatementParserINDEX)
	}
	p.SetState(2242)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(2240)
			p.IndexName()
		}

	case SQLServerStatementParserALL:
		{
			p.SetState(2241)
			p.Match(SQLServerStatementParserALL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(2244)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2245)
		p.TableName()
	}
	{
		p.SetState(2246)
		p.AlterIndexClause()
	}

	return localctx
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabase
	return p
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *AlterDatabaseContext) DatabaseName() IDatabaseNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *AlterDatabaseContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURRENT, 0)
}

func (s *AlterDatabaseContext) AllAlterDatabaseClause() []IAlterDatabaseClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterDatabaseClauseContext)(nil)).Elem())
	var tst = make([]IAlterDatabaseClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterDatabaseClauseContext)
		}
	}

	return tst
}

func (s *AlterDatabaseContext) AlterDatabaseClause(i int) IAlterDatabaseClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDatabaseClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseClauseContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterDatabase(s)
	}
}

func (s *AlterDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterDatabase(s)
	}
}

func (s *AlterDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	this := p
	_ = this

	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, SQLServerStatementParserRULE_alterDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2248)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2249)
		p.Match(SQLServerStatementParserDATABASE)
	}
	p.SetState(2252)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(2250)
			p.DatabaseName()
		}

	case SQLServerStatementParserCURRENT:
		{
			p.SetState(2251)
			p.Match(SQLServerStatementParserCURRENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(SQLServerStatementParserLP_-29))|(1<<(SQLServerStatementParserADD-29))|(1<<(SQLServerStatementParserSET-29)))) != 0) || _la == SQLServerStatementParserDEFAULT || _la == SQLServerStatementParserNAME || _la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserREADONLY || _la == SQLServerStatementParserCOLLATE || (((_la-535)&-(0x1f+1)) == 0 && ((1<<uint((_la-535)))&((1<<(SQLServerStatementParserREMOVE-535))|(1<<(SQLServerStatementParserAUTOGROW_SINGLE_FILE-535))|(1<<(SQLServerStatementParserAUTOGROW_ALL_FILES-535))|(1<<(SQLServerStatementParserREADWRITE-535))|(1<<(SQLServerStatementParserREAD_WRITE-535))|(1<<(SQLServerStatementParserMODIFY-535)))) != 0) || _la == SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS || _la == SQLServerStatementParserFAILOVER {
		{
			p.SetState(2254)
			p.AlterDatabaseClause()
		}

		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterProcedureContext is an interface to support dynamic dispatch.
type IAlterProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterProcedureContext differentiates from other interfaces.
	IsAlterProcedureContext()
}

type AlterProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProcedureContext() *AlterProcedureContext {
	var p = new(AlterProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterProcedure
	return p
}

func (*AlterProcedureContext) IsAlterProcedureContext() {}

func NewAlterProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProcedureContext {
	var p = new(AlterProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterProcedure

	return p
}

func (s *AlterProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterProcedureContext) ProcedureName() IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *AlterProcedureContext) ProcParameters() IProcParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcParametersContext)
}

func (s *AlterProcedureContext) CreateOrAlterProcClause() ICreateOrAlterProcClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterProcClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterProcClauseContext)
}

func (s *AlterProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROC, 0)
}

func (s *AlterProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROCEDURE, 0)
}

func (s *AlterProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterProcedure(s)
	}
}

func (s *AlterProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterProcedure() (localctx IAlterProcedureContext) {
	this := p
	_ = this

	localctx = NewAlterProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, SQLServerStatementParserRULE_alterProcedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2260)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2261)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserPROCEDURE || _la == SQLServerStatementParserPROC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2262)
		p.ProcedureName()
	}
	{
		p.SetState(2263)
		p.ProcParameters()
	}
	{
		p.SetState(2264)
		p.CreateOrAlterProcClause()
	}

	return localctx
}

// IAlterFunctionContext is an interface to support dynamic dispatch.
type IAlterFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterFunctionContext differentiates from other interfaces.
	IsAlterFunctionContext()
}

type AlterFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterFunctionContext() *AlterFunctionContext {
	var p = new(AlterFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterFunction
	return p
}

func (*AlterFunctionContext) IsAlterFunctionContext() {}

func NewAlterFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterFunctionContext {
	var p = new(AlterFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterFunction

	return p
}

func (s *AlterFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterFunctionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *AlterFunctionContext) FunctionName() IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *AlterFunctionContext) FuncParameters() IFuncParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncParametersContext)
}

func (s *AlterFunctionContext) FuncReturns() IFuncReturnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncReturnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncReturnsContext)
}

func (s *AlterFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterFunction(s)
	}
}

func (s *AlterFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterFunction(s)
	}
}

func (s *AlterFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterFunction() (localctx IAlterFunctionContext) {
	this := p
	_ = this

	localctx = NewAlterFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, SQLServerStatementParserRULE_alterFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2266)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2267)
		p.Match(SQLServerStatementParserFUNCTION)
	}
	{
		p.SetState(2268)
		p.FunctionName()
	}
	{
		p.SetState(2269)
		p.FuncParameters()
	}
	{
		p.SetState(2270)
		p.FuncReturns()
	}

	return localctx
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterView
	return p
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *AlterViewContext) ViewName() IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *AlterViewContext) CreateOrAlterViewClause() ICreateOrAlterViewClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterViewClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterViewClauseContext)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterView() (localctx IAlterViewContext) {
	this := p
	_ = this

	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, SQLServerStatementParserRULE_alterView)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2272)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2273)
		p.Match(SQLServerStatementParserVIEW)
	}
	{
		p.SetState(2274)
		p.ViewName()
	}
	{
		p.SetState(2275)
		p.CreateOrAlterViewClause()
	}

	return localctx
}

// IAlterTriggerContext is an interface to support dynamic dispatch.
type IAlterTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTriggerContext differentiates from other interfaces.
	IsAlterTriggerContext()
}

type AlterTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTriggerContext() *AlterTriggerContext {
	var p = new(AlterTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTrigger
	return p
}

func (*AlterTriggerContext) IsAlterTriggerContext() {}

func NewAlterTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTriggerContext {
	var p = new(AlterTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTrigger

	return p
}

func (s *AlterTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTriggerContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *AlterTriggerContext) TriggerName() ITriggerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerNameContext)
}

func (s *AlterTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterTriggerContext) TriggerTarget() ITriggerTargetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerTargetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerTargetContext)
}

func (s *AlterTriggerContext) CreateTriggerClause() ICreateTriggerClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTriggerClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerClauseContext)
}

func (s *AlterTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTrigger(s)
	}
}

func (s *AlterTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTrigger(s)
	}
}

func (s *AlterTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTrigger() (localctx IAlterTriggerContext) {
	this := p
	_ = this

	localctx = NewAlterTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, SQLServerStatementParserRULE_alterTrigger)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2277)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2278)
		p.Match(SQLServerStatementParserTRIGGER)
	}
	{
		p.SetState(2279)
		p.TriggerName()
	}
	{
		p.SetState(2280)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2281)
		p.TriggerTarget()
	}
	{
		p.SetState(2282)
		p.CreateTriggerClause()
	}

	return localctx
}

// IAlterSequenceContext is an interface to support dynamic dispatch.
type IAlterSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterSequenceContext differentiates from other interfaces.
	IsAlterSequenceContext()
}

type AlterSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSequenceContext() *AlterSequenceContext {
	var p = new(AlterSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterSequence
	return p
}

func (*AlterSequenceContext) IsAlterSequenceContext() {}

func NewAlterSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSequenceContext {
	var p = new(AlterSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterSequence

	return p
}

func (s *AlterSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSequenceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEQUENCE, 0)
}

func (s *AlterSequenceContext) SequenceName() ISequenceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequenceNameContext)
}

func (s *AlterSequenceContext) AllCreateOrAlterSequenceClause() []ICreateOrAlterSequenceClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICreateOrAlterSequenceClauseContext)(nil)).Elem())
	var tst = make([]ICreateOrAlterSequenceClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICreateOrAlterSequenceClauseContext)
		}
	}

	return tst
}

func (s *AlterSequenceContext) CreateOrAlterSequenceClause(i int) ICreateOrAlterSequenceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateOrAlterSequenceClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICreateOrAlterSequenceClauseContext)
}

func (s *AlterSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterSequence(s)
	}
}

func (s *AlterSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterSequence(s)
	}
}

func (s *AlterSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterSequence() (localctx IAlterSequenceContext) {
	this := p
	_ = this

	localctx = NewAlterSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, SQLServerStatementParserRULE_alterSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2285)
		p.Match(SQLServerStatementParserSEQUENCE)
	}
	{
		p.SetState(2286)
		p.SequenceName()
	}
	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserAS || _la == SQLServerStatementParserNO || _la == SQLServerStatementParserSTART || (((_la-519)&-(0x1f+1)) == 0 && ((1<<uint((_la-519)))&((1<<(SQLServerStatementParserINCREMENT-519))|(1<<(SQLServerStatementParserCYCLE-519))|(1<<(SQLServerStatementParserCACHE-519))|(1<<(SQLServerStatementParserMINVALUE-519))|(1<<(SQLServerStatementParserMAXVALUE-519))|(1<<(SQLServerStatementParserRESTART-519)))) != 0) {
		{
			p.SetState(2287)
			p.CreateOrAlterSequenceClause()
		}

		p.SetState(2292)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterServiceContext is an interface to support dynamic dispatch.
type IAlterServiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterServiceContext differentiates from other interfaces.
	IsAlterServiceContext()
}

type AlterServiceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServiceContext() *AlterServiceContext {
	var p = new(AlterServiceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterService
	return p
}

func (*AlterServiceContext) IsAlterServiceContext() {}

func NewAlterServiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServiceContext {
	var p = new(AlterServiceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterService

	return p
}

func (s *AlterServiceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServiceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterServiceContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *AlterServiceContext) ServiceName() IServiceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceNameContext)
}

func (s *AlterServiceContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterServiceContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUEUE, 0)
}

func (s *AlterServiceContext) QueueName() IQueueNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueueNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueueNameContext)
}

func (s *AlterServiceContext) AlterServiceClause() IAlterServiceClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterServiceClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterServiceClauseContext)
}

func (s *AlterServiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterService(s)
	}
}

func (s *AlterServiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterService(s)
	}
}

func (s *AlterServiceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterService(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterService() (localctx IAlterServiceContext) {
	this := p
	_ = this

	localctx = NewAlterServiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, SQLServerStatementParserRULE_alterService)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2293)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2294)
		p.Match(SQLServerStatementParserSERVICE)
	}
	{
		p.SetState(2295)
		p.ServiceName()
	}
	p.SetState(2299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2296)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(2297)
			p.Match(SQLServerStatementParserQUEUE)
		}
		{
			p.SetState(2298)
			p.QueueName()
		}

	}
	p.SetState(2302)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(2301)
			p.AlterServiceClause()
		}

	}

	return localctx
}

// IAlterSchemaContext is an interface to support dynamic dispatch.
type IAlterSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterSchemaContext differentiates from other interfaces.
	IsAlterSchemaContext()
}

type AlterSchemaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSchemaContext() *AlterSchemaContext {
	var p = new(AlterSchemaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterSchema
	return p
}

func (*AlterSchemaContext) IsAlterSchemaContext() {}

func NewAlterSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSchemaContext {
	var p = new(AlterSchemaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterSchema

	return p
}

func (s *AlterSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSchemaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *AlterSchemaContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *AlterSchemaContext) TRANSFER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSFER, 0)
}

func (s *AlterSchemaContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AlterSchemaContext) Class_() IClass_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_Context)
}

func (s *AlterSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterSchema(s)
	}
}

func (s *AlterSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterSchema(s)
	}
}

func (s *AlterSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterSchema() (localctx IAlterSchemaContext) {
	this := p
	_ = this

	localctx = NewAlterSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, SQLServerStatementParserRULE_alterSchema)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2304)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(2305)
		p.Match(SQLServerStatementParserSCHEMA)
	}
	{
		p.SetState(2306)
		p.SchemaName()
	}
	{
		p.SetState(2307)
		p.Match(SQLServerStatementParserTRANSFER)
	}
	p.SetState(2309)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2308)
			p.Class_()
		}

	}
	{
		p.SetState(2311)
		p.IgnoredIdentifier()
	}

	return localctx
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropTable
	return p
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *DropTableContext) TableNames() ITableNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNamesContext)
}

func (s *DropTableContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropTable() (localctx IDropTableContext) {
	this := p
	_ = this

	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, SQLServerStatementParserRULE_dropTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2313)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2314)
		p.Match(SQLServerStatementParserTABLE)
	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2315)
			p.IfExist()
		}

	}
	{
		p.SetState(2318)
		p.TableNames()
	}

	return localctx
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropIndex
	return p
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *DropIndexContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *DropIndexContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *DropIndexContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropIndex() (localctx IDropIndexContext) {
	this := p
	_ = this

	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, SQLServerStatementParserRULE_dropIndex)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2320)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2321)
		p.Match(SQLServerStatementParserINDEX)
	}
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2322)
			p.IfExist()
		}

	}
	{
		p.SetState(2325)
		p.IndexName()
	}
	{
		p.SetState(2326)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2327)
		p.TableName()
	}

	return localctx
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropDatabase
	return p
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *DropDatabaseContext) AllDatabaseName() []IDatabaseNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem())
	var tst = make([]IDatabaseNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatabaseNameContext)
		}
	}

	return tst
}

func (s *DropDatabaseContext) DatabaseName(i int) IDatabaseNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *DropDatabaseContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropDatabaseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropDatabaseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropDatabase() (localctx IDropDatabaseContext) {
	this := p
	_ = this

	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, SQLServerStatementParserRULE_dropDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2329)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2330)
		p.Match(SQLServerStatementParserDATABASE)
	}
	p.SetState(2332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2331)
			p.IfExist()
		}

	}
	{
		p.SetState(2334)
		p.DatabaseName()
	}
	p.SetState(2339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2335)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2336)
			p.DatabaseName()
		}

		p.SetState(2341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropFunction
	return p
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *DropFunctionContext) AllFunctionName() []IFunctionNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem())
	var tst = make([]IFunctionNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionNameContext)
		}
	}

	return tst
}

func (s *DropFunctionContext) FunctionName(i int) IFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *DropFunctionContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropFunction() (localctx IDropFunctionContext) {
	this := p
	_ = this

	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, SQLServerStatementParserRULE_dropFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2342)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2343)
		p.Match(SQLServerStatementParserFUNCTION)
	}
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2344)
			p.IfExist()
		}

	}
	{
		p.SetState(2347)
		p.FunctionName()
	}
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2348)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2349)
			p.FunctionName()
		}

		p.SetState(2354)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropProcedure
	return p
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropProcedureContext) AllProcedureName() []IProcedureNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem())
	var tst = make([]IProcedureNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcedureNameContext)
		}
	}

	return tst
}

func (s *DropProcedureContext) ProcedureName(i int) IProcedureNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *DropProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROC, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROCEDURE, 0)
}

func (s *DropProcedureContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropProcedureContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropProcedureContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropProcedure() (localctx IDropProcedureContext) {
	this := p
	_ = this

	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, SQLServerStatementParserRULE_dropProcedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2355)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2356)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserPROCEDURE || _la == SQLServerStatementParserPROC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2357)
			p.IfExist()
		}

	}
	{
		p.SetState(2360)
		p.ProcedureName()
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2361)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2362)
			p.ProcedureName()
		}

		p.SetState(2367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropView
	return p
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *DropViewContext) AllViewName() []IViewNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewNameContext)(nil)).Elem())
	var tst = make([]IViewNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewNameContext)
		}
	}

	return tst
}

func (s *DropViewContext) ViewName(i int) IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *DropViewContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropViewContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropViewContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropView() (localctx IDropViewContext) {
	this := p
	_ = this

	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, SQLServerStatementParserRULE_dropView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2368)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2369)
		p.Match(SQLServerStatementParserVIEW)
	}
	p.SetState(2371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2370)
			p.IfExist()
		}

	}
	{
		p.SetState(2373)
		p.ViewName()
	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2374)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2375)
			p.ViewName()
		}

		p.SetState(2380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropTrigger
	return p
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *DropTriggerContext) AllTriggerName() []ITriggerNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITriggerNameContext)(nil)).Elem())
	var tst = make([]ITriggerNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITriggerNameContext)
		}
	}

	return tst
}

func (s *DropTriggerContext) TriggerName(i int) ITriggerNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITriggerNameContext)
}

func (s *DropTriggerContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTriggerContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropTriggerContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *DropTriggerContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *DropTriggerContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *DropTriggerContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (s *DropTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropTrigger() (localctx IDropTriggerContext) {
	this := p
	_ = this

	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, SQLServerStatementParserRULE_dropTrigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2381)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2382)
		p.Match(SQLServerStatementParserTRIGGER)
	}
	p.SetState(2384)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2383)
			p.IfExist()
		}

	}
	{
		p.SetState(2386)
		p.TriggerName()
	}
	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2387)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2388)
			p.TriggerName()
		}

		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2400)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2394)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(2398)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserDATABASE:
			{
				p.SetState(2395)
				p.Match(SQLServerStatementParserDATABASE)
			}

		case SQLServerStatementParserALL:
			{
				p.SetState(2396)
				p.Match(SQLServerStatementParserALL)
			}
			{
				p.SetState(2397)
				p.Match(SQLServerStatementParserSERVER)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IDropSequenceContext is an interface to support dynamic dispatch.
type IDropSequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropSequenceContext differentiates from other interfaces.
	IsDropSequenceContext()
}

type DropSequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSequenceContext() *DropSequenceContext {
	var p = new(DropSequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropSequence
	return p
}

func (*DropSequenceContext) IsDropSequenceContext() {}

func NewDropSequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSequenceContext {
	var p = new(DropSequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropSequence

	return p
}

func (s *DropSequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSequenceContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropSequenceContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEQUENCE, 0)
}

func (s *DropSequenceContext) AllSequenceName() []ISequenceNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequenceNameContext)(nil)).Elem())
	var tst = make([]ISequenceNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequenceNameContext)
		}
	}

	return tst
}

func (s *DropSequenceContext) SequenceName(i int) ISequenceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequenceNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequenceNameContext)
}

func (s *DropSequenceContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropSequenceContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropSequenceContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropSequence(s)
	}
}

func (s *DropSequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropSequence(s)
	}
}

func (s *DropSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropSequence() (localctx IDropSequenceContext) {
	this := p
	_ = this

	localctx = NewDropSequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, SQLServerStatementParserRULE_dropSequence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2402)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2403)
		p.Match(SQLServerStatementParserSEQUENCE)
	}
	p.SetState(2405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2404)
			p.IfExist()
		}

	}
	{
		p.SetState(2407)
		p.SequenceName()
	}
	p.SetState(2412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2408)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2409)
			p.SequenceName()
		}

		p.SetState(2414)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropServiceContext is an interface to support dynamic dispatch.
type IDropServiceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropServiceContext differentiates from other interfaces.
	IsDropServiceContext()
}

type DropServiceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServiceContext() *DropServiceContext {
	var p = new(DropServiceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropService
	return p
}

func (*DropServiceContext) IsDropServiceContext() {}

func NewDropServiceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServiceContext {
	var p = new(DropServiceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropService

	return p
}

func (s *DropServiceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServiceContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropServiceContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *DropServiceContext) ServiceName() IServiceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceNameContext)
}

func (s *DropServiceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServiceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServiceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropService(s)
	}
}

func (s *DropServiceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropService(s)
	}
}

func (s *DropServiceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropService(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropService() (localctx IDropServiceContext) {
	this := p
	_ = this

	localctx = NewDropServiceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, SQLServerStatementParserRULE_dropService)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2415)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2416)
		p.Match(SQLServerStatementParserSERVICE)
	}
	{
		p.SetState(2417)
		p.ServiceName()
	}

	return localctx
}

// IDropSchemaContext is an interface to support dynamic dispatch.
type IDropSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropSchemaContext differentiates from other interfaces.
	IsDropSchemaContext()
}

type DropSchemaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSchemaContext() *DropSchemaContext {
	var p = new(DropSchemaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropSchema
	return p
}

func (*DropSchemaContext) IsDropSchemaContext() {}

func NewDropSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSchemaContext {
	var p = new(DropSchemaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropSchema

	return p
}

func (s *DropSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSchemaContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *DropSchemaContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *DropSchemaContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIF, 0)
}

func (s *DropSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXISTS, 0)
}

func (s *DropSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropSchema(s)
	}
}

func (s *DropSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropSchema(s)
	}
}

func (s *DropSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropSchema() (localctx IDropSchemaContext) {
	this := p
	_ = this

	localctx = NewDropSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, SQLServerStatementParserRULE_dropSchema)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2419)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(2420)
		p.Match(SQLServerStatementParserSCHEMA)
	}
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(2421)
			p.Match(SQLServerStatementParserIF)
		}
		{
			p.SetState(2422)
			p.Match(SQLServerStatementParserEXISTS)
		}

	}
	{
		p.SetState(2425)
		p.SchemaName()
	}

	return localctx
}

// ITruncateTableContext is an interface to support dynamic dispatch.
type ITruncateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTruncateTableContext differentiates from other interfaces.
	IsTruncateTableContext()
}

type TruncateTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableContext() *TruncateTableContext {
	var p = new(TruncateTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_truncateTable
	return p
}

func (*TruncateTableContext) IsTruncateTableContext() {}

func NewTruncateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableContext {
	var p = new(TruncateTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_truncateTable

	return p
}

func (s *TruncateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *TruncateTableContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTruncateTable(s)
	}
}

func (s *TruncateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTruncateTable(s)
	}
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TruncateTable() (localctx ITruncateTableContext) {
	this := p
	_ = this

	localctx = NewTruncateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, SQLServerStatementParserRULE_truncateTable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2427)
		p.Match(SQLServerStatementParserTRUNCATE)
	}
	{
		p.SetState(2428)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(2429)
		p.TableName()
	}

	return localctx
}

// IFileTableClauseContext is an interface to support dynamic dispatch.
type IFileTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileTableClauseContext differentiates from other interfaces.
	IsFileTableClauseContext()
}

type FileTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileTableClauseContext() *FileTableClauseContext {
	var p = new(FileTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileTableClause
	return p
}

func (*FileTableClauseContext) IsFileTableClauseContext() {}

func NewFileTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileTableClauseContext {
	var p = new(FileTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileTableClause

	return p
}

func (s *FileTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileTableClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *FileTableClauseContext) FILETABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE, 0)
}

func (s *FileTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileTableClause(s)
	}
}

func (s *FileTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileTableClause(s)
	}
}

func (s *FileTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileTableClause() (localctx IFileTableClauseContext) {
	this := p
	_ = this

	localctx = NewFileTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, SQLServerStatementParserRULE_fileTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2433)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAS {
		{
			p.SetState(2431)
			p.Match(SQLServerStatementParserAS)
		}
		{
			p.SetState(2432)
			p.Match(SQLServerStatementParserFILETABLE)
		}

	}

	return localctx
}

// ICreateDefinitionClauseContext is an interface to support dynamic dispatch.
type ICreateDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDefinitionClauseContext differentiates from other interfaces.
	IsCreateDefinitionClauseContext()
}

type CreateDefinitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionClauseContext() *CreateDefinitionClauseContext {
	var p = new(CreateDefinitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createDefinitionClause
	return p
}

func (*CreateDefinitionClauseContext) IsCreateDefinitionClauseContext() {}

func NewCreateDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionClauseContext {
	var p = new(CreateDefinitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createDefinitionClause

	return p
}

func (s *CreateDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionClauseContext) CreateTableDefinitions() ICreateTableDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableDefinitionsContext)
}

func (s *CreateDefinitionClauseContext) PartitionScheme() IPartitionSchemeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionSchemeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionSchemeContext)
}

func (s *CreateDefinitionClauseContext) FileGroup() IFileGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileGroupContext)
}

func (s *CreateDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateDefinitionClause(s)
	}
}

func (s *CreateDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateDefinitionClause(s)
	}
}

func (s *CreateDefinitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateDefinitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateDefinitionClause() (localctx ICreateDefinitionClauseContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, SQLServerStatementParserRULE_createDefinitionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2435)
		p.CreateTableDefinitions()
	}
	{
		p.SetState(2436)
		p.PartitionScheme()
	}
	{
		p.SetState(2437)
		p.FileGroup()
	}

	return localctx
}

// ICreateTableDefinitionsContext is an interface to support dynamic dispatch.
type ICreateTableDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableDefinitionsContext differentiates from other interfaces.
	IsCreateTableDefinitionsContext()
}

type CreateTableDefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableDefinitionsContext() *CreateTableDefinitionsContext {
	var p = new(CreateTableDefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTableDefinitions
	return p
}

func (*CreateTableDefinitionsContext) IsCreateTableDefinitionsContext() {}

func NewCreateTableDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableDefinitionsContext {
	var p = new(CreateTableDefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTableDefinitions

	return p
}

func (s *CreateTableDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableDefinitionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CreateTableDefinitionsContext) AllCreateTableDefinition() []ICreateTableDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICreateTableDefinitionContext)(nil)).Elem())
	var tst = make([]ICreateTableDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICreateTableDefinitionContext)
		}
	}

	return tst
}

func (s *CreateTableDefinitionsContext) CreateTableDefinition(i int) ICreateTableDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICreateTableDefinitionContext)
}

func (s *CreateTableDefinitionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CreateTableDefinitionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateTableDefinitionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateTableDefinitionsContext) PeriodClause() IPeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPeriodClauseContext)
}

func (s *CreateTableDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTableDefinitions(s)
	}
}

func (s *CreateTableDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTableDefinitions(s)
	}
}

func (s *CreateTableDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTableDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTableDefinitions() (localctx ICreateTableDefinitionsContext) {
	this := p
	_ = this

	localctx = NewCreateTableDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, SQLServerStatementParserRULE_createTableDefinitions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2439)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2440)
		p.CreateTableDefinition()
	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2441)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(2442)
				p.CreateTableDefinition()
			}

		}
		p.SetState(2447)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 213, p.GetParserRuleContext())
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2448)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2449)
			p.PeriodClause()
		}

	}
	{
		p.SetState(2452)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ICreateTableDefinitionContext is an interface to support dynamic dispatch.
type ICreateTableDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableDefinitionContext differentiates from other interfaces.
	IsCreateTableDefinitionContext()
}

type CreateTableDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableDefinitionContext() *CreateTableDefinitionContext {
	var p = new(CreateTableDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTableDefinition
	return p
}

func (*CreateTableDefinitionContext) IsCreateTableDefinitionContext() {}

func NewCreateTableDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableDefinitionContext {
	var p = new(CreateTableDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTableDefinition

	return p
}

func (s *CreateTableDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableDefinitionContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *CreateTableDefinitionContext) ComputedColumnDefinition() IComputedColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnDefinitionContext)
}

func (s *CreateTableDefinitionContext) ColumnSetDefinition() IColumnSetDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnSetDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnSetDefinitionContext)
}

func (s *CreateTableDefinitionContext) TableConstraint() ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *CreateTableDefinitionContext) TableIndex() ITableIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableIndexContext)
}

func (s *CreateTableDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTableDefinition(s)
	}
}

func (s *CreateTableDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTableDefinition(s)
	}
}

func (s *CreateTableDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTableDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTableDefinition() (localctx ICreateTableDefinitionContext) {
	this := p
	_ = this

	localctx = NewCreateTableDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, SQLServerStatementParserRULE_createTableDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2459)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 215, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2454)
			p.ColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2455)
			p.ComputedColumnDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2456)
			p.ColumnSetDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2457)
			p.TableConstraint()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2458)
			p.TableIndex()
		}

	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) ColumnConstraints() IColumnConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintsContext)
}

func (s *ColumnDefinitionContext) AllColumnDefinitionOption() []IColumnDefinitionOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnDefinitionOptionContext)(nil)).Elem())
	var tst = make([]IColumnDefinitionOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnDefinitionOptionContext)
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) ColumnDefinitionOption(i int) IColumnDefinitionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionOptionContext)
}

func (s *ColumnDefinitionContext) ColumnIndex() IColumnIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnIndexContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, SQLServerStatementParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2461)
		p.ColumnName()
	}
	{
		p.SetState(2462)
		p.DataType()
	}
	p.SetState(2466)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2463)
				p.ColumnDefinitionOption()
			}

		}
		p.SetState(2468)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 216, p.GetParserRuleContext())
	}
	{
		p.SetState(2469)
		p.ColumnConstraints()
	}
	p.SetState(2471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserINDEX {
		{
			p.SetState(2470)
			p.ColumnIndex()
		}

	}

	return localctx
}

// IColumnDefinitionOptionContext is an interface to support dynamic dispatch.
type IColumnDefinitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionOptionContext differentiates from other interfaces.
	IsColumnDefinitionOptionContext()
}

type ColumnDefinitionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionOptionContext() *ColumnDefinitionOptionContext {
	var p = new(ColumnDefinitionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnDefinitionOption
	return p
}

func (*ColumnDefinitionOptionContext) IsColumnDefinitionOptionContext() {}

func NewColumnDefinitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionOptionContext {
	var p = new(ColumnDefinitionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnDefinitionOption

	return p
}

func (s *ColumnDefinitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionOptionContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *ColumnDefinitionOptionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *ColumnDefinitionOptionContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *ColumnDefinitionOptionContext) SPARSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSPARSE, 0)
}

func (s *ColumnDefinitionOptionContext) MASKED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASKED, 0)
}

func (s *ColumnDefinitionOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *ColumnDefinitionOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ColumnDefinitionOptionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *ColumnDefinitionOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ColumnDefinitionOptionContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *ColumnDefinitionOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ColumnDefinitionOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *ColumnDefinitionOptionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ColumnDefinitionOptionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *ColumnDefinitionOptionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *ColumnDefinitionOptionContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTITY, 0)
}

func (s *ColumnDefinitionOptionContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNUMBER_)
}

func (s *ColumnDefinitionOptionContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, i)
}

func (s *ColumnDefinitionOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ColumnDefinitionOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ColumnDefinitionOptionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *ColumnDefinitionOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *ColumnDefinitionOptionContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *ColumnDefinitionOptionContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGENERATED, 0)
}

func (s *ColumnDefinitionOptionContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALWAYS, 0)
}

func (s *ColumnDefinitionOptionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *ColumnDefinitionOptionContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *ColumnDefinitionOptionContext) START() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTART, 0)
}

func (s *ColumnDefinitionOptionContext) END() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEND, 0)
}

func (s *ColumnDefinitionOptionContext) HIDDEN_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHIDDEN_, 0)
}

func (s *ColumnDefinitionOptionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *ColumnDefinitionOptionContext) ROWGUIDCOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWGUIDCOL, 0)
}

func (s *ColumnDefinitionOptionContext) ENCRYPTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTED, 0)
}

func (s *ColumnDefinitionOptionContext) EncryptedOptions() IEncryptedOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncryptedOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncryptedOptionsContext)
}

func (s *ColumnDefinitionOptionContext) AllColumnConstraint() []IColumnConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnConstraintContext)(nil)).Elem())
	var tst = make([]IColumnConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnConstraintContext)
		}
	}

	return tst
}

func (s *ColumnDefinitionOptionContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnDefinitionOptionContext) ColumnIndex() IColumnIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnIndexContext)
}

func (s *ColumnDefinitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnDefinitionOption(s)
	}
}

func (s *ColumnDefinitionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnDefinitionOption(s)
	}
}

func (s *ColumnDefinitionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnDefinitionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnDefinitionOption() (localctx IColumnDefinitionOptionContext) {
	this := p
	_ = this

	localctx = NewColumnDefinitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, SQLServerStatementParserRULE_columnDefinitionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(2526)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 223, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2473)
			p.Match(SQLServerStatementParserFILESTREAM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2474)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(2475)
			p.CollationName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2476)
			p.Match(SQLServerStatementParserSPARSE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2477)
			p.Match(SQLServerStatementParserMASKED)
		}
		{
			p.SetState(2478)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(2479)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(2480)
			p.Match(SQLServerStatementParserFUNCTION)
		}
		{
			p.SetState(2481)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2482)
			p.Match(SQLServerStatementParserSTRING_)
		}
		{
			p.SetState(2483)
			p.Match(SQLServerStatementParserRP_)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(2486)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserCONSTRAINT {
			{
				p.SetState(2484)
				p.Match(SQLServerStatementParserCONSTRAINT)
			}
			{
				p.SetState(2485)
				p.IgnoredIdentifier()
			}

		}
		{
			p.SetState(2488)
			p.Match(SQLServerStatementParserDEFAULT)
		}
		{
			p.SetState(2489)
			p.expr(0)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2490)
			p.Match(SQLServerStatementParserIDENTITY)
		}
		p.SetState(2496)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(2491)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(2492)
				p.Match(SQLServerStatementParserNUMBER_)
			}
			{
				p.SetState(2493)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(2494)
				p.Match(SQLServerStatementParserNUMBER_)
			}
			{
				p.SetState(2495)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2498)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(2499)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(2500)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2501)
			p.Match(SQLServerStatementParserGENERATED)
		}
		{
			p.SetState(2502)
			p.Match(SQLServerStatementParserALWAYS)
		}
		{
			p.SetState(2503)
			p.Match(SQLServerStatementParserAS)
		}
		{
			p.SetState(2504)
			p.Match(SQLServerStatementParserROW)
		}
		{
			p.SetState(2505)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSTART || _la == SQLServerStatementParserEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2507)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserHIDDEN_ {
			{
				p.SetState(2506)
				p.Match(SQLServerStatementParserHIDDEN_)
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2510)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(2509)
				p.Match(SQLServerStatementParserNOT)
			}

		}
		{
			p.SetState(2512)
			p.Match(SQLServerStatementParserNULL)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2513)
			p.Match(SQLServerStatementParserROWGUIDCOL)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2514)
			p.Match(SQLServerStatementParserENCRYPTED)
		}
		{
			p.SetState(2515)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(2516)
			p.EncryptedOptions()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2517)
			p.ColumnConstraint()
		}
		p.SetState(2522)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2518)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(2519)
					p.ColumnConstraint()
				}

			}
			p.SetState(2524)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 222, p.GetParserRuleContext())
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2525)
			p.ColumnIndex()
		}

	}

	return localctx
}

// IEncryptedOptionsContext is an interface to support dynamic dispatch.
type IEncryptedOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncryptedOptionsContext differentiates from other interfaces.
	IsEncryptedOptionsContext()
}

type EncryptedOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncryptedOptionsContext() *EncryptedOptionsContext {
	var p = new(EncryptedOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_encryptedOptions
	return p
}

func (*EncryptedOptionsContext) IsEncryptedOptionsContext() {}

func NewEncryptedOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncryptedOptionsContext {
	var p = new(EncryptedOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_encryptedOptions

	return p
}

func (s *EncryptedOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *EncryptedOptionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *EncryptedOptionsContext) COLUMN_ENCRYPTION_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, 0)
}

func (s *EncryptedOptionsContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *EncryptedOptionsContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *EncryptedOptionsContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *EncryptedOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *EncryptedOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *EncryptedOptionsContext) ENCRYPTION_TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION_TYPE, 0)
}

func (s *EncryptedOptionsContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALGORITHM, 0)
}

func (s *EncryptedOptionsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *EncryptedOptionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *EncryptedOptionsContext) DETERMINISTIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDETERMINISTIC, 0)
}

func (s *EncryptedOptionsContext) RANDOMIZED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRANDOMIZED, 0)
}

func (s *EncryptedOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptedOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncryptedOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEncryptedOptions(s)
	}
}

func (s *EncryptedOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEncryptedOptions(s)
	}
}

func (s *EncryptedOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEncryptedOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EncryptedOptions() (localctx IEncryptedOptionsContext) {
	this := p
	_ = this

	localctx = NewEncryptedOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, SQLServerStatementParserRULE_encryptedOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2528)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2529)
		p.Match(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY)
	}
	{
		p.SetState(2530)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2531)
		p.IgnoredIdentifier()
	}
	{
		p.SetState(2532)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(2533)
		p.Match(SQLServerStatementParserENCRYPTION_TYPE)
	}
	{
		p.SetState(2534)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2535)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserDETERMINISTIC || _la == SQLServerStatementParserRANDOMIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2536)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(2537)
		p.Match(SQLServerStatementParserALGORITHM)
	}
	{
		p.SetState(2538)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2539)
		p.Match(SQLServerStatementParserSTRING_)
	}
	{
		p.SetState(2540)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IColumnConstraintContext is an interface to support dynamic dispatch.
type IColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnConstraintContext differentiates from other interfaces.
	IsColumnConstraintContext()
}

type ColumnConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintContext() *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnConstraint
	return p
}

func (*ColumnConstraintContext) IsColumnConstraintContext() {}

func NewColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintContext {
	var p = new(ColumnConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnConstraint

	return p
}

func (s *ColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintContext) PrimaryKeyConstraint() IPrimaryKeyConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyConstraintContext)
}

func (s *ColumnConstraintContext) ColumnForeignKeyConstraint() IColumnForeignKeyConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnForeignKeyConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnForeignKeyConstraintContext)
}

func (s *ColumnConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *ColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *ColumnConstraintContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnConstraint(s)
	}
}

func (s *ColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnConstraint() (localctx IColumnConstraintContext) {
	this := p
	_ = this

	localctx = NewColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, SQLServerStatementParserRULE_columnConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2544)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(2542)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}
		{
			p.SetState(2543)
			p.ConstraintName()
		}

	}
	p.SetState(2549)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE, SQLServerStatementParserKEY:
		{
			p.SetState(2546)
			p.PrimaryKeyConstraint()
		}

	case SQLServerStatementParserFOREIGN, SQLServerStatementParserREFERENCES:
		{
			p.SetState(2547)
			p.ColumnForeignKeyConstraint()
		}

	case SQLServerStatementParserCHECK:
		{
			p.SetState(2548)
			p.CheckConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComputedColumnConstraintContext is an interface to support dynamic dispatch.
type IComputedColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputedColumnConstraintContext differentiates from other interfaces.
	IsComputedColumnConstraintContext()
}

type ComputedColumnConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputedColumnConstraintContext() *ComputedColumnConstraintContext {
	var p = new(ComputedColumnConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnConstraint
	return p
}

func (*ComputedColumnConstraintContext) IsComputedColumnConstraintContext() {}

func NewComputedColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnConstraintContext {
	var p = new(ComputedColumnConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnConstraint

	return p
}

func (s *ComputedColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnConstraintContext) PrimaryKeyConstraint() IPrimaryKeyConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyConstraintContext)
}

func (s *ComputedColumnConstraintContext) ComputedColumnForeignKeyConstraint() IComputedColumnForeignKeyConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnForeignKeyConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnForeignKeyConstraintContext)
}

func (s *ComputedColumnConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *ComputedColumnConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *ComputedColumnConstraintContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ComputedColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterComputedColumnConstraint(s)
	}
}

func (s *ComputedColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitComputedColumnConstraint(s)
	}
}

func (s *ComputedColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitComputedColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ComputedColumnConstraint() (localctx IComputedColumnConstraintContext) {
	this := p
	_ = this

	localctx = NewComputedColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, SQLServerStatementParserRULE_computedColumnConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2553)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(2551)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}
		{
			p.SetState(2552)
			p.ConstraintName()
		}

	}
	p.SetState(2558)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE, SQLServerStatementParserKEY:
		{
			p.SetState(2555)
			p.PrimaryKeyConstraint()
		}

	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFOREIGN, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(2556)
			p.ComputedColumnForeignKeyConstraint()
		}

	case SQLServerStatementParserCHECK:
		{
			p.SetState(2557)
			p.CheckConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IComputedColumnForeignKeyConstraintContext is an interface to support dynamic dispatch.
type IComputedColumnForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputedColumnForeignKeyConstraintContext differentiates from other interfaces.
	IsComputedColumnForeignKeyConstraintContext()
}

type ComputedColumnForeignKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputedColumnForeignKeyConstraintContext() *ComputedColumnForeignKeyConstraintContext {
	var p = new(ComputedColumnForeignKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnForeignKeyConstraint
	return p
}

func (*ComputedColumnForeignKeyConstraintContext) IsComputedColumnForeignKeyConstraintContext() {}

func NewComputedColumnForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnForeignKeyConstraintContext {
	var p = new(ComputedColumnForeignKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnForeignKeyConstraint

	return p
}

func (s *ComputedColumnForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnForeignKeyConstraintContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ComputedColumnForeignKeyConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOREIGN, 0)
}

func (s *ComputedColumnForeignKeyConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *ComputedColumnForeignKeyConstraintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ComputedColumnForeignKeyConstraintContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ComputedColumnForeignKeyConstraintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ComputedColumnForeignKeyConstraintContext) AllComputedColumnForeignKeyOnAction() []IComputedColumnForeignKeyOnActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComputedColumnForeignKeyOnActionContext)(nil)).Elem())
	var tst = make([]IComputedColumnForeignKeyOnActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComputedColumnForeignKeyOnActionContext)
		}
	}

	return tst
}

func (s *ComputedColumnForeignKeyConstraintContext) ComputedColumnForeignKeyOnAction(i int) IComputedColumnForeignKeyOnActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnForeignKeyOnActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnForeignKeyOnActionContext)
}

func (s *ComputedColumnForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterComputedColumnForeignKeyConstraint(s)
	}
}

func (s *ComputedColumnForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitComputedColumnForeignKeyConstraint(s)
	}
}

func (s *ComputedColumnForeignKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitComputedColumnForeignKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ComputedColumnForeignKeyConstraint() (localctx IComputedColumnForeignKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewComputedColumnForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, SQLServerStatementParserRULE_computedColumnForeignKeyConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFOREIGN {
		{
			p.SetState(2560)
			p.Match(SQLServerStatementParserFOREIGN)
		}
		{
			p.SetState(2561)
			p.Match(SQLServerStatementParserKEY)
		}

	}
	{
		p.SetState(2564)
		p.TableName()
	}
	p.SetState(2569)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2565)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(2566)
			p.ColumnName()
		}
		{
			p.SetState(2567)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserON || _la == SQLServerStatementParserNOT {
		{
			p.SetState(2571)
			p.ComputedColumnForeignKeyOnAction()
		}

		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComputedColumnForeignKeyOnActionContext is an interface to support dynamic dispatch.
type IComputedColumnForeignKeyOnActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputedColumnForeignKeyOnActionContext differentiates from other interfaces.
	IsComputedColumnForeignKeyOnActionContext()
}

type ComputedColumnForeignKeyOnActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputedColumnForeignKeyOnActionContext() *ComputedColumnForeignKeyOnActionContext {
	var p = new(ComputedColumnForeignKeyOnActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnForeignKeyOnAction
	return p
}

func (*ComputedColumnForeignKeyOnActionContext) IsComputedColumnForeignKeyOnActionContext() {}

func NewComputedColumnForeignKeyOnActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnForeignKeyOnActionContext {
	var p = new(ComputedColumnForeignKeyOnActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnForeignKeyOnAction

	return p
}

func (s *ComputedColumnForeignKeyOnActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnForeignKeyOnActionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETE, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACTION, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCASCADE, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *ComputedColumnForeignKeyOnActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnForeignKeyOnActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnForeignKeyOnActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterComputedColumnForeignKeyOnAction(s)
	}
}

func (s *ComputedColumnForeignKeyOnActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitComputedColumnForeignKeyOnAction(s)
	}
}

func (s *ComputedColumnForeignKeyOnActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitComputedColumnForeignKeyOnAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ComputedColumnForeignKeyOnAction() (localctx IComputedColumnForeignKeyOnActionContext) {
	this := p
	_ = this

	localctx = NewComputedColumnForeignKeyOnActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, SQLServerStatementParserRULE_computedColumnForeignKeyOnAction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2591)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2577)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(2578)
			p.Match(SQLServerStatementParserDELETE)
		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserNO:
			{
				p.SetState(2579)
				p.Match(SQLServerStatementParserNO)
			}
			{
				p.SetState(2580)
				p.Match(SQLServerStatementParserACTION)
			}

		case SQLServerStatementParserCASCADE:
			{
				p.SetState(2581)
				p.Match(SQLServerStatementParserCASCADE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2584)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(2585)
			p.Match(SQLServerStatementParserUPDATE)
		}
		{
			p.SetState(2586)
			p.Match(SQLServerStatementParserNO)
		}
		{
			p.SetState(2587)
			p.Match(SQLServerStatementParserACTION)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2588)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(2589)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(2590)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	}

	return localctx
}

// IPrimaryKeyConstraintContext is an interface to support dynamic dispatch.
type IPrimaryKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyConstraintContext differentiates from other interfaces.
	IsPrimaryKeyConstraintContext()
}

type PrimaryKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyConstraintContext() *PrimaryKeyConstraintContext {
	var p = new(PrimaryKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyConstraint
	return p
}

func (*PrimaryKeyConstraintContext) IsPrimaryKeyConstraintContext() {}

func NewPrimaryKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyConstraintContext {
	var p = new(PrimaryKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyConstraint

	return p
}

func (s *PrimaryKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyConstraintContext) PrimaryKey() IPrimaryKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *PrimaryKeyConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUE, 0)
}

func (s *PrimaryKeyConstraintContext) DiskTablePrimaryKeyConstraintOption() IDiskTablePrimaryKeyConstraintOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiskTablePrimaryKeyConstraintOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiskTablePrimaryKeyConstraintOptionContext)
}

func (s *PrimaryKeyConstraintContext) MemoryTablePrimaryKeyConstraintOption() IMemoryTablePrimaryKeyConstraintOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemoryTablePrimaryKeyConstraintOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemoryTablePrimaryKeyConstraintOptionContext)
}

func (s *PrimaryKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrimaryKeyConstraint(s)
	}
}

func (s *PrimaryKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrimaryKeyConstraint(s)
	}
}

func (s *PrimaryKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrimaryKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrimaryKeyConstraint() (localctx IPrimaryKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, SQLServerStatementParserRULE_primaryKeyConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserKEY:
		{
			p.SetState(2593)
			p.PrimaryKey()
		}

	case SQLServerStatementParserUNIQUE:
		{
			p.SetState(2594)
			p.Match(SQLServerStatementParserUNIQUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 234, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2597)
			p.DiskTablePrimaryKeyConstraintOption()
		}

	case 2:
		{
			p.SetState(2598)
			p.MemoryTablePrimaryKeyConstraintOption()
		}

	}

	return localctx
}

// IDiskTablePrimaryKeyConstraintOptionContext is an interface to support dynamic dispatch.
type IDiskTablePrimaryKeyConstraintOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiskTablePrimaryKeyConstraintOptionContext differentiates from other interfaces.
	IsDiskTablePrimaryKeyConstraintOptionContext()
}

type DiskTablePrimaryKeyConstraintOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiskTablePrimaryKeyConstraintOptionContext() *DiskTablePrimaryKeyConstraintOptionContext {
	var p = new(DiskTablePrimaryKeyConstraintOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_diskTablePrimaryKeyConstraintOption
	return p
}

func (*DiskTablePrimaryKeyConstraintOptionContext) IsDiskTablePrimaryKeyConstraintOptionContext() {}

func NewDiskTablePrimaryKeyConstraintOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiskTablePrimaryKeyConstraintOptionContext {
	var p = new(DiskTablePrimaryKeyConstraintOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_diskTablePrimaryKeyConstraintOption

	return p
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DiskTablePrimaryKeyConstraintOptionContext) ClusterOption() IClusterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterOptionContext)
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) PrimaryKeyWithClause() IPrimaryKeyWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyWithClauseContext)
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) PrimaryKeyOnClause() IPrimaryKeyOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyOnClauseContext)
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDiskTablePrimaryKeyConstraintOption(s)
	}
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDiskTablePrimaryKeyConstraintOption(s)
	}
}

func (s *DiskTablePrimaryKeyConstraintOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDiskTablePrimaryKeyConstraintOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DiskTablePrimaryKeyConstraintOption() (localctx IDiskTablePrimaryKeyConstraintOptionContext) {
	this := p
	_ = this

	localctx = NewDiskTablePrimaryKeyConstraintOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, SQLServerStatementParserRULE_diskTablePrimaryKeyConstraintOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED {
		{
			p.SetState(2601)
			p.ClusterOption()
		}

	}
	p.SetState(2605)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2604)
			p.PrimaryKeyWithClause()
		}

	}
	p.SetState(2608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2607)
			p.PrimaryKeyOnClause()
		}

	}

	return localctx
}

// IClusterOptionContext is an interface to support dynamic dispatch.
type IClusterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClusterOptionContext differentiates from other interfaces.
	IsClusterOptionContext()
}

type ClusterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterOptionContext() *ClusterOptionContext {
	var p = new(ClusterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_clusterOption
	return p
}

func (*ClusterOptionContext) IsClusterOptionContext() {}

func NewClusterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterOptionContext {
	var p = new(ClusterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_clusterOption

	return p
}

func (s *ClusterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterOptionContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLUSTERED, 0)
}

func (s *ClusterOptionContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *ClusterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClusterOption(s)
	}
}

func (s *ClusterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClusterOption(s)
	}
}

func (s *ClusterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClusterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClusterOption() (localctx IClusterOptionContext) {
	this := p
	_ = this

	localctx = NewClusterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, SQLServerStatementParserRULE_clusterOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2610)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimaryKeyWithClauseContext is an interface to support dynamic dispatch.
type IPrimaryKeyWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyWithClauseContext differentiates from other interfaces.
	IsPrimaryKeyWithClauseContext()
}

type PrimaryKeyWithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyWithClauseContext() *PrimaryKeyWithClauseContext {
	var p = new(PrimaryKeyWithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyWithClause
	return p
}

func (*PrimaryKeyWithClauseContext) IsPrimaryKeyWithClauseContext() {}

func NewPrimaryKeyWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyWithClauseContext {
	var p = new(PrimaryKeyWithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyWithClause

	return p
}

func (s *PrimaryKeyWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *PrimaryKeyWithClauseContext) FILLFACTOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILLFACTOR, 0)
}

func (s *PrimaryKeyWithClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *PrimaryKeyWithClauseContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *PrimaryKeyWithClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *PrimaryKeyWithClauseContext) AllIndexOption() []IIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem())
	var tst = make([]IIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexOptionContext)
		}
	}

	return tst
}

func (s *PrimaryKeyWithClauseContext) IndexOption(i int) IIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *PrimaryKeyWithClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *PrimaryKeyWithClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *PrimaryKeyWithClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *PrimaryKeyWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrimaryKeyWithClause(s)
	}
}

func (s *PrimaryKeyWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrimaryKeyWithClause(s)
	}
}

func (s *PrimaryKeyWithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrimaryKeyWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrimaryKeyWithClause() (localctx IPrimaryKeyWithClauseContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, SQLServerStatementParserRULE_primaryKeyWithClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2612)
		p.Match(SQLServerStatementParserWITH)
	}
	p.SetState(2627)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserFILLFACTOR:
		{
			p.SetState(2613)
			p.Match(SQLServerStatementParserFILLFACTOR)
		}
		{
			p.SetState(2614)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2615)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserLP_:
		{
			p.SetState(2616)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(2617)
			p.IndexOption()
		}
		p.SetState(2622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(2618)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(2619)
				p.IndexOption()
			}

			p.SetState(2624)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2625)
			p.Match(SQLServerStatementParserRP_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimaryKeyOnClauseContext is an interface to support dynamic dispatch.
type IPrimaryKeyOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyOnClauseContext differentiates from other interfaces.
	IsPrimaryKeyOnClauseContext()
}

type PrimaryKeyOnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyOnClauseContext() *PrimaryKeyOnClauseContext {
	var p = new(PrimaryKeyOnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyOnClause
	return p
}

func (*PrimaryKeyOnClauseContext) IsPrimaryKeyOnClauseContext() {}

func NewPrimaryKeyOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyOnClauseContext {
	var p = new(PrimaryKeyOnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyOnClause

	return p
}

func (s *PrimaryKeyOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyOnClauseContext) OnSchemaColumn() IOnSchemaColumnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSchemaColumnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSchemaColumnContext)
}

func (s *PrimaryKeyOnClauseContext) OnFileGroup() IOnFileGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnFileGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnFileGroupContext)
}

func (s *PrimaryKeyOnClauseContext) OnString() IOnStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnStringContext)
}

func (s *PrimaryKeyOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrimaryKeyOnClause(s)
	}
}

func (s *PrimaryKeyOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrimaryKeyOnClause(s)
	}
}

func (s *PrimaryKeyOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrimaryKeyOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrimaryKeyOnClause() (localctx IPrimaryKeyOnClauseContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, SQLServerStatementParserRULE_primaryKeyOnClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2632)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2629)
			p.OnSchemaColumn()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2630)
			p.OnFileGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2631)
			p.OnString()
		}

	}

	return localctx
}

// IOnSchemaColumnContext is an interface to support dynamic dispatch.
type IOnSchemaColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnSchemaColumnContext differentiates from other interfaces.
	IsOnSchemaColumnContext()
}

type OnSchemaColumnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnSchemaColumnContext() *OnSchemaColumnContext {
	var p = new(OnSchemaColumnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onSchemaColumn
	return p
}

func (*OnSchemaColumnContext) IsOnSchemaColumnContext() {}

func NewOnSchemaColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnSchemaColumnContext {
	var p = new(OnSchemaColumnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onSchemaColumn

	return p
}

func (s *OnSchemaColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *OnSchemaColumnContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnSchemaColumnContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *OnSchemaColumnContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OnSchemaColumnContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *OnSchemaColumnContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OnSchemaColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnSchemaColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnSchemaColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnSchemaColumn(s)
	}
}

func (s *OnSchemaColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnSchemaColumn(s)
	}
}

func (s *OnSchemaColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnSchemaColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnSchemaColumn() (localctx IOnSchemaColumnContext) {
	this := p
	_ = this

	localctx = NewOnSchemaColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, SQLServerStatementParserRULE_onSchemaColumn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2634)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2635)
		p.SchemaName()
	}
	{
		p.SetState(2636)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2637)
		p.ColumnName()
	}
	{
		p.SetState(2638)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IOnFileGroupContext is an interface to support dynamic dispatch.
type IOnFileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnFileGroupContext differentiates from other interfaces.
	IsOnFileGroupContext()
}

type OnFileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnFileGroupContext() *OnFileGroupContext {
	var p = new(OnFileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onFileGroup
	return p
}

func (*OnFileGroupContext) IsOnFileGroupContext() {}

func NewOnFileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnFileGroupContext {
	var p = new(OnFileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onFileGroup

	return p
}

func (s *OnFileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *OnFileGroupContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnFileGroupContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *OnFileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnFileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnFileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnFileGroup(s)
	}
}

func (s *OnFileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnFileGroup(s)
	}
}

func (s *OnFileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnFileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnFileGroup() (localctx IOnFileGroupContext) {
	this := p
	_ = this

	localctx = NewOnFileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, SQLServerStatementParserRULE_onFileGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2640)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2641)
		p.IgnoredIdentifier()
	}

	return localctx
}

// IOnStringContext is an interface to support dynamic dispatch.
type IOnStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnStringContext differentiates from other interfaces.
	IsOnStringContext()
}

type OnStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnStringContext() *OnStringContext {
	var p = new(OnStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onString
	return p
}

func (*OnStringContext) IsOnStringContext() {}

func NewOnStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnStringContext {
	var p = new(OnStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onString

	return p
}

func (s *OnStringContext) GetParser() antlr.Parser { return s.parser }

func (s *OnStringContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnStringContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *OnStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnString(s)
	}
}

func (s *OnStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnString(s)
	}
}

func (s *OnStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnString() (localctx IOnStringContext) {
	this := p
	_ = this

	localctx = NewOnStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, SQLServerStatementParserRULE_onString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2643)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2644)
		p.Match(SQLServerStatementParserSTRING_)
	}

	return localctx
}

// IMemoryTablePrimaryKeyConstraintOptionContext is an interface to support dynamic dispatch.
type IMemoryTablePrimaryKeyConstraintOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemoryTablePrimaryKeyConstraintOptionContext differentiates from other interfaces.
	IsMemoryTablePrimaryKeyConstraintOptionContext()
}

type MemoryTablePrimaryKeyConstraintOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemoryTablePrimaryKeyConstraintOptionContext() *MemoryTablePrimaryKeyConstraintOptionContext {
	var p = new(MemoryTablePrimaryKeyConstraintOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_memoryTablePrimaryKeyConstraintOption
	return p
}

func (*MemoryTablePrimaryKeyConstraintOptionContext) IsMemoryTablePrimaryKeyConstraintOptionContext() {
}

func NewMemoryTablePrimaryKeyConstraintOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemoryTablePrimaryKeyConstraintOptionContext {
	var p = new(MemoryTablePrimaryKeyConstraintOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_memoryTablePrimaryKeyConstraintOption

	return p
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MemoryTablePrimaryKeyConstraintOptionContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHASH, 0)
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) WithBucket() IWithBucketContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithBucketContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithBucketContext)
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMemoryTablePrimaryKeyConstraintOption(s)
	}
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMemoryTablePrimaryKeyConstraintOption(s)
	}
}

func (s *MemoryTablePrimaryKeyConstraintOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMemoryTablePrimaryKeyConstraintOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MemoryTablePrimaryKeyConstraintOption() (localctx IMemoryTablePrimaryKeyConstraintOptionContext) {
	this := p
	_ = this

	localctx = NewMemoryTablePrimaryKeyConstraintOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, SQLServerStatementParserRULE_memoryTablePrimaryKeyConstraintOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2652)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 242, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2646)
			p.Match(SQLServerStatementParserNONCLUSTERED)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2647)
			p.Match(SQLServerStatementParserNONCLUSTERED)
		}
		{
			p.SetState(2648)
			p.Match(SQLServerStatementParserHASH)
		}
		p.SetState(2650)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2649)
				p.WithBucket()
			}

		}

	}

	return localctx
}

// IWithBucketContext is an interface to support dynamic dispatch.
type IWithBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithBucketContext differentiates from other interfaces.
	IsWithBucketContext()
}

type WithBucketContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithBucketContext() *WithBucketContext {
	var p = new(WithBucketContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withBucket
	return p
}

func (*WithBucketContext) IsWithBucketContext() {}

func NewWithBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithBucketContext {
	var p = new(WithBucketContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withBucket

	return p
}

func (s *WithBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *WithBucketContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithBucketContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *WithBucketContext) BUCKET_COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBUCKET_COUNT, 0)
}

func (s *WithBucketContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *WithBucketContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *WithBucketContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *WithBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithBucket(s)
	}
}

func (s *WithBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithBucket(s)
	}
}

func (s *WithBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithBucket() (localctx IWithBucketContext) {
	this := p
	_ = this

	localctx = NewWithBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, SQLServerStatementParserRULE_withBucket)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2654)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(2655)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2656)
		p.Match(SQLServerStatementParserBUCKET_COUNT)
	}
	{
		p.SetState(2657)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2658)
		p.Match(SQLServerStatementParserNUMBER_)
	}
	{
		p.SetState(2659)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IColumnForeignKeyConstraintContext is an interface to support dynamic dispatch.
type IColumnForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnForeignKeyConstraintContext differentiates from other interfaces.
	IsColumnForeignKeyConstraintContext()
}

type ColumnForeignKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnForeignKeyConstraintContext() *ColumnForeignKeyConstraintContext {
	var p = new(ColumnForeignKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnForeignKeyConstraint
	return p
}

func (*ColumnForeignKeyConstraintContext) IsColumnForeignKeyConstraintContext() {}

func NewColumnForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnForeignKeyConstraintContext {
	var p = new(ColumnForeignKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnForeignKeyConstraint

	return p
}

func (s *ColumnForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnForeignKeyConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREFERENCES, 0)
}

func (s *ColumnForeignKeyConstraintContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ColumnForeignKeyConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOREIGN, 0)
}

func (s *ColumnForeignKeyConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *ColumnForeignKeyConstraintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ColumnForeignKeyConstraintContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnForeignKeyConstraintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ColumnForeignKeyConstraintContext) AllForeignKeyOnAction() []IForeignKeyOnActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForeignKeyOnActionContext)(nil)).Elem())
	var tst = make([]IForeignKeyOnActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForeignKeyOnActionContext)
		}
	}

	return tst
}

func (s *ColumnForeignKeyConstraintContext) ForeignKeyOnAction(i int) IForeignKeyOnActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeignKeyOnActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForeignKeyOnActionContext)
}

func (s *ColumnForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnForeignKeyConstraint(s)
	}
}

func (s *ColumnForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnForeignKeyConstraint(s)
	}
}

func (s *ColumnForeignKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnForeignKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnForeignKeyConstraint() (localctx IColumnForeignKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewColumnForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, SQLServerStatementParserRULE_columnForeignKeyConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2663)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFOREIGN {
		{
			p.SetState(2661)
			p.Match(SQLServerStatementParserFOREIGN)
		}
		{
			p.SetState(2662)
			p.Match(SQLServerStatementParserKEY)
		}

	}
	{
		p.SetState(2665)
		p.Match(SQLServerStatementParserREFERENCES)
	}
	{
		p.SetState(2666)
		p.TableName()
	}
	p.SetState(2671)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2667)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(2668)
			p.ColumnName()
		}
		{
			p.SetState(2669)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	p.SetState(2676)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2673)
				p.ForeignKeyOnAction()
			}

		}
		p.SetState(2678)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 245, p.GetParserRuleContext())
	}

	return localctx
}

// IForeignKeyOnActionContext is an interface to support dynamic dispatch.
type IForeignKeyOnActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeignKeyOnActionContext differentiates from other interfaces.
	IsForeignKeyOnActionContext()
}

type ForeignKeyOnActionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeignKeyOnActionContext() *ForeignKeyOnActionContext {
	var p = new(ForeignKeyOnActionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_foreignKeyOnAction
	return p
}

func (*ForeignKeyOnActionContext) IsForeignKeyOnActionContext() {}

func NewForeignKeyOnActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeignKeyOnActionContext {
	var p = new(ForeignKeyOnActionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_foreignKeyOnAction

	return p
}

func (s *ForeignKeyOnActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeignKeyOnActionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ForeignKeyOnActionContext) ForeignKeyOn() IForeignKeyOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeignKeyOnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForeignKeyOnContext)
}

func (s *ForeignKeyOnActionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETE, 0)
}

func (s *ForeignKeyOnActionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *ForeignKeyOnActionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *ForeignKeyOnActionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *ForeignKeyOnActionContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *ForeignKeyOnActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyOnActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeignKeyOnActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterForeignKeyOnAction(s)
	}
}

func (s *ForeignKeyOnActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitForeignKeyOnAction(s)
	}
}

func (s *ForeignKeyOnActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitForeignKeyOnAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ForeignKeyOnAction() (localctx IForeignKeyOnActionContext) {
	this := p
	_ = this

	localctx = NewForeignKeyOnActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, SQLServerStatementParserRULE_foreignKeyOnAction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2685)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2679)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(2680)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserUPDATE || _la == SQLServerStatementParserDELETE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2681)
			p.ForeignKeyOn()
		}

	case SQLServerStatementParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2682)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(2683)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(2684)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForeignKeyOnContext is an interface to support dynamic dispatch.
type IForeignKeyOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeignKeyOnContext differentiates from other interfaces.
	IsForeignKeyOnContext()
}

type ForeignKeyOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeignKeyOnContext() *ForeignKeyOnContext {
	var p = new(ForeignKeyOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_foreignKeyOn
	return p
}

func (*ForeignKeyOnContext) IsForeignKeyOnContext() {}

func NewForeignKeyOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeignKeyOnContext {
	var p = new(ForeignKeyOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_foreignKeyOn

	return p
}

func (s *ForeignKeyOnContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeignKeyOnContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO, 0)
}

func (s *ForeignKeyOnContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACTION, 0)
}

func (s *ForeignKeyOnContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCASCADE, 0)
}

func (s *ForeignKeyOnContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *ForeignKeyOnContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *ForeignKeyOnContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *ForeignKeyOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeignKeyOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterForeignKeyOn(s)
	}
}

func (s *ForeignKeyOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitForeignKeyOn(s)
	}
}

func (s *ForeignKeyOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitForeignKeyOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ForeignKeyOn() (localctx IForeignKeyOnContext) {
	this := p
	_ = this

	localctx = NewForeignKeyOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, SQLServerStatementParserRULE_foreignKeyOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2692)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNO:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2687)
			p.Match(SQLServerStatementParserNO)
		}
		{
			p.SetState(2688)
			p.Match(SQLServerStatementParserACTION)
		}

	case SQLServerStatementParserCASCADE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2689)
			p.Match(SQLServerStatementParserCASCADE)
		}

	case SQLServerStatementParserSET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2690)
			p.Match(SQLServerStatementParserSET)
		}
		{
			p.SetState(2691)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserNULL || _la == SQLServerStatementParserDEFAULT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICheckConstraintContext is an interface to support dynamic dispatch.
type ICheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckConstraintContext differentiates from other interfaces.
	IsCheckConstraintContext()
}

type CheckConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckConstraintContext() *CheckConstraintContext {
	var p = new(CheckConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_checkConstraint
	return p
}

func (*CheckConstraintContext) IsCheckConstraintContext() {}

func NewCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintContext {
	var p = new(CheckConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_checkConstraint

	return p
}

func (s *CheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *CheckConstraintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CheckConstraintContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckConstraintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CheckConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *CheckConstraintContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *CheckConstraintContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *CheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCheckConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CheckConstraint() (localctx ICheckConstraintContext) {
	this := p
	_ = this

	localctx = NewCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, SQLServerStatementParserRULE_checkConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2694)
		p.Match(SQLServerStatementParserCHECK)
	}
	p.SetState(2698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserNOT {
		{
			p.SetState(2695)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(2696)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(2697)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	}
	{
		p.SetState(2700)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2701)
		p.expr(0)
	}
	{
		p.SetState(2702)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IColumnIndexContext is an interface to support dynamic dispatch.
type IColumnIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnIndexContext differentiates from other interfaces.
	IsColumnIndexContext()
}

type ColumnIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnIndexContext() *ColumnIndexContext {
	var p = new(ColumnIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnIndex
	return p
}

func (*ColumnIndexContext) IsColumnIndexContext() {}

func NewColumnIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnIndexContext {
	var p = new(ColumnIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnIndex

	return p
}

func (s *ColumnIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *ColumnIndexContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *ColumnIndexContext) ClusterOption() IClusterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterOptionContext)
}

func (s *ColumnIndexContext) WithIndexOption() IWithIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithIndexOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithIndexOptionContext)
}

func (s *ColumnIndexContext) IndexOnClause() IIndexOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexOnClauseContext)
}

func (s *ColumnIndexContext) FileStreamOn() IFileStreamOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStreamOnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileStreamOnContext)
}

func (s *ColumnIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnIndex(s)
	}
}

func (s *ColumnIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnIndex(s)
	}
}

func (s *ColumnIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnIndex() (localctx IColumnIndexContext) {
	this := p
	_ = this

	localctx = NewColumnIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, SQLServerStatementParserRULE_columnIndex)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2704)
		p.Match(SQLServerStatementParserINDEX)
	}
	{
		p.SetState(2705)
		p.IndexName()
	}
	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED {
		{
			p.SetState(2706)
			p.ClusterOption()
		}

	}
	p.SetState(2710)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2709)
			p.WithIndexOption()
		}

	}
	p.SetState(2713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2712)
			p.IndexOnClause()
		}

	}
	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFILESTREAM_ON {
		{
			p.SetState(2715)
			p.FileStreamOn()
		}

	}

	return localctx
}

// IWithIndexOptionContext is an interface to support dynamic dispatch.
type IWithIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithIndexOptionContext differentiates from other interfaces.
	IsWithIndexOptionContext()
}

type WithIndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithIndexOptionContext() *WithIndexOptionContext {
	var p = new(WithIndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withIndexOption
	return p
}

func (*WithIndexOptionContext) IsWithIndexOptionContext() {}

func NewWithIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithIndexOptionContext {
	var p = new(WithIndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withIndexOption

	return p
}

func (s *WithIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithIndexOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithIndexOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *WithIndexOptionContext) AllIndexOption() []IIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem())
	var tst = make([]IIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexOptionContext)
		}
	}

	return tst
}

func (s *WithIndexOptionContext) IndexOption(i int) IIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *WithIndexOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *WithIndexOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *WithIndexOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *WithIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithIndexOption(s)
	}
}

func (s *WithIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithIndexOption(s)
	}
}

func (s *WithIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithIndexOption() (localctx IWithIndexOptionContext) {
	this := p
	_ = this

	localctx = NewWithIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, SQLServerStatementParserRULE_withIndexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2718)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(2719)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2720)
		p.IndexOption()
	}
	p.SetState(2725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2721)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2722)
			p.IndexOption()
		}

		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2728)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IIndexOnClauseContext is an interface to support dynamic dispatch.
type IIndexOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexOnClauseContext differentiates from other interfaces.
	IsIndexOnClauseContext()
}

type IndexOnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOnClauseContext() *IndexOnClauseContext {
	var p = new(IndexOnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexOnClause
	return p
}

func (*IndexOnClauseContext) IsIndexOnClauseContext() {}

func NewIndexOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOnClauseContext {
	var p = new(IndexOnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexOnClause

	return p
}

func (s *IndexOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOnClauseContext) OnSchemaColumn() IOnSchemaColumnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnSchemaColumnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnSchemaColumnContext)
}

func (s *IndexOnClauseContext) OnFileGroup() IOnFileGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnFileGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnFileGroupContext)
}

func (s *IndexOnClauseContext) OnDefault() IOnDefaultContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnDefaultContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnDefaultContext)
}

func (s *IndexOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexOnClause(s)
	}
}

func (s *IndexOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexOnClause(s)
	}
}

func (s *IndexOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexOnClause() (localctx IIndexOnClauseContext) {
	this := p
	_ = this

	localctx = NewIndexOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, SQLServerStatementParserRULE_indexOnClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2733)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 254, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2730)
			p.OnSchemaColumn()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2731)
			p.OnFileGroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2732)
			p.OnDefault()
		}

	}

	return localctx
}

// IOnDefaultContext is an interface to support dynamic dispatch.
type IOnDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnDefaultContext differentiates from other interfaces.
	IsOnDefaultContext()
}

type OnDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnDefaultContext() *OnDefaultContext {
	var p = new(OnDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onDefault
	return p
}

func (*OnDefaultContext) IsOnDefaultContext() {}

func NewOnDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnDefaultContext {
	var p = new(OnDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onDefault

	return p
}

func (s *OnDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *OnDefaultContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *OnDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnDefault(s)
	}
}

func (s *OnDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnDefault(s)
	}
}

func (s *OnDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnDefault() (localctx IOnDefaultContext) {
	this := p
	_ = this

	localctx = NewOnDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, SQLServerStatementParserRULE_onDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2735)
		p.Match(SQLServerStatementParserON)
	}
	{
		p.SetState(2736)
		p.Match(SQLServerStatementParserDEFAULT)
	}

	return localctx
}

// IFileStreamOnContext is an interface to support dynamic dispatch.
type IFileStreamOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileStreamOnContext differentiates from other interfaces.
	IsFileStreamOnContext()
}

type FileStreamOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileStreamOnContext() *FileStreamOnContext {
	var p = new(FileStreamOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileStreamOn
	return p
}

func (*FileStreamOnContext) IsFileStreamOnContext() {}

func NewFileStreamOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileStreamOnContext {
	var p = new(FileStreamOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileStreamOn

	return p
}

func (s *FileStreamOnContext) GetParser() antlr.Parser { return s.parser }

func (s *FileStreamOnContext) FILESTREAM_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM_ON, 0)
}

func (s *FileStreamOnContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *FileStreamOnContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *FileStreamOnContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *FileStreamOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileStreamOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileStreamOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileStreamOn(s)
	}
}

func (s *FileStreamOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileStreamOn(s)
	}
}

func (s *FileStreamOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileStreamOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileStreamOn() (localctx IFileStreamOnContext) {
	this := p
	_ = this

	localctx = NewFileStreamOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, SQLServerStatementParserRULE_fileStreamOn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2738)
		p.Match(SQLServerStatementParserFILESTREAM_ON)
	}
	p.SetState(2742)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2739)
			p.IgnoredIdentifier()
		}

	case 2:
		{
			p.SetState(2740)
			p.SchemaName()
		}

	case 3:
		{
			p.SetState(2741)
			p.Match(SQLServerStatementParserSTRING_)
		}

	}

	return localctx
}

// IColumnConstraintsContext is an interface to support dynamic dispatch.
type IColumnConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnConstraintsContext differentiates from other interfaces.
	IsColumnConstraintsContext()
}

type ColumnConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintsContext() *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnConstraints
	return p
}

func (*ColumnConstraintsContext) IsColumnConstraintsContext() {}

func NewColumnConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnConstraints

	return p
}

func (s *ColumnConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintsContext) AllColumnConstraint() []IColumnConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnConstraintContext)(nil)).Elem())
	var tst = make([]IColumnConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnConstraintContext)
		}
	}

	return tst
}

func (s *ColumnConstraintsContext) ColumnConstraint(i int) IColumnConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *ColumnConstraintsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ColumnConstraintsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ColumnConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnConstraints(s)
	}
}

func (s *ColumnConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnConstraints(s)
	}
}

func (s *ColumnConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnConstraints() (localctx IColumnConstraintsContext) {
	this := p
	_ = this

	localctx = NewColumnConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, SQLServerStatementParserRULE_columnConstraints)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2752)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2744)
			p.ColumnConstraint()
		}
		p.SetState(2749)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2745)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(2746)
					p.ColumnConstraint()
				}

			}
			p.SetState(2751)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 256, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IComputedColumnDefinitionContext is an interface to support dynamic dispatch.
type IComputedColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputedColumnDefinitionContext differentiates from other interfaces.
	IsComputedColumnDefinitionContext()
}

type ComputedColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputedColumnDefinitionContext() *ComputedColumnDefinitionContext {
	var p = new(ComputedColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnDefinition
	return p
}

func (*ComputedColumnDefinitionContext) IsComputedColumnDefinitionContext() {}

func NewComputedColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputedColumnDefinitionContext {
	var p = new(ComputedColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_computedColumnDefinition

	return p
}

func (s *ComputedColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputedColumnDefinitionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ComputedColumnDefinitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *ComputedColumnDefinitionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ComputedColumnDefinitionContext) PERSISTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTED, 0)
}

func (s *ComputedColumnDefinitionContext) ComputedColumnConstraint() IComputedColumnConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnConstraintContext)
}

func (s *ComputedColumnDefinitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *ComputedColumnDefinitionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *ComputedColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputedColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputedColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterComputedColumnDefinition(s)
	}
}

func (s *ComputedColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitComputedColumnDefinition(s)
	}
}

func (s *ComputedColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitComputedColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ComputedColumnDefinition() (localctx IComputedColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewComputedColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, SQLServerStatementParserRULE_computedColumnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2754)
		p.ColumnName()
	}
	{
		p.SetState(2755)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(2756)
		p.expr(0)
	}
	p.SetState(2762)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2757)
			p.Match(SQLServerStatementParserPERSISTED)
		}
		p.SetState(2760)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNOT {
			{
				p.SetState(2758)
				p.Match(SQLServerStatementParserNOT)
			}
			{
				p.SetState(2759)
				p.Match(SQLServerStatementParserNULL)
			}

		}

	}
	p.SetState(2765)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 260, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2764)
			p.ComputedColumnConstraint()
		}

	}

	return localctx
}

// IColumnSetDefinitionContext is an interface to support dynamic dispatch.
type IColumnSetDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnSetDefinitionContext differentiates from other interfaces.
	IsColumnSetDefinitionContext()
}

type ColumnSetDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnSetDefinitionContext() *ColumnSetDefinitionContext {
	var p = new(ColumnSetDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_columnSetDefinition
	return p
}

func (*ColumnSetDefinitionContext) IsColumnSetDefinitionContext() {}

func NewColumnSetDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnSetDefinitionContext {
	var p = new(ColumnSetDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_columnSetDefinition

	return p
}

func (s *ColumnSetDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnSetDefinitionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *ColumnSetDefinitionContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *ColumnSetDefinitionContext) COLUMN_SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN_SET, 0)
}

func (s *ColumnSetDefinitionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *ColumnSetDefinitionContext) ALL_SPARSE_COLUMNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL_SPARSE_COLUMNS, 0)
}

func (s *ColumnSetDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnSetDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnSetDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterColumnSetDefinition(s)
	}
}

func (s *ColumnSetDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitColumnSetDefinition(s)
	}
}

func (s *ColumnSetDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitColumnSetDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ColumnSetDefinition() (localctx IColumnSetDefinitionContext) {
	this := p
	_ = this

	localctx = NewColumnSetDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, SQLServerStatementParserRULE_columnSetDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2767)
		p.IgnoredIdentifier()
	}
	{
		p.SetState(2768)
		p.Match(SQLServerStatementParserIDENTIFIER_)
	}
	{
		p.SetState(2769)
		p.Match(SQLServerStatementParserCOLUMN_SET)
	}
	{
		p.SetState(2770)
		p.Match(SQLServerStatementParserFOR)
	}
	{
		p.SetState(2771)
		p.Match(SQLServerStatementParserALL_SPARSE_COLUMNS)
	}

	return localctx
}

// ITableConstraintContext is an interface to support dynamic dispatch.
type ITableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableConstraintContext differentiates from other interfaces.
	IsTableConstraintContext()
}

type TableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableConstraintContext() *TableConstraintContext {
	var p = new(TableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableConstraint
	return p
}

func (*TableConstraintContext) IsTableConstraintContext() {}

func NewTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintContext {
	var p = new(TableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableConstraint

	return p
}

func (s *TableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintContext) TablePrimaryConstraint() ITablePrimaryConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePrimaryConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePrimaryConstraintContext)
}

func (s *TableConstraintContext) TableForeignKeyConstraint() ITableForeignKeyConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableForeignKeyConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableForeignKeyConstraintContext)
}

func (s *TableConstraintContext) CheckConstraint() ICheckConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *TableConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *TableConstraintContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *TableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableConstraint(s)
	}
}

func (s *TableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableConstraint(s)
	}
}

func (s *TableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableConstraint() (localctx ITableConstraintContext) {
	this := p
	_ = this

	localctx = NewTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, SQLServerStatementParserRULE_tableConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(2773)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}
		{
			p.SetState(2774)
			p.ConstraintName()
		}

	}
	p.SetState(2780)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE, SQLServerStatementParserKEY:
		{
			p.SetState(2777)
			p.TablePrimaryConstraint()
		}

	case SQLServerStatementParserLP_, SQLServerStatementParserFOREIGN:
		{
			p.SetState(2778)
			p.TableForeignKeyConstraint()
		}

	case SQLServerStatementParserCHECK:
		{
			p.SetState(2779)
			p.CheckConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITablePrimaryConstraintContext is an interface to support dynamic dispatch.
type ITablePrimaryConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePrimaryConstraintContext differentiates from other interfaces.
	IsTablePrimaryConstraintContext()
}

type TablePrimaryConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePrimaryConstraintContext() *TablePrimaryConstraintContext {
	var p = new(TablePrimaryConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tablePrimaryConstraint
	return p
}

func (*TablePrimaryConstraintContext) IsTablePrimaryConstraintContext() {}

func NewTablePrimaryConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePrimaryConstraintContext {
	var p = new(TablePrimaryConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tablePrimaryConstraint

	return p
}

func (s *TablePrimaryConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePrimaryConstraintContext) PrimaryKeyUnique() IPrimaryKeyUniqueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyUniqueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyUniqueContext)
}

func (s *TablePrimaryConstraintContext) DiskTablePrimaryConstraintOption() IDiskTablePrimaryConstraintOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDiskTablePrimaryConstraintOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDiskTablePrimaryConstraintOptionContext)
}

func (s *TablePrimaryConstraintContext) MemoryTablePrimaryConstraintOption() IMemoryTablePrimaryConstraintOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemoryTablePrimaryConstraintOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemoryTablePrimaryConstraintOptionContext)
}

func (s *TablePrimaryConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePrimaryConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePrimaryConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTablePrimaryConstraint(s)
	}
}

func (s *TablePrimaryConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTablePrimaryConstraint(s)
	}
}

func (s *TablePrimaryConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTablePrimaryConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TablePrimaryConstraint() (localctx ITablePrimaryConstraintContext) {
	this := p
	_ = this

	localctx = NewTablePrimaryConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, SQLServerStatementParserRULE_tablePrimaryConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2782)
		p.PrimaryKeyUnique()
	}
	p.SetState(2785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 263, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2783)
			p.DiskTablePrimaryConstraintOption()
		}

	case 2:
		{
			p.SetState(2784)
			p.MemoryTablePrimaryConstraintOption()
		}

	}

	return localctx
}

// IPrimaryKeyUniqueContext is an interface to support dynamic dispatch.
type IPrimaryKeyUniqueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyUniqueContext differentiates from other interfaces.
	IsPrimaryKeyUniqueContext()
}

type PrimaryKeyUniqueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyUniqueContext() *PrimaryKeyUniqueContext {
	var p = new(PrimaryKeyUniqueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyUnique
	return p
}

func (*PrimaryKeyUniqueContext) IsPrimaryKeyUniqueContext() {}

func NewPrimaryKeyUniqueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyUniqueContext {
	var p = new(PrimaryKeyUniqueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_primaryKeyUnique

	return p
}

func (s *PrimaryKeyUniqueContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyUniqueContext) PrimaryKey() IPrimaryKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *PrimaryKeyUniqueContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUE, 0)
}

func (s *PrimaryKeyUniqueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyUniqueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyUniqueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrimaryKeyUnique(s)
	}
}

func (s *PrimaryKeyUniqueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrimaryKeyUnique(s)
	}
}

func (s *PrimaryKeyUniqueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrimaryKeyUnique(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrimaryKeyUnique() (localctx IPrimaryKeyUniqueContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyUniqueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, SQLServerStatementParserRULE_primaryKeyUnique)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2789)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserKEY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2787)
			p.PrimaryKey()
		}

	case SQLServerStatementParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2788)
			p.Match(SQLServerStatementParserUNIQUE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDiskTablePrimaryConstraintOptionContext is an interface to support dynamic dispatch.
type IDiskTablePrimaryConstraintOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiskTablePrimaryConstraintOptionContext differentiates from other interfaces.
	IsDiskTablePrimaryConstraintOptionContext()
}

type DiskTablePrimaryConstraintOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiskTablePrimaryConstraintOptionContext() *DiskTablePrimaryConstraintOptionContext {
	var p = new(DiskTablePrimaryConstraintOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_diskTablePrimaryConstraintOption
	return p
}

func (*DiskTablePrimaryConstraintOptionContext) IsDiskTablePrimaryConstraintOptionContext() {}

func NewDiskTablePrimaryConstraintOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiskTablePrimaryConstraintOptionContext {
	var p = new(DiskTablePrimaryConstraintOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_diskTablePrimaryConstraintOption

	return p
}

func (s *DiskTablePrimaryConstraintOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DiskTablePrimaryConstraintOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *DiskTablePrimaryConstraintOptionContext) ClusterOption() IClusterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterOptionContext)
}

func (s *DiskTablePrimaryConstraintOptionContext) PrimaryKeyWithClause() IPrimaryKeyWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyWithClauseContext)
}

func (s *DiskTablePrimaryConstraintOptionContext) PrimaryKeyOnClause() IPrimaryKeyOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyOnClauseContext)
}

func (s *DiskTablePrimaryConstraintOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiskTablePrimaryConstraintOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiskTablePrimaryConstraintOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDiskTablePrimaryConstraintOption(s)
	}
}

func (s *DiskTablePrimaryConstraintOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDiskTablePrimaryConstraintOption(s)
	}
}

func (s *DiskTablePrimaryConstraintOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDiskTablePrimaryConstraintOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DiskTablePrimaryConstraintOption() (localctx IDiskTablePrimaryConstraintOptionContext) {
	this := p
	_ = this

	localctx = NewDiskTablePrimaryConstraintOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, SQLServerStatementParserRULE_diskTablePrimaryConstraintOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2792)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED {
		{
			p.SetState(2791)
			p.ClusterOption()
		}

	}
	{
		p.SetState(2794)
		p.ColumnNames()
	}
	p.SetState(2796)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2795)
			p.PrimaryKeyWithClause()
		}

	}
	p.SetState(2799)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2798)
			p.PrimaryKeyOnClause()
		}

	}

	return localctx
}

// IMemoryTablePrimaryConstraintOptionContext is an interface to support dynamic dispatch.
type IMemoryTablePrimaryConstraintOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemoryTablePrimaryConstraintOptionContext differentiates from other interfaces.
	IsMemoryTablePrimaryConstraintOptionContext()
}

type MemoryTablePrimaryConstraintOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemoryTablePrimaryConstraintOptionContext() *MemoryTablePrimaryConstraintOptionContext {
	var p = new(MemoryTablePrimaryConstraintOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_memoryTablePrimaryConstraintOption
	return p
}

func (*MemoryTablePrimaryConstraintOptionContext) IsMemoryTablePrimaryConstraintOptionContext() {}

func NewMemoryTablePrimaryConstraintOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemoryTablePrimaryConstraintOptionContext {
	var p = new(MemoryTablePrimaryConstraintOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_memoryTablePrimaryConstraintOption

	return p
}

func (s *MemoryTablePrimaryConstraintOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MemoryTablePrimaryConstraintOptionContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *MemoryTablePrimaryConstraintOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *MemoryTablePrimaryConstraintOptionContext) HashWithBucket() IHashWithBucketContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHashWithBucketContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHashWithBucketContext)
}

func (s *MemoryTablePrimaryConstraintOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemoryTablePrimaryConstraintOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemoryTablePrimaryConstraintOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMemoryTablePrimaryConstraintOption(s)
	}
}

func (s *MemoryTablePrimaryConstraintOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMemoryTablePrimaryConstraintOption(s)
	}
}

func (s *MemoryTablePrimaryConstraintOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMemoryTablePrimaryConstraintOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MemoryTablePrimaryConstraintOption() (localctx IMemoryTablePrimaryConstraintOptionContext) {
	this := p
	_ = this

	localctx = NewMemoryTablePrimaryConstraintOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, SQLServerStatementParserRULE_memoryTablePrimaryConstraintOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2801)
		p.Match(SQLServerStatementParserNONCLUSTERED)
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserLP_:
		{
			p.SetState(2802)
			p.ColumnNames()
		}

	case SQLServerStatementParserHASH:
		{
			p.SetState(2803)
			p.HashWithBucket()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHashWithBucketContext is an interface to support dynamic dispatch.
type IHashWithBucketContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHashWithBucketContext differentiates from other interfaces.
	IsHashWithBucketContext()
}

type HashWithBucketContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHashWithBucketContext() *HashWithBucketContext {
	var p = new(HashWithBucketContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_hashWithBucket
	return p
}

func (*HashWithBucketContext) IsHashWithBucketContext() {}

func NewHashWithBucketContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HashWithBucketContext {
	var p = new(HashWithBucketContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_hashWithBucket

	return p
}

func (s *HashWithBucketContext) GetParser() antlr.Parser { return s.parser }

func (s *HashWithBucketContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHASH, 0)
}

func (s *HashWithBucketContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *HashWithBucketContext) WithBucket() IWithBucketContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithBucketContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithBucketContext)
}

func (s *HashWithBucketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashWithBucketContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HashWithBucketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterHashWithBucket(s)
	}
}

func (s *HashWithBucketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitHashWithBucket(s)
	}
}

func (s *HashWithBucketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitHashWithBucket(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) HashWithBucket() (localctx IHashWithBucketContext) {
	this := p
	_ = this

	localctx = NewHashWithBucketContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, SQLServerStatementParserRULE_hashWithBucket)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2806)
		p.Match(SQLServerStatementParserHASH)
	}
	{
		p.SetState(2807)
		p.ColumnNames()
	}
	{
		p.SetState(2808)
		p.WithBucket()
	}

	return localctx
}

// ITableForeignKeyConstraintContext is an interface to support dynamic dispatch.
type ITableForeignKeyConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableForeignKeyConstraintContext differentiates from other interfaces.
	IsTableForeignKeyConstraintContext()
}

type TableForeignKeyConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableForeignKeyConstraintContext() *TableForeignKeyConstraintContext {
	var p = new(TableForeignKeyConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableForeignKeyConstraint
	return p
}

func (*TableForeignKeyConstraintContext) IsTableForeignKeyConstraintContext() {}

func NewTableForeignKeyConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableForeignKeyConstraintContext {
	var p = new(TableForeignKeyConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableForeignKeyConstraint

	return p
}

func (s *TableForeignKeyConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *TableForeignKeyConstraintContext) AllColumnNames() []IColumnNamesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem())
	var tst = make([]IColumnNamesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNamesContext)
		}
	}

	return tst
}

func (s *TableForeignKeyConstraintContext) ColumnNames(i int) IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *TableForeignKeyConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREFERENCES, 0)
}

func (s *TableForeignKeyConstraintContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableForeignKeyConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOREIGN, 0)
}

func (s *TableForeignKeyConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *TableForeignKeyConstraintContext) AllForeignKeyOnAction() []IForeignKeyOnActionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForeignKeyOnActionContext)(nil)).Elem())
	var tst = make([]IForeignKeyOnActionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForeignKeyOnActionContext)
		}
	}

	return tst
}

func (s *TableForeignKeyConstraintContext) ForeignKeyOnAction(i int) IForeignKeyOnActionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeignKeyOnActionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForeignKeyOnActionContext)
}

func (s *TableForeignKeyConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableForeignKeyConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableForeignKeyConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableForeignKeyConstraint(s)
	}
}

func (s *TableForeignKeyConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableForeignKeyConstraint(s)
	}
}

func (s *TableForeignKeyConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableForeignKeyConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableForeignKeyConstraint() (localctx ITableForeignKeyConstraintContext) {
	this := p
	_ = this

	localctx = NewTableForeignKeyConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, SQLServerStatementParserRULE_tableForeignKeyConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFOREIGN {
		{
			p.SetState(2810)
			p.Match(SQLServerStatementParserFOREIGN)
		}
		{
			p.SetState(2811)
			p.Match(SQLServerStatementParserKEY)
		}

	}
	{
		p.SetState(2814)
		p.ColumnNames()
	}
	{
		p.SetState(2815)
		p.Match(SQLServerStatementParserREFERENCES)
	}
	{
		p.SetState(2816)
		p.TableName()
	}
	{
		p.SetState(2817)
		p.ColumnNames()
	}
	p.SetState(2821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserON || _la == SQLServerStatementParserNOT {
		{
			p.SetState(2818)
			p.ForeignKeyOnAction()
		}

		p.SetState(2823)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableIndexContext is an interface to support dynamic dispatch.
type ITableIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableIndexContext differentiates from other interfaces.
	IsTableIndexContext()
}

type TableIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableIndexContext() *TableIndexContext {
	var p = new(TableIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableIndex
	return p
}

func (*TableIndexContext) IsTableIndexContext() {}

func NewTableIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableIndexContext {
	var p = new(TableIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableIndex

	return p
}

func (s *TableIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *TableIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *TableIndexContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *TableIndexContext) IndexNameOption() IIndexNameOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameOptionContext)
}

func (s *TableIndexContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *TableIndexContext) IndexOptions() IIndexOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexOptionsContext)
}

func (s *TableIndexContext) IndexOnClause() IIndexOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexOnClauseContext)
}

func (s *TableIndexContext) FileStreamOn() IFileStreamOnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStreamOnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileStreamOnContext)
}

func (s *TableIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableIndex(s)
	}
}

func (s *TableIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableIndex(s)
	}
}

func (s *TableIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableIndex() (localctx ITableIndexContext) {
	this := p
	_ = this

	localctx = NewTableIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, SQLServerStatementParserRULE_tableIndex)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2824)
		p.Match(SQLServerStatementParserINDEX)
	}
	{
		p.SetState(2825)
		p.IndexName()
	}
	{
		p.SetState(2826)
		p.IndexNameOption()
	}
	p.SetState(2829)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(2827)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(2828)
			p.IndexOptions()
		}

	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2831)
			p.IndexOnClause()
		}

	}
	p.SetState(2835)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFILESTREAM_ON {
		{
			p.SetState(2834)
			p.FileStreamOn()
		}

	}

	return localctx
}

// IIndexNameOptionContext is an interface to support dynamic dispatch.
type IIndexNameOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNameOptionContext differentiates from other interfaces.
	IsIndexNameOptionContext()
}

type IndexNameOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameOptionContext() *IndexNameOptionContext {
	var p = new(IndexNameOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexNameOption
	return p
}

func (*IndexNameOptionContext) IsIndexNameOptionContext() {}

func NewIndexNameOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameOptionContext {
	var p = new(IndexNameOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexNameOption

	return p
}

func (s *IndexNameOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *IndexNameOptionContext) ClusterOption() IClusterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterOptionContext)
}

func (s *IndexNameOptionContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLUSTERED, 0)
}

func (s *IndexNameOptionContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *IndexNameOptionContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *IndexNameOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexNameOption(s)
	}
}

func (s *IndexNameOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexNameOption(s)
	}
}

func (s *IndexNameOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexNameOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexNameOption() (localctx IIndexNameOptionContext) {
	this := p
	_ = this

	localctx = NewIndexNameOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, SQLServerStatementParserRULE_indexNameOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2848)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 276, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2838)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED {
			{
				p.SetState(2837)
				p.ClusterOption()
			}

		}
		{
			p.SetState(2840)
			p.ColumnNames()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2841)
			p.Match(SQLServerStatementParserCLUSTERED)
		}
		{
			p.SetState(2842)
			p.Match(SQLServerStatementParserCOLUMNSTORE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNONCLUSTERED {
			{
				p.SetState(2843)
				p.Match(SQLServerStatementParserNONCLUSTERED)
			}

		}
		{
			p.SetState(2846)
			p.Match(SQLServerStatementParserCOLUMNSTORE)
		}
		{
			p.SetState(2847)
			p.ColumnNames()
		}

	}

	return localctx
}

// IIndexOptionsContext is an interface to support dynamic dispatch.
type IIndexOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexOptionsContext differentiates from other interfaces.
	IsIndexOptionsContext()
}

type IndexOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionsContext() *IndexOptionsContext {
	var p = new(IndexOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexOptions
	return p
}

func (*IndexOptionsContext) IsIndexOptionsContext() {}

func NewIndexOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionsContext {
	var p = new(IndexOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexOptions

	return p
}

func (s *IndexOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *IndexOptionsContext) AllIndexOption() []IIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem())
	var tst = make([]IIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexOptionContext)
		}
	}

	return tst
}

func (s *IndexOptionsContext) IndexOption(i int) IIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *IndexOptionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *IndexOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *IndexOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *IndexOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexOptions(s)
	}
}

func (s *IndexOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexOptions(s)
	}
}

func (s *IndexOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexOptions() (localctx IIndexOptionsContext) {
	this := p
	_ = this

	localctx = NewIndexOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, SQLServerStatementParserRULE_indexOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2850)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2851)
		p.IndexOption()
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2852)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2853)
			p.IndexOption()
		}

		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2859)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IPeriodClauseContext is an interface to support dynamic dispatch.
type IPeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPeriodClauseContext differentiates from other interfaces.
	IsPeriodClauseContext()
}

type PeriodClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodClauseContext() *PeriodClauseContext {
	var p = new(PeriodClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_periodClause
	return p
}

func (*PeriodClauseContext) IsPeriodClauseContext() {}

func NewPeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodClauseContext {
	var p = new(PeriodClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_periodClause

	return p
}

func (s *PeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodClauseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERIOD, 0)
}

func (s *PeriodClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *PeriodClauseContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_TIME, 0)
}

func (s *PeriodClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *PeriodClauseContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *PeriodClauseContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *PeriodClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *PeriodClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *PeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPeriodClause(s)
	}
}

func (s *PeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPeriodClause(s)
	}
}

func (s *PeriodClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPeriodClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PeriodClause() (localctx IPeriodClauseContext) {
	this := p
	_ = this

	localctx = NewPeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, SQLServerStatementParserRULE_periodClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2861)
		p.Match(SQLServerStatementParserPERIOD)
	}
	{
		p.SetState(2862)
		p.Match(SQLServerStatementParserFOR)
	}
	{
		p.SetState(2863)
		p.Match(SQLServerStatementParserSYSTEM_TIME)
	}
	{
		p.SetState(2864)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2865)
		p.ColumnName()
	}
	{
		p.SetState(2866)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(2867)
		p.ColumnName()
	}
	{
		p.SetState(2868)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IPartitionSchemeContext is an interface to support dynamic dispatch.
type IPartitionSchemeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionSchemeContext differentiates from other interfaces.
	IsPartitionSchemeContext()
}

type PartitionSchemeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionSchemeContext() *PartitionSchemeContext {
	var p = new(PartitionSchemeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_partitionScheme
	return p
}

func (*PartitionSchemeContext) IsPartitionSchemeContext() {}

func NewPartitionSchemeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSchemeContext {
	var p = new(PartitionSchemeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_partitionScheme

	return p
}

func (s *PartitionSchemeContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSchemeContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *PartitionSchemeContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *PartitionSchemeContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *PartitionSchemeContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *PartitionSchemeContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *PartitionSchemeContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *PartitionSchemeContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *PartitionSchemeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSchemeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSchemeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPartitionScheme(s)
	}
}

func (s *PartitionSchemeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPartitionScheme(s)
	}
}

func (s *PartitionSchemeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPartitionScheme(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PartitionScheme() (localctx IPartitionSchemeContext) {
	this := p
	_ = this

	localctx = NewPartitionSchemeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, SQLServerStatementParserRULE_partitionScheme)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(2870)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(2878)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 278, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2871)
				p.SchemaName()
			}
			{
				p.SetState(2872)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(2873)
				p.ColumnName()
			}
			{
				p.SetState(2874)
				p.Match(SQLServerStatementParserRP_)
			}

		case 2:
			{
				p.SetState(2876)
				p.IgnoredIdentifier()
			}

		case 3:
			{
				p.SetState(2877)
				p.Match(SQLServerStatementParserSTRING_)
			}

		}

	}

	return localctx
}

// IFileGroupContext is an interface to support dynamic dispatch.
type IFileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileGroupContext differentiates from other interfaces.
	IsFileGroupContext()
}

type FileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileGroupContext() *FileGroupContext {
	var p = new(FileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileGroup
	return p
}

func (*FileGroupContext) IsFileGroupContext() {}

func NewFileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileGroupContext {
	var p = new(FileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileGroup

	return p
}

func (s *FileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *FileGroupContext) TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTEXTIMAGE_ON, 0)
}

func (s *FileGroupContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *FileGroupContext) TableOptions() ITableOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *FileGroupContext) AllIgnoredIdentifier() []IIgnoredIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem())
	var tst = make([]IIgnoredIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIgnoredIdentifierContext)
		}
	}

	return tst
}

func (s *FileGroupContext) IgnoredIdentifier(i int) IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *FileGroupContext) AllSTRING_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserSTRING_)
}

func (s *FileGroupContext) STRING_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, i)
}

func (s *FileGroupContext) FILESTREAM_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM_ON, 0)
}

func (s *FileGroupContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *FileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileGroup(s)
	}
}

func (s *FileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileGroup(s)
	}
}

func (s *FileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileGroup() (localctx IFileGroupContext) {
	this := p
	_ = this

	localctx = NewFileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, SQLServerStatementParserRULE_fileGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserTEXTIMAGE_ON {
		{
			p.SetState(2882)
			p.Match(SQLServerStatementParserTEXTIMAGE_ON)
		}
		p.SetState(2885)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(2883)
				p.IgnoredIdentifier()
			}

		case SQLServerStatementParserSTRING_:
			{
				p.SetState(2884)
				p.Match(SQLServerStatementParserSTRING_)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFILESTREAM_ON || _la == SQLServerStatementParserIDENTIFIER_ {
		p.SetState(2894)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserFILESTREAM_ON:
			{
				p.SetState(2889)
				p.Match(SQLServerStatementParserFILESTREAM_ON)
			}

			{
				p.SetState(2890)
				p.SchemaName()
			}

		case SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(2891)
				p.IgnoredIdentifier()
			}
			{
				p.SetState(2892)
				p.Match(SQLServerStatementParserSTRING_)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(2900)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2898)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(2899)
			p.TableOptions()
		}

	}

	return localctx
}

// ITableOptionsContext is an interface to support dynamic dispatch.
type ITableOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableOptionsContext differentiates from other interfaces.
	IsTableOptionsContext()
}

type TableOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionsContext() *TableOptionsContext {
	var p = new(TableOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableOptions
	return p
}

func (*TableOptionsContext) IsTableOptionsContext() {}

func NewTableOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionsContext {
	var p = new(TableOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableOptions

	return p
}

func (s *TableOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *TableOptionsContext) AllTableOption() []ITableOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableOptionContext)(nil)).Elem())
	var tst = make([]ITableOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableOptionContext)
		}
	}

	return tst
}

func (s *TableOptionsContext) TableOption(i int) ITableOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *TableOptionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *TableOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *TableOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *TableOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableOptions(s)
	}
}

func (s *TableOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableOptions(s)
	}
}

func (s *TableOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableOptions() (localctx ITableOptionsContext) {
	this := p
	_ = this

	localctx = NewTableOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, SQLServerStatementParserRULE_tableOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2902)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2903)
		p.TableOption()
	}
	p.SetState(2908)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2904)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2905)
			p.TableOption()
		}

		p.SetState(2910)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2911)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ITableOptionContext is an interface to support dynamic dispatch.
type ITableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableOptionContext differentiates from other interfaces.
	IsTableOptionContext()
}

type TableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionContext() *TableOptionContext {
	var p = new(TableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableOption
	return p
}

func (*TableOptionContext) IsTableOptionContext() {}

func NewTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionContext {
	var p = new(TableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableOption

	return p
}

func (s *TableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionContext) DATA_COMPRESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_COMPRESSION, 0)
}

func (s *TableOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *TableOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *TableOptionContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *TableOptionContext) PAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE, 0)
}

func (s *TableOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *TableOptionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITIONS, 0)
}

func (s *TableOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *TableOptionContext) PartitionExpressions() IPartitionExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionExpressionsContext)
}

func (s *TableOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *TableOptionContext) FILETABLE_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_DIRECTORY, 0)
}

func (s *TableOptionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *TableOptionContext) FILETABLE_COLLATE_FILENAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_COLLATE_FILENAME, 0)
}

func (s *TableOptionContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *TableOptionContext) DATABASE_DEAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE_DEAULT, 0)
}

func (s *TableOptionContext) FILETABLE_PRIMARY_KEY_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, 0)
}

func (s *TableOptionContext) FILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, 0)
}

func (s *TableOptionContext) FILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, 0)
}

func (s *TableOptionContext) SYSTEM_VERSIONING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_VERSIONING, 0)
}

func (s *TableOptionContext) OnHistoryTableClause() IOnHistoryTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnHistoryTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnHistoryTableClauseContext)
}

func (s *TableOptionContext) REMOTE_DATA_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE_DATA_ARCHIVE, 0)
}

func (s *TableOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *TableOptionContext) MigrationState_() IMigrationState_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMigrationState_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMigrationState_Context)
}

func (s *TableOptionContext) TableStretchOptions() ITableStretchOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableStretchOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableStretchOptionsContext)
}

func (s *TableOptionContext) TableOperationOption() ITableOperationOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableOperationOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableOperationOptionContext)
}

func (s *TableOptionContext) DistributionOption() IDistributionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistributionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistributionOptionContext)
}

func (s *TableOptionContext) DataWareHouseTableOption() IDataWareHouseTableOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataWareHouseTableOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataWareHouseTableOptionContext)
}

func (s *TableOptionContext) DataDelectionOption() IDataDelectionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataDelectionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataDelectionOptionContext)
}

func (s *TableOptionContext) DataWareHousePartitionOption() IDataWareHousePartitionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataWareHousePartitionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataWareHousePartitionOptionContext)
}

func (s *TableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableOption(s)
	}
}

func (s *TableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableOption(s)
	}
}

func (s *TableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableOption() (localctx ITableOptionContext) {
	this := p
	_ = this

	localctx = NewTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, SQLServerStatementParserRULE_tableOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2963)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 291, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2913)
			p.Match(SQLServerStatementParserDATA_COMPRESSION)
		}
		{
			p.SetState(2914)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2915)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserROW || _la == SQLServerStatementParserNONE || _la == SQLServerStatementParserPAGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserON {
			{
				p.SetState(2916)
				p.Match(SQLServerStatementParserON)
			}
			{
				p.SetState(2917)
				p.Match(SQLServerStatementParserPARTITIONS)
			}
			{
				p.SetState(2918)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(2919)
				p.PartitionExpressions()
			}
			{
				p.SetState(2920)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2924)
			p.Match(SQLServerStatementParserFILETABLE_DIRECTORY)
		}
		{
			p.SetState(2925)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2926)
			p.IgnoredIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2927)
			p.Match(SQLServerStatementParserFILETABLE_COLLATE_FILENAME)
		}
		{
			p.SetState(2928)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(2931)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_:
			{
				p.SetState(2929)
				p.CollationName()
			}

		case SQLServerStatementParserDATABASE_DEAULT:
			{
				p.SetState(2930)
				p.Match(SQLServerStatementParserDATABASE_DEAULT)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2933)
			p.Match(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME)
		}
		{
			p.SetState(2934)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2935)
			p.IgnoredIdentifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2936)
			p.Match(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME)
		}
		{
			p.SetState(2937)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2938)
			p.IgnoredIdentifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2939)
			p.Match(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME)
		}
		{
			p.SetState(2940)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2941)
			p.IgnoredIdentifier()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2942)
			p.Match(SQLServerStatementParserSYSTEM_VERSIONING)
		}
		{
			p.SetState(2943)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(2944)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(2946)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(2945)
				p.OnHistoryTableClause()
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2948)
			p.Match(SQLServerStatementParserREMOTE_DATA_ARCHIVE)
		}
		{
			p.SetState(2949)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserON:
			{
				p.SetState(2950)
				p.Match(SQLServerStatementParserON)
			}
			p.SetState(2952)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserLP_ {
				{
					p.SetState(2951)
					p.TableStretchOptions()
				}

			}

		case SQLServerStatementParserOFF:
			{
				p.SetState(2954)
				p.Match(SQLServerStatementParserOFF)
			}
			{
				p.SetState(2955)
				p.MigrationState_()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2958)
			p.TableOperationOption()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2959)
			p.DistributionOption()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2960)
			p.DataWareHouseTableOption()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2961)
			p.DataDelectionOption()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2962)
			p.DataWareHousePartitionOption()
		}

	}

	return localctx
}

// IDataDelectionOptionContext is an interface to support dynamic dispatch.
type IDataDelectionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDelectionOptionContext differentiates from other interfaces.
	IsDataDelectionOptionContext()
}

type DataDelectionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDelectionOptionContext() *DataDelectionOptionContext {
	var p = new(DataDelectionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataDelectionOption
	return p
}

func (*DataDelectionOptionContext) IsDataDelectionOptionContext() {}

func NewDataDelectionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDelectionOptionContext {
	var p = new(DataDelectionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataDelectionOption

	return p
}

func (s *DataDelectionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDelectionOptionContext) DATA_DELETION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_DELETION, 0)
}

func (s *DataDelectionOptionContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *DataDelectionOptionContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *DataDelectionOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *DataDelectionOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DataDelectionOptionContext) FILTER_COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILTER_COLUMN, 0)
}

func (s *DataDelectionOptionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DataDelectionOptionContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *DataDelectionOptionContext) RETENTION_PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETENTION_PERIOD, 0)
}

func (s *DataDelectionOptionContext) HistoryRetentionPeriod() IHistoryRetentionPeriodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHistoryRetentionPeriodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHistoryRetentionPeriodContext)
}

func (s *DataDelectionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDelectionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDelectionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataDelectionOption(s)
	}
}

func (s *DataDelectionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataDelectionOption(s)
	}
}

func (s *DataDelectionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataDelectionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataDelectionOption() (localctx IDataDelectionOptionContext) {
	this := p
	_ = this

	localctx = NewDataDelectionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, SQLServerStatementParserRULE_dataDelectionOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2965)
		p.Match(SQLServerStatementParserDATA_DELETION)
	}
	{
		p.SetState(2966)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2967)
		p.Match(SQLServerStatementParserON)
	}

	{
		p.SetState(2968)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2969)
		p.Match(SQLServerStatementParserFILTER_COLUMN)
	}
	{
		p.SetState(2970)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2971)
		p.ColumnName()
	}
	{
		p.SetState(2972)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(2973)
		p.Match(SQLServerStatementParserRETENTION_PERIOD)
	}
	{
		p.SetState(2974)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2975)
		p.HistoryRetentionPeriod()
	}

	return localctx
}

// ITableStretchOptionsContext is an interface to support dynamic dispatch.
type ITableStretchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableStretchOptionsContext differentiates from other interfaces.
	IsTableStretchOptionsContext()
}

type TableStretchOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableStretchOptionsContext() *TableStretchOptionsContext {
	var p = new(TableStretchOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableStretchOptions
	return p
}

func (*TableStretchOptionsContext) IsTableStretchOptionsContext() {}

func NewTableStretchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableStretchOptionsContext {
	var p = new(TableStretchOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableStretchOptions

	return p
}

func (s *TableStretchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableStretchOptionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *TableStretchOptionsContext) AllTableStretchOption() []ITableStretchOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableStretchOptionContext)(nil)).Elem())
	var tst = make([]ITableStretchOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableStretchOptionContext)
		}
	}

	return tst
}

func (s *TableStretchOptionsContext) TableStretchOption(i int) ITableStretchOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableStretchOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableStretchOptionContext)
}

func (s *TableStretchOptionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *TableStretchOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *TableStretchOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *TableStretchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableStretchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableStretchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableStretchOptions(s)
	}
}

func (s *TableStretchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableStretchOptions(s)
	}
}

func (s *TableStretchOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableStretchOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableStretchOptions() (localctx ITableStretchOptionsContext) {
	this := p
	_ = this

	localctx = NewTableStretchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, SQLServerStatementParserRULE_tableStretchOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2977)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(2978)
		p.TableStretchOption()
	}
	p.SetState(2983)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(2979)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(2980)
			p.TableStretchOption()
		}

		p.SetState(2985)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2986)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ITableStretchOptionContext is an interface to support dynamic dispatch.
type ITableStretchOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableStretchOptionContext differentiates from other interfaces.
	IsTableStretchOptionContext()
}

type TableStretchOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableStretchOptionContext() *TableStretchOptionContext {
	var p = new(TableStretchOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableStretchOption
	return p
}

func (*TableStretchOptionContext) IsTableStretchOptionContext() {}

func NewTableStretchOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableStretchOptionContext {
	var p = new(TableStretchOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableStretchOption

	return p
}

func (s *TableStretchOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableStretchOptionContext) MIGRATION_STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIGRATION_STATE, 0)
}

func (s *TableStretchOptionContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *TableStretchOptionContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *TableStretchOptionContext) OUTBOUND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTBOUND, 0)
}

func (s *TableStretchOptionContext) INBOUND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINBOUND, 0)
}

func (s *TableStretchOptionContext) PAUSED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAUSED, 0)
}

func (s *TableStretchOptionContext) FILTER_PREDICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILTER_PREDICATE, 0)
}

func (s *TableStretchOptionContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *TableStretchOptionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *TableStretchOptionContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TableStretchOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableStretchOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableStretchOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableStretchOption(s)
	}
}

func (s *TableStretchOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableStretchOption(s)
	}
}

func (s *TableStretchOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableStretchOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableStretchOption() (localctx ITableStretchOptionContext) {
	this := p
	_ = this

	localctx = NewTableStretchOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, SQLServerStatementParserRULE_tableStretchOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFILTER_PREDICATE {
		{
			p.SetState(2988)
			p.Match(SQLServerStatementParserFILTER_PREDICATE)
		}
		{
			p.SetState(2989)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(2992)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserNULL:
			{
				p.SetState(2990)
				p.Match(SQLServerStatementParserNULL)
			}

		case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(2991)
				p.FunctionCall()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(2994)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	{
		p.SetState(2997)
		p.Match(SQLServerStatementParserMIGRATION_STATE)
	}
	{
		p.SetState(2998)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(2999)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-263)&-(0x1f+1)) == 0 && ((1<<uint((_la-263)))&((1<<(SQLServerStatementParserINBOUND-263))|(1<<(SQLServerStatementParserOUTBOUND-263))|(1<<(SQLServerStatementParserPAUSED-263)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMigrationState_Context is an interface to support dynamic dispatch.
type IMigrationState_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMigrationState_Context differentiates from other interfaces.
	IsMigrationState_Context()
}

type MigrationState_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMigrationState_Context() *MigrationState_Context {
	var p = new(MigrationState_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_migrationState_
	return p
}

func (*MigrationState_Context) IsMigrationState_Context() {}

func NewMigrationState_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MigrationState_Context {
	var p = new(MigrationState_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_migrationState_

	return p
}

func (s *MigrationState_Context) GetParser() antlr.Parser { return s.parser }

func (s *MigrationState_Context) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *MigrationState_Context) MIGRATION_STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIGRATION_STATE, 0)
}

func (s *MigrationState_Context) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *MigrationState_Context) PAUSED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAUSED, 0)
}

func (s *MigrationState_Context) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *MigrationState_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MigrationState_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MigrationState_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMigrationState_(s)
	}
}

func (s *MigrationState_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMigrationState_(s)
	}
}

func (s *MigrationState_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMigrationState_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MigrationState_() (localctx IMigrationState_Context) {
	this := p
	_ = this

	localctx = NewMigrationState_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, SQLServerStatementParserRULE_migrationState_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3001)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3002)
		p.Match(SQLServerStatementParserMIGRATION_STATE)
	}
	{
		p.SetState(3003)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3004)
		p.Match(SQLServerStatementParserPAUSED)
	}
	{
		p.SetState(3005)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ITableOperationOptionContext is an interface to support dynamic dispatch.
type ITableOperationOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableOperationOptionContext differentiates from other interfaces.
	IsTableOperationOptionContext()
}

type TableOperationOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOperationOptionContext() *TableOperationOptionContext {
	var p = new(TableOperationOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableOperationOption
	return p
}

func (*TableOperationOptionContext) IsTableOperationOptionContext() {}

func NewTableOperationOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOperationOptionContext {
	var p = new(TableOperationOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableOperationOption

	return p
}

func (s *TableOperationOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOperationOptionContext) MEMORY_OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED, 0)
}

func (s *TableOperationOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *TableOperationOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *TableOperationOptionContext) DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDURABILITY, 0)
}

func (s *TableOperationOptionContext) SCHEMA_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_ONLY, 0)
}

func (s *TableOperationOptionContext) SCHEMA_AND_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_AND_DATA, 0)
}

func (s *TableOperationOptionContext) SYSTEM_VERSIONING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_VERSIONING, 0)
}

func (s *TableOperationOptionContext) OnHistoryTableClause() IOnHistoryTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnHistoryTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnHistoryTableClauseContext)
}

func (s *TableOperationOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOperationOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOperationOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableOperationOption(s)
	}
}

func (s *TableOperationOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableOperationOption(s)
	}
}

func (s *TableOperationOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableOperationOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableOperationOption() (localctx ITableOperationOptionContext) {
	this := p
	_ = this

	localctx = NewTableOperationOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, SQLServerStatementParserRULE_tableOperationOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserMEMORY_OPTIMIZED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3007)
			p.Match(SQLServerStatementParserMEMORY_OPTIMIZED)
		}
		{
			p.SetState(3008)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3009)
			p.Match(SQLServerStatementParserON)
		}

	case SQLServerStatementParserDURABILITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3010)
			p.Match(SQLServerStatementParserDURABILITY)
		}
		{
			p.SetState(3011)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3012)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSCHEMA_AND_DATA || _la == SQLServerStatementParserSCHEMA_ONLY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSYSTEM_VERSIONING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3013)
			p.Match(SQLServerStatementParserSYSTEM_VERSIONING)
		}
		{
			p.SetState(3014)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3015)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(3017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(3016)
				p.OnHistoryTableClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDistributionOptionContext is an interface to support dynamic dispatch.
type IDistributionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDistributionOptionContext differentiates from other interfaces.
	IsDistributionOptionContext()
}

type DistributionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionOptionContext() *DistributionOptionContext {
	var p = new(DistributionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_distributionOption
	return p
}

func (*DistributionOptionContext) IsDistributionOptionContext() {}

func NewDistributionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionOptionContext {
	var p = new(DistributionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_distributionOption

	return p
}

func (s *DistributionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionOptionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISTRIBUTION, 0)
}

func (s *DistributionOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *DistributionOptionContext) HASH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHASH, 0)
}

func (s *DistributionOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DistributionOptionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DistributionOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DistributionOptionContext) ROUND_ROBIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROUND_ROBIN, 0)
}

func (s *DistributionOptionContext) REPLICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATE, 0)
}

func (s *DistributionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDistributionOption(s)
	}
}

func (s *DistributionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDistributionOption(s)
	}
}

func (s *DistributionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDistributionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DistributionOption() (localctx IDistributionOptionContext) {
	this := p
	_ = this

	localctx = NewDistributionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, SQLServerStatementParserRULE_distributionOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3021)
		p.Match(SQLServerStatementParserDISTRIBUTION)
	}
	{
		p.SetState(3022)
		p.Match(SQLServerStatementParserEQ_)
	}
	p.SetState(3030)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserHASH:
		{
			p.SetState(3023)
			p.Match(SQLServerStatementParserHASH)
		}
		{
			p.SetState(3024)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3025)
			p.ColumnName()
		}
		{
			p.SetState(3026)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserROUND_ROBIN:
		{
			p.SetState(3028)
			p.Match(SQLServerStatementParserROUND_ROBIN)
		}

	case SQLServerStatementParserREPLICATE:
		{
			p.SetState(3029)
			p.Match(SQLServerStatementParserREPLICATE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataWareHouseTableOptionContext is an interface to support dynamic dispatch.
type IDataWareHouseTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataWareHouseTableOptionContext differentiates from other interfaces.
	IsDataWareHouseTableOptionContext()
}

type DataWareHouseTableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataWareHouseTableOptionContext() *DataWareHouseTableOptionContext {
	var p = new(DataWareHouseTableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataWareHouseTableOption
	return p
}

func (*DataWareHouseTableOptionContext) IsDataWareHouseTableOptionContext() {}

func NewDataWareHouseTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataWareHouseTableOptionContext {
	var p = new(DataWareHouseTableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataWareHouseTableOption

	return p
}

func (s *DataWareHouseTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataWareHouseTableOptionContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLUSTERED, 0)
}

func (s *DataWareHouseTableOptionContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *DataWareHouseTableOptionContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *DataWareHouseTableOptionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserORDER, 0)
}

func (s *DataWareHouseTableOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *DataWareHouseTableOptionContext) HEAP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHEAP, 0)
}

func (s *DataWareHouseTableOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DataWareHouseTableOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DataWareHouseTableOptionContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *DataWareHouseTableOptionContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DataWareHouseTableOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DataWareHouseTableOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DataWareHouseTableOptionContext) AllASC() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserASC)
}

func (s *DataWareHouseTableOptionContext) ASC(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASC, i)
}

func (s *DataWareHouseTableOptionContext) AllDESC() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDESC)
}

func (s *DataWareHouseTableOptionContext) DESC(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDESC, i)
}

func (s *DataWareHouseTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataWareHouseTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataWareHouseTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataWareHouseTableOption(s)
	}
}

func (s *DataWareHouseTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataWareHouseTableOption(s)
	}
}

func (s *DataWareHouseTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataWareHouseTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataWareHouseTableOption() (localctx IDataWareHouseTableOptionContext) {
	this := p
	_ = this

	localctx = NewDataWareHouseTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, SQLServerStatementParserRULE_dataWareHouseTableOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3060)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3032)
			p.Match(SQLServerStatementParserCLUSTERED)
		}
		{
			p.SetState(3033)
			p.Match(SQLServerStatementParserCOLUMNSTORE)
		}
		{
			p.SetState(3034)
			p.Match(SQLServerStatementParserINDEX)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3035)
			p.Match(SQLServerStatementParserCLUSTERED)
		}
		{
			p.SetState(3036)
			p.Match(SQLServerStatementParserCOLUMNSTORE)
		}
		{
			p.SetState(3037)
			p.Match(SQLServerStatementParserINDEX)
		}
		{
			p.SetState(3038)
			p.Match(SQLServerStatementParserORDER)
		}
		{
			p.SetState(3039)
			p.ColumnNames()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3040)
			p.Match(SQLServerStatementParserHEAP)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3041)
			p.Match(SQLServerStatementParserCLUSTERED)
		}
		{
			p.SetState(3042)
			p.Match(SQLServerStatementParserINDEX)
		}
		{
			p.SetState(3043)
			p.Match(SQLServerStatementParserLP_)
		}

		{
			p.SetState(3044)
			p.ColumnName()
		}
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC {
			{
				p.SetState(3045)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

		p.SetState(3055)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3048)
				p.Match(SQLServerStatementParserCOMMA_)
			}

			{
				p.SetState(3049)
				p.ColumnName()
			}
			p.SetState(3051)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC {
				{
					p.SetState(3050)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SQLServerStatementParserASC || _la == SQLServerStatementParserDESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

			p.SetState(3057)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3058)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IDataWareHousePartitionOptionContext is an interface to support dynamic dispatch.
type IDataWareHousePartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataWareHousePartitionOptionContext differentiates from other interfaces.
	IsDataWareHousePartitionOptionContext()
}

type DataWareHousePartitionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataWareHousePartitionOptionContext() *DataWareHousePartitionOptionContext {
	var p = new(DataWareHousePartitionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataWareHousePartitionOption
	return p
}

func (*DataWareHousePartitionOptionContext) IsDataWareHousePartitionOptionContext() {}

func NewDataWareHousePartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataWareHousePartitionOptionContext {
	var p = new(DataWareHousePartitionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataWareHousePartitionOption

	return p
}

func (s *DataWareHousePartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataWareHousePartitionOptionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITION, 0)
}

func (s *DataWareHousePartitionOptionContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *DataWareHousePartitionOptionContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *DataWareHousePartitionOptionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DataWareHousePartitionOptionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRANGE, 0)
}

func (s *DataWareHousePartitionOptionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *DataWareHousePartitionOptionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVALUES, 0)
}

func (s *DataWareHousePartitionOptionContext) AllSimpleExpr() []ISimpleExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem())
	var tst = make([]ISimpleExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleExprContext)
		}
	}

	return tst
}

func (s *DataWareHousePartitionOptionContext) SimpleExpr(i int) ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *DataWareHousePartitionOptionContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *DataWareHousePartitionOptionContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *DataWareHousePartitionOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DataWareHousePartitionOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DataWareHousePartitionOptionContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLEFT, 0)
}

func (s *DataWareHousePartitionOptionContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRIGHT, 0)
}

func (s *DataWareHousePartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataWareHousePartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataWareHousePartitionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataWareHousePartitionOption(s)
	}
}

func (s *DataWareHousePartitionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataWareHousePartitionOption(s)
	}
}

func (s *DataWareHousePartitionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataWareHousePartitionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataWareHousePartitionOption() (localctx IDataWareHousePartitionOptionContext) {
	this := p
	_ = this

	localctx = NewDataWareHousePartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, SQLServerStatementParserRULE_dataWareHousePartitionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3062)
		p.Match(SQLServerStatementParserPARTITION)
	}
	{
		p.SetState(3063)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3064)
		p.ColumnName()
	}
	{
		p.SetState(3065)
		p.Match(SQLServerStatementParserRANGE)
	}
	p.SetState(3067)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLEFT || _la == SQLServerStatementParserRIGHT {
		{
			p.SetState(3066)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserLEFT || _la == SQLServerStatementParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3069)
		p.Match(SQLServerStatementParserFOR)
	}
	{
		p.SetState(3070)
		p.Match(SQLServerStatementParserVALUES)
	}
	{
		p.SetState(3071)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3072)
		p.simpleExpr(0)
	}
	p.SetState(3077)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3073)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3074)
			p.simpleExpr(0)
		}

		p.SetState(3079)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3080)
		p.Match(SQLServerStatementParserRP_)
	}
	{
		p.SetState(3081)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ICreateIndexSpecificationContext is an interface to support dynamic dispatch.
type ICreateIndexSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateIndexSpecificationContext differentiates from other interfaces.
	IsCreateIndexSpecificationContext()
}

type CreateIndexSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexSpecificationContext() *CreateIndexSpecificationContext {
	var p = new(CreateIndexSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createIndexSpecification
	return p
}

func (*CreateIndexSpecificationContext) IsCreateIndexSpecificationContext() {}

func NewCreateIndexSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexSpecificationContext {
	var p = new(CreateIndexSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createIndexSpecification

	return p
}

func (s *CreateIndexSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexSpecificationContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUE, 0)
}

func (s *CreateIndexSpecificationContext) ClusterOption() IClusterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterOptionContext)
}

func (s *CreateIndexSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateIndexSpecification(s)
	}
}

func (s *CreateIndexSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateIndexSpecification(s)
	}
}

func (s *CreateIndexSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateIndexSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateIndexSpecification() (localctx ICreateIndexSpecificationContext) {
	this := p
	_ = this

	localctx = NewCreateIndexSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, SQLServerStatementParserRULE_createIndexSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserUNIQUE {
		{
			p.SetState(3083)
			p.Match(SQLServerStatementParserUNIQUE)
		}

	}
	p.SetState(3087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCLUSTERED || _la == SQLServerStatementParserNONCLUSTERED {
		{
			p.SetState(3086)
			p.ClusterOption()
		}

	}

	return localctx
}

// IAlterDefinitionClauseContext is an interface to support dynamic dispatch.
type IAlterDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDefinitionClauseContext differentiates from other interfaces.
	IsAlterDefinitionClauseContext()
}

type AlterDefinitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDefinitionClauseContext() *AlterDefinitionClauseContext {
	var p = new(AlterDefinitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterDefinitionClause
	return p
}

func (*AlterDefinitionClauseContext) IsAlterDefinitionClauseContext() {}

func NewAlterDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDefinitionClauseContext {
	var p = new(AlterDefinitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterDefinitionClause

	return p
}

func (s *AlterDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDefinitionClauseContext) AddColumnSpecification() IAddColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddColumnSpecificationContext)
}

func (s *AlterDefinitionClauseContext) ModifyColumnSpecification() IModifyColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifyColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifyColumnSpecificationContext)
}

func (s *AlterDefinitionClauseContext) AlterDrop() IAlterDropContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDropContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterDropContext)
}

func (s *AlterDefinitionClauseContext) AlterCheckConstraint() IAlterCheckConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterCheckConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterCheckConstraintContext)
}

func (s *AlterDefinitionClauseContext) AlterTableTrigger() IAlterTableTriggerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableTriggerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableTriggerContext)
}

func (s *AlterDefinitionClauseContext) AlterSwitch() IAlterSwitchContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterSwitchContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterSwitchContext)
}

func (s *AlterDefinitionClauseContext) AlterSet() IAlterSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterSetContext)
}

func (s *AlterDefinitionClauseContext) AlterTableOption() IAlterTableOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableOptionContext)
}

func (s *AlterDefinitionClauseContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREBUILD, 0)
}

func (s *AlterDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterDefinitionClause(s)
	}
}

func (s *AlterDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterDefinitionClause(s)
	}
}

func (s *AlterDefinitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterDefinitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterDefinitionClause() (localctx IAlterDefinitionClauseContext) {
	this := p
	_ = this

	localctx = NewAlterDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, SQLServerStatementParserRULE_alterDefinitionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3098)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 306, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3089)
			p.AddColumnSpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3090)
			p.ModifyColumnSpecification()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3091)
			p.AlterDrop()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3092)
			p.AlterCheckConstraint()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3093)
			p.AlterTableTrigger()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3094)
			p.AlterSwitch()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3095)
			p.AlterSet()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3096)
			p.AlterTableOption()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3097)
			p.Match(SQLServerStatementParserREBUILD)
		}

	}

	return localctx
}

// IAddColumnSpecificationContext is an interface to support dynamic dispatch.
type IAddColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddColumnSpecificationContext differentiates from other interfaces.
	IsAddColumnSpecificationContext()
}

type AddColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddColumnSpecificationContext() *AddColumnSpecificationContext {
	var p = new(AddColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_addColumnSpecification
	return p
}

func (*AddColumnSpecificationContext) IsAddColumnSpecificationContext() {}

func NewAddColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnSpecificationContext {
	var p = new(AddColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_addColumnSpecification

	return p
}

func (s *AddColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnSpecificationContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADD, 0)
}

func (s *AddColumnSpecificationContext) AlterColumnAddOptions() IAlterColumnAddOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterColumnAddOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterColumnAddOptionsContext)
}

func (s *AddColumnSpecificationContext) GeneratedColumnNamesClause() IGeneratedColumnNamesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratedColumnNamesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnNamesClauseContext)
}

func (s *AddColumnSpecificationContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AddColumnSpecificationContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *AddColumnSpecificationContext) NOCHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOCHECK, 0)
}

func (s *AddColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAddColumnSpecification(s)
	}
}

func (s *AddColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAddColumnSpecification(s)
	}
}

func (s *AddColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAddColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AddColumnSpecification() (localctx IAddColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewAddColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, SQLServerStatementParserRULE_addColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3100)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3101)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserCHECK || _la == SQLServerStatementParserNOCHECK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3104)
		p.Match(SQLServerStatementParserADD)
	}
	p.SetState(3107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 308, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3105)
			p.AlterColumnAddOptions()
		}

	case 2:
		{
			p.SetState(3106)
			p.GeneratedColumnNamesClause()
		}

	}

	return localctx
}

// IModifyColumnSpecificationContext is an interface to support dynamic dispatch.
type IModifyColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifyColumnSpecificationContext differentiates from other interfaces.
	IsModifyColumnSpecificationContext()
}

type ModifyColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyColumnSpecificationContext() *ModifyColumnSpecificationContext {
	var p = new(ModifyColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_modifyColumnSpecification
	return p
}

func (*ModifyColumnSpecificationContext) IsModifyColumnSpecificationContext() {}

func NewModifyColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnSpecificationContext {
	var p = new(ModifyColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_modifyColumnSpecification

	return p
}

func (s *ModifyColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnSpecificationContext) AlterColumnOperation() IAlterColumnOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterColumnOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterColumnOperationContext)
}

func (s *ModifyColumnSpecificationContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ModifyColumnSpecificationContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *ModifyColumnSpecificationContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *ModifyColumnSpecificationContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *ModifyColumnSpecificationContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *ModifyColumnSpecificationContext) SPARSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSPARSE, 0)
}

func (s *ModifyColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterModifyColumnSpecification(s)
	}
}

func (s *ModifyColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitModifyColumnSpecification(s)
	}
}

func (s *ModifyColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitModifyColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ModifyColumnSpecification() (localctx IModifyColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewModifyColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, SQLServerStatementParserRULE_modifyColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3109)
		p.AlterColumnOperation()
	}
	{
		p.SetState(3110)
		p.DataType()
	}
	p.SetState(3113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOLLATE {
		{
			p.SetState(3111)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(3112)
			p.CollationName()
		}

	}
	p.SetState(3118)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNULL:
		{
			p.SetState(3115)
			p.Match(SQLServerStatementParserNULL)
		}

	case SQLServerStatementParserNOT:
		{
			p.SetState(3116)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(3117)
			p.Match(SQLServerStatementParserNULL)
		}

	case SQLServerStatementParserEOF, SQLServerStatementParserCOMMA_, SQLServerStatementParserSEMI_, SQLServerStatementParserSELECT, SQLServerStatementParserINSERT, SQLServerStatementParserUPDATE, SQLServerStatementParserDELETE, SQLServerStatementParserCREATE, SQLServerStatementParserALTER, SQLServerStatementParserDROP, SQLServerStatementParserTRUNCATE, SQLServerStatementParserSET, SQLServerStatementParserWITH, SQLServerStatementParserDECLARE, SQLServerStatementParserRETURN, SQLServerStatementParserEND, SQLServerStatementParserSPARSE:

	default:
	}
	p.SetState(3121)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserSPARSE {
		{
			p.SetState(3120)
			p.Match(SQLServerStatementParserSPARSE)
		}

	}

	return localctx
}

// IAlterColumnOperationContext is an interface to support dynamic dispatch.
type IAlterColumnOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterColumnOperationContext differentiates from other interfaces.
	IsAlterColumnOperationContext()
}

type AlterColumnOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterColumnOperationContext() *AlterColumnOperationContext {
	var p = new(AlterColumnOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnOperation
	return p
}

func (*AlterColumnOperationContext) IsAlterColumnOperationContext() {}

func NewAlterColumnOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnOperationContext {
	var p = new(AlterColumnOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnOperation

	return p
}

func (s *AlterColumnOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnOperationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterColumnOperationContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN, 0)
}

func (s *AlterColumnOperationContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *AlterColumnOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterColumnOperation(s)
	}
}

func (s *AlterColumnOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterColumnOperation(s)
	}
}

func (s *AlterColumnOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterColumnOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterColumnOperation() (localctx IAlterColumnOperationContext) {
	this := p
	_ = this

	localctx = NewAlterColumnOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, SQLServerStatementParserRULE_alterColumnOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3123)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(3124)
		p.Match(SQLServerStatementParserCOLUMN)
	}
	{
		p.SetState(3125)
		p.ColumnName()
	}

	return localctx
}

// IAlterColumnAddOptionsContext is an interface to support dynamic dispatch.
type IAlterColumnAddOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterColumnAddOptionsContext differentiates from other interfaces.
	IsAlterColumnAddOptionsContext()
}

type AlterColumnAddOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterColumnAddOptionsContext() *AlterColumnAddOptionsContext {
	var p = new(AlterColumnAddOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnAddOptions
	return p
}

func (*AlterColumnAddOptionsContext) IsAlterColumnAddOptionsContext() {}

func NewAlterColumnAddOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnAddOptionsContext {
	var p = new(AlterColumnAddOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnAddOptions

	return p
}

func (s *AlterColumnAddOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnAddOptionsContext) AllAlterColumnAddOption() []IAlterColumnAddOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterColumnAddOptionContext)(nil)).Elem())
	var tst = make([]IAlterColumnAddOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterColumnAddOptionContext)
		}
	}

	return tst
}

func (s *AlterColumnAddOptionsContext) AlterColumnAddOption(i int) IAlterColumnAddOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterColumnAddOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterColumnAddOptionContext)
}

func (s *AlterColumnAddOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterColumnAddOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterColumnAddOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnAddOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnAddOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterColumnAddOptions(s)
	}
}

func (s *AlterColumnAddOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterColumnAddOptions(s)
	}
}

func (s *AlterColumnAddOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterColumnAddOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterColumnAddOptions() (localctx IAlterColumnAddOptionsContext) {
	this := p
	_ = this

	localctx = NewAlterColumnAddOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, SQLServerStatementParserRULE_alterColumnAddOptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.AlterColumnAddOption()
	}
	p.SetState(3132)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3128)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3129)
				p.AlterColumnAddOption()
			}

		}
		p.SetState(3134)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 312, p.GetParserRuleContext())
	}

	return localctx
}

// IAlterColumnAddOptionContext is an interface to support dynamic dispatch.
type IAlterColumnAddOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterColumnAddOptionContext differentiates from other interfaces.
	IsAlterColumnAddOptionContext()
}

type AlterColumnAddOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterColumnAddOptionContext() *AlterColumnAddOptionContext {
	var p = new(AlterColumnAddOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnAddOption
	return p
}

func (*AlterColumnAddOptionContext) IsAlterColumnAddOptionContext() {}

func NewAlterColumnAddOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterColumnAddOptionContext {
	var p = new(AlterColumnAddOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterColumnAddOption

	return p
}

func (s *AlterColumnAddOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterColumnAddOptionContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AlterColumnAddOptionContext) ComputedColumnDefinition() IComputedColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnDefinitionContext)
}

func (s *AlterColumnAddOptionContext) ColumnSetDefinition() IColumnSetDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnSetDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnSetDefinitionContext)
}

func (s *AlterColumnAddOptionContext) TableConstraint() ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *AlterColumnAddOptionContext) AlterTableTableIndex() IAlterTableTableIndexContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableTableIndexContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableTableIndexContext)
}

func (s *AlterColumnAddOptionContext) ConstraintForColumn() IConstraintForColumnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintForColumnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintForColumnContext)
}

func (s *AlterColumnAddOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnAddOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterColumnAddOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterColumnAddOption(s)
	}
}

func (s *AlterColumnAddOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterColumnAddOption(s)
	}
}

func (s *AlterColumnAddOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterColumnAddOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterColumnAddOption() (localctx IAlterColumnAddOptionContext) {
	this := p
	_ = this

	localctx = NewAlterColumnAddOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, SQLServerStatementParserRULE_alterColumnAddOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3141)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 313, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3135)
			p.ColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3136)
			p.ComputedColumnDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3137)
			p.ColumnSetDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3138)
			p.TableConstraint()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3139)
			p.AlterTableTableIndex()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3140)
			p.ConstraintForColumn()
		}

	}

	return localctx
}

// IConstraintForColumnContext is an interface to support dynamic dispatch.
type IConstraintForColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintForColumnContext differentiates from other interfaces.
	IsConstraintForColumnContext()
}

type ConstraintForColumnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintForColumnContext() *ConstraintForColumnContext {
	var p = new(ConstraintForColumnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_constraintForColumn
	return p
}

func (*ConstraintForColumnContext) IsConstraintForColumnContext() {}

func NewConstraintForColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintForColumnContext {
	var p = new(ConstraintForColumnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_constraintForColumn

	return p
}

func (s *ConstraintForColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintForColumnContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *ConstraintForColumnContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *ConstraintForColumnContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *ConstraintForColumnContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ConstraintForColumnContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *ConstraintForColumnContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ConstraintForColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintForColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintForColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterConstraintForColumn(s)
	}
}

func (s *ConstraintForColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitConstraintForColumn(s)
	}
}

func (s *ConstraintForColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitConstraintForColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ConstraintForColumn() (localctx IConstraintForColumnContext) {
	this := p
	_ = this

	localctx = NewConstraintForColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, SQLServerStatementParserRULE_constraintForColumn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3145)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(3143)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}
		{
			p.SetState(3144)
			p.ConstraintName()
		}

	}
	{
		p.SetState(3147)
		p.Match(SQLServerStatementParserDEFAULT)
	}
	{
		p.SetState(3148)
		p.simpleExpr(0)
	}
	{
		p.SetState(3149)
		p.Match(SQLServerStatementParserFOR)
	}
	{
		p.SetState(3150)
		p.ColumnName()
	}

	return localctx
}

// IGeneratedColumnNamesClauseContext is an interface to support dynamic dispatch.
type IGeneratedColumnNamesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratedColumnNamesClauseContext differentiates from other interfaces.
	IsGeneratedColumnNamesClauseContext()
}

type GeneratedColumnNamesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnNamesClauseContext() *GeneratedColumnNamesClauseContext {
	var p = new(GeneratedColumnNamesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnNamesClause
	return p
}

func (*GeneratedColumnNamesClauseContext) IsGeneratedColumnNamesClauseContext() {}

func NewGeneratedColumnNamesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnNamesClauseContext {
	var p = new(GeneratedColumnNamesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnNamesClause

	return p
}

func (s *GeneratedColumnNamesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnNamesClauseContext) GeneratedColumnNameClause() IGeneratedColumnNameClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratedColumnNameClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnNameClauseContext)
}

func (s *GeneratedColumnNamesClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *GeneratedColumnNamesClauseContext) PeriodClause() IPeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPeriodClauseContext)
}

func (s *GeneratedColumnNamesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnNamesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnNamesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterGeneratedColumnNamesClause(s)
	}
}

func (s *GeneratedColumnNamesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitGeneratedColumnNamesClause(s)
	}
}

func (s *GeneratedColumnNamesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitGeneratedColumnNamesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) GeneratedColumnNamesClause() (localctx IGeneratedColumnNamesClauseContext) {
	this := p
	_ = this

	localctx = NewGeneratedColumnNamesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, SQLServerStatementParserRULE_generatedColumnNamesClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3160)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 315, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3152)
			p.GeneratedColumnNameClause()
		}
		{
			p.SetState(3153)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3154)
			p.PeriodClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3156)
			p.PeriodClause()
		}
		{
			p.SetState(3157)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3158)
			p.GeneratedColumnNameClause()
		}

	}

	return localctx
}

// IGeneratedColumnNameClauseContext is an interface to support dynamic dispatch.
type IGeneratedColumnNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratedColumnNameClauseContext differentiates from other interfaces.
	IsGeneratedColumnNameClauseContext()
}

type GeneratedColumnNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnNameClauseContext() *GeneratedColumnNameClauseContext {
	var p = new(GeneratedColumnNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnNameClause
	return p
}

func (*GeneratedColumnNameClauseContext) IsGeneratedColumnNameClauseContext() {}

func NewGeneratedColumnNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnNameClauseContext {
	var p = new(GeneratedColumnNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnNameClause

	return p
}

func (s *GeneratedColumnNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnNameClauseContext) AllGeneratedColumnName() []IGeneratedColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGeneratedColumnNameContext)(nil)).Elem())
	var tst = make([]IGeneratedColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGeneratedColumnNameContext)
		}
	}

	return tst
}

func (s *GeneratedColumnNameClauseContext) GeneratedColumnName(i int) IGeneratedColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneratedColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnNameContext)
}

func (s *GeneratedColumnNameClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *GeneratedColumnNameClauseContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *GeneratedColumnNameClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *GeneratedColumnNameClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *GeneratedColumnNameClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVALUES, 0)
}

func (s *GeneratedColumnNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterGeneratedColumnNameClause(s)
	}
}

func (s *GeneratedColumnNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitGeneratedColumnNameClause(s)
	}
}

func (s *GeneratedColumnNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitGeneratedColumnNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) GeneratedColumnNameClause() (localctx IGeneratedColumnNameClauseContext) {
	this := p
	_ = this

	localctx = NewGeneratedColumnNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, SQLServerStatementParserRULE_generatedColumnNameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3162)
		p.GeneratedColumnName()
	}
	{
		p.SetState(3163)
		p.Match(SQLServerStatementParserDEFAULT)
	}
	{
		p.SetState(3164)
		p.simpleExpr(0)
	}
	p.SetState(3167)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3165)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3166)
			p.Match(SQLServerStatementParserVALUES)
		}

	}
	{
		p.SetState(3169)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(3170)
		p.GeneratedColumnName()
	}

	return localctx
}

// IGeneratedColumnNameContext is an interface to support dynamic dispatch.
type IGeneratedColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneratedColumnNameContext differentiates from other interfaces.
	IsGeneratedColumnNameContext()
}

type GeneratedColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnNameContext() *GeneratedColumnNameContext {
	var p = new(GeneratedColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnName
	return p
}

func (*GeneratedColumnNameContext) IsGeneratedColumnNameContext() {}

func NewGeneratedColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnNameContext {
	var p = new(GeneratedColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_generatedColumnName

	return p
}

func (s *GeneratedColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnNameContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *GeneratedColumnNameContext) DataTypeName() IDataTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *GeneratedColumnNameContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGENERATED, 0)
}

func (s *GeneratedColumnNameContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALWAYS, 0)
}

func (s *GeneratedColumnNameContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *GeneratedColumnNameContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *GeneratedColumnNameContext) HIDDEN_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHIDDEN_, 0)
}

func (s *GeneratedColumnNameContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *GeneratedColumnNameContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *GeneratedColumnNameContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *GeneratedColumnNameContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *GeneratedColumnNameContext) START() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTART, 0)
}

func (s *GeneratedColumnNameContext) END() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEND, 0)
}

func (s *GeneratedColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterGeneratedColumnName(s)
	}
}

func (s *GeneratedColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitGeneratedColumnName(s)
	}
}

func (s *GeneratedColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitGeneratedColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) GeneratedColumnName() (localctx IGeneratedColumnNameContext) {
	this := p
	_ = this

	localctx = NewGeneratedColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, SQLServerStatementParserRULE_generatedColumnName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3172)
		p.ColumnName()
	}
	{
		p.SetState(3173)
		p.DataTypeName()
	}
	{
		p.SetState(3174)
		p.Match(SQLServerStatementParserGENERATED)
	}
	{
		p.SetState(3175)
		p.Match(SQLServerStatementParserALWAYS)
	}
	{
		p.SetState(3176)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(3177)
		p.Match(SQLServerStatementParserROW)
	}
	p.SetState(3179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3178)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSTART || _la == SQLServerStatementParserEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3182)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserHIDDEN_ {
		{
			p.SetState(3181)
			p.Match(SQLServerStatementParserHIDDEN_)
		}

	}
	p.SetState(3186)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserNOT {
		{
			p.SetState(3184)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(3185)
			p.Match(SQLServerStatementParserNULL)
		}

	}
	p.SetState(3190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(3188)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}
		{
			p.SetState(3189)
			p.IgnoredIdentifier()
		}

	}

	return localctx
}

// IAlterDropContext is an interface to support dynamic dispatch.
type IAlterDropContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDropContext differentiates from other interfaces.
	IsAlterDropContext()
}

type AlterDropContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDropContext() *AlterDropContext {
	var p = new(AlterDropContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterDrop
	return p
}

func (*AlterDropContext) IsAlterDropContext() {}

func NewAlterDropContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDropContext {
	var p = new(AlterDropContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterDrop

	return p
}

func (s *AlterDropContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDropContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *AlterDropContext) AlterTableDropConstraint() IAlterTableDropConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableDropConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropConstraintContext)
}

func (s *AlterDropContext) DropColumnSpecification() IDropColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropColumnSpecificationContext)
}

func (s *AlterDropContext) DropIndexSpecification() IDropIndexSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropIndexSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropIndexSpecificationContext)
}

func (s *AlterDropContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERIOD, 0)
}

func (s *AlterDropContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *AlterDropContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_TIME, 0)
}

func (s *AlterDropContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDropContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDropContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterDrop(s)
	}
}

func (s *AlterDropContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterDrop(s)
	}
}

func (s *AlterDropContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterDrop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterDrop() (localctx IAlterDropContext) {
	this := p
	_ = this

	localctx = NewAlterDropContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, SQLServerStatementParserRULE_alterDrop)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3192)
		p.Match(SQLServerStatementParserDROP)
	}
	p.SetState(3199)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 321, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3193)
			p.AlterTableDropConstraint()
		}

	case 2:
		{
			p.SetState(3194)
			p.DropColumnSpecification()
		}

	case 3:
		{
			p.SetState(3195)
			p.DropIndexSpecification()
		}

	case 4:
		{
			p.SetState(3196)
			p.Match(SQLServerStatementParserPERIOD)
		}
		{
			p.SetState(3197)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(3198)
			p.Match(SQLServerStatementParserSYSTEM_TIME)
		}

	}

	return localctx
}

// IAlterTableDropConstraintContext is an interface to support dynamic dispatch.
type IAlterTableDropConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableDropConstraintContext differentiates from other interfaces.
	IsAlterTableDropConstraintContext()
}

type AlterTableDropConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropConstraintContext() *AlterTableDropConstraintContext {
	var p = new(AlterTableDropConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTableDropConstraint
	return p
}

func (*AlterTableDropConstraintContext) IsAlterTableDropConstraintContext() {}

func NewAlterTableDropConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropConstraintContext {
	var p = new(AlterTableDropConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTableDropConstraint

	return p
}

func (s *AlterTableDropConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropConstraintContext) AllDropConstraintName() []IDropConstraintNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDropConstraintNameContext)(nil)).Elem())
	var tst = make([]IDropConstraintNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDropConstraintNameContext)
		}
	}

	return tst
}

func (s *AlterTableDropConstraintContext) DropConstraintName(i int) IDropConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropConstraintNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDropConstraintNameContext)
}

func (s *AlterTableDropConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *AlterTableDropConstraintContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *AlterTableDropConstraintContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterTableDropConstraintContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterTableDropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTableDropConstraint(s)
	}
}

func (s *AlterTableDropConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTableDropConstraint(s)
	}
}

func (s *AlterTableDropConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTableDropConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTableDropConstraint() (localctx IAlterTableDropConstraintContext) {
	this := p
	_ = this

	localctx = NewAlterTableDropConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, SQLServerStatementParserRULE_alterTableDropConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONSTRAINT {
		{
			p.SetState(3201)
			p.Match(SQLServerStatementParserCONSTRAINT)
		}

	}
	p.SetState(3205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(3204)
			p.IfExist()
		}

	}
	{
		p.SetState(3207)
		p.DropConstraintName()
	}
	p.SetState(3212)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3208)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3209)
				p.DropConstraintName()
			}

		}
		p.SetState(3214)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 324, p.GetParserRuleContext())
	}

	return localctx
}

// IDropConstraintNameContext is an interface to support dynamic dispatch.
type IDropConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropConstraintNameContext differentiates from other interfaces.
	IsDropConstraintNameContext()
}

type DropConstraintNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropConstraintNameContext() *DropConstraintNameContext {
	var p = new(DropConstraintNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintName
	return p
}

func (*DropConstraintNameContext) IsDropConstraintNameContext() {}

func NewDropConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropConstraintNameContext {
	var p = new(DropConstraintNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintName

	return p
}

func (s *DropConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DropConstraintNameContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *DropConstraintNameContext) DropConstraintWithClause() IDropConstraintWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropConstraintWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropConstraintWithClauseContext)
}

func (s *DropConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropConstraintName(s)
	}
}

func (s *DropConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropConstraintName(s)
	}
}

func (s *DropConstraintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropConstraintName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropConstraintName() (localctx IDropConstraintNameContext) {
	this := p
	_ = this

	localctx = NewDropConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, SQLServerStatementParserRULE_dropConstraintName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3215)
		p.ConstraintName()
	}
	p.SetState(3217)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3216)
			p.DropConstraintWithClause()
		}

	}

	return localctx
}

// IDropConstraintWithClauseContext is an interface to support dynamic dispatch.
type IDropConstraintWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropConstraintWithClauseContext differentiates from other interfaces.
	IsDropConstraintWithClauseContext()
}

type DropConstraintWithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropConstraintWithClauseContext() *DropConstraintWithClauseContext {
	var p = new(DropConstraintWithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintWithClause
	return p
}

func (*DropConstraintWithClauseContext) IsDropConstraintWithClauseContext() {}

func NewDropConstraintWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropConstraintWithClauseContext {
	var p = new(DropConstraintWithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintWithClause

	return p
}

func (s *DropConstraintWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropConstraintWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *DropConstraintWithClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DropConstraintWithClauseContext) AllDropConstraintOption() []IDropConstraintOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDropConstraintOptionContext)(nil)).Elem())
	var tst = make([]IDropConstraintOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDropConstraintOptionContext)
		}
	}

	return tst
}

func (s *DropConstraintWithClauseContext) DropConstraintOption(i int) IDropConstraintOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropConstraintOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDropConstraintOptionContext)
}

func (s *DropConstraintWithClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DropConstraintWithClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropConstraintWithClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropConstraintWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropConstraintWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropConstraintWithClause(s)
	}
}

func (s *DropConstraintWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropConstraintWithClause(s)
	}
}

func (s *DropConstraintWithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropConstraintWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropConstraintWithClause() (localctx IDropConstraintWithClauseContext) {
	this := p
	_ = this

	localctx = NewDropConstraintWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, SQLServerStatementParserRULE_dropConstraintWithClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3219)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(3220)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3221)
		p.DropConstraintOption()
	}
	p.SetState(3226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3222)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3223)
			p.DropConstraintOption()
		}

		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3229)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IDropConstraintOptionContext is an interface to support dynamic dispatch.
type IDropConstraintOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropConstraintOptionContext differentiates from other interfaces.
	IsDropConstraintOptionContext()
}

type DropConstraintOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropConstraintOptionContext() *DropConstraintOptionContext {
	var p = new(DropConstraintOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintOption
	return p
}

func (*DropConstraintOptionContext) IsDropConstraintOptionContext() {}

func NewDropConstraintOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropConstraintOptionContext {
	var p = new(DropConstraintOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropConstraintOption

	return p
}

func (s *DropConstraintOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropConstraintOptionContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *DropConstraintOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *DropConstraintOptionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *DropConstraintOptionContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLINE, 0)
}

func (s *DropConstraintOptionContext) OnOffOption() IOnOffOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOffOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOffOptionContext)
}

func (s *DropConstraintOptionContext) MOVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOVE, 0)
}

func (s *DropConstraintOptionContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTO, 0)
}

func (s *DropConstraintOptionContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *DropConstraintOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *DropConstraintOptionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DropConstraintOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *DropConstraintOptionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *DropConstraintOptionContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *DropConstraintOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropConstraintOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropConstraintOption(s)
	}
}

func (s *DropConstraintOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropConstraintOption(s)
	}
}

func (s *DropConstraintOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropConstraintOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropConstraintOption() (localctx IDropConstraintOptionContext) {
	this := p
	_ = this

	localctx = NewDropConstraintOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, SQLServerStatementParserRULE_dropConstraintOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3248)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserMAXDOP:
		{
			p.SetState(3231)
			p.Match(SQLServerStatementParserMAXDOP)
		}
		{
			p.SetState(3232)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3233)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserONLINE:
		{
			p.SetState(3234)
			p.Match(SQLServerStatementParserONLINE)
		}
		{
			p.SetState(3235)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3236)
			p.OnOffOption()
		}

	case SQLServerStatementParserMOVE:
		{
			p.SetState(3237)
			p.Match(SQLServerStatementParserMOVE)
		}
		{
			p.SetState(3238)
			p.Match(SQLServerStatementParserTO)
		}
		p.SetState(3246)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 327, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3239)
				p.SchemaName()
			}
			{
				p.SetState(3240)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(3241)
				p.ColumnName()
			}
			{
				p.SetState(3242)
				p.Match(SQLServerStatementParserRP_)
			}

		case 2:
			{
				p.SetState(3244)
				p.IgnoredIdentifier()
			}

		case 3:
			{
				p.SetState(3245)
				p.Match(SQLServerStatementParserSTRING_)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnOffOptionContext is an interface to support dynamic dispatch.
type IOnOffOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnOffOptionContext differentiates from other interfaces.
	IsOnOffOptionContext()
}

type OnOffOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnOffOptionContext() *OnOffOptionContext {
	var p = new(OnOffOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onOffOption
	return p
}

func (*OnOffOptionContext) IsOnOffOptionContext() {}

func NewOnOffOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnOffOptionContext {
	var p = new(OnOffOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onOffOption

	return p
}

func (s *OnOffOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OnOffOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *OnOffOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *OnOffOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnOffOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnOffOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnOffOption(s)
	}
}

func (s *OnOffOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnOffOption(s)
	}
}

func (s *OnOffOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnOffOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnOffOption() (localctx IOnOffOptionContext) {
	this := p
	_ = this

	localctx = NewOnOffOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, SQLServerStatementParserRULE_onOffOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3250)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDropColumnSpecificationContext is an interface to support dynamic dispatch.
type IDropColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropColumnSpecificationContext differentiates from other interfaces.
	IsDropColumnSpecificationContext()
}

type DropColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropColumnSpecificationContext() *DropColumnSpecificationContext {
	var p = new(DropColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropColumnSpecification
	return p
}

func (*DropColumnSpecificationContext) IsDropColumnSpecificationContext() {}

func NewDropColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnSpecificationContext {
	var p = new(DropColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropColumnSpecification

	return p
}

func (s *DropColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnSpecificationContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN, 0)
}

func (s *DropColumnSpecificationContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *DropColumnSpecificationContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DropColumnSpecificationContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropColumnSpecificationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropColumnSpecificationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropColumnSpecification(s)
	}
}

func (s *DropColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropColumnSpecification(s)
	}
}

func (s *DropColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropColumnSpecification() (localctx IDropColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewDropColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, SQLServerStatementParserRULE_dropColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3252)
		p.Match(SQLServerStatementParserCOLUMN)
	}
	p.SetState(3254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(3253)
			p.IfExist()
		}

	}
	{
		p.SetState(3256)
		p.ColumnName()
	}
	p.SetState(3261)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3257)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3258)
				p.ColumnName()
			}

		}
		p.SetState(3263)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 330, p.GetParserRuleContext())
	}

	return localctx
}

// IDropIndexSpecificationContext is an interface to support dynamic dispatch.
type IDropIndexSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropIndexSpecificationContext differentiates from other interfaces.
	IsDropIndexSpecificationContext()
}

type DropIndexSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropIndexSpecificationContext() *DropIndexSpecificationContext {
	var p = new(DropIndexSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropIndexSpecification
	return p
}

func (*DropIndexSpecificationContext) IsDropIndexSpecificationContext() {}

func NewDropIndexSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexSpecificationContext {
	var p = new(DropIndexSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropIndexSpecification

	return p
}

func (s *DropIndexSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexSpecificationContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *DropIndexSpecificationContext) AllIndexName() []IIndexNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexNameContext)(nil)).Elem())
	var tst = make([]IIndexNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexNameContext)
		}
	}

	return tst
}

func (s *DropIndexSpecificationContext) IndexName(i int) IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DropIndexSpecificationContext) IfExist() IIfExistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfExistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropIndexSpecificationContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DropIndexSpecificationContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DropIndexSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropIndexSpecification(s)
	}
}

func (s *DropIndexSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropIndexSpecification(s)
	}
}

func (s *DropIndexSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropIndexSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropIndexSpecification() (localctx IDropIndexSpecificationContext) {
	this := p
	_ = this

	localctx = NewDropIndexSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, SQLServerStatementParserRULE_dropIndexSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3264)
		p.Match(SQLServerStatementParserINDEX)
	}
	p.SetState(3266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(3265)
			p.IfExist()
		}

	}
	{
		p.SetState(3268)
		p.IndexName()
	}
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3269)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3270)
				p.IndexName()
			}

		}
		p.SetState(3275)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 332, p.GetParserRuleContext())
	}

	return localctx
}

// IAlterCheckConstraintContext is an interface to support dynamic dispatch.
type IAlterCheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterCheckConstraintContext differentiates from other interfaces.
	IsAlterCheckConstraintContext()
}

type AlterCheckConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterCheckConstraintContext() *AlterCheckConstraintContext {
	var p = new(AlterCheckConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterCheckConstraint
	return p
}

func (*AlterCheckConstraintContext) IsAlterCheckConstraintContext() {}

func NewAlterCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCheckConstraintContext {
	var p = new(AlterCheckConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterCheckConstraint

	return p
}

func (s *AlterCheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCheckConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONSTRAINT, 0)
}

func (s *AlterCheckConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *AlterCheckConstraintContext) NOCHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOCHECK, 0)
}

func (s *AlterCheckConstraintContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *AlterCheckConstraintContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *AlterCheckConstraintContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AlterCheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterCheckConstraint(s)
	}
}

func (s *AlterCheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterCheckConstraint(s)
	}
}

func (s *AlterCheckConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterCheckConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterCheckConstraint() (localctx IAlterCheckConstraintContext) {
	this := p
	_ = this

	localctx = NewAlterCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, SQLServerStatementParserRULE_alterCheckConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3277)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3276)
			p.Match(SQLServerStatementParserWITH)
		}

	}
	{
		p.SetState(3279)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserCHECK || _la == SQLServerStatementParserNOCHECK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3280)
		p.Match(SQLServerStatementParserCONSTRAINT)
	}
	p.SetState(3283)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALL:
		{
			p.SetState(3281)
			p.Match(SQLServerStatementParserALL)
		}

	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(3282)
			p.ConstraintName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterTableTriggerContext is an interface to support dynamic dispatch.
type IAlterTableTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableTriggerContext differentiates from other interfaces.
	IsAlterTableTriggerContext()
}

type AlterTableTriggerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableTriggerContext() *AlterTableTriggerContext {
	var p = new(AlterTableTriggerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTableTrigger
	return p
}

func (*AlterTableTriggerContext) IsAlterTableTriggerContext() {}

func NewAlterTableTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableTriggerContext {
	var p = new(AlterTableTriggerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTableTrigger

	return p
}

func (s *AlterTableTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableTriggerContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *AlterTableTriggerContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE, 0)
}

func (s *AlterTableTriggerContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE, 0)
}

func (s *AlterTableTriggerContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *AlterTableTriggerContext) IgnoredIdentifiers() IIgnoredIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifiersContext)
}

func (s *AlterTableTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTableTrigger(s)
	}
}

func (s *AlterTableTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTableTrigger(s)
	}
}

func (s *AlterTableTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTableTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTableTrigger() (localctx IAlterTableTriggerContext) {
	this := p
	_ = this

	localctx = NewAlterTableTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, SQLServerStatementParserRULE_alterTableTrigger)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3285)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserENABLE || _la == SQLServerStatementParserDISABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3286)
		p.Match(SQLServerStatementParserTRIGGER)
	}
	p.SetState(3289)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALL:
		{
			p.SetState(3287)
			p.Match(SQLServerStatementParserALL)
		}

	case SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(3288)
			p.IgnoredIdentifiers()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterSwitchContext is an interface to support dynamic dispatch.
type IAlterSwitchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterSwitchContext differentiates from other interfaces.
	IsAlterSwitchContext()
}

type AlterSwitchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSwitchContext() *AlterSwitchContext {
	var p = new(AlterSwitchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterSwitch
	return p
}

func (*AlterSwitchContext) IsAlterSwitchContext() {}

func NewAlterSwitchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSwitchContext {
	var p = new(AlterSwitchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterSwitch

	return p
}

func (s *AlterSwitchContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSwitchContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSWITCH, 0)
}

func (s *AlterSwitchContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTO, 0)
}

func (s *AlterSwitchContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterSwitchContext) AllPARTITION() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserPARTITION)
}

func (s *AlterSwitchContext) PARTITION(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITION, i)
}

func (s *AlterSwitchContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AlterSwitchContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AlterSwitchContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AlterSwitchContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterSwitchContext) LowPriorityLockWait() ILowPriorityLockWaitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILowPriorityLockWaitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILowPriorityLockWaitContext)
}

func (s *AlterSwitchContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterSwitchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSwitchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSwitchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterSwitch(s)
	}
}

func (s *AlterSwitchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterSwitch(s)
	}
}

func (s *AlterSwitchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterSwitch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterSwitch() (localctx IAlterSwitchContext) {
	this := p
	_ = this

	localctx = NewAlterSwitchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, SQLServerStatementParserRULE_alterSwitch)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3291)
		p.Match(SQLServerStatementParserSWITCH)
	}
	p.SetState(3294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPARTITION {
		{
			p.SetState(3292)
			p.Match(SQLServerStatementParserPARTITION)
		}
		{
			p.SetState(3293)
			p.expr(0)
		}

	}
	{
		p.SetState(3296)
		p.Match(SQLServerStatementParserTO)
	}
	{
		p.SetState(3297)
		p.TableName()
	}
	p.SetState(3300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPARTITION {
		{
			p.SetState(3298)
			p.Match(SQLServerStatementParserPARTITION)
		}
		{
			p.SetState(3299)
			p.expr(0)
		}

	}
	p.SetState(3307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3302)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3303)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3304)
			p.LowPriorityLockWait()
		}
		{
			p.SetState(3305)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IAlterSetContext is an interface to support dynamic dispatch.
type IAlterSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterSetContext differentiates from other interfaces.
	IsAlterSetContext()
}

type AlterSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSetContext() *AlterSetContext {
	var p = new(AlterSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterSet
	return p
}

func (*AlterSetContext) IsAlterSetContext() {}

func NewAlterSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSetContext {
	var p = new(AlterSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterSet

	return p
}

func (s *AlterSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSetContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *AlterSetContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterSetContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterSetContext) SetFileStreamClause() ISetFileStreamClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetFileStreamClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetFileStreamClauseContext)
}

func (s *AlterSetContext) SetSystemVersionClause() ISetSystemVersionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetSystemVersionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetSystemVersionClauseContext)
}

func (s *AlterSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterSet(s)
	}
}

func (s *AlterSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterSet(s)
	}
}

func (s *AlterSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterSet() (localctx IAlterSetContext) {
	this := p
	_ = this

	localctx = NewAlterSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, SQLServerStatementParserRULE_alterSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3309)
		p.Match(SQLServerStatementParserSET)
	}
	{
		p.SetState(3310)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(3313)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserFILESTREAM_ON:
		{
			p.SetState(3311)
			p.SetFileStreamClause()
		}

	case SQLServerStatementParserSYSTEM_VERSIONING:
		{
			p.SetState(3312)
			p.SetSystemVersionClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(3315)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ISetFileStreamClauseContext is an interface to support dynamic dispatch.
type ISetFileStreamClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetFileStreamClauseContext differentiates from other interfaces.
	IsSetFileStreamClauseContext()
}

type SetFileStreamClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetFileStreamClauseContext() *SetFileStreamClauseContext {
	var p = new(SetFileStreamClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setFileStreamClause
	return p
}

func (*SetFileStreamClauseContext) IsSetFileStreamClauseContext() {}

func NewSetFileStreamClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetFileStreamClauseContext {
	var p = new(SetFileStreamClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setFileStreamClause

	return p
}

func (s *SetFileStreamClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetFileStreamClauseContext) FILESTREAM_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM_ON, 0)
}

func (s *SetFileStreamClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SetFileStreamClauseContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *SetFileStreamClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *SetFileStreamClauseContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *SetFileStreamClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetFileStreamClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetFileStreamClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetFileStreamClause(s)
	}
}

func (s *SetFileStreamClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetFileStreamClause(s)
	}
}

func (s *SetFileStreamClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetFileStreamClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetFileStreamClause() (localctx ISetFileStreamClauseContext) {
	this := p
	_ = this

	localctx = NewSetFileStreamClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, SQLServerStatementParserRULE_setFileStreamClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3317)
		p.Match(SQLServerStatementParserFILESTREAM_ON)
	}
	{
		p.SetState(3318)
		p.Match(SQLServerStatementParserEQ_)
	}
	p.SetState(3322)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 340, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3319)
			p.SchemaName()
		}

	case 2:
		{
			p.SetState(3320)
			p.IgnoredIdentifier()
		}

	case 3:
		{
			p.SetState(3321)
			p.Match(SQLServerStatementParserSTRING_)
		}

	}

	return localctx
}

// ISetSystemVersionClauseContext is an interface to support dynamic dispatch.
type ISetSystemVersionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetSystemVersionClauseContext differentiates from other interfaces.
	IsSetSystemVersionClauseContext()
}

type SetSystemVersionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetSystemVersionClauseContext() *SetSystemVersionClauseContext {
	var p = new(SetSystemVersionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setSystemVersionClause
	return p
}

func (*SetSystemVersionClauseContext) IsSetSystemVersionClauseContext() {}

func NewSetSystemVersionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetSystemVersionClauseContext {
	var p = new(SetSystemVersionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setSystemVersionClause

	return p
}

func (s *SetSystemVersionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetSystemVersionClauseContext) SYSTEM_VERSIONING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_VERSIONING, 0)
}

func (s *SetSystemVersionClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SetSystemVersionClauseContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *SetSystemVersionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *SetSystemVersionClauseContext) AlterSetOnClause() IAlterSetOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterSetOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterSetOnClauseContext)
}

func (s *SetSystemVersionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVersionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetSystemVersionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetSystemVersionClause(s)
	}
}

func (s *SetSystemVersionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetSystemVersionClause(s)
	}
}

func (s *SetSystemVersionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetSystemVersionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetSystemVersionClause() (localctx ISetSystemVersionClauseContext) {
	this := p
	_ = this

	localctx = NewSetSystemVersionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, SQLServerStatementParserRULE_setSystemVersionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3324)
		p.Match(SQLServerStatementParserSYSTEM_VERSIONING)
	}
	{
		p.SetState(3325)
		p.Match(SQLServerStatementParserEQ_)
	}
	p.SetState(3331)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserOFF:
		{
			p.SetState(3326)
			p.Match(SQLServerStatementParserOFF)
		}

	case SQLServerStatementParserON:
		{
			p.SetState(3327)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(3329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(3328)
				p.AlterSetOnClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterSetOnClauseContext is an interface to support dynamic dispatch.
type IAlterSetOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterSetOnClauseContext differentiates from other interfaces.
	IsAlterSetOnClauseContext()
}

type AlterSetOnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSetOnClauseContext() *AlterSetOnClauseContext {
	var p = new(AlterSetOnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterSetOnClause
	return p
}

func (*AlterSetOnClauseContext) IsAlterSetOnClauseContext() {}

func NewAlterSetOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSetOnClauseContext {
	var p = new(AlterSetOnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterSetOnClause

	return p
}

func (s *AlterSetOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSetOnClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterSetOnClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterSetOnClauseContext) HISTORY_TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHISTORY_TABLE, 0)
}

func (s *AlterSetOnClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AlterSetOnClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterSetOnClauseContext) DataConsistencyCheckClause() IDataConsistencyCheckClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataConsistencyCheckClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataConsistencyCheckClauseContext)
}

func (s *AlterSetOnClauseContext) HistoryRetentionPeriodClause() IHistoryRetentionPeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHistoryRetentionPeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHistoryRetentionPeriodClauseContext)
}

func (s *AlterSetOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSetOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSetOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterSetOnClause(s)
	}
}

func (s *AlterSetOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterSetOnClause(s)
	}
}

func (s *AlterSetOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterSetOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterSetOnClause() (localctx IAlterSetOnClauseContext) {
	this := p
	_ = this

	localctx = NewAlterSetOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, SQLServerStatementParserRULE_alterSetOnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3333)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(3337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserHISTORY_TABLE {
		{
			p.SetState(3334)
			p.Match(SQLServerStatementParserHISTORY_TABLE)
		}
		{
			p.SetState(3335)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3336)
			p.TableName()
		}

	}
	p.SetState(3340)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3339)
			p.DataConsistencyCheckClause()
		}

	}
	p.SetState(3343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ || _la == SQLServerStatementParserHISTORY_RETENTION_PERIOD {
		{
			p.SetState(3342)
			p.HistoryRetentionPeriodClause()
		}

	}
	{
		p.SetState(3345)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IDataConsistencyCheckClauseContext is an interface to support dynamic dispatch.
type IDataConsistencyCheckClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataConsistencyCheckClauseContext differentiates from other interfaces.
	IsDataConsistencyCheckClauseContext()
}

type DataConsistencyCheckClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataConsistencyCheckClauseContext() *DataConsistencyCheckClauseContext {
	var p = new(DataConsistencyCheckClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dataConsistencyCheckClause
	return p
}

func (*DataConsistencyCheckClauseContext) IsDataConsistencyCheckClauseContext() {}

func NewDataConsistencyCheckClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataConsistencyCheckClauseContext {
	var p = new(DataConsistencyCheckClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dataConsistencyCheckClause

	return p
}

func (s *DataConsistencyCheckClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataConsistencyCheckClauseContext) DATA_CONSISTENCY_CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_CONSISTENCY_CHECK, 0)
}

func (s *DataConsistencyCheckClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *DataConsistencyCheckClauseContext) OnOffOption() IOnOffOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOffOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOffOptionContext)
}

func (s *DataConsistencyCheckClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *DataConsistencyCheckClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataConsistencyCheckClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataConsistencyCheckClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDataConsistencyCheckClause(s)
	}
}

func (s *DataConsistencyCheckClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDataConsistencyCheckClause(s)
	}
}

func (s *DataConsistencyCheckClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDataConsistencyCheckClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DataConsistencyCheckClause() (localctx IDataConsistencyCheckClauseContext) {
	this := p
	_ = this

	localctx = NewDataConsistencyCheckClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, SQLServerStatementParserRULE_dataConsistencyCheckClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3347)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	{
		p.SetState(3350)
		p.Match(SQLServerStatementParserDATA_CONSISTENCY_CHECK)
	}
	{
		p.SetState(3351)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3352)
		p.OnOffOption()
	}

	return localctx
}

// IHistoryRetentionPeriodClauseContext is an interface to support dynamic dispatch.
type IHistoryRetentionPeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHistoryRetentionPeriodClauseContext differentiates from other interfaces.
	IsHistoryRetentionPeriodClauseContext()
}

type HistoryRetentionPeriodClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHistoryRetentionPeriodClauseContext() *HistoryRetentionPeriodClauseContext {
	var p = new(HistoryRetentionPeriodClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_historyRetentionPeriodClause
	return p
}

func (*HistoryRetentionPeriodClauseContext) IsHistoryRetentionPeriodClauseContext() {}

func NewHistoryRetentionPeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistoryRetentionPeriodClauseContext {
	var p = new(HistoryRetentionPeriodClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_historyRetentionPeriodClause

	return p
}

func (s *HistoryRetentionPeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HistoryRetentionPeriodClauseContext) HISTORY_RETENTION_PERIOD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHISTORY_RETENTION_PERIOD, 0)
}

func (s *HistoryRetentionPeriodClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *HistoryRetentionPeriodClauseContext) HistoryRetentionPeriod() IHistoryRetentionPeriodContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHistoryRetentionPeriodContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHistoryRetentionPeriodContext)
}

func (s *HistoryRetentionPeriodClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *HistoryRetentionPeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistoryRetentionPeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistoryRetentionPeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterHistoryRetentionPeriodClause(s)
	}
}

func (s *HistoryRetentionPeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitHistoryRetentionPeriodClause(s)
	}
}

func (s *HistoryRetentionPeriodClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitHistoryRetentionPeriodClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) HistoryRetentionPeriodClause() (localctx IHistoryRetentionPeriodClauseContext) {
	this := p
	_ = this

	localctx = NewHistoryRetentionPeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, SQLServerStatementParserRULE_historyRetentionPeriodClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3354)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	{
		p.SetState(3357)
		p.Match(SQLServerStatementParserHISTORY_RETENTION_PERIOD)
	}
	{
		p.SetState(3358)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3359)
		p.HistoryRetentionPeriod()
	}

	return localctx
}

// IHistoryRetentionPeriodContext is an interface to support dynamic dispatch.
type IHistoryRetentionPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHistoryRetentionPeriodContext differentiates from other interfaces.
	IsHistoryRetentionPeriodContext()
}

type HistoryRetentionPeriodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHistoryRetentionPeriodContext() *HistoryRetentionPeriodContext {
	var p = new(HistoryRetentionPeriodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_historyRetentionPeriod
	return p
}

func (*HistoryRetentionPeriodContext) IsHistoryRetentionPeriodContext() {}

func NewHistoryRetentionPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistoryRetentionPeriodContext {
	var p = new(HistoryRetentionPeriodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_historyRetentionPeriod

	return p
}

func (s *HistoryRetentionPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *HistoryRetentionPeriodContext) INFINITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINFINITE, 0)
}

func (s *HistoryRetentionPeriodContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *HistoryRetentionPeriodContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAY, 0)
}

func (s *HistoryRetentionPeriodContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAYS, 0)
}

func (s *HistoryRetentionPeriodContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWEEK, 0)
}

func (s *HistoryRetentionPeriodContext) WEEKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWEEKS, 0)
}

func (s *HistoryRetentionPeriodContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMONTH, 0)
}

func (s *HistoryRetentionPeriodContext) MONTHS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMONTHS, 0)
}

func (s *HistoryRetentionPeriodContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserYEAR, 0)
}

func (s *HistoryRetentionPeriodContext) YEARS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserYEARS, 0)
}

func (s *HistoryRetentionPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistoryRetentionPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistoryRetentionPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterHistoryRetentionPeriod(s)
	}
}

func (s *HistoryRetentionPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitHistoryRetentionPeriod(s)
	}
}

func (s *HistoryRetentionPeriodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitHistoryRetentionPeriod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) HistoryRetentionPeriod() (localctx IHistoryRetentionPeriodContext) {
	this := p
	_ = this

	localctx = NewHistoryRetentionPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, SQLServerStatementParserRULE_historyRetentionPeriod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3364)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserINFINITE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3361)
			p.Match(SQLServerStatementParserINFINITE)
		}

	case SQLServerStatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3362)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(3363)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-137)&-(0x1f+1)) == 0 && ((1<<uint((_la-137)))&((1<<(SQLServerStatementParserYEAR-137))|(1<<(SQLServerStatementParserMONTH-137))|(1<<(SQLServerStatementParserWEEK-137))|(1<<(SQLServerStatementParserDAY-137)))) != 0) || (((_la-244)&-(0x1f+1)) == 0 && ((1<<uint((_la-244)))&((1<<(SQLServerStatementParserYEARS-244))|(1<<(SQLServerStatementParserMONTHS-244))|(1<<(SQLServerStatementParserWEEKS-244))|(1<<(SQLServerStatementParserDAYS-244)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterTableTableIndexContext is an interface to support dynamic dispatch.
type IAlterTableTableIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableTableIndexContext differentiates from other interfaces.
	IsAlterTableTableIndexContext()
}

type AlterTableTableIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableTableIndexContext() *AlterTableTableIndexContext {
	var p = new(AlterTableTableIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTableTableIndex
	return p
}

func (*AlterTableTableIndexContext) IsAlterTableTableIndexContext() {}

func NewAlterTableTableIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableTableIndexContext {
	var p = new(AlterTableTableIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTableTableIndex

	return p
}

func (s *AlterTableTableIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableTableIndexContext) IndexWithName() IIndexWithNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexWithNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexWithNameContext)
}

func (s *AlterTableTableIndexContext) IndexNonClusterClause() IIndexNonClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNonClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNonClusterClauseContext)
}

func (s *AlterTableTableIndexContext) IndexClusterClause() IIndexClusterClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexClusterClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexClusterClauseContext)
}

func (s *AlterTableTableIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableTableIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableTableIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTableTableIndex(s)
	}
}

func (s *AlterTableTableIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTableTableIndex(s)
	}
}

func (s *AlterTableTableIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTableTableIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTableTableIndex() (localctx IAlterTableTableIndexContext) {
	this := p
	_ = this

	localctx = NewAlterTableTableIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, SQLServerStatementParserRULE_alterTableTableIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3366)
		p.IndexWithName()
	}
	p.SetState(3369)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNONCLUSTERED:
		{
			p.SetState(3367)
			p.IndexNonClusterClause()
		}

	case SQLServerStatementParserCLUSTERED:
		{
			p.SetState(3368)
			p.IndexClusterClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexWithNameContext is an interface to support dynamic dispatch.
type IIndexWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexWithNameContext differentiates from other interfaces.
	IsIndexWithNameContext()
}

type IndexWithNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexWithNameContext() *IndexWithNameContext {
	var p = new(IndexWithNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexWithName
	return p
}

func (*IndexWithNameContext) IsIndexWithNameContext() {}

func NewIndexWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexWithNameContext {
	var p = new(IndexWithNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexWithName

	return p
}

func (s *IndexWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexWithNameContext) INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINDEX, 0)
}

func (s *IndexWithNameContext) IndexName() IIndexNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *IndexWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexWithName(s)
	}
}

func (s *IndexWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexWithName(s)
	}
}

func (s *IndexWithNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexWithName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexWithName() (localctx IIndexWithNameContext) {
	this := p
	_ = this

	localctx = NewIndexWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, SQLServerStatementParserRULE_indexWithName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3371)
		p.Match(SQLServerStatementParserINDEX)
	}
	{
		p.SetState(3372)
		p.IndexName()
	}

	return localctx
}

// IIndexNonClusterClauseContext is an interface to support dynamic dispatch.
type IIndexNonClusterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNonClusterClauseContext differentiates from other interfaces.
	IsIndexNonClusterClauseContext()
}

type IndexNonClusterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNonClusterClauseContext() *IndexNonClusterClauseContext {
	var p = new(IndexNonClusterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexNonClusterClause
	return p
}

func (*IndexNonClusterClauseContext) IsIndexNonClusterClauseContext() {}

func NewIndexNonClusterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNonClusterClauseContext {
	var p = new(IndexNonClusterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexNonClusterClause

	return p
}

func (s *IndexNonClusterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNonClusterClauseContext) NONCLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONCLUSTERED, 0)
}

func (s *IndexNonClusterClauseContext) HashWithBucket() IHashWithBucketContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHashWithBucketContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHashWithBucketContext)
}

func (s *IndexNonClusterClauseContext) ColumnNamesWithSort() IColumnNamesWithSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesWithSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesWithSortContext)
}

func (s *IndexNonClusterClauseContext) AlterTableIndexOnClause() IAlterTableIndexOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableIndexOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableIndexOnClauseContext)
}

func (s *IndexNonClusterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNonClusterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNonClusterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexNonClusterClause(s)
	}
}

func (s *IndexNonClusterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexNonClusterClause(s)
	}
}

func (s *IndexNonClusterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexNonClusterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexNonClusterClause() (localctx IIndexNonClusterClauseContext) {
	this := p
	_ = this

	localctx = NewIndexNonClusterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, SQLServerStatementParserRULE_indexNonClusterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3374)
		p.Match(SQLServerStatementParserNONCLUSTERED)
	}
	p.SetState(3380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserHASH:
		{
			p.SetState(3375)
			p.HashWithBucket()
		}

	case SQLServerStatementParserLP_:
		{
			p.SetState(3376)
			p.ColumnNamesWithSort()
		}
		p.SetState(3378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserON || _la == SQLServerStatementParserDEFAULT {
			{
				p.SetState(3377)
				p.AlterTableIndexOnClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterTableIndexOnClauseContext is an interface to support dynamic dispatch.
type IAlterTableIndexOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableIndexOnClauseContext differentiates from other interfaces.
	IsAlterTableIndexOnClauseContext()
}

type AlterTableIndexOnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableIndexOnClauseContext() *AlterTableIndexOnClauseContext {
	var p = new(AlterTableIndexOnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTableIndexOnClause
	return p
}

func (*AlterTableIndexOnClauseContext) IsAlterTableIndexOnClauseContext() {}

func NewAlterTableIndexOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableIndexOnClauseContext {
	var p = new(AlterTableIndexOnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTableIndexOnClause

	return p
}

func (s *AlterTableIndexOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableIndexOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterTableIndexOnClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AlterTableIndexOnClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *AlterTableIndexOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableIndexOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableIndexOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTableIndexOnClause(s)
	}
}

func (s *AlterTableIndexOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTableIndexOnClause(s)
	}
}

func (s *AlterTableIndexOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTableIndexOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTableIndexOnClause() (localctx IAlterTableIndexOnClauseContext) {
	this := p
	_ = this

	localctx = NewAlterTableIndexOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, SQLServerStatementParserRULE_alterTableIndexOnClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3385)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3382)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(3383)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3384)
			p.Match(SQLServerStatementParserDEFAULT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexClusterClauseContext is an interface to support dynamic dispatch.
type IIndexClusterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexClusterClauseContext differentiates from other interfaces.
	IsIndexClusterClauseContext()
}

type IndexClusterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexClusterClauseContext() *IndexClusterClauseContext {
	var p = new(IndexClusterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_indexClusterClause
	return p
}

func (*IndexClusterClauseContext) IsIndexClusterClauseContext() {}

func NewIndexClusterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexClusterClauseContext {
	var p = new(IndexClusterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_indexClusterClause

	return p
}

func (s *IndexClusterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexClusterClauseContext) CLUSTERED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLUSTERED, 0)
}

func (s *IndexClusterClauseContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *IndexClusterClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *IndexClusterClauseContext) COMPRESSION_DELAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESSION_DELAY, 0)
}

func (s *IndexClusterClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *IndexClusterClauseContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *IndexClusterClauseContext) IndexOnClause() IIndexOnClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOnClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexOnClauseContext)
}

func (s *IndexClusterClauseContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *IndexClusterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexClusterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexClusterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIndexClusterClause(s)
	}
}

func (s *IndexClusterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIndexClusterClause(s)
	}
}

func (s *IndexClusterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIndexClusterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IndexClusterClause() (localctx IIndexClusterClauseContext) {
	this := p
	_ = this

	localctx = NewIndexClusterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, SQLServerStatementParserRULE_indexClusterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3387)
		p.Match(SQLServerStatementParserCLUSTERED)
	}
	{
		p.SetState(3388)
		p.Match(SQLServerStatementParserCOLUMNSTORE)
	}
	p.SetState(3396)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3389)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3390)
			p.Match(SQLServerStatementParserCOMPRESSION_DELAY)
		}
		{
			p.SetState(3391)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3392)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		p.SetState(3394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserMINUTES {
			{
				p.SetState(3393)
				p.Match(SQLServerStatementParserMINUTES)
			}

		}

	}
	p.SetState(3399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(3398)
			p.IndexOnClause()
		}

	}

	return localctx
}

// IAlterTableOptionContext is an interface to support dynamic dispatch.
type IAlterTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableOptionContext differentiates from other interfaces.
	IsAlterTableOptionContext()
}

type AlterTableOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableOptionContext() *AlterTableOptionContext {
	var p = new(AlterTableOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterTableOption
	return p
}

func (*AlterTableOptionContext) IsAlterTableOptionContext() {}

func NewAlterTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableOptionContext {
	var p = new(AlterTableOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterTableOption

	return p
}

func (s *AlterTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableOptionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *AlterTableOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterTableOptionContext) LOCK_ESCALATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCK_ESCALATION, 0)
}

func (s *AlterTableOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AlterTableOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterTableOptionContext) AUTO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO, 0)
}

func (s *AlterTableOptionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *AlterTableOptionContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE, 0)
}

func (s *AlterTableOptionContext) MEMORY_OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED, 0)
}

func (s *AlterTableOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterTableOptionContext) DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDURABILITY, 0)
}

func (s *AlterTableOptionContext) SCHEMA_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_ONLY, 0)
}

func (s *AlterTableOptionContext) SCHEMA_AND_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA_AND_DATA, 0)
}

func (s *AlterTableOptionContext) SYSTEM_VERSIONING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYSTEM_VERSIONING, 0)
}

func (s *AlterTableOptionContext) OnHistoryTableClause() IOnHistoryTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnHistoryTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnHistoryTableClauseContext)
}

func (s *AlterTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterTableOption(s)
	}
}

func (s *AlterTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterTableOption(s)
	}
}

func (s *AlterTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterTableOption() (localctx IAlterTableOptionContext) {
	this := p
	_ = this

	localctx = NewAlterTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, SQLServerStatementParserRULE_alterTableOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3419)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserSET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3401)
			p.Match(SQLServerStatementParserSET)
		}
		{
			p.SetState(3402)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3403)
			p.Match(SQLServerStatementParserLOCK_ESCALATION)
		}
		{
			p.SetState(3404)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3405)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserTABLE || _la == SQLServerStatementParserDISABLE || _la == SQLServerStatementParserAUTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3406)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserMEMORY_OPTIMIZED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3407)
			p.Match(SQLServerStatementParserMEMORY_OPTIMIZED)
		}
		{
			p.SetState(3408)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3409)
			p.Match(SQLServerStatementParserON)
		}

	case SQLServerStatementParserDURABILITY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3410)
			p.Match(SQLServerStatementParserDURABILITY)
		}
		{
			p.SetState(3411)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3412)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSCHEMA_AND_DATA || _la == SQLServerStatementParserSCHEMA_ONLY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSYSTEM_VERSIONING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3413)
			p.Match(SQLServerStatementParserSYSTEM_VERSIONING)
		}
		{
			p.SetState(3414)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3415)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(3417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(3416)
				p.OnHistoryTableClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnHistoryTableClauseContext is an interface to support dynamic dispatch.
type IOnHistoryTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnHistoryTableClauseContext differentiates from other interfaces.
	IsOnHistoryTableClauseContext()
}

type OnHistoryTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnHistoryTableClauseContext() *OnHistoryTableClauseContext {
	var p = new(OnHistoryTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onHistoryTableClause
	return p
}

func (*OnHistoryTableClauseContext) IsOnHistoryTableClauseContext() {}

func NewOnHistoryTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnHistoryTableClauseContext {
	var p = new(OnHistoryTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onHistoryTableClause

	return p
}

func (s *OnHistoryTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnHistoryTableClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OnHistoryTableClauseContext) HISTORY_TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHISTORY_TABLE, 0)
}

func (s *OnHistoryTableClauseContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *OnHistoryTableClauseContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *OnHistoryTableClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *OnHistoryTableClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OnHistoryTableClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *OnHistoryTableClauseContext) DATA_CONSISTENCY_CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_CONSISTENCY_CHECK, 0)
}

func (s *OnHistoryTableClauseContext) OnOffOption() IOnOffOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnOffOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnOffOptionContext)
}

func (s *OnHistoryTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnHistoryTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnHistoryTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnHistoryTableClause(s)
	}
}

func (s *OnHistoryTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnHistoryTableClause(s)
	}
}

func (s *OnHistoryTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnHistoryTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnHistoryTableClause() (localctx IOnHistoryTableClauseContext) {
	this := p
	_ = this

	localctx = NewOnHistoryTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, SQLServerStatementParserRULE_onHistoryTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3421)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3422)
		p.Match(SQLServerStatementParserHISTORY_TABLE)
	}
	{
		p.SetState(3423)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3424)
		p.TableName()
	}
	p.SetState(3429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3425)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3426)
			p.Match(SQLServerStatementParserDATA_CONSISTENCY_CHECK)
		}
		{
			p.SetState(3427)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3428)
			p.OnOffOption()
		}

	}
	{
		p.SetState(3431)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IIfExistContext is an interface to support dynamic dispatch.
type IIfExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfExistContext differentiates from other interfaces.
	IsIfExistContext()
}

type IfExistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistContext() *IfExistContext {
	var p = new(IfExistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_ifExist
	return p
}

func (*IfExistContext) IsIfExistContext() {}

func NewIfExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistContext {
	var p = new(IfExistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_ifExist

	return p
}

func (s *IfExistContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIF, 0)
}

func (s *IfExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXISTS, 0)
}

func (s *IfExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterIfExist(s)
	}
}

func (s *IfExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitIfExist(s)
	}
}

func (s *IfExistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitIfExist(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) IfExist() (localctx IIfExistContext) {
	this := p
	_ = this

	localctx = NewIfExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, SQLServerStatementParserRULE_ifExist)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3433)
		p.Match(SQLServerStatementParserIF)
	}
	{
		p.SetState(3434)
		p.Match(SQLServerStatementParserEXISTS)
	}

	return localctx
}

// ICreateDatabaseClauseContext is an interface to support dynamic dispatch.
type ICreateDatabaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDatabaseClauseContext differentiates from other interfaces.
	IsCreateDatabaseClauseContext()
}

type CreateDatabaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseClauseContext() *CreateDatabaseClauseContext {
	var p = new(CreateDatabaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createDatabaseClause
	return p
}

func (*CreateDatabaseClauseContext) IsCreateDatabaseClauseContext() {}

func NewCreateDatabaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseClauseContext {
	var p = new(CreateDatabaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createDatabaseClause

	return p
}

func (s *CreateDatabaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseClauseContext) CONTAINMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTAINMENT, 0)
}

func (s *CreateDatabaseClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *CreateDatabaseClauseContext) FileDefinitionClause() IFileDefinitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileDefinitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileDefinitionClauseContext)
}

func (s *CreateDatabaseClauseContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *CreateDatabaseClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *CreateDatabaseClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *CreateDatabaseClauseContext) AllDatabaseOption() []IDatabaseOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatabaseOptionContext)(nil)).Elem())
	var tst = make([]IDatabaseOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatabaseOptionContext)
		}
	}

	return tst
}

func (s *CreateDatabaseClauseContext) DatabaseOption(i int) IDatabaseOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatabaseOptionContext)
}

func (s *CreateDatabaseClauseContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *CreateDatabaseClauseContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTIAL, 0)
}

func (s *CreateDatabaseClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateDatabaseClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateDatabaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateDatabaseClause(s)
	}
}

func (s *CreateDatabaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateDatabaseClause(s)
	}
}

func (s *CreateDatabaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateDatabaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateDatabaseClause() (localctx ICreateDatabaseClauseContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, SQLServerStatementParserRULE_createDatabaseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCONTAINMENT {
		{
			p.SetState(3436)
			p.Match(SQLServerStatementParserCONTAINMENT)
		}
		{
			p.SetState(3437)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3438)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserNONE || _la == SQLServerStatementParserPARTIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(3441)
			p.FileDefinitionClause()
		}

	}
	p.SetState(3446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOLLATE {
		{
			p.SetState(3444)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(3445)
			p.IgnoredIdentifier()
		}

	}
	p.SetState(3457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3448)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3449)
			p.DatabaseOption()
		}
		p.SetState(3454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3450)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3451)
				p.DatabaseOption()
			}

			p.SetState(3456)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IFileDefinitionClauseContext is an interface to support dynamic dispatch.
type IFileDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDefinitionClauseContext differentiates from other interfaces.
	IsFileDefinitionClauseContext()
}

type FileDefinitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDefinitionClauseContext() *FileDefinitionClauseContext {
	var p = new(FileDefinitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileDefinitionClause
	return p
}

func (*FileDefinitionClauseContext) IsFileDefinitionClauseContext() {}

func NewFileDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDefinitionClauseContext {
	var p = new(FileDefinitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileDefinitionClause

	return p
}

func (s *FileDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDefinitionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *FileDefinitionClauseContext) AllFileSpec() []IFileSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileSpecContext)(nil)).Elem())
	var tst = make([]IFileSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileSpecContext)
		}
	}

	return tst
}

func (s *FileDefinitionClauseContext) FileSpec(i int) IFileSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileSpecContext)
}

func (s *FileDefinitionClauseContext) DatabaseLogOns() IDatabaseLogOnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseLogOnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseLogOnsContext)
}

func (s *FileDefinitionClauseContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRIMARY, 0)
}

func (s *FileDefinitionClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *FileDefinitionClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *FileDefinitionClauseContext) AllDatabaseFileGroup() []IDatabaseFileGroupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatabaseFileGroupContext)(nil)).Elem())
	var tst = make([]IDatabaseFileGroupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatabaseFileGroupContext)
		}
	}

	return tst
}

func (s *FileDefinitionClauseContext) DatabaseFileGroup(i int) IDatabaseFileGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseFileGroupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatabaseFileGroupContext)
}

func (s *FileDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileDefinitionClause(s)
	}
}

func (s *FileDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileDefinitionClause(s)
	}
}

func (s *FileDefinitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileDefinitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileDefinitionClause() (localctx IFileDefinitionClauseContext) {
	this := p
	_ = this

	localctx = NewFileDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, SQLServerStatementParserRULE_fileDefinitionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3459)
		p.Match(SQLServerStatementParserON)
	}
	p.SetState(3461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserPRIMARY {
		{
			p.SetState(3460)
			p.Match(SQLServerStatementParserPRIMARY)
		}

	}
	{
		p.SetState(3463)
		p.FileSpec()
	}
	p.SetState(3468)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3464)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3465)
				p.FileSpec()
			}

		}
		p.SetState(3470)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext())
	}
	p.SetState(3475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3471)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3472)
			p.DatabaseFileGroup()
		}

		p.SetState(3477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3478)
		p.DatabaseLogOns()
	}

	return localctx
}

// IDatabaseOptionContext is an interface to support dynamic dispatch.
type IDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseOptionContext differentiates from other interfaces.
	IsDatabaseOptionContext()
}

type DatabaseOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseOptionContext() *DatabaseOptionContext {
	var p = new(DatabaseOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseOption
	return p
}

func (*DatabaseOptionContext) IsDatabaseOptionContext() {}

func NewDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseOptionContext {
	var p = new(DatabaseOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseOption

	return p
}

func (s *DatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseOptionContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *DatabaseOptionContext) AllFileStreamOption() []IFileStreamOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileStreamOptionContext)(nil)).Elem())
	var tst = make([]IFileStreamOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileStreamOptionContext)
		}
	}

	return tst
}

func (s *DatabaseOptionContext) FileStreamOption(i int) IFileStreamOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStreamOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileStreamOptionContext)
}

func (s *DatabaseOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DatabaseOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DatabaseOptionContext) DEFAULT_FULLTEXT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, 0)
}

func (s *DatabaseOptionContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *DatabaseOptionContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *DatabaseOptionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *DatabaseOptionContext) DEFAULT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_LANGUAGE, 0)
}

func (s *DatabaseOptionContext) NESTED_TRIGGERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNESTED_TRIGGERS, 0)
}

func (s *DatabaseOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *DatabaseOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *DatabaseOptionContext) TRANSFORM_NOISE_WORDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSFORM_NOISE_WORDS, 0)
}

func (s *DatabaseOptionContext) TWO_DIGIT_YEAR_CUTOFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, 0)
}

func (s *DatabaseOptionContext) DB_CHAINING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDB_CHAINING, 0)
}

func (s *DatabaseOptionContext) TRUSTWORTHY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUSTWORTHY, 0)
}

func (s *DatabaseOptionContext) PERSISTENT_LOG_BUFFER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTENT_LOG_BUFFER, 0)
}

func (s *DatabaseOptionContext) DIRECTORY_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDIRECTORY_NAME, 0)
}

func (s *DatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseOption(s)
	}
}

func (s *DatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseOption(s)
	}
}

func (s *DatabaseOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseOption() (localctx IDatabaseOptionContext) {
	this := p
	_ = this

	localctx = NewDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, SQLServerStatementParserRULE_databaseOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(3514)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserFILESTREAM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3480)
			p.Match(SQLServerStatementParserFILESTREAM)
		}
		{
			p.SetState(3481)
			p.FileStreamOption()
		}
		p.SetState(3486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3482)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(3483)
					p.FileStreamOption()
				}

			}
			p.SetState(3488)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 367, p.GetParserRuleContext())
		}

	case SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3489)
			p.Match(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE)
		}
		{
			p.SetState(3490)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3491)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserDEFAULT_LANGUAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3492)
			p.Match(SQLServerStatementParserDEFAULT_LANGUAGE)
		}
		{
			p.SetState(3493)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3494)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserNESTED_TRIGGERS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3495)
			p.Match(SQLServerStatementParserNESTED_TRIGGERS)
		}
		{
			p.SetState(3496)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3497)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTRANSFORM_NOISE_WORDS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3498)
			p.Match(SQLServerStatementParserTRANSFORM_NOISE_WORDS)
		}
		{
			p.SetState(3499)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3500)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3501)
			p.Match(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF)
		}
		{
			p.SetState(3502)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3503)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserDB_CHAINING:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3504)
			p.Match(SQLServerStatementParserDB_CHAINING)
		}
		{
			p.SetState(3505)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTRUSTWORTHY:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3506)
			p.Match(SQLServerStatementParserTRUSTWORTHY)
		}
		{
			p.SetState(3507)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserPERSISTENT_LOG_BUFFER:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3508)
			p.Match(SQLServerStatementParserPERSISTENT_LOG_BUFFER)
		}
		{
			p.SetState(3509)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3510)
			p.Match(SQLServerStatementParserON)
		}

		{
			p.SetState(3511)
			p.Match(SQLServerStatementParserDIRECTORY_NAME)
		}
		{
			p.SetState(3512)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3513)
			p.IgnoredIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileStreamOptionContext is an interface to support dynamic dispatch.
type IFileStreamOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileStreamOptionContext differentiates from other interfaces.
	IsFileStreamOptionContext()
}

type FileStreamOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileStreamOptionContext() *FileStreamOptionContext {
	var p = new(FileStreamOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileStreamOption
	return p
}

func (*FileStreamOptionContext) IsFileStreamOptionContext() {}

func NewFileStreamOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileStreamOptionContext {
	var p = new(FileStreamOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileStreamOption

	return p
}

func (s *FileStreamOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FileStreamOptionContext) NON_TRANSACTED_ACCESS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNON_TRANSACTED_ACCESS, 0)
}

func (s *FileStreamOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *FileStreamOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *FileStreamOptionContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *FileStreamOptionContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULL, 0)
}

func (s *FileStreamOptionContext) DIRECTORY_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDIRECTORY_NAME, 0)
}

func (s *FileStreamOptionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *FileStreamOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileStreamOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileStreamOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileStreamOption(s)
	}
}

func (s *FileStreamOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileStreamOption(s)
	}
}

func (s *FileStreamOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileStreamOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileStreamOption() (localctx IFileStreamOptionContext) {
	this := p
	_ = this

	localctx = NewFileStreamOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, SQLServerStatementParserRULE_fileStreamOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3522)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserNON_TRANSACTED_ACCESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3516)
			p.Match(SQLServerStatementParserNON_TRANSACTED_ACCESS)
		}
		{
			p.SetState(3517)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3518)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserFULL || _la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDIRECTORY_NAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3519)
			p.Match(SQLServerStatementParserDIRECTORY_NAME)
		}
		{
			p.SetState(3520)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3521)
			p.IgnoredIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileSpecContext is an interface to support dynamic dispatch.
type IFileSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileSpecContext differentiates from other interfaces.
	IsFileSpecContext()
}

type FileSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSpecContext() *FileSpecContext {
	var p = new(FileSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileSpec
	return p
}

func (*FileSpecContext) IsFileSpecContext() {}

func NewFileSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSpecContext {
	var p = new(FileSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileSpec

	return p
}

func (s *FileSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSpecContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *FileSpecContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *FileSpecContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *FileSpecContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *FileSpecContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *FileSpecContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *FileSpecContext) FILENAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILENAME, 0)
}

func (s *FileSpecContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *FileSpecContext) DatabaseFileSpecOption() IDatabaseFileSpecOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseFileSpecOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseFileSpecOptionContext)
}

func (s *FileSpecContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *FileSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileSpec(s)
	}
}

func (s *FileSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileSpec(s)
	}
}

func (s *FileSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileSpec() (localctx IFileSpecContext) {
	this := p
	_ = this

	localctx = NewFileSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, SQLServerStatementParserRULE_fileSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3524)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3525)
		p.Match(SQLServerStatementParserNAME)
	}
	{
		p.SetState(3526)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3527)
		p.IgnoredIdentifier()
	}
	{
		p.SetState(3528)
		p.Match(SQLServerStatementParserCOMMA_)
	}
	{
		p.SetState(3529)
		p.Match(SQLServerStatementParserFILENAME)
	}
	{
		p.SetState(3530)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(3531)
		p.Match(SQLServerStatementParserSTRING_)
	}
	{
		p.SetState(3532)
		p.DatabaseFileSpecOption()
	}
	{
		p.SetState(3533)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IDatabaseFileSpecOptionContext is an interface to support dynamic dispatch.
type IDatabaseFileSpecOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseFileSpecOptionContext differentiates from other interfaces.
	IsDatabaseFileSpecOptionContext()
}

type DatabaseFileSpecOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseFileSpecOptionContext() *DatabaseFileSpecOptionContext {
	var p = new(DatabaseFileSpecOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileSpecOption
	return p
}

func (*DatabaseFileSpecOptionContext) IsDatabaseFileSpecOptionContext() {}

func NewDatabaseFileSpecOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseFileSpecOptionContext {
	var p = new(DatabaseFileSpecOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileSpecOption

	return p
}

func (s *DatabaseFileSpecOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseFileSpecOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DatabaseFileSpecOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DatabaseFileSpecOptionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIZE, 0)
}

func (s *DatabaseFileSpecOptionContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *DatabaseFileSpecOptionContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *DatabaseFileSpecOptionContext) AllNumberLiterals() []INumberLiteralsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem())
	var tst = make([]INumberLiteralsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberLiteralsContext)
		}
	}

	return tst
}

func (s *DatabaseFileSpecOptionContext) NumberLiterals(i int) INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *DatabaseFileSpecOptionContext) MAXSIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXSIZE, 0)
}

func (s *DatabaseFileSpecOptionContext) FILEGROWTH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROWTH, 0)
}

func (s *DatabaseFileSpecOptionContext) UNLIMITED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNLIMITED, 0)
}

func (s *DatabaseFileSpecOptionContext) AllKB() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserKB)
}

func (s *DatabaseFileSpecOptionContext) KB(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKB, i)
}

func (s *DatabaseFileSpecOptionContext) AllMB() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserMB)
}

func (s *DatabaseFileSpecOptionContext) MB(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMB, i)
}

func (s *DatabaseFileSpecOptionContext) AllGB() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserGB)
}

func (s *DatabaseFileSpecOptionContext) GB(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGB, i)
}

func (s *DatabaseFileSpecOptionContext) AllTB() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserTB)
}

func (s *DatabaseFileSpecOptionContext) TB(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTB, i)
}

func (s *DatabaseFileSpecOptionContext) MOD_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOD_, 0)
}

func (s *DatabaseFileSpecOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseFileSpecOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseFileSpecOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseFileSpecOption(s)
	}
}

func (s *DatabaseFileSpecOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseFileSpecOption(s)
	}
}

func (s *DatabaseFileSpecOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseFileSpecOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseFileSpecOption() (localctx IDatabaseFileSpecOptionContext) {
	this := p
	_ = this

	localctx = NewDatabaseFileSpecOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, SQLServerStatementParserRULE_databaseFileSpecOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3542)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 371, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3535)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3536)
			p.Match(SQLServerStatementParserSIZE)
		}
		{
			p.SetState(3537)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3538)
			p.NumberLiterals()
		}
		p.SetState(3540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0 {
			{
				p.SetState(3539)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(3554)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3544)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3545)
			p.Match(SQLServerStatementParserMAXSIZE)
		}
		{
			p.SetState(3546)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(3552)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserMINUS_, SQLServerStatementParserNUMBER_:
			{
				p.SetState(3547)
				p.NumberLiterals()
			}
			p.SetState(3549)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0 {
				{
					p.SetState(3548)
					_la = p.GetTokenStream().LA(1)

					if !(((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case SQLServerStatementParserUNLIMITED:
			{
				p.SetState(3551)
				p.Match(SQLServerStatementParserUNLIMITED)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}
	p.SetState(3563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3556)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3557)
			p.Match(SQLServerStatementParserFILEGROWTH)
		}
		{
			p.SetState(3558)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3559)
			p.NumberLiterals()
		}
		p.SetState(3561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserMOD_ || (((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0) {
			{
				p.SetState(3560)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserMOD_ || (((_la-480)&-(0x1f+1)) == 0 && ((1<<uint((_la-480)))&((1<<(SQLServerStatementParserKB-480))|(1<<(SQLServerStatementParserMB-480))|(1<<(SQLServerStatementParserGB-480))|(1<<(SQLServerStatementParserTB-480)))) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}

	return localctx
}

// IDatabaseFileGroupContext is an interface to support dynamic dispatch.
type IDatabaseFileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseFileGroupContext differentiates from other interfaces.
	IsDatabaseFileGroupContext()
}

type DatabaseFileGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseFileGroupContext() *DatabaseFileGroupContext {
	var p = new(DatabaseFileGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileGroup
	return p
}

func (*DatabaseFileGroupContext) IsDatabaseFileGroupContext() {}

func NewDatabaseFileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseFileGroupContext {
	var p = new(DatabaseFileGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileGroup

	return p
}

func (s *DatabaseFileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseFileGroupContext) FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROUP, 0)
}

func (s *DatabaseFileGroupContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *DatabaseFileGroupContext) AllFileSpec() []IFileSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileSpecContext)(nil)).Elem())
	var tst = make([]IFileSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileSpecContext)
		}
	}

	return tst
}

func (s *DatabaseFileGroupContext) FileSpec(i int) IFileSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileSpecContext)
}

func (s *DatabaseFileGroupContext) DatabaseFileGroupContains() IDatabaseFileGroupContainsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseFileGroupContainsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseFileGroupContainsContext)
}

func (s *DatabaseFileGroupContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DatabaseFileGroupContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DatabaseFileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseFileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseFileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseFileGroup(s)
	}
}

func (s *DatabaseFileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseFileGroup(s)
	}
}

func (s *DatabaseFileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseFileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseFileGroup() (localctx IDatabaseFileGroupContext) {
	this := p
	_ = this

	localctx = NewDatabaseFileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, SQLServerStatementParserRULE_databaseFileGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3565)
		p.Match(SQLServerStatementParserFILEGROUP)
	}
	{
		p.SetState(3566)
		p.IgnoredIdentifier()
	}
	p.SetState(3568)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 377, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3567)
			p.DatabaseFileGroupContains()
		}

	}
	{
		p.SetState(3570)
		p.FileSpec()
	}
	p.SetState(3575)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3571)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3572)
				p.FileSpec()
			}

		}
		p.SetState(3577)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 378, p.GetParserRuleContext())
	}

	return localctx
}

// IDatabaseFileGroupContainsContext is an interface to support dynamic dispatch.
type IDatabaseFileGroupContainsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseFileGroupContainsContext differentiates from other interfaces.
	IsDatabaseFileGroupContainsContext()
}

type DatabaseFileGroupContainsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseFileGroupContainsContext() *DatabaseFileGroupContainsContext {
	var p = new(DatabaseFileGroupContainsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileGroupContains
	return p
}

func (*DatabaseFileGroupContainsContext) IsDatabaseFileGroupContainsContext() {}

func NewDatabaseFileGroupContainsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseFileGroupContainsContext {
	var p = new(DatabaseFileGroupContainsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseFileGroupContains

	return p
}

func (s *DatabaseFileGroupContainsContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseFileGroupContainsContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTAINS, 0)
}

func (s *DatabaseFileGroupContainsContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *DatabaseFileGroupContainsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *DatabaseFileGroupContainsContext) MEMORY_OPTIMIZED_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED_DATA, 0)
}

func (s *DatabaseFileGroupContainsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseFileGroupContainsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseFileGroupContainsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseFileGroupContains(s)
	}
}

func (s *DatabaseFileGroupContainsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseFileGroupContains(s)
	}
}

func (s *DatabaseFileGroupContainsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseFileGroupContains(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseFileGroupContains() (localctx IDatabaseFileGroupContainsContext) {
	this := p
	_ = this

	localctx = NewDatabaseFileGroupContainsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, SQLServerStatementParserRULE_databaseFileGroupContains)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3587)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 381, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserCONTAINS {
			{
				p.SetState(3578)
				p.Match(SQLServerStatementParserCONTAINS)
			}
			{
				p.SetState(3579)
				p.Match(SQLServerStatementParserFILESTREAM)
			}

		}
		p.SetState(3583)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserDEFAULT {
			{
				p.SetState(3582)
				p.Match(SQLServerStatementParserDEFAULT)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3585)
			p.Match(SQLServerStatementParserCONTAINS)
		}
		{
			p.SetState(3586)
			p.Match(SQLServerStatementParserMEMORY_OPTIMIZED_DATA)
		}

	}

	return localctx
}

// IDatabaseLogOnsContext is an interface to support dynamic dispatch.
type IDatabaseLogOnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabaseLogOnsContext differentiates from other interfaces.
	IsDatabaseLogOnsContext()
}

type DatabaseLogOnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseLogOnsContext() *DatabaseLogOnsContext {
	var p = new(DatabaseLogOnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databaseLogOns
	return p
}

func (*DatabaseLogOnsContext) IsDatabaseLogOnsContext() {}

func NewDatabaseLogOnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseLogOnsContext {
	var p = new(DatabaseLogOnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databaseLogOns

	return p
}

func (s *DatabaseLogOnsContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseLogOnsContext) LOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOG, 0)
}

func (s *DatabaseLogOnsContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *DatabaseLogOnsContext) AllFileSpec() []IFileSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileSpecContext)(nil)).Elem())
	var tst = make([]IFileSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileSpecContext)
		}
	}

	return tst
}

func (s *DatabaseLogOnsContext) FileSpec(i int) IFileSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileSpecContext)
}

func (s *DatabaseLogOnsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DatabaseLogOnsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DatabaseLogOnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseLogOnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseLogOnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabaseLogOns(s)
	}
}

func (s *DatabaseLogOnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabaseLogOns(s)
	}
}

func (s *DatabaseLogOnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabaseLogOns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabaseLogOns() (localctx IDatabaseLogOnsContext) {
	this := p
	_ = this

	localctx = NewDatabaseLogOnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, SQLServerStatementParserRULE_databaseLogOns)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3599)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLOG {
		{
			p.SetState(3589)
			p.Match(SQLServerStatementParserLOG)
		}
		{
			p.SetState(3590)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(3591)
			p.FileSpec()
		}
		p.SetState(3596)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3592)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3593)
				p.FileSpec()
			}

			p.SetState(3598)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IDeclareVariableContext is an interface to support dynamic dispatch.
type IDeclareVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareVariableContext differentiates from other interfaces.
	IsDeclareVariableContext()
}

type DeclareVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareVariableContext() *DeclareVariableContext {
	var p = new(DeclareVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_declareVariable
	return p
}

func (*DeclareVariableContext) IsDeclareVariableContext() {}

func NewDeclareVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareVariableContext {
	var p = new(DeclareVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_declareVariable

	return p
}

func (s *DeclareVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareVariableContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDECLARE, 0)
}

func (s *DeclareVariableContext) AllVariable() []IVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableContext)(nil)).Elem())
	var tst = make([]IVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableContext)
		}
	}

	return tst
}

func (s *DeclareVariableContext) Variable(i int) IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *DeclareVariableContext) TableVariable() ITableVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableVariableContext)
}

func (s *DeclareVariableContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *DeclareVariableContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *DeclareVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDeclareVariable(s)
	}
}

func (s *DeclareVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDeclareVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DeclareVariable() (localctx IDeclareVariableContext) {
	this := p
	_ = this

	localctx = NewDeclareVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, SQLServerStatementParserRULE_declareVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3601)
		p.Match(SQLServerStatementParserDECLARE)
	}
	p.SetState(3611)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3602)
			p.Variable()
		}
		p.SetState(3607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3603)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3604)
				p.Variable()
			}

			p.SetState(3609)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(3610)
			p.TableVariable()
		}

	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *VariableContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *VariableContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *VariableContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *VariableContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, SQLServerStatementParserRULE_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3625)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 388, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3613)
			p.VariableName()
		}
		p.SetState(3615)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(3614)
				p.Match(SQLServerStatementParserAS)
			}

		}
		{
			p.SetState(3617)
			p.DataType()
		}
		p.SetState(3620)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 387, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3618)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(3619)
				p.simpleExpr(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3622)
			p.VariableName()
		}
		{
			p.SetState(3623)
			p.Match(SQLServerStatementParserCURSOR)
		}

	}

	return localctx
}

// ITableVariableContext is an interface to support dynamic dispatch.
type ITableVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableVariableContext differentiates from other interfaces.
	IsTableVariableContext()
}

type TableVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableVariableContext() *TableVariableContext {
	var p = new(TableVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableVariable
	return p
}

func (*TableVariableContext) IsTableVariableContext() {}

func NewTableVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableVariableContext {
	var p = new(TableVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableVariable

	return p
}

func (s *TableVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *TableVariableContext) VariTableTypeDefinition() IVariTableTypeDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariTableTypeDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariTableTypeDefinitionContext)
}

func (s *TableVariableContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *TableVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableVariable(s)
	}
}

func (s *TableVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableVariable(s)
	}
}

func (s *TableVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableVariable() (localctx ITableVariableContext) {
	this := p
	_ = this

	localctx = NewTableVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, SQLServerStatementParserRULE_tableVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3627)
		p.VariableName()
	}
	p.SetState(3629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAS {
		{
			p.SetState(3628)
			p.Match(SQLServerStatementParserAS)
		}

	}
	{
		p.SetState(3631)
		p.VariTableTypeDefinition()
	}

	return localctx
}

// IVariTableTypeDefinitionContext is an interface to support dynamic dispatch.
type IVariTableTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariTableTypeDefinitionContext differentiates from other interfaces.
	IsVariTableTypeDefinitionContext()
}

type VariTableTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariTableTypeDefinitionContext() *VariTableTypeDefinitionContext {
	var p = new(VariTableTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variTableTypeDefinition
	return p
}

func (*VariTableTypeDefinitionContext) IsVariTableTypeDefinitionContext() {}

func NewVariTableTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariTableTypeDefinitionContext {
	var p = new(VariTableTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variTableTypeDefinition

	return p
}

func (s *VariTableTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariTableTypeDefinitionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *VariTableTypeDefinitionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *VariTableTypeDefinitionContext) AllTableVariableClause() []ITableVariableClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableVariableClauseContext)(nil)).Elem())
	var tst = make([]ITableVariableClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableVariableClauseContext)
		}
	}

	return tst
}

func (s *VariTableTypeDefinitionContext) TableVariableClause(i int) ITableVariableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableVariableClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableVariableClauseContext)
}

func (s *VariTableTypeDefinitionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *VariTableTypeDefinitionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *VariTableTypeDefinitionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *VariTableTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariTableTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariTableTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariTableTypeDefinition(s)
	}
}

func (s *VariTableTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariTableTypeDefinition(s)
	}
}

func (s *VariTableTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariTableTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) VariTableTypeDefinition() (localctx IVariTableTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewVariTableTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, SQLServerStatementParserRULE_variTableTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3633)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(3634)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(3635)
		p.TableVariableClause()
	}
	p.SetState(3640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(3636)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(3637)
			p.TableVariableClause()
		}

		p.SetState(3642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3643)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ITableVariableClauseContext is an interface to support dynamic dispatch.
type ITableVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableVariableClauseContext differentiates from other interfaces.
	IsTableVariableClauseContext()
}

type TableVariableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableVariableClauseContext() *TableVariableClauseContext {
	var p = new(TableVariableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableVariableClause
	return p
}

func (*TableVariableClauseContext) IsTableVariableClauseContext() {}

func NewTableVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableVariableClauseContext {
	var p = new(TableVariableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableVariableClause

	return p
}

func (s *TableVariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableVariableClauseContext) VariableTableColumnDefinition() IVariableTableColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableTableColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableTableColumnDefinitionContext)
}

func (s *TableVariableClauseContext) VariableTableConstraint() IVariableTableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableTableConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableTableConstraintContext)
}

func (s *TableVariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableVariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableVariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableVariableClause(s)
	}
}

func (s *TableVariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableVariableClause(s)
	}
}

func (s *TableVariableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableVariableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableVariableClause() (localctx ITableVariableClauseContext) {
	this := p
	_ = this

	localctx = NewTableVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, SQLServerStatementParserRULE_tableVariableClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3647)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3645)
			p.VariableTableColumnDefinition()
		}

	case SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE, SQLServerStatementParserCHECK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3646)
			p.VariableTableConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableTableColumnDefinitionContext is an interface to support dynamic dispatch.
type IVariableTableColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTableColumnDefinitionContext differentiates from other interfaces.
	IsVariableTableColumnDefinitionContext()
}

type VariableTableColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTableColumnDefinitionContext() *VariableTableColumnDefinitionContext {
	var p = new(VariableTableColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variableTableColumnDefinition
	return p
}

func (*VariableTableColumnDefinitionContext) IsVariableTableColumnDefinitionContext() {}

func NewVariableTableColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTableColumnDefinitionContext {
	var p = new(VariableTableColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variableTableColumnDefinition

	return p
}

func (s *VariableTableColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTableColumnDefinitionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *VariableTableColumnDefinitionContext) VariableTableColumnConstraint() IVariableTableColumnConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableTableColumnConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableTableColumnConstraintContext)
}

func (s *VariableTableColumnDefinitionContext) DataTypeName() IDataTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *VariableTableColumnDefinitionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *VariableTableColumnDefinitionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *VariableTableColumnDefinitionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VariableTableColumnDefinitionContext) IDENTITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTITY, 0)
}

func (s *VariableTableColumnDefinitionContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *VariableTableColumnDefinitionContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *VariableTableColumnDefinitionContext) ROWGUIDCOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROWGUIDCOL, 0)
}

func (s *VariableTableColumnDefinitionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *VariableTableColumnDefinitionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *VariableTableColumnDefinitionContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNUMBER_)
}

func (s *VariableTableColumnDefinitionContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, i)
}

func (s *VariableTableColumnDefinitionContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, 0)
}

func (s *VariableTableColumnDefinitionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *VariableTableColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTableColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTableColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariableTableColumnDefinition(s)
	}
}

func (s *VariableTableColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariableTableColumnDefinition(s)
	}
}

func (s *VariableTableColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariableTableColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) VariableTableColumnDefinition() (localctx IVariableTableColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewVariableTableColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, SQLServerStatementParserRULE_variableTableColumnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3649)
		p.ColumnName()
	}
	p.SetState(3653)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCHAR, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserINTEGER, SQLServerStatementParserREAL, SQLServerStatementParserDECIMAL, SQLServerStatementParserBIT, SQLServerStatementParserSMALLINT, SQLServerStatementParserINT, SQLServerStatementParserTINYINT, SQLServerStatementParserNUMERIC, SQLServerStatementParserFLOAT, SQLServerStatementParserBIGINT, SQLServerStatementParserTEXT, SQLServerStatementParserVARCHAR, SQLServerStatementParserBINARY, SQLServerStatementParserXML, SQLServerStatementParserMONEY, SQLServerStatementParserSMALLMONEY, SQLServerStatementParserDATETIMEOFFSET, SQLServerStatementParserDATETIME, SQLServerStatementParserDATETIME2, SQLServerStatementParserSMALLDATETIME, SQLServerStatementParserNCHAR, SQLServerStatementParserNVARCHAR, SQLServerStatementParserNTEXT, SQLServerStatementParserVARBINARY, SQLServerStatementParserIMAGE, SQLServerStatementParserSQL_VARIANT, SQLServerStatementParserUNIQUEIDENTIFIER, SQLServerStatementParserHIERARCHYID, SQLServerStatementParserGEOMETRY, SQLServerStatementParserGEOGRAPHY, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(3650)
			p.DataTypeName()
		}

	case SQLServerStatementParserAS:
		{
			p.SetState(3651)
			p.Match(SQLServerStatementParserAS)
		}
		{
			p.SetState(3652)
			p.expr(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOLLATE {
		{
			p.SetState(3655)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(3656)
			p.CollationName()
		}

	}
	p.SetState(3671)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserRP_, SQLServerStatementParserCOMMA_, SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE, SQLServerStatementParserWITH, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserDEFAULT, SQLServerStatementParserCHECK, SQLServerStatementParserROWGUIDCOL:
		p.SetState(3661)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserDEFAULT {
			{
				p.SetState(3659)
				p.Match(SQLServerStatementParserDEFAULT)
			}
			{
				p.SetState(3660)
				p.expr(0)
			}

		}

	case SQLServerStatementParserIDENTITY:
		{
			p.SetState(3663)
			p.Match(SQLServerStatementParserIDENTITY)
		}
		p.SetState(3669)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(3664)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(3665)
				p.Match(SQLServerStatementParserNUMBER_)
			}
			{
				p.SetState(3666)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3667)
				p.Match(SQLServerStatementParserNUMBER_)
			}
			{
				p.SetState(3668)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(3674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserROWGUIDCOL {
		{
			p.SetState(3673)
			p.Match(SQLServerStatementParserROWGUIDCOL)
		}

	}
	{
		p.SetState(3676)
		p.VariableTableColumnConstraint()
	}

	return localctx
}

// IVariableTableColumnConstraintContext is an interface to support dynamic dispatch.
type IVariableTableColumnConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTableColumnConstraintContext differentiates from other interfaces.
	IsVariableTableColumnConstraintContext()
}

type VariableTableColumnConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTableColumnConstraintContext() *VariableTableColumnConstraintContext {
	var p = new(VariableTableColumnConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variableTableColumnConstraint
	return p
}

func (*VariableTableColumnConstraintContext) IsVariableTableColumnConstraintContext() {}

func NewVariableTableColumnConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTableColumnConstraintContext {
	var p = new(VariableTableColumnConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variableTableColumnConstraint

	return p
}

func (s *VariableTableColumnConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTableColumnConstraintContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, 0)
}

func (s *VariableTableColumnConstraintContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *VariableTableColumnConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRIMARY, 0)
}

func (s *VariableTableColumnConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *VariableTableColumnConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUE, 0)
}

func (s *VariableTableColumnConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *VariableTableColumnConstraintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *VariableTableColumnConstraintContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VariableTableColumnConstraintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *VariableTableColumnConstraintContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *VariableTableColumnConstraintContext) IndexOption() IIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *VariableTableColumnConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTableColumnConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTableColumnConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariableTableColumnConstraint(s)
	}
}

func (s *VariableTableColumnConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariableTableColumnConstraint(s)
	}
}

func (s *VariableTableColumnConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariableTableColumnConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) VariableTableColumnConstraint() (localctx IVariableTableColumnConstraintContext) {
	this := p
	_ = this

	localctx = NewVariableTableColumnConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, SQLServerStatementParserRULE_variableTableColumnConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3681)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserNULL:
			{
				p.SetState(3678)
				p.Match(SQLServerStatementParserNULL)
			}

		case SQLServerStatementParserNOT:
			{
				p.SetState(3679)
				p.Match(SQLServerStatementParserNOT)
			}
			{
				p.SetState(3680)
				p.Match(SQLServerStatementParserNULL)
			}

		case SQLServerStatementParserRP_, SQLServerStatementParserCOMMA_:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3686)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserPRIMARY:
			{
				p.SetState(3683)
				p.Match(SQLServerStatementParserPRIMARY)
			}
			{
				p.SetState(3684)
				p.Match(SQLServerStatementParserKEY)
			}

		case SQLServerStatementParserUNIQUE:
			{
				p.SetState(3685)
				p.Match(SQLServerStatementParserUNIQUE)
			}

		case SQLServerStatementParserRP_, SQLServerStatementParserCOMMA_:

		default:
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3688)
			p.Match(SQLServerStatementParserCHECK)
		}
		{
			p.SetState(3689)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3690)
			p.expr(0)
		}
		{
			p.SetState(3691)
			p.Match(SQLServerStatementParserRP_)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3693)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3694)
			p.IndexOption()
		}

	}

	return localctx
}

// IVariableTableConstraintContext is an interface to support dynamic dispatch.
type IVariableTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableTableConstraintContext differentiates from other interfaces.
	IsVariableTableConstraintContext()
}

type VariableTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableTableConstraintContext() *VariableTableConstraintContext {
	var p = new(VariableTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_variableTableConstraint
	return p
}

func (*VariableTableConstraintContext) IsVariableTableConstraintContext() {}

func NewVariableTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableTableConstraintContext {
	var p = new(VariableTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_variableTableConstraint

	return p
}

func (s *VariableTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableTableConstraintContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *VariableTableConstraintContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *VariableTableConstraintContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *VariableTableConstraintContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *VariableTableConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRIMARY, 0)
}

func (s *VariableTableConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *VariableTableConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNIQUE, 0)
}

func (s *VariableTableConstraintContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *VariableTableConstraintContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *VariableTableConstraintContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *VariableTableConstraintContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VariableTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterVariableTableConstraint(s)
	}
}

func (s *VariableTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitVariableTableConstraint(s)
	}
}

func (s *VariableTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitVariableTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) VariableTableConstraint() (localctx IVariableTableConstraintContext) {
	this := p
	_ = this

	localctx = NewVariableTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, SQLServerStatementParserRULE_variableTableConstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3715)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPRIMARY, SQLServerStatementParserUNIQUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3700)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserPRIMARY:
			{
				p.SetState(3697)
				p.Match(SQLServerStatementParserPRIMARY)
			}
			{
				p.SetState(3698)
				p.Match(SQLServerStatementParserKEY)
			}

		case SQLServerStatementParserUNIQUE:
			{
				p.SetState(3699)
				p.Match(SQLServerStatementParserUNIQUE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(3702)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3703)
			p.ColumnName()
		}
		p.SetState(3708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3704)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3705)
				p.ColumnName()
			}

			p.SetState(3710)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3711)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserCHECK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3713)
			p.Match(SQLServerStatementParserCHECK)
		}
		{
			p.SetState(3714)
			p.expr(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISetVariableContext is an interface to support dynamic dispatch.
type ISetVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetVariableContext differentiates from other interfaces.
	IsSetVariableContext()
}

type SetVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVariableContext() *SetVariableContext {
	var p = new(SetVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setVariable
	return p
}

func (*SetVariableContext) IsSetVariableContext() {}

func NewSetVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVariableContext {
	var p = new(SetVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setVariable

	return p
}

func (s *SetVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVariableContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *SetVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *SetVariableContext) SetVariableClause() ISetVariableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetVariableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetVariableClauseContext)
}

func (s *SetVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetVariable(s)
	}
}

func (s *SetVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetVariable(s)
	}
}

func (s *SetVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetVariable() (localctx ISetVariableContext) {
	this := p
	_ = this

	localctx = NewSetVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, SQLServerStatementParserRULE_setVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3717)
		p.Match(SQLServerStatementParserSET)
	}
	{
		p.SetState(3718)
		p.VariableName()
	}
	{
		p.SetState(3719)
		p.SetVariableClause()
	}

	return localctx
}

// ISetVariableClauseContext is an interface to support dynamic dispatch.
type ISetVariableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetVariableClauseContext differentiates from other interfaces.
	IsSetVariableClauseContext()
}

type SetVariableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVariableClauseContext() *SetVariableClauseContext {
	var p = new(SetVariableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setVariableClause
	return p
}

func (*SetVariableClauseContext) IsSetVariableClauseContext() {}

func NewSetVariableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVariableClauseContext {
	var p = new(SetVariableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setVariableClause

	return p
}

func (s *SetVariableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVariableClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SetVariableClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetVariableClauseContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *SetVariableClauseContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetVariableClauseContext) AllDOT_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDOT_)
}

func (s *SetVariableClauseContext) DOT_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, i)
}

func (s *SetVariableClauseContext) NCHAR_TEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNCHAR_TEXT, 0)
}

func (s *SetVariableClauseContext) CompoundOperation() ICompoundOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundOperationContext)
}

func (s *SetVariableClauseContext) CursorVariable() ICursorVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursorVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursorVariableContext)
}

func (s *SetVariableClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *SetVariableClauseContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *SetVariableClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *SetVariableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetVariableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetVariableClause(s)
	}
}

func (s *SetVariableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetVariableClause(s)
	}
}

func (s *SetVariableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetVariableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetVariableClause() (localctx ISetVariableClauseContext) {
	this := p
	_ = this

	localctx = NewSetVariableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, SQLServerStatementParserRULE_setVariableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3744)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserDOT_ {
			{
				p.SetState(3721)
				p.Match(SQLServerStatementParserDOT_)
			}
			{
				p.SetState(3722)
				p.Identifier()
			}

		}
		{
			p.SetState(3725)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(3732)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 405, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3726)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(3727)
				p.Identifier()
			}
			{
				p.SetState(3728)
				p.Match(SQLServerStatementParserDOT_)
			}
			{
				p.SetState(3729)
				p.Identifier()
			}

		case 3:
			{
				p.SetState(3731)
				p.Match(SQLServerStatementParserNCHAR_TEXT)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3734)
			p.CompoundOperation()
		}
		{
			p.SetState(3735)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3737)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3738)
			p.CursorVariable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3739)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3740)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(3741)
			p.Select()
		}
		{
			p.SetState(3742)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// ICursorVariableContext is an interface to support dynamic dispatch.
type ICursorVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursorVariableContext differentiates from other interfaces.
	IsCursorVariableContext()
}

type CursorVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorVariableContext() *CursorVariableContext {
	var p = new(CursorVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_cursorVariable
	return p
}

func (*CursorVariableContext) IsCursorVariableContext() {}

func NewCursorVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorVariableContext {
	var p = new(CursorVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_cursorVariable

	return p
}

func (s *CursorVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *CursorVariableContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR, 0)
}

func (s *CursorVariableContext) CursorClause() ICursorClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursorClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursorClauseContext)
}

func (s *CursorVariableContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserFOR)
}

func (s *CursorVariableContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, i)
}

func (s *CursorVariableContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CursorVariableContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *CursorVariableContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *CursorVariableContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOF, 0)
}

func (s *CursorVariableContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *CursorVariableContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CursorVariableContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CursorVariableContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CursorVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCursorVariable(s)
	}
}

func (s *CursorVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCursorVariable(s)
	}
}

func (s *CursorVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCursorVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CursorVariable() (localctx ICursorVariableContext) {
	this := p
	_ = this

	localctx = NewCursorVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, SQLServerStatementParserRULE_cursorVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3765)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserAT_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3746)
			p.VariableName()
		}

	case SQLServerStatementParserCURSOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3747)
			p.Match(SQLServerStatementParserCURSOR)
		}
		{
			p.SetState(3748)
			p.CursorClause()
		}
		{
			p.SetState(3749)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(3750)
			p.Select()
		}

		{
			p.SetState(3751)
			p.Match(SQLServerStatementParserFOR)
		}
		p.SetState(3763)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserREAD_ONLY:
			{
				p.SetState(3752)
				p.Match(SQLServerStatementParserREAD_ONLY)
			}

		case SQLServerStatementParserUPDATE:
			{
				p.SetState(3753)
				p.Match(SQLServerStatementParserUPDATE)
			}

			{
				p.SetState(3754)
				p.Match(SQLServerStatementParserOF)
			}
			{
				p.SetState(3755)
				p.Name()
			}
			p.SetState(3760)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(3756)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(3757)
					p.Name()
				}

				p.SetState(3762)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICursorClauseContext is an interface to support dynamic dispatch.
type ICursorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursorClauseContext differentiates from other interfaces.
	IsCursorClauseContext()
}

type CursorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorClauseContext() *CursorClauseContext {
	var p = new(CursorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_cursorClause
	return p
}

func (*CursorClauseContext) IsCursorClauseContext() {}

func NewCursorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorClauseContext {
	var p = new(CursorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_cursorClause

	return p
}

func (s *CursorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorClauseContext) TYPE_WARNING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE_WARNING, 0)
}

func (s *CursorClauseContext) FORWARD_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORWARD_ONLY, 0)
}

func (s *CursorClauseContext) SCROLL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCROLL, 0)
}

func (s *CursorClauseContext) STATIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATIC, 0)
}

func (s *CursorClauseContext) KEYSET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEYSET, 0)
}

func (s *CursorClauseContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDYNAMIC, 0)
}

func (s *CursorClauseContext) FAST_FORWARD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFAST_FORWARD, 0)
}

func (s *CursorClauseContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *CursorClauseContext) SCROLL_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCROLL_LOCKS, 0)
}

func (s *CursorClauseContext) OPTIMISTIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMISTIC, 0)
}

func (s *CursorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCursorClause(s)
	}
}

func (s *CursorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCursorClause(s)
	}
}

func (s *CursorClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCursorClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CursorClause() (localctx ICursorClauseContext) {
	this := p
	_ = this

	localctx = NewCursorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, SQLServerStatementParserRULE_cursorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3768)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFORWARD_ONLY || _la == SQLServerStatementParserSCROLL {
		{
			p.SetState(3767)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserFORWARD_ONLY || _la == SQLServerStatementParserSCROLL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3771)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-492)&-(0x1f+1)) == 0 && ((1<<uint((_la-492)))&((1<<(SQLServerStatementParserSTATIC-492))|(1<<(SQLServerStatementParserKEYSET-492))|(1<<(SQLServerStatementParserDYNAMIC-492))|(1<<(SQLServerStatementParserFAST_FORWARD-492)))) != 0 {
		{
			p.SetState(3770)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-492)&-(0x1f+1)) == 0 && ((1<<uint((_la-492)))&((1<<(SQLServerStatementParserSTATIC-492))|(1<<(SQLServerStatementParserKEYSET-492))|(1<<(SQLServerStatementParserDYNAMIC-492))|(1<<(SQLServerStatementParserFAST_FORWARD-492)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserSCROLL_LOCKS || _la == SQLServerStatementParserOPTIMISTIC {
		{
			p.SetState(3773)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserSCROLL_LOCKS || _la == SQLServerStatementParserOPTIMISTIC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3777)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserTYPE_WARNING {
		{
			p.SetState(3776)
			p.Match(SQLServerStatementParserTYPE_WARNING)
		}

	}

	return localctx
}

// ICompoundOperationContext is an interface to support dynamic dispatch.
type ICompoundOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundOperationContext differentiates from other interfaces.
	IsCompoundOperationContext()
}

type CompoundOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundOperationContext() *CompoundOperationContext {
	var p = new(CompoundOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_compoundOperation
	return p
}

func (*CompoundOperationContext) IsCompoundOperationContext() {}

func NewCompoundOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundOperationContext {
	var p = new(CompoundOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_compoundOperation

	return p
}

func (s *CompoundOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundOperationContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPLUS_, 0)
}

func (s *CompoundOperationContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *CompoundOperationContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUS_, 0)
}

func (s *CompoundOperationContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASTERISK_, 0)
}

func (s *CompoundOperationContext) SLASH_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSLASH_, 0)
}

func (s *CompoundOperationContext) MOD_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMOD_, 0)
}

func (s *CompoundOperationContext) AMPERSAND_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAMPERSAND_, 0)
}

func (s *CompoundOperationContext) CARET_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCARET_, 0)
}

func (s *CompoundOperationContext) VERTICAL_BAR_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVERTICAL_BAR_, 0)
}

func (s *CompoundOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCompoundOperation(s)
	}
}

func (s *CompoundOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCompoundOperation(s)
	}
}

func (s *CompoundOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCompoundOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CompoundOperation() (localctx ICompoundOperationContext) {
	this := p
	_ = this

	localctx = NewCompoundOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, SQLServerStatementParserRULE_compoundOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3795)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPLUS_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3779)
			p.Match(SQLServerStatementParserPLUS_)
		}
		{
			p.SetState(3780)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserMINUS_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3781)
			p.Match(SQLServerStatementParserMINUS_)
		}
		{
			p.SetState(3782)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserASTERISK_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3783)
			p.Match(SQLServerStatementParserASTERISK_)
		}
		{
			p.SetState(3784)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserSLASH_:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3785)
			p.Match(SQLServerStatementParserSLASH_)
		}
		{
			p.SetState(3786)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserMOD_:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3787)
			p.Match(SQLServerStatementParserMOD_)
		}
		{
			p.SetState(3788)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserAMPERSAND_:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3789)
			p.Match(SQLServerStatementParserAMPERSAND_)
		}
		{
			p.SetState(3790)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserCARET_:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3791)
			p.Match(SQLServerStatementParserCARET_)
		}
		{
			p.SetState(3792)
			p.Match(SQLServerStatementParserEQ_)
		}

	case SQLServerStatementParserVERTICAL_BAR_:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3793)
			p.Match(SQLServerStatementParserVERTICAL_BAR_)
		}
		{
			p.SetState(3794)
			p.Match(SQLServerStatementParserEQ_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFuncParametersContext is an interface to support dynamic dispatch.
type IFuncParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncParametersContext differentiates from other interfaces.
	IsFuncParametersContext()
}

type FuncParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncParametersContext() *FuncParametersContext {
	var p = new(FuncParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_funcParameters
	return p
}

func (*FuncParametersContext) IsFuncParametersContext() {}

func NewFuncParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncParametersContext {
	var p = new(FuncParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_funcParameters

	return p
}

func (s *FuncParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncParametersContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *FuncParametersContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *FuncParametersContext) AllVariableName() []IVariableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableNameContext)(nil)).Elem())
	var tst = make([]IVariableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableNameContext)
		}
	}

	return tst
}

func (s *FuncParametersContext) VariableName(i int) IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *FuncParametersContext) AllDataType() []IDataTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeContext)(nil)).Elem())
	var tst = make([]IDataTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeContext)
		}
	}

	return tst
}

func (s *FuncParametersContext) DataType(i int) IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FuncParametersContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserAS)
}

func (s *FuncParametersContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, i)
}

func (s *FuncParametersContext) AllOwner() []IOwnerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwnerContext)(nil)).Elem())
	var tst = make([]IOwnerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwnerContext)
		}
	}

	return tst
}

func (s *FuncParametersContext) Owner(i int) IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *FuncParametersContext) AllDOT_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDOT_)
}

func (s *FuncParametersContext) DOT_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, i)
}

func (s *FuncParametersContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *FuncParametersContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *FuncParametersContext) AllIgnoredIdentifier() []IIgnoredIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem())
	var tst = make([]IIgnoredIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIgnoredIdentifierContext)
		}
	}

	return tst
}

func (s *FuncParametersContext) IgnoredIdentifier(i int) IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *FuncParametersContext) AllREADONLY() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserREADONLY)
}

func (s *FuncParametersContext) READONLY(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREADONLY, i)
}

func (s *FuncParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFuncParameters(s)
	}
}

func (s *FuncParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFuncParameters(s)
	}
}

func (s *FuncParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFuncParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FuncParameters() (localctx IFuncParametersContext) {
	this := p
	_ = this

	localctx = NewFuncParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, SQLServerStatementParserRULE_funcParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3797)
		p.Match(SQLServerStatementParserLP_)
	}
	p.SetState(3817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserAT_ {
		{
			p.SetState(3798)
			p.VariableName()
		}
		p.SetState(3800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserAS {
			{
				p.SetState(3799)
				p.Match(SQLServerStatementParserAS)
			}

		}
		p.SetState(3805)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 416, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3802)
				p.Owner()
			}
			{
				p.SetState(3803)
				p.Match(SQLServerStatementParserDOT_)
			}

		}
		{
			p.SetState(3807)
			p.DataType()
		}
		p.SetState(3810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEQ_ {
			{
				p.SetState(3808)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(3809)
				p.IgnoredIdentifier()
			}

		}
		p.SetState(3813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserREADONLY {
			{
				p.SetState(3812)
				p.Match(SQLServerStatementParserREADONLY)
			}

		}

		p.SetState(3819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3820)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IFuncReturnsContext is an interface to support dynamic dispatch.
type IFuncReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncReturnsContext differentiates from other interfaces.
	IsFuncReturnsContext()
}

type FuncReturnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncReturnsContext() *FuncReturnsContext {
	var p = new(FuncReturnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_funcReturns
	return p
}

func (*FuncReturnsContext) IsFuncReturnsContext() {}

func NewFuncReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncReturnsContext {
	var p = new(FuncReturnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_funcReturns

	return p
}

func (s *FuncReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncReturnsContext) FuncScalarReturn() IFuncScalarReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncScalarReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncScalarReturnContext)
}

func (s *FuncReturnsContext) FuncInlineReturn() IFuncInlineReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncInlineReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncInlineReturnContext)
}

func (s *FuncReturnsContext) FuncMutiReturn() IFuncMutiReturnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFuncMutiReturnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFuncMutiReturnContext)
}

func (s *FuncReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFuncReturns(s)
	}
}

func (s *FuncReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFuncReturns(s)
	}
}

func (s *FuncReturnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFuncReturns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FuncReturns() (localctx IFuncReturnsContext) {
	this := p
	_ = this

	localctx = NewFuncReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, SQLServerStatementParserRULE_funcReturns)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3825)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3822)
			p.FuncScalarReturn()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3823)
			p.FuncInlineReturn()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3824)
			p.FuncMutiReturn()
		}

	}

	return localctx
}

// IFuncMutiReturnContext is an interface to support dynamic dispatch.
type IFuncMutiReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncMutiReturnContext differentiates from other interfaces.
	IsFuncMutiReturnContext()
}

type FuncMutiReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncMutiReturnContext() *FuncMutiReturnContext {
	var p = new(FuncMutiReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_funcMutiReturn
	return p
}

func (*FuncMutiReturnContext) IsFuncMutiReturnContext() {}

func NewFuncMutiReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncMutiReturnContext {
	var p = new(FuncMutiReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_funcMutiReturn

	return p
}

func (s *FuncMutiReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncMutiReturnContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURNS, 0)
}

func (s *FuncMutiReturnContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *FuncMutiReturnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *FuncMutiReturnContext) CreateTableDefinitions() ICreateTableDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableDefinitionsContext)
}

func (s *FuncMutiReturnContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBEGIN, 0)
}

func (s *FuncMutiReturnContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FuncMutiReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURN, 0)
}

func (s *FuncMutiReturnContext) END() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEND, 0)
}

func (s *FuncMutiReturnContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *FuncMutiReturnContext) AllFunctionOption() []IFunctionOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem())
	var tst = make([]IFunctionOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionOptionContext)
		}
	}

	return tst
}

func (s *FuncMutiReturnContext) FunctionOption(i int) IFunctionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionOptionContext)
}

func (s *FuncMutiReturnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *FuncMutiReturnContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *FuncMutiReturnContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *FuncMutiReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncMutiReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncMutiReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFuncMutiReturn(s)
	}
}

func (s *FuncMutiReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFuncMutiReturn(s)
	}
}

func (s *FuncMutiReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFuncMutiReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FuncMutiReturn() (localctx IFuncMutiReturnContext) {
	this := p
	_ = this

	localctx = NewFuncMutiReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, SQLServerStatementParserRULE_funcMutiReturn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3827)
		p.Match(SQLServerStatementParserRETURNS)
	}
	{
		p.SetState(3828)
		p.VariableName()
	}
	{
		p.SetState(3829)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(3830)
		p.CreateTableDefinitions()
	}
	p.SetState(3840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3831)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3832)
			p.FunctionOption()
		}
		p.SetState(3837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3833)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3834)
				p.FunctionOption()
			}

			p.SetState(3839)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAS {
		{
			p.SetState(3842)
			p.Match(SQLServerStatementParserAS)
		}

	}
	{
		p.SetState(3845)
		p.Match(SQLServerStatementParserBEGIN)
	}
	{
		p.SetState(3846)
		p.CompoundStatement()
	}
	{
		p.SetState(3847)
		p.Match(SQLServerStatementParserRETURN)
	}
	{
		p.SetState(3848)
		p.Match(SQLServerStatementParserEND)
	}

	return localctx
}

// IFuncInlineReturnContext is an interface to support dynamic dispatch.
type IFuncInlineReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncInlineReturnContext differentiates from other interfaces.
	IsFuncInlineReturnContext()
}

type FuncInlineReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncInlineReturnContext() *FuncInlineReturnContext {
	var p = new(FuncInlineReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_funcInlineReturn
	return p
}

func (*FuncInlineReturnContext) IsFuncInlineReturnContext() {}

func NewFuncInlineReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncInlineReturnContext {
	var p = new(FuncInlineReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_funcInlineReturn

	return p
}

func (s *FuncInlineReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncInlineReturnContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURNS, 0)
}

func (s *FuncInlineReturnContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *FuncInlineReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURN, 0)
}

func (s *FuncInlineReturnContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *FuncInlineReturnContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *FuncInlineReturnContext) AllFunctionOption() []IFunctionOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem())
	var tst = make([]IFunctionOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionOptionContext)
		}
	}

	return tst
}

func (s *FuncInlineReturnContext) FunctionOption(i int) IFunctionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionOptionContext)
}

func (s *FuncInlineReturnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *FuncInlineReturnContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *FuncInlineReturnContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *FuncInlineReturnContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *FuncInlineReturnContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *FuncInlineReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncInlineReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncInlineReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFuncInlineReturn(s)
	}
}

func (s *FuncInlineReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFuncInlineReturn(s)
	}
}

func (s *FuncInlineReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFuncInlineReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FuncInlineReturn() (localctx IFuncInlineReturnContext) {
	this := p
	_ = this

	localctx = NewFuncInlineReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, SQLServerStatementParserRULE_funcInlineReturn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3850)
		p.Match(SQLServerStatementParserRETURNS)
	}
	{
		p.SetState(3851)
		p.Match(SQLServerStatementParserTABLE)
	}
	p.SetState(3861)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3852)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3853)
			p.FunctionOption()
		}
		p.SetState(3858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3854)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3855)
				p.FunctionOption()
			}

			p.SetState(3860)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3864)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAS {
		{
			p.SetState(3863)
			p.Match(SQLServerStatementParserAS)
		}

	}
	{
		p.SetState(3866)
		p.Match(SQLServerStatementParserRETURN)
	}
	p.SetState(3868)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(3867)
			p.Match(SQLServerStatementParserLP_)
		}

	}
	{
		p.SetState(3870)
		p.Select()
	}
	p.SetState(3872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserRP_ {
		{
			p.SetState(3871)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IFuncScalarReturnContext is an interface to support dynamic dispatch.
type IFuncScalarReturnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncScalarReturnContext differentiates from other interfaces.
	IsFuncScalarReturnContext()
}

type FuncScalarReturnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncScalarReturnContext() *FuncScalarReturnContext {
	var p = new(FuncScalarReturnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_funcScalarReturn
	return p
}

func (*FuncScalarReturnContext) IsFuncScalarReturnContext() {}

func NewFuncScalarReturnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncScalarReturnContext {
	var p = new(FuncScalarReturnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_funcScalarReturn

	return p
}

func (s *FuncScalarReturnContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncScalarReturnContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURNS, 0)
}

func (s *FuncScalarReturnContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FuncScalarReturnContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBEGIN, 0)
}

func (s *FuncScalarReturnContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FuncScalarReturnContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURN, 0)
}

func (s *FuncScalarReturnContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FuncScalarReturnContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *FuncScalarReturnContext) AllFunctionOption() []IFunctionOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem())
	var tst = make([]IFunctionOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionOptionContext)
		}
	}

	return tst
}

func (s *FuncScalarReturnContext) FunctionOption(i int) IFunctionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionOptionContext)
}

func (s *FuncScalarReturnContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *FuncScalarReturnContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *FuncScalarReturnContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *FuncScalarReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncScalarReturnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncScalarReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFuncScalarReturn(s)
	}
}

func (s *FuncScalarReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFuncScalarReturn(s)
	}
}

func (s *FuncScalarReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFuncScalarReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FuncScalarReturn() (localctx IFuncScalarReturnContext) {
	this := p
	_ = this

	localctx = NewFuncScalarReturnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, SQLServerStatementParserRULE_funcScalarReturn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3874)
		p.Match(SQLServerStatementParserRETURNS)
	}
	{
		p.SetState(3875)
		p.DataType()
	}
	p.SetState(3885)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3876)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(3877)
			p.FunctionOption()
		}
		p.SetState(3882)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3878)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3879)
				p.FunctionOption()
			}

			p.SetState(3884)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3888)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAS {
		{
			p.SetState(3887)
			p.Match(SQLServerStatementParserAS)
		}

	}
	{
		p.SetState(3890)
		p.Match(SQLServerStatementParserBEGIN)
	}
	{
		p.SetState(3891)
		p.CompoundStatement()
	}
	{
		p.SetState(3892)
		p.Match(SQLServerStatementParserRETURN)
	}
	{
		p.SetState(3893)
		p.expr(0)
	}

	return localctx
}

// ITableTypeDefinitionContext is an interface to support dynamic dispatch.
type ITableTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableTypeDefinitionContext differentiates from other interfaces.
	IsTableTypeDefinitionContext()
}

type TableTypeDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableTypeDefinitionContext() *TableTypeDefinitionContext {
	var p = new(TableTypeDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_tableTypeDefinition
	return p
}

func (*TableTypeDefinitionContext) IsTableTypeDefinitionContext() {}

func NewTableTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableTypeDefinitionContext {
	var p = new(TableTypeDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_tableTypeDefinition

	return p
}

func (s *TableTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableTypeDefinitionContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableTypeDefinitionContext) ColumnConstraint() IColumnConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnConstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintContext)
}

func (s *TableTypeDefinitionContext) ComputedColumnDefinition() IComputedColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComputedColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComputedColumnDefinitionContext)
}

func (s *TableTypeDefinitionContext) AllTableConstraint() []ITableConstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem())
	var tst = make([]ITableConstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableConstraintContext)
		}
	}

	return tst
}

func (s *TableTypeDefinitionContext) TableConstraint(i int) ITableConstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableConstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableConstraintContext)
}

func (s *TableTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTableTypeDefinition(s)
	}
}

func (s *TableTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTableTypeDefinition(s)
	}
}

func (s *TableTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTableTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TableTypeDefinition() (localctx ITableTypeDefinitionContext) {
	this := p
	_ = this

	localctx = NewTableTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, SQLServerStatementParserRULE_tableTypeDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3899)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 432, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3895)
			p.ColumnDefinition()
		}
		{
			p.SetState(3896)
			p.ColumnConstraint()
		}

	case 2:
		{
			p.SetState(3898)
			p.ComputedColumnDefinition()
		}

	}
	p.SetState(3904)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserLP_ || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(SQLServerStatementParserCONSTRAINT-61))|(1<<(SQLServerStatementParserPRIMARY-61))|(1<<(SQLServerStatementParserUNIQUE-61))|(1<<(SQLServerStatementParserFOREIGN-61))|(1<<(SQLServerStatementParserKEY-61)))) != 0) || _la == SQLServerStatementParserCHECK {
		{
			p.SetState(3901)
			p.TableConstraint()
		}

		p.SetState(3906)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) AllValidStatement() []IValidStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValidStatementContext)(nil)).Elem())
	var tst = make([]IValidStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValidStatementContext)
		}
	}

	return tst
}

func (s *CompoundStatementContext) ValidStatement(i int) IValidStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValidStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValidStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, SQLServerStatementParserRULE_compoundStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-45)&-(0x1f+1)) == 0 && ((1<<uint((_la-45)))&((1<<(SQLServerStatementParserSELECT-45))|(1<<(SQLServerStatementParserINSERT-45))|(1<<(SQLServerStatementParserUPDATE-45))|(1<<(SQLServerStatementParserDELETE-45))|(1<<(SQLServerStatementParserCREATE-45))|(1<<(SQLServerStatementParserALTER-45))|(1<<(SQLServerStatementParserDROP-45))|(1<<(SQLServerStatementParserTRUNCATE-45))|(1<<(SQLServerStatementParserSET-45))|(1<<(SQLServerStatementParserWITH-45)))) != 0) || _la == SQLServerStatementParserDECLARE {
		{
			p.SetState(3907)
			p.ValidStatement()
		}

		p.SetState(3912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionOptionContext is an interface to support dynamic dispatch.
type IFunctionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionOptionContext differentiates from other interfaces.
	IsFunctionOptionContext()
}

type FunctionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionOptionContext() *FunctionOptionContext {
	var p = new(FunctionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_functionOption
	return p
}

func (*FunctionOptionContext) IsFunctionOptionContext() {}

func NewFunctionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionOptionContext {
	var p = new(FunctionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_functionOption

	return p
}

func (s *FunctionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *FunctionOptionContext) SCHEMABINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMABINDING, 0)
}

func (s *FunctionOptionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRETURNS, 0)
}

func (s *FunctionOptionContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserNULL)
}

func (s *FunctionOptionContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNULL, i)
}

func (s *FunctionOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *FunctionOptionContext) INPUT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINPUT, 0)
}

func (s *FunctionOptionContext) CALLED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCALLED, 0)
}

func (s *FunctionOptionContext) ExecuteAsClause() IExecuteAsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecuteAsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecuteAsClauseContext)
}

func (s *FunctionOptionContext) INLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINLINE, 0)
}

func (s *FunctionOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *FunctionOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *FunctionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFunctionOption(s)
	}
}

func (s *FunctionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFunctionOption(s)
	}
}

func (s *FunctionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFunctionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FunctionOption() (localctx IFunctionOptionContext) {
	this := p
	_ = this

	localctx = NewFunctionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, SQLServerStatementParserRULE_functionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3938)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3914)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserENCRYPTION {
			{
				p.SetState(3913)
				p.Match(SQLServerStatementParserENCRYPTION)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3917)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserSCHEMABINDING {
			{
				p.SetState(3916)
				p.Match(SQLServerStatementParserSCHEMABINDING)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3928)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserRETURNS:
			{
				p.SetState(3919)
				p.Match(SQLServerStatementParserRETURNS)
			}
			{
				p.SetState(3920)
				p.Match(SQLServerStatementParserNULL)
			}
			{
				p.SetState(3921)
				p.Match(SQLServerStatementParserON)
			}
			{
				p.SetState(3922)
				p.Match(SQLServerStatementParserNULL)
			}
			{
				p.SetState(3923)
				p.Match(SQLServerStatementParserINPUT)
			}

		case SQLServerStatementParserCALLED:
			{
				p.SetState(3924)
				p.Match(SQLServerStatementParserCALLED)
			}
			{
				p.SetState(3925)
				p.Match(SQLServerStatementParserON)
			}
			{
				p.SetState(3926)
				p.Match(SQLServerStatementParserNULL)
			}
			{
				p.SetState(3927)
				p.Match(SQLServerStatementParserINPUT)
			}

		case SQLServerStatementParserCOMMA_, SQLServerStatementParserAS, SQLServerStatementParserBEGIN, SQLServerStatementParserRETURN:

		default:
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEXECUTE || _la == SQLServerStatementParserEXEC {
			{
				p.SetState(3930)
				p.ExecuteAsClause()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(3936)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserINLINE {
			{
				p.SetState(3933)
				p.Match(SQLServerStatementParserINLINE)
			}
			{
				p.SetState(3934)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(3935)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}

	return localctx
}

// IValidStatementContext is an interface to support dynamic dispatch.
type IValidStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValidStatementContext differentiates from other interfaces.
	IsValidStatementContext()
}

type ValidStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValidStatementContext() *ValidStatementContext {
	var p = new(ValidStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_validStatement
	return p
}

func (*ValidStatementContext) IsValidStatementContext() {}

func NewValidStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValidStatementContext {
	var p = new(ValidStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_validStatement

	return p
}

func (s *ValidStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ValidStatementContext) CreateTable() ICreateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *ValidStatementContext) AlterTable() IAlterTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *ValidStatementContext) DropTable() IDropTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *ValidStatementContext) TruncateTable() ITruncateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITruncateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITruncateTableContext)
}

func (s *ValidStatementContext) Insert() IInsertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *ValidStatementContext) Update() IUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *ValidStatementContext) Delete() IDeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteContext)
}

func (s *ValidStatementContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *ValidStatementContext) SetVariable() ISetVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetVariableContext)
}

func (s *ValidStatementContext) DeclareVariable() IDeclareVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclareVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclareVariableContext)
}

func (s *ValidStatementContext) SEMI_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEMI_, 0)
}

func (s *ValidStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValidStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValidStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterValidStatement(s)
	}
}

func (s *ValidStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitValidStatement(s)
	}
}

func (s *ValidStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitValidStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ValidStatement() (localctx IValidStatementContext) {
	this := p
	_ = this

	localctx = NewValidStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, SQLServerStatementParserRULE_validStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 441, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3940)
			p.CreateTable()
		}

	case 2:
		{
			p.SetState(3941)
			p.AlterTable()
		}

	case 3:
		{
			p.SetState(3942)
			p.DropTable()
		}

	case 4:
		{
			p.SetState(3943)
			p.TruncateTable()
		}

	case 5:
		{
			p.SetState(3944)
			p.Insert()
		}

	case 6:
		{
			p.SetState(3945)
			p.Update()
		}

	case 7:
		{
			p.SetState(3946)
			p.Delete()
		}

	case 8:
		{
			p.SetState(3947)
			p.Select()
		}

	case 9:
		{
			p.SetState(3948)
			p.SetVariable()
		}

	case 10:
		{
			p.SetState(3949)
			p.DeclareVariable()
		}

	}
	p.SetState(3953)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 442, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3952)
			p.Match(SQLServerStatementParserSEMI_)
		}

	}

	return localctx
}

// IProcParametersContext is an interface to support dynamic dispatch.
type IProcParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcParametersContext differentiates from other interfaces.
	IsProcParametersContext()
}

type ProcParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcParametersContext() *ProcParametersContext {
	var p = new(ProcParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procParameters
	return p
}

func (*ProcParametersContext) IsProcParametersContext() {}

func NewProcParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcParametersContext {
	var p = new(ProcParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procParameters

	return p
}

func (s *ProcParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcParametersContext) AllProcParameter() []IProcParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcParameterContext)(nil)).Elem())
	var tst = make([]IProcParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcParameterContext)
		}
	}

	return tst
}

func (s *ProcParametersContext) ProcParameter(i int) IProcParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcParameterContext)
}

func (s *ProcParametersContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ProcParametersContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ProcParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcParameters(s)
	}
}

func (s *ProcParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcParameters(s)
	}
}

func (s *ProcParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcParameters() (localctx IProcParametersContext) {
	this := p
	_ = this

	localctx = NewProcParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, SQLServerStatementParserRULE_procParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3963)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserAT_ {
		{
			p.SetState(3955)
			p.ProcParameter()
		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3956)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3957)
				p.ProcParameter()
			}

			p.SetState(3962)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IProcParameterContext is an interface to support dynamic dispatch.
type IProcParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcParameterContext differentiates from other interfaces.
	IsProcParameterContext()
}

type ProcParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcParameterContext() *ProcParameterContext {
	var p = new(ProcParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procParameter
	return p
}

func (*ProcParameterContext) IsProcParameterContext() {}

func NewProcParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcParameterContext {
	var p = new(ProcParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procParameter

	return p
}

func (s *ProcParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcParameterContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ProcParameterContext) VARYING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVARYING, 0)
}

func (s *ProcParameterContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ProcParameterContext) Literals() ILiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralsContext)
}

func (s *ProcParameterContext) OUT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUT, 0)
}

func (s *ProcParameterContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOUTPUT, 0)
}

func (s *ProcParameterContext) READONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREADONLY, 0)
}

func (s *ProcParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcParameter(s)
	}
}

func (s *ProcParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcParameter(s)
	}
}

func (s *ProcParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcParameter() (localctx IProcParameterContext) {
	this := p
	_ = this

	localctx = NewProcParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, SQLServerStatementParserRULE_procParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3965)
		p.Variable()
	}
	p.SetState(3967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserVARYING {
		{
			p.SetState(3966)
			p.Match(SQLServerStatementParserVARYING)
		}

	}
	p.SetState(3971)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserEQ_ {
		{
			p.SetState(3969)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(3970)
			p.Literals()
		}

	}
	p.SetState(3974)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserREADONLY || _la == SQLServerStatementParserOUTPUT || _la == SQLServerStatementParserOUT {
		{
			p.SetState(3973)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREADONLY || _la == SQLServerStatementParserOUTPUT || _la == SQLServerStatementParserOUT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICreateOrAlterProcClauseContext is an interface to support dynamic dispatch.
type ICreateOrAlterProcClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateOrAlterProcClauseContext differentiates from other interfaces.
	IsCreateOrAlterProcClauseContext()
}

type CreateOrAlterProcClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrAlterProcClauseContext() *CreateOrAlterProcClauseContext {
	var p = new(CreateOrAlterProcClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterProcClause
	return p
}

func (*CreateOrAlterProcClauseContext) IsCreateOrAlterProcClauseContext() {}

func NewCreateOrAlterProcClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrAlterProcClauseContext {
	var p = new(CreateOrAlterProcClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterProcClause

	return p
}

func (s *CreateOrAlterProcClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrAlterProcClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateOrAlterProcClauseContext) ProcAsClause() IProcAsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcAsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcAsClauseContext)
}

func (s *CreateOrAlterProcClauseContext) WithCreateProcOption() IWithCreateProcOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithCreateProcOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithCreateProcOptionContext)
}

func (s *CreateOrAlterProcClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *CreateOrAlterProcClauseContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *CreateOrAlterProcClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrAlterProcClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrAlterProcClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateOrAlterProcClause(s)
	}
}

func (s *CreateOrAlterProcClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateOrAlterProcClause(s)
	}
}

func (s *CreateOrAlterProcClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateOrAlterProcClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateOrAlterProcClause() (localctx ICreateOrAlterProcClauseContext) {
	this := p
	_ = this

	localctx = NewCreateOrAlterProcClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, SQLServerStatementParserRULE_createOrAlterProcClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3977)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(3976)
			p.WithCreateProcOption()
		}

	}
	p.SetState(3981)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFOR {
		{
			p.SetState(3979)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(3980)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	}
	{
		p.SetState(3983)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(3984)
		p.ProcAsClause()
	}

	return localctx
}

// IWithCreateProcOptionContext is an interface to support dynamic dispatch.
type IWithCreateProcOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithCreateProcOptionContext differentiates from other interfaces.
	IsWithCreateProcOptionContext()
}

type WithCreateProcOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithCreateProcOptionContext() *WithCreateProcOptionContext {
	var p = new(WithCreateProcOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withCreateProcOption
	return p
}

func (*WithCreateProcOptionContext) IsWithCreateProcOptionContext() {}

func NewWithCreateProcOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithCreateProcOptionContext {
	var p = new(WithCreateProcOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withCreateProcOption

	return p
}

func (s *WithCreateProcOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithCreateProcOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithCreateProcOptionContext) AllProcOption() []IProcOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcOptionContext)(nil)).Elem())
	var tst = make([]IProcOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcOptionContext)
		}
	}

	return tst
}

func (s *WithCreateProcOptionContext) ProcOption(i int) IProcOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcOptionContext)
}

func (s *WithCreateProcOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *WithCreateProcOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *WithCreateProcOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithCreateProcOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithCreateProcOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithCreateProcOption(s)
	}
}

func (s *WithCreateProcOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithCreateProcOption(s)
	}
}

func (s *WithCreateProcOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithCreateProcOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithCreateProcOption() (localctx IWithCreateProcOptionContext) {
	this := p
	_ = this

	localctx = NewWithCreateProcOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, SQLServerStatementParserRULE_withCreateProcOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3986)
		p.Match(SQLServerStatementParserWITH)
	}
	p.SetState(3995)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserEXECUTE || _la == SQLServerStatementParserEXEC || _la == SQLServerStatementParserENCRYPTION || _la == SQLServerStatementParserRECOMPILE || _la == SQLServerStatementParserSCHEMABINDING || _la == SQLServerStatementParserNATIVE_COMPILATION {
		{
			p.SetState(3987)
			p.ProcOption()
		}
		p.SetState(3992)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(3988)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(3989)
				p.ProcOption()
			}

			p.SetState(3994)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IProcOptionContext is an interface to support dynamic dispatch.
type IProcOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcOptionContext differentiates from other interfaces.
	IsProcOptionContext()
}

type ProcOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcOptionContext() *ProcOptionContext {
	var p = new(ProcOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procOption
	return p
}

func (*ProcOptionContext) IsProcOptionContext() {}

func NewProcOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcOptionContext {
	var p = new(ProcOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procOption

	return p
}

func (s *ProcOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *ProcOptionContext) RECOMPILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECOMPILE, 0)
}

func (s *ProcOptionContext) ExecuteAsClause() IExecuteAsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecuteAsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecuteAsClauseContext)
}

func (s *ProcOptionContext) NATIVE_COMPILATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNATIVE_COMPILATION, 0)
}

func (s *ProcOptionContext) SCHEMABINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMABINDING, 0)
}

func (s *ProcOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcOption(s)
	}
}

func (s *ProcOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcOption(s)
	}
}

func (s *ProcOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcOption() (localctx IProcOptionContext) {
	this := p
	_ = this

	localctx = NewProcOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, SQLServerStatementParserRULE_procOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4002)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserENCRYPTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3997)
			p.Match(SQLServerStatementParserENCRYPTION)
		}

	case SQLServerStatementParserRECOMPILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3998)
			p.Match(SQLServerStatementParserRECOMPILE)
		}

	case SQLServerStatementParserEXECUTE, SQLServerStatementParserEXEC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3999)
			p.ExecuteAsClause()
		}

	case SQLServerStatementParserNATIVE_COMPILATION:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4000)
			p.Match(SQLServerStatementParserNATIVE_COMPILATION)
		}

	case SQLServerStatementParserSCHEMABINDING:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4001)
			p.Match(SQLServerStatementParserSCHEMABINDING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcAsClauseContext is an interface to support dynamic dispatch.
type IProcAsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcAsClauseContext differentiates from other interfaces.
	IsProcAsClauseContext()
}

type ProcAsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcAsClauseContext() *ProcAsClauseContext {
	var p = new(ProcAsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procAsClause
	return p
}

func (*ProcAsClauseContext) IsProcAsClauseContext() {}

func NewProcAsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcAsClauseContext {
	var p = new(ProcAsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procAsClause

	return p
}

func (s *ProcAsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcAsClauseContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *ProcAsClauseContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBEGIN, 0)
}

func (s *ProcAsClauseContext) END() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEND, 0)
}

func (s *ProcAsClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNAL, 0)
}

func (s *ProcAsClauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *ProcAsClauseContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ProcAsClauseContext) AllOwner() []IOwnerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwnerContext)(nil)).Elem())
	var tst = make([]IOwnerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwnerContext)
		}
	}

	return tst
}

func (s *ProcAsClauseContext) Owner(i int) IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ProcAsClauseContext) AllDOT_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDOT_)
}

func (s *ProcAsClauseContext) DOT_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, i)
}

func (s *ProcAsClauseContext) ATOMIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserATOMIC, 0)
}

func (s *ProcAsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *ProcAsClauseContext) AllProcSetOption() []IProcSetOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProcSetOptionContext)(nil)).Elem())
	var tst = make([]IProcSetOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProcSetOptionContext)
		}
	}

	return tst
}

func (s *ProcAsClauseContext) ProcSetOption(i int) IProcSetOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcSetOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProcSetOptionContext)
}

func (s *ProcAsClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ProcAsClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ProcAsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcAsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcAsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcAsClause(s)
	}
}

func (s *ProcAsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcAsClause(s)
	}
}

func (s *ProcAsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcAsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcAsClause() (localctx IProcAsClauseContext) {
	this := p
	_ = this

	localctx = NewProcAsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, SQLServerStatementParserRULE_procAsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4039)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 459, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserBEGIN {
			{
				p.SetState(4004)
				p.Match(SQLServerStatementParserBEGIN)
			}

		}
		{
			p.SetState(4007)
			p.CompoundStatement()
		}
		p.SetState(4009)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEND {
			{
				p.SetState(4008)
				p.Match(SQLServerStatementParserEND)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4011)
			p.Match(SQLServerStatementParserEXTERNAL)
		}
		{
			p.SetState(4012)
			p.Match(SQLServerStatementParserNAME)
		}
		p.SetState(4016)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4013)
				p.Owner()
			}
			{
				p.SetState(4014)
				p.Match(SQLServerStatementParserDOT_)
			}

		}
		p.SetState(4021)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 456, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4018)
				p.Owner()
			}
			{
				p.SetState(4019)
				p.Match(SQLServerStatementParserDOT_)
			}

		}
		{
			p.SetState(4023)
			p.Name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4024)
			p.Match(SQLServerStatementParserBEGIN)
		}
		{
			p.SetState(4025)
			p.Match(SQLServerStatementParserATOMIC)
		}
		{
			p.SetState(4026)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4027)
			p.ProcSetOption()
		}
		p.SetState(4032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4028)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4029)
				p.ProcSetOption()
			}

			p.SetState(4034)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4035)
			p.CompoundStatement()
		}
		p.SetState(4037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEND {
			{
				p.SetState(4036)
				p.Match(SQLServerStatementParserEND)
			}

		}

	}

	return localctx
}

// IProcSetOptionContext is an interface to support dynamic dispatch.
type IProcSetOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcSetOptionContext differentiates from other interfaces.
	IsProcSetOptionContext()
}

type ProcSetOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcSetOptionContext() *ProcSetOptionContext {
	var p = new(ProcSetOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_procSetOption
	return p
}

func (*ProcSetOptionContext) IsProcSetOptionContext() {}

func NewProcSetOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcSetOptionContext {
	var p = new(ProcSetOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_procSetOption

	return p
}

func (s *ProcSetOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcSetOptionContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLANGUAGE, 0)
}

func (s *ProcSetOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ProcSetOptionContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *ProcSetOptionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *ProcSetOptionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserISOLATION, 0)
}

func (s *ProcSetOptionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLEVEL, 0)
}

func (s *ProcSetOptionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSNAPSHOT, 0)
}

func (s *ProcSetOptionContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPEATABLE, 0)
}

func (s *ProcSetOptionContext) READ() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD, 0)
}

func (s *ProcSetOptionContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERIALIZABLE, 0)
}

func (s *ProcSetOptionContext) DATEFIRST() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATEFIRST, 0)
}

func (s *ProcSetOptionContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *ProcSetOptionContext) DATEFORMAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATEFORMAT, 0)
}

func (s *ProcSetOptionContext) DELAYED_DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELAYED_DURABILITY, 0)
}

func (s *ProcSetOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ProcSetOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ProcSetOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcSetOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcSetOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterProcSetOption(s)
	}
}

func (s *ProcSetOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitProcSetOption(s)
	}
}

func (s *ProcSetOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitProcSetOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ProcSetOption() (localctx IProcSetOptionContext) {
	this := p
	_ = this

	localctx = NewProcSetOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, SQLServerStatementParserRULE_procSetOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4063)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserLANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4041)
			p.Match(SQLServerStatementParserLANGUAGE)
		}
		{
			p.SetState(4042)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4043)
			p.StringLiterals()
		}

	case SQLServerStatementParserTRANSACTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4044)
			p.Match(SQLServerStatementParserTRANSACTION)
		}
		{
			p.SetState(4045)
			p.Match(SQLServerStatementParserISOLATION)
		}
		{
			p.SetState(4046)
			p.Match(SQLServerStatementParserLEVEL)
		}
		{
			p.SetState(4047)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(4052)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserSNAPSHOT:
			{
				p.SetState(4048)
				p.Match(SQLServerStatementParserSNAPSHOT)
			}

		case SQLServerStatementParserREPEATABLE:
			{
				p.SetState(4049)
				p.Match(SQLServerStatementParserREPEATABLE)
			}
			{
				p.SetState(4050)
				p.Match(SQLServerStatementParserREAD)
			}

		case SQLServerStatementParserSERIALIZABLE:
			{
				p.SetState(4051)
				p.Match(SQLServerStatementParserSERIALIZABLE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SQLServerStatementParserDATEFIRST:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4054)
			p.Match(SQLServerStatementParserDATEFIRST)
		}
		{
			p.SetState(4055)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4056)
			p.NumberLiterals()
		}

	case SQLServerStatementParserDATEFORMAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4057)
			p.Match(SQLServerStatementParserDATEFORMAT)
		}
		{
			p.SetState(4058)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4059)
			p.StringLiterals()
		}

	case SQLServerStatementParserDELAYED_DURABILITY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4060)
			p.Match(SQLServerStatementParserDELAYED_DURABILITY)
		}
		{
			p.SetState(4061)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4062)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreateOrAlterViewClauseContext is an interface to support dynamic dispatch.
type ICreateOrAlterViewClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateOrAlterViewClauseContext differentiates from other interfaces.
	IsCreateOrAlterViewClauseContext()
}

type CreateOrAlterViewClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrAlterViewClauseContext() *CreateOrAlterViewClauseContext {
	var p = new(CreateOrAlterViewClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterViewClause
	return p
}

func (*CreateOrAlterViewClauseContext) IsCreateOrAlterViewClauseContext() {}

func NewCreateOrAlterViewClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrAlterViewClauseContext {
	var p = new(CreateOrAlterViewClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterViewClause

	return p
}

func (s *CreateOrAlterViewClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrAlterViewClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateOrAlterViewClauseContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CreateOrAlterViewClauseContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserWITH)
}

func (s *CreateOrAlterViewClauseContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, i)
}

func (s *CreateOrAlterViewClauseContext) AllViewAttribute() []IViewAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IViewAttributeContext)(nil)).Elem())
	var tst = make([]IViewAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IViewAttributeContext)
		}
	}

	return tst
}

func (s *CreateOrAlterViewClauseContext) ViewAttribute(i int) IViewAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IViewAttributeContext)
}

func (s *CreateOrAlterViewClauseContext) WithCommonTableExpr() IWithCommonTableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithCommonTableExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithCommonTableExprContext)
}

func (s *CreateOrAlterViewClauseContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECK, 0)
}

func (s *CreateOrAlterViewClauseContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTION, 0)
}

func (s *CreateOrAlterViewClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateOrAlterViewClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateOrAlterViewClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrAlterViewClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrAlterViewClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateOrAlterViewClause(s)
	}
}

func (s *CreateOrAlterViewClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateOrAlterViewClause(s)
	}
}

func (s *CreateOrAlterViewClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateOrAlterViewClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateOrAlterViewClause() (localctx ICreateOrAlterViewClauseContext) {
	this := p
	_ = this

	localctx = NewCreateOrAlterViewClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, SQLServerStatementParserRULE_createOrAlterViewClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4065)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4066)
			p.ViewAttribute()
		}
		p.SetState(4071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4067)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4068)
				p.ViewAttribute()
			}

			p.SetState(4073)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(4076)
		p.Match(SQLServerStatementParserAS)
	}
	p.SetState(4078)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4077)
			p.WithCommonTableExpr()
		}

	}
	{
		p.SetState(4080)
		p.Select()
	}
	p.SetState(4084)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4081)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4082)
			p.Match(SQLServerStatementParserCHECK)
		}
		{
			p.SetState(4083)
			p.Match(SQLServerStatementParserOPTION)
		}

	}

	return localctx
}

// IViewAttributeContext is an interface to support dynamic dispatch.
type IViewAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsViewAttributeContext differentiates from other interfaces.
	IsViewAttributeContext()
}

type ViewAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewAttributeContext() *ViewAttributeContext {
	var p = new(ViewAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_viewAttribute
	return p
}

func (*ViewAttributeContext) IsViewAttributeContext() {}

func NewViewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewAttributeContext {
	var p = new(ViewAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_viewAttribute

	return p
}

func (s *ViewAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewAttributeContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *ViewAttributeContext) SCHEMABINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMABINDING, 0)
}

func (s *ViewAttributeContext) VIEW_METADATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW_METADATA, 0)
}

func (s *ViewAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterViewAttribute(s)
	}
}

func (s *ViewAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitViewAttribute(s)
	}
}

func (s *ViewAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitViewAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ViewAttribute() (localctx IViewAttributeContext) {
	this := p
	_ = this

	localctx = NewViewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, SQLServerStatementParserRULE_viewAttribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4086)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserENCRYPTION || _la == SQLServerStatementParserSCHEMABINDING || _la == SQLServerStatementParserVIEW_METADATA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IWithCommonTableExprContext is an interface to support dynamic dispatch.
type IWithCommonTableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithCommonTableExprContext differentiates from other interfaces.
	IsWithCommonTableExprContext()
}

type WithCommonTableExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithCommonTableExprContext() *WithCommonTableExprContext {
	var p = new(WithCommonTableExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withCommonTableExpr
	return p
}

func (*WithCommonTableExprContext) IsWithCommonTableExprContext() {}

func NewWithCommonTableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithCommonTableExprContext {
	var p = new(WithCommonTableExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withCommonTableExpr

	return p
}

func (s *WithCommonTableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *WithCommonTableExprContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithCommonTableExprContext) AllCommonTableExpr() []ICommonTableExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommonTableExprContext)(nil)).Elem())
	var tst = make([]ICommonTableExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommonTableExprContext)
		}
	}

	return tst
}

func (s *WithCommonTableExprContext) CommonTableExpr(i int) ICommonTableExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommonTableExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommonTableExprContext)
}

func (s *WithCommonTableExprContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *WithCommonTableExprContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *WithCommonTableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithCommonTableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithCommonTableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithCommonTableExpr(s)
	}
}

func (s *WithCommonTableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithCommonTableExpr(s)
	}
}

func (s *WithCommonTableExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithCommonTableExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithCommonTableExpr() (localctx IWithCommonTableExprContext) {
	this := p
	_ = this

	localctx = NewWithCommonTableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, SQLServerStatementParserRULE_withCommonTableExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4088)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(4089)
		p.CommonTableExpr()
	}
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(4090)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4091)
			p.CommonTableExpr()
		}

		p.SetState(4096)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommonTableExprContext is an interface to support dynamic dispatch.
type ICommonTableExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommonTableExprContext differentiates from other interfaces.
	IsCommonTableExprContext()
}

type CommonTableExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExprContext() *CommonTableExprContext {
	var p = new(CommonTableExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_commonTableExpr
	return p
}

func (*CommonTableExprContext) IsCommonTableExprContext() {}

func NewCommonTableExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExprContext {
	var p = new(CommonTableExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_commonTableExpr

	return p
}

func (s *CommonTableExprContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExprContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CommonTableExprContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CommonTableExprContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *CommonTableExprContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *CommonTableExprContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CommonTableExprContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *CommonTableExprContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *CommonTableExprContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *CommonTableExprContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *CommonTableExprContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CommonTableExprContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CommonTableExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCommonTableExpr(s)
	}
}

func (s *CommonTableExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCommonTableExpr(s)
	}
}

func (s *CommonTableExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCommonTableExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CommonTableExpr() (localctx ICommonTableExprContext) {
	this := p
	_ = this

	localctx = NewCommonTableExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, SQLServerStatementParserRULE_commonTableExpr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4097)
		p.Name()
	}
	p.SetState(4109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(4098)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4099)
			p.ColumnName()
		}
		p.SetState(4104)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4100)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4101)
				p.ColumnName()
			}

			p.SetState(4106)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4107)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	{
		p.SetState(4111)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(4112)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4113)
		p.Select()
	}
	{
		p.SetState(4114)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// ICreateTriggerClauseContext is an interface to support dynamic dispatch.
type ICreateTriggerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTriggerClauseContext differentiates from other interfaces.
	IsCreateTriggerClauseContext()
}

type CreateTriggerClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTriggerClauseContext() *CreateTriggerClauseContext {
	var p = new(CreateTriggerClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTriggerClause
	return p
}

func (*CreateTriggerClauseContext) IsCreateTriggerClauseContext() {}

func NewCreateTriggerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerClauseContext {
	var p = new(CreateTriggerClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTriggerClause

	return p
}

func (s *CreateTriggerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateTriggerClauseContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserFOR)
}

func (s *CreateTriggerClauseContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, i)
}

func (s *CreateTriggerClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAFTER, 0)
}

func (s *CreateTriggerClauseContext) INSTEAD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSTEAD, 0)
}

func (s *CreateTriggerClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOF, 0)
}

func (s *CreateTriggerClauseContext) CompoundStatement() ICompoundStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CreateTriggerClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNAL, 0)
}

func (s *CreateTriggerClauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *CreateTriggerClauseContext) MethodSpecifier() IMethodSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodSpecifierContext)
}

func (s *CreateTriggerClauseContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserWITH)
}

func (s *CreateTriggerClauseContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, i)
}

func (s *CreateTriggerClauseContext) AllDmlTriggerOption() []IDmlTriggerOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDmlTriggerOptionContext)(nil)).Elem())
	var tst = make([]IDmlTriggerOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDmlTriggerOptionContext)
		}
	}

	return tst
}

func (s *CreateTriggerClauseContext) DmlTriggerOption(i int) IDmlTriggerOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDmlTriggerOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDmlTriggerOptionContext)
}

func (s *CreateTriggerClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateTriggerClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateTriggerClauseContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERT, 0)
}

func (s *CreateTriggerClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *CreateTriggerClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETE, 0)
}

func (s *CreateTriggerClauseContext) APPEND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAPPEND, 0)
}

func (s *CreateTriggerClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOT, 0)
}

func (s *CreateTriggerClauseContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *CreateTriggerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTriggerClause(s)
	}
}

func (s *CreateTriggerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTriggerClause(s)
	}
}

func (s *CreateTriggerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTriggerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTriggerClause() (localctx ICreateTriggerClauseContext) {
	this := p
	_ = this

	localctx = NewCreateTriggerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, SQLServerStatementParserRULE_createTriggerClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4121)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4116)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4117)
			p.DmlTriggerOption()
		}
		{
			p.SetState(4118)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4119)
			p.DmlTriggerOption()
		}

	}
	p.SetState(4127)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserFOR:
		{
			p.SetState(4123)
			p.Match(SQLServerStatementParserFOR)
		}

	case SQLServerStatementParserAFTER:
		{
			p.SetState(4124)
			p.Match(SQLServerStatementParserAFTER)
		}

	case SQLServerStatementParserINSTEAD:
		{
			p.SetState(4125)
			p.Match(SQLServerStatementParserINSTEAD)
		}
		{
			p.SetState(4126)
			p.Match(SQLServerStatementParserOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(4130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserINSERT {
		{
			p.SetState(4129)
			p.Match(SQLServerStatementParserINSERT)
		}

	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 472, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4132)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	p.SetState(4136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserUPDATE {
		{
			p.SetState(4135)
			p.Match(SQLServerStatementParserUPDATE)
		}

	}
	p.SetState(4139)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 474, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4138)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	p.SetState(4142)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserDELETE {
		{
			p.SetState(4141)
			p.Match(SQLServerStatementParserDELETE)
		}

	}
	p.SetState(4145)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(4144)
			p.Match(SQLServerStatementParserCOMMA_)
		}

	}
	p.SetState(4149)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4147)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4148)
			p.Match(SQLServerStatementParserAPPEND)
		}

	}
	p.SetState(4154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserNOT {
		{
			p.SetState(4151)
			p.Match(SQLServerStatementParserNOT)
		}
		{
			p.SetState(4152)
			p.Match(SQLServerStatementParserFOR)
		}
		{
			p.SetState(4153)
			p.Match(SQLServerStatementParserREPLICATION)
		}

	}
	{
		p.SetState(4156)
		p.Match(SQLServerStatementParserAS)
	}
	p.SetState(4161)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserEOF, SQLServerStatementParserSEMI_, SQLServerStatementParserSELECT, SQLServerStatementParserINSERT, SQLServerStatementParserUPDATE, SQLServerStatementParserDELETE, SQLServerStatementParserCREATE, SQLServerStatementParserALTER, SQLServerStatementParserDROP, SQLServerStatementParserTRUNCATE, SQLServerStatementParserSET, SQLServerStatementParserWITH, SQLServerStatementParserDECLARE:
		{
			p.SetState(4157)
			p.CompoundStatement()
		}

	case SQLServerStatementParserEXTERNAL:
		{
			p.SetState(4158)
			p.Match(SQLServerStatementParserEXTERNAL)
		}
		{
			p.SetState(4159)
			p.Match(SQLServerStatementParserNAME)
		}
		{
			p.SetState(4160)
			p.MethodSpecifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDmlTriggerOptionContext is an interface to support dynamic dispatch.
type IDmlTriggerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDmlTriggerOptionContext differentiates from other interfaces.
	IsDmlTriggerOptionContext()
}

type DmlTriggerOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDmlTriggerOptionContext() *DmlTriggerOptionContext {
	var p = new(DmlTriggerOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dmlTriggerOption
	return p
}

func (*DmlTriggerOptionContext) IsDmlTriggerOptionContext() {}

func NewDmlTriggerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DmlTriggerOptionContext {
	var p = new(DmlTriggerOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dmlTriggerOption

	return p
}

func (s *DmlTriggerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DmlTriggerOptionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *DmlTriggerOptionContext) ExecuteAsClause() IExecuteAsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExecuteAsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExecuteAsClauseContext)
}

func (s *DmlTriggerOptionContext) NATIVE_COMPILATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNATIVE_COMPILATION, 0)
}

func (s *DmlTriggerOptionContext) SCHEMABINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMABINDING, 0)
}

func (s *DmlTriggerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DmlTriggerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DmlTriggerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDmlTriggerOption(s)
	}
}

func (s *DmlTriggerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDmlTriggerOption(s)
	}
}

func (s *DmlTriggerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDmlTriggerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DmlTriggerOption() (localctx IDmlTriggerOptionContext) {
	this := p
	_ = this

	localctx = NewDmlTriggerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, SQLServerStatementParserRULE_dmlTriggerOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4168)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserENCRYPTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4163)
			p.Match(SQLServerStatementParserENCRYPTION)
		}

	case SQLServerStatementParserEXECUTE, SQLServerStatementParserEXEC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4164)
			p.ExecuteAsClause()
		}

	case SQLServerStatementParserNATIVE_COMPILATION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4165)
			p.Match(SQLServerStatementParserNATIVE_COMPILATION)
		}

	case SQLServerStatementParserSCHEMABINDING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4166)
			p.Match(SQLServerStatementParserSCHEMABINDING)
		}

	case SQLServerStatementParserCOMMA_, SQLServerStatementParserFOR, SQLServerStatementParserAFTER, SQLServerStatementParserINSTEAD:
		p.EnterOuterAlt(localctx, 5)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMethodSpecifierContext is an interface to support dynamic dispatch.
type IMethodSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodSpecifierContext differentiates from other interfaces.
	IsMethodSpecifierContext()
}

type MethodSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodSpecifierContext() *MethodSpecifierContext {
	var p = new(MethodSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_methodSpecifier
	return p
}

func (*MethodSpecifierContext) IsMethodSpecifierContext() {}

func NewMethodSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodSpecifierContext {
	var p = new(MethodSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_methodSpecifier

	return p
}

func (s *MethodSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodSpecifierContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *MethodSpecifierContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *MethodSpecifierContext) AllDOT_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserDOT_)
}

func (s *MethodSpecifierContext) DOT_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDOT_, i)
}

func (s *MethodSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterMethodSpecifier(s)
	}
}

func (s *MethodSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitMethodSpecifier(s)
	}
}

func (s *MethodSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitMethodSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) MethodSpecifier() (localctx IMethodSpecifierContext) {
	this := p
	_ = this

	localctx = NewMethodSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, SQLServerStatementParserRULE_methodSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4170)
		p.Name()
	}
	{
		p.SetState(4171)
		p.Match(SQLServerStatementParserDOT_)
	}
	{
		p.SetState(4172)
		p.Name()
	}
	{
		p.SetState(4173)
		p.Match(SQLServerStatementParserDOT_)
	}
	{
		p.SetState(4174)
		p.Name()
	}

	return localctx
}

// ITriggerTargetContext is an interface to support dynamic dispatch.
type ITriggerTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTriggerTargetContext differentiates from other interfaces.
	IsTriggerTargetContext()
}

type TriggerTargetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerTargetContext() *TriggerTargetContext {
	var p = new(TriggerTargetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_triggerTarget
	return p
}

func (*TriggerTargetContext) IsTriggerTargetContext() {}

func NewTriggerTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerTargetContext {
	var p = new(TriggerTargetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_triggerTarget

	return p
}

func (s *TriggerTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerTargetContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TriggerTargetContext) ViewName() IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *TriggerTargetContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *TriggerTargetContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *TriggerTargetContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *TriggerTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTriggerTarget(s)
	}
}

func (s *TriggerTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTriggerTarget(s)
	}
}

func (s *TriggerTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTriggerTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TriggerTarget() (localctx ITriggerTargetContext) {
	this := p
	_ = this

	localctx = NewTriggerTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, SQLServerStatementParserRULE_triggerTarget)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4181)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4176)
			p.TableName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4177)
			p.ViewName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4178)
			p.Match(SQLServerStatementParserALL)
		}
		{
			p.SetState(4179)
			p.Match(SQLServerStatementParserSERVER)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4180)
			p.Match(SQLServerStatementParserDATABASE)
		}

	}

	return localctx
}

// ICreateOrAlterSequenceClauseContext is an interface to support dynamic dispatch.
type ICreateOrAlterSequenceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateOrAlterSequenceClauseContext differentiates from other interfaces.
	IsCreateOrAlterSequenceClauseContext()
}

type CreateOrAlterSequenceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrAlterSequenceClauseContext() *CreateOrAlterSequenceClauseContext {
	var p = new(CreateOrAlterSequenceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterSequenceClause
	return p
}

func (*CreateOrAlterSequenceClauseContext) IsCreateOrAlterSequenceClauseContext() {}

func NewCreateOrAlterSequenceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrAlterSequenceClauseContext {
	var p = new(CreateOrAlterSequenceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createOrAlterSequenceClause

	return p
}

func (s *CreateOrAlterSequenceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrAlterSequenceClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateOrAlterSequenceClauseContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateOrAlterSequenceClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *CreateOrAlterSequenceClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CreateOrAlterSequenceClauseContext) START() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTART, 0)
}

func (s *CreateOrAlterSequenceClauseContext) RESTART() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESTART, 0)
}

func (s *CreateOrAlterSequenceClauseContext) INCREMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINCREMENT, 0)
}

func (s *CreateOrAlterSequenceClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBY, 0)
}

func (s *CreateOrAlterSequenceClauseContext) MINVALUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINVALUE, 0)
}

func (s *CreateOrAlterSequenceClauseContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO, 0)
}

func (s *CreateOrAlterSequenceClauseContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXVALUE, 0)
}

func (s *CreateOrAlterSequenceClauseContext) CACHE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCACHE, 0)
}

func (s *CreateOrAlterSequenceClauseContext) CYCLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCYCLE, 0)
}

func (s *CreateOrAlterSequenceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrAlterSequenceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrAlterSequenceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateOrAlterSequenceClause(s)
	}
}

func (s *CreateOrAlterSequenceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateOrAlterSequenceClause(s)
	}
}

func (s *CreateOrAlterSequenceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateOrAlterSequenceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateOrAlterSequenceClause() (localctx ICreateOrAlterSequenceClauseContext) {
	this := p
	_ = this

	localctx = NewCreateOrAlterSequenceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, SQLServerStatementParserRULE_createOrAlterSequenceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 485, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4183)
			p.Match(SQLServerStatementParserAS)
		}
		{
			p.SetState(4184)
			p.DataType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4185)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSTART || _la == SQLServerStatementParserRESTART) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4186)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4187)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4188)
			p.Match(SQLServerStatementParserINCREMENT)
		}
		{
			p.SetState(4189)
			p.Match(SQLServerStatementParserBY)
		}
		{
			p.SetState(4190)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4191)
			p.Match(SQLServerStatementParserMINVALUE)
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4192)
				p.expr(0)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4195)
			p.Match(SQLServerStatementParserNO)
		}
		{
			p.SetState(4196)
			p.Match(SQLServerStatementParserMINVALUE)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4197)
			p.Match(SQLServerStatementParserMAXVALUE)
		}
		p.SetState(4199)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4198)
				p.expr(0)
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4201)
			p.Match(SQLServerStatementParserNO)
		}
		{
			p.SetState(4202)
			p.Match(SQLServerStatementParserMAXVALUE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4203)
			p.Match(SQLServerStatementParserCACHE)
		}
		{
			p.SetState(4204)
			p.expr(0)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4205)
			p.Match(SQLServerStatementParserNO)
		}
		{
			p.SetState(4206)
			p.Match(SQLServerStatementParserCACHE)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(4208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserNO {
			{
				p.SetState(4207)
				p.Match(SQLServerStatementParserNO)
			}

		}
		{
			p.SetState(4210)
			p.Match(SQLServerStatementParserCYCLE)
		}

	}

	return localctx
}

// ICreateIndexClauseContext is an interface to support dynamic dispatch.
type ICreateIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateIndexClauseContext differentiates from other interfaces.
	IsCreateIndexClauseContext()
}

type CreateIndexClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexClauseContext() *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createIndexClause
	return p
}

func (*CreateIndexClauseContext) IsCreateIndexClauseContext() {}

func NewCreateIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createIndexClause

	return p
}

func (s *CreateIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexClauseContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINCLUDE, 0)
}

func (s *CreateIndexClauseContext) ColumnNamesWithSort() IColumnNamesWithSortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesWithSortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesWithSortContext)
}

func (s *CreateIndexClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWHERE, 0)
}

func (s *CreateIndexClauseContext) FilterPredicate() IFilterPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterPredicateContext)
}

func (s *CreateIndexClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *CreateIndexClauseContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *CreateIndexClauseContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *CreateIndexClauseContext) AllRelationalIndexOption() []IRelationalIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationalIndexOptionContext)(nil)).Elem())
	var tst = make([]IRelationalIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationalIndexOptionContext)
		}
	}

	return tst
}

func (s *CreateIndexClauseContext) RelationalIndexOption(i int) IRelationalIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationalIndexOptionContext)
}

func (s *CreateIndexClauseContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *CreateIndexClauseContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *CreateIndexClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CreateIndexClauseContext) FILESTREAM_ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM_ON, 0)
}

func (s *CreateIndexClauseContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *CreateIndexClauseContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *CreateIndexClauseContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *CreateIndexClauseContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CreateIndexClauseContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *CreateIndexClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateIndexClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateIndexClause() (localctx ICreateIndexClauseContext) {
	this := p
	_ = this

	localctx = NewCreateIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, SQLServerStatementParserRULE_createIndexClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserINCLUDE {
		{
			p.SetState(4213)
			p.Match(SQLServerStatementParserINCLUDE)
		}
		{
			p.SetState(4214)
			p.ColumnNamesWithSort()
		}

	}
	p.SetState(4219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWHERE {
		{
			p.SetState(4217)
			p.Match(SQLServerStatementParserWHERE)
		}
		{
			p.SetState(4218)
			p.FilterPredicate()
		}

	}
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4221)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4222)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4223)
			p.RelationalIndexOption()
		}
		p.SetState(4228)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4224)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4225)
				p.RelationalIndexOption()
			}

			p.SetState(4230)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4231)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	p.SetState(4244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(4235)
			p.Match(SQLServerStatementParserON)
		}
		p.SetState(4242)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 490, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4236)
				p.SchemaName()
			}
			{
				p.SetState(4237)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4238)
				p.ColumnName()
			}
			{
				p.SetState(4239)
				p.Match(SQLServerStatementParserRP_)
			}

		case 2:
			{
				p.SetState(4241)
				p.Name()
			}

		}

	}
	p.SetState(4251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserFILESTREAM_ON {
		{
			p.SetState(4246)
			p.Match(SQLServerStatementParserFILESTREAM_ON)
		}
		p.SetState(4249)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(4247)
				p.Name()
			}

		case SQLServerStatementParserSTRING_:
			{
				p.SetState(4248)
				p.StringLiterals()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// IFilterPredicateContext is an interface to support dynamic dispatch.
type IFilterPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterPredicateContext differentiates from other interfaces.
	IsFilterPredicateContext()
}

type FilterPredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterPredicateContext() *FilterPredicateContext {
	var p = new(FilterPredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_filterPredicate
	return p
}

func (*FilterPredicateContext) IsFilterPredicateContext() {}

func NewFilterPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterPredicateContext {
	var p = new(FilterPredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_filterPredicate

	return p
}

func (s *FilterPredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterPredicateContext) AllConjunct() []IConjunctContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctContext)(nil)).Elem())
	var tst = make([]IConjunctContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctContext)
		}
	}

	return tst
}

func (s *FilterPredicateContext) Conjunct(i int) IConjunctContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctContext)
}

func (s *FilterPredicateContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserAND)
}

func (s *FilterPredicateContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAND, i)
}

func (s *FilterPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterPredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFilterPredicate(s)
	}
}

func (s *FilterPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFilterPredicate(s)
	}
}

func (s *FilterPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFilterPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FilterPredicate() (localctx IFilterPredicateContext) {
	this := p
	_ = this

	localctx = NewFilterPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, SQLServerStatementParserRULE_filterPredicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4253)
		p.Conjunct()
	}
	p.SetState(4258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserAND {
		{
			p.SetState(4254)
			p.Match(SQLServerStatementParserAND)
		}
		{
			p.SetState(4255)
			p.Conjunct()
		}

		p.SetState(4260)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IConjunctContext is an interface to support dynamic dispatch.
type IConjunctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctContext differentiates from other interfaces.
	IsConjunctContext()
}

type ConjunctContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctContext() *ConjunctContext {
	var p = new(ConjunctContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_conjunct
	return p
}

func (*ConjunctContext) IsConjunctContext() {}

func NewConjunctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctContext {
	var p = new(ConjunctContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_conjunct

	return p
}

func (s *ConjunctContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ConjunctContext) IN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIN, 0)
}

func (s *ConjunctContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ConjunctContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ConjunctContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ConjunctContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ConjunctContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ConjunctContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ConjunctContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ConjunctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterConjunct(s)
	}
}

func (s *ConjunctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitConjunct(s)
	}
}

func (s *ConjunctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitConjunct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Conjunct() (localctx IConjunctContext) {
	this := p
	_ = this

	localctx = NewConjunctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, SQLServerStatementParserRULE_conjunct)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4261)
			p.ColumnName()
		}
		{
			p.SetState(4262)
			p.Match(SQLServerStatementParserIN)
		}
		{
			p.SetState(4263)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4264)
			p.expr(0)
		}
		p.SetState(4269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4265)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4266)
				p.expr(0)
			}

			p.SetState(4271)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4272)
			p.Match(SQLServerStatementParserRP_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4274)
			p.ColumnName()
		}
		{
			p.SetState(4275)
			p.ComparisonOperator()
		}
		{
			p.SetState(4276)
			p.expr(0)
		}

	}

	return localctx
}

// IAlterIndexClauseContext is an interface to support dynamic dispatch.
type IAlterIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterIndexClauseContext differentiates from other interfaces.
	IsAlterIndexClauseContext()
}

type AlterIndexClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterIndexClauseContext() *AlterIndexClauseContext {
	var p = new(AlterIndexClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterIndexClause
	return p
}

func (*AlterIndexClauseContext) IsAlterIndexClauseContext() {}

func NewAlterIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterIndexClauseContext {
	var p = new(AlterIndexClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterIndexClause

	return p
}

func (s *AlterIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterIndexClauseContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREBUILD, 0)
}

func (s *AlterIndexClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITION, 0)
}

func (s *AlterIndexClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AlterIndexClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AlterIndexClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterIndexClauseContext) AllRelationalIndexOption() []IRelationalIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRelationalIndexOptionContext)(nil)).Elem())
	var tst = make([]IRelationalIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRelationalIndexOptionContext)
		}
	}

	return tst
}

func (s *AlterIndexClauseContext) RelationalIndexOption(i int) IRelationalIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationalIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRelationalIndexOptionContext)
}

func (s *AlterIndexClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterIndexClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *AlterIndexClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AlterIndexClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterIndexClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterIndexClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE, 0)
}

func (s *AlterIndexClauseContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREORGANIZE, 0)
}

func (s *AlterIndexClauseContext) ReorganizeOption() IReorganizeOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReorganizeOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReorganizeOptionContext)
}

func (s *AlterIndexClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *AlterIndexClauseContext) AllSetIndexOption() []ISetIndexOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISetIndexOptionContext)(nil)).Elem())
	var tst = make([]ISetIndexOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISetIndexOptionContext)
		}
	}

	return tst
}

func (s *AlterIndexClauseContext) SetIndexOption(i int) ISetIndexOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetIndexOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISetIndexOptionContext)
}

func (s *AlterIndexClauseContext) RESUME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUME, 0)
}

func (s *AlterIndexClauseContext) AllResumableIndexOptions() []IResumableIndexOptionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResumableIndexOptionsContext)(nil)).Elem())
	var tst = make([]IResumableIndexOptionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResumableIndexOptionsContext)
		}
	}

	return tst
}

func (s *AlterIndexClauseContext) ResumableIndexOptions(i int) IResumableIndexOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResumableIndexOptionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResumableIndexOptionsContext)
}

func (s *AlterIndexClauseContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAUSE, 0)
}

func (s *AlterIndexClauseContext) ABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserABORT, 0)
}

func (s *AlterIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterIndexClause(s)
	}
}

func (s *AlterIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterIndexClause(s)
	}
}

func (s *AlterIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterIndexClause() (localctx IAlterIndexClauseContext) {
	this := p
	_ = this

	localctx = NewAlterIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, SQLServerStatementParserRULE_alterIndexClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4342)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserREBUILD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4280)
			p.Match(SQLServerStatementParserREBUILD)
		}
		p.SetState(4287)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserPARTITION {
			{
				p.SetState(4281)
				p.Match(SQLServerStatementParserPARTITION)
			}
			{
				p.SetState(4282)
				p.Match(SQLServerStatementParserEQ_)
			}
			p.SetState(4285)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQLServerStatementParserALL:
				{
					p.SetState(4283)
					p.Match(SQLServerStatementParserALL)
				}

			case SQLServerStatementParserNOT_, SQLServerStatementParserTILDE_, SQLServerStatementParserPLUS_, SQLServerStatementParserMINUS_, SQLServerStatementParserLP_, SQLServerStatementParserLBE_, SQLServerStatementParserQUESTION_, SQLServerStatementParserAT_, SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCASE, SQLServerStatementParserCAST, SQLServerStatementParserIF, SQLServerStatementParserNOT, SQLServerStatementParserNULL, SQLServerStatementParserTRUE, SQLServerStatementParserFALSE, SQLServerStatementParserEXISTS, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserCHAR, SQLServerStatementParserARRAY, SQLServerStatementParserINTERVAL, SQLServerStatementParserDATE, SQLServerStatementParserTIME, SQLServerStatementParserTIMESTAMP, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserCONVERT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_, SQLServerStatementParserSTRING_, SQLServerStatementParserNUMBER_, SQLServerStatementParserHEX_DIGIT_, SQLServerStatementParserBIT_NUM_:
				{
					p.SetState(4284)
					p.expr(0)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(4301)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(4289)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(4290)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4291)
				p.RelationalIndexOption()
			}
			p.SetState(4296)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(4292)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(4293)
					p.RelationalIndexOption()
				}

				p.SetState(4298)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4299)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	case SQLServerStatementParserDISABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4303)
			p.Match(SQLServerStatementParserDISABLE)
		}

	case SQLServerStatementParserREORGANIZE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4304)
			p.Match(SQLServerStatementParserREORGANIZE)
		}
		p.SetState(4308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserPARTITION {
			{
				p.SetState(4305)
				p.Match(SQLServerStatementParserPARTITION)
			}
			{
				p.SetState(4306)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(4307)
				p.expr(0)
			}

		}
		p.SetState(4315)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(4310)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(4311)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4312)
				p.ReorganizeOption()
			}
			{
				p.SetState(4313)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	case SQLServerStatementParserSET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4317)
			p.Match(SQLServerStatementParserSET)
		}
		{
			p.SetState(4318)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4319)
			p.SetIndexOption()
		}

		{
			p.SetState(4320)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4321)
			p.SetIndexOption()
		}

		{
			p.SetState(4323)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserRESUME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4325)
			p.Match(SQLServerStatementParserRESUME)
		}
		p.SetState(4338)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(4326)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(4327)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4328)
				p.ResumableIndexOptions()
			}
			p.SetState(4333)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(4329)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(4330)
					p.ResumableIndexOptions()
				}

				p.SetState(4335)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4336)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	case SQLServerStatementParserPAUSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4340)
			p.Match(SQLServerStatementParserPAUSE)
		}

	case SQLServerStatementParserABORT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4341)
			p.Match(SQLServerStatementParserABORT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRelationalIndexOptionContext is an interface to support dynamic dispatch.
type IRelationalIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalIndexOptionContext differentiates from other interfaces.
	IsRelationalIndexOptionContext()
}

type RelationalIndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalIndexOptionContext() *RelationalIndexOptionContext {
	var p = new(RelationalIndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_relationalIndexOption
	return p
}

func (*RelationalIndexOptionContext) IsRelationalIndexOptionContext() {}

func NewRelationalIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalIndexOptionContext {
	var p = new(RelationalIndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_relationalIndexOption

	return p
}

func (s *RelationalIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalIndexOptionContext) PAD_INDEX() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAD_INDEX, 0)
}

func (s *RelationalIndexOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *RelationalIndexOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *RelationalIndexOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *RelationalIndexOptionContext) FILLFACTOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILLFACTOR, 0)
}

func (s *RelationalIndexOptionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RelationalIndexOptionContext) SORT_IN_TEMPDB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSORT_IN_TEMPDB, 0)
}

func (s *RelationalIndexOptionContext) IGNORE_DUP_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIGNORE_DUP_KEY, 0)
}

func (s *RelationalIndexOptionContext) STATISTICS_NORECOMPUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_NORECOMPUTE, 0)
}

func (s *RelationalIndexOptionContext) STATISTICS_INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_INCREMENTAL, 0)
}

func (s *RelationalIndexOptionContext) DROP_EXISTING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP_EXISTING, 0)
}

func (s *RelationalIndexOptionContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLINE, 0)
}

func (s *RelationalIndexOptionContext) LowPriorityLockWait() ILowPriorityLockWaitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILowPriorityLockWaitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILowPriorityLockWaitContext)
}

func (s *RelationalIndexOptionContext) RESUMABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUMABLE, 0)
}

func (s *RelationalIndexOptionContext) MAX_DURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_DURATION, 0)
}

func (s *RelationalIndexOptionContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *RelationalIndexOptionContext) ALLOW_ROW_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_ROW_LOCKS, 0)
}

func (s *RelationalIndexOptionContext) ALLOW_PAGE_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_PAGE_LOCKS, 0)
}

func (s *RelationalIndexOptionContext) OPTIMIZE_FOR_SEQUENTIAL_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY, 0)
}

func (s *RelationalIndexOptionContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *RelationalIndexOptionContext) DATA_COMPRESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_COMPRESSION, 0)
}

func (s *RelationalIndexOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *RelationalIndexOptionContext) ROW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROW, 0)
}

func (s *RelationalIndexOptionContext) PAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE, 0)
}

func (s *RelationalIndexOptionContext) COLUMNSTORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE, 0)
}

func (s *RelationalIndexOptionContext) COLUMNSTORE_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMNSTORE_ARCHIVE, 0)
}

func (s *RelationalIndexOptionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTITIONS, 0)
}

func (s *RelationalIndexOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *RelationalIndexOptionContext) AllPartitionNumberRange() []IPartitionNumberRangeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPartitionNumberRangeContext)(nil)).Elem())
	var tst = make([]IPartitionNumberRangeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPartitionNumberRangeContext)
		}
	}

	return tst
}

func (s *RelationalIndexOptionContext) PartitionNumberRange(i int) IPartitionNumberRangeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionNumberRangeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPartitionNumberRangeContext)
}

func (s *RelationalIndexOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *RelationalIndexOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *RelationalIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRelationalIndexOption(s)
	}
}

func (s *RelationalIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRelationalIndexOption(s)
	}
}

func (s *RelationalIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRelationalIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RelationalIndexOption() (localctx IRelationalIndexOptionContext) {
	this := p
	_ = this

	localctx = NewRelationalIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, SQLServerStatementParserRULE_relationalIndexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(4411)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserPAD_INDEX:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4344)
			p.Match(SQLServerStatementParserPAD_INDEX)
		}
		{
			p.SetState(4345)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4346)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserFILLFACTOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4347)
			p.Match(SQLServerStatementParserFILLFACTOR)
		}
		{
			p.SetState(4348)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4349)
			p.expr(0)
		}

	case SQLServerStatementParserSORT_IN_TEMPDB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4350)
			p.Match(SQLServerStatementParserSORT_IN_TEMPDB)
		}
		{
			p.SetState(4351)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4352)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserIGNORE_DUP_KEY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4353)
			p.Match(SQLServerStatementParserIGNORE_DUP_KEY)
		}
		{
			p.SetState(4354)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4355)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSTATISTICS_NORECOMPUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4356)
			p.Match(SQLServerStatementParserSTATISTICS_NORECOMPUTE)
		}
		{
			p.SetState(4357)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4358)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSTATISTICS_INCREMENTAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4359)
			p.Match(SQLServerStatementParserSTATISTICS_INCREMENTAL)
		}
		{
			p.SetState(4360)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4361)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDROP_EXISTING:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4362)
			p.Match(SQLServerStatementParserDROP_EXISTING)
		}
		{
			p.SetState(4363)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4364)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserONLINE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4365)
			p.Match(SQLServerStatementParserONLINE)
		}
		{
			p.SetState(4366)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(4372)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserON:
			{
				p.SetState(4367)
				p.Match(SQLServerStatementParserON)
			}
			p.SetState(4369)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserWAIT_AT_LOW_PRIORITY {
				{
					p.SetState(4368)
					p.LowPriorityLockWait()
				}

			}

		case SQLServerStatementParserOFF:
			{
				p.SetState(4371)
				p.Match(SQLServerStatementParserOFF)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SQLServerStatementParserRESUMABLE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4374)
			p.Match(SQLServerStatementParserRESUMABLE)
		}
		{
			p.SetState(4375)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4376)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserMAX_DURATION:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4377)
			p.Match(SQLServerStatementParserMAX_DURATION)
		}
		{
			p.SetState(4378)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4379)
			p.expr(0)
		}
		p.SetState(4381)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserMINUTES {
			{
				p.SetState(4380)
				p.Match(SQLServerStatementParserMINUTES)
			}

		}

	case SQLServerStatementParserALLOW_ROW_LOCKS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4383)
			p.Match(SQLServerStatementParserALLOW_ROW_LOCKS)
		}
		{
			p.SetState(4384)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4385)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserALLOW_PAGE_LOCKS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4386)
			p.Match(SQLServerStatementParserALLOW_PAGE_LOCKS)
		}
		{
			p.SetState(4387)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4388)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4389)
			p.Match(SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY)
		}
		{
			p.SetState(4390)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4391)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserMAXDOP:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4392)
			p.Match(SQLServerStatementParserMAXDOP)
		}
		{
			p.SetState(4393)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4394)
			p.expr(0)
		}

	case SQLServerStatementParserDATA_COMPRESSION:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4395)
			p.Match(SQLServerStatementParserDATA_COMPRESSION)
		}
		{
			p.SetState(4396)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4397)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserROW || _la == SQLServerStatementParserCOLUMNSTORE || _la == SQLServerStatementParserNONE || _la == SQLServerStatementParserPAGE || _la == SQLServerStatementParserCOLUMNSTORE_ARCHIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserON {
			{
				p.SetState(4398)
				p.Match(SQLServerStatementParserON)
			}
			{
				p.SetState(4399)
				p.Match(SQLServerStatementParserPARTITIONS)
			}
			{
				p.SetState(4400)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4401)
				p.PartitionNumberRange()
			}
			p.SetState(4406)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(4402)
						p.Match(SQLServerStatementParserCOMMA_)
					}
					{
						p.SetState(4403)
						p.PartitionNumberRange()
					}

				}
				p.SetState(4408)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext())
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartitionNumberRangeContext is an interface to support dynamic dispatch.
type IPartitionNumberRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionNumberRangeContext differentiates from other interfaces.
	IsPartitionNumberRangeContext()
}

type PartitionNumberRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionNumberRangeContext() *PartitionNumberRangeContext {
	var p = new(PartitionNumberRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_partitionNumberRange
	return p
}

func (*PartitionNumberRangeContext) IsPartitionNumberRangeContext() {}

func NewPartitionNumberRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionNumberRangeContext {
	var p = new(PartitionNumberRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_partitionNumberRange

	return p
}

func (s *PartitionNumberRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionNumberRangeContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PartitionNumberRangeContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PartitionNumberRangeContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTO, 0)
}

func (s *PartitionNumberRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionNumberRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionNumberRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPartitionNumberRange(s)
	}
}

func (s *PartitionNumberRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPartitionNumberRange(s)
	}
}

func (s *PartitionNumberRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPartitionNumberRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PartitionNumberRange() (localctx IPartitionNumberRangeContext) {
	this := p
	_ = this

	localctx = NewPartitionNumberRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, SQLServerStatementParserRULE_partitionNumberRange)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4413)
		p.expr(0)
	}
	p.SetState(4416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserTO {
		{
			p.SetState(4414)
			p.Match(SQLServerStatementParserTO)
		}
		{
			p.SetState(4415)
			p.expr(0)
		}

	}

	return localctx
}

// IReorganizeOptionContext is an interface to support dynamic dispatch.
type IReorganizeOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReorganizeOptionContext differentiates from other interfaces.
	IsReorganizeOptionContext()
}

type ReorganizeOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReorganizeOptionContext() *ReorganizeOptionContext {
	var p = new(ReorganizeOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_reorganizeOption
	return p
}

func (*ReorganizeOptionContext) IsReorganizeOptionContext() {}

func NewReorganizeOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReorganizeOptionContext {
	var p = new(ReorganizeOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_reorganizeOption

	return p
}

func (s *ReorganizeOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReorganizeOptionContext) LOB_COMPACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOB_COMPACTION, 0)
}

func (s *ReorganizeOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ReorganizeOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ReorganizeOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ReorganizeOptionContext) COMPRESS_ALL_ROW_GROUPS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, 0)
}

func (s *ReorganizeOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorganizeOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReorganizeOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterReorganizeOption(s)
	}
}

func (s *ReorganizeOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitReorganizeOption(s)
	}
}

func (s *ReorganizeOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitReorganizeOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ReorganizeOption() (localctx IReorganizeOptionContext) {
	this := p
	_ = this

	localctx = NewReorganizeOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, SQLServerStatementParserRULE_reorganizeOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4424)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserLOB_COMPACTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4418)
			p.Match(SQLServerStatementParserLOB_COMPACTION)
		}
		{
			p.SetState(4419)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4420)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4421)
			p.Match(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS)
		}
		{
			p.SetState(4422)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4423)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISetIndexOptionContext is an interface to support dynamic dispatch.
type ISetIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetIndexOptionContext differentiates from other interfaces.
	IsSetIndexOptionContext()
}

type SetIndexOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetIndexOptionContext() *SetIndexOptionContext {
	var p = new(SetIndexOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setIndexOption
	return p
}

func (*SetIndexOptionContext) IsSetIndexOptionContext() {}

func NewSetIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetIndexOptionContext {
	var p = new(SetIndexOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setIndexOption

	return p
}

func (s *SetIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetIndexOptionContext) ALLOW_ROW_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_ROW_LOCKS, 0)
}

func (s *SetIndexOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SetIndexOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *SetIndexOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *SetIndexOptionContext) ALLOW_PAGE_LOCKS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_PAGE_LOCKS, 0)
}

func (s *SetIndexOptionContext) OPTIMIZE_FOR_SEQUENTIAL_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY, 0)
}

func (s *SetIndexOptionContext) IGNORE_DUP_KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIGNORE_DUP_KEY, 0)
}

func (s *SetIndexOptionContext) STATISTICS_NORECOMPUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATISTICS_NORECOMPUTE, 0)
}

func (s *SetIndexOptionContext) COMPRESSION_DELAY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPRESSION_DELAY, 0)
}

func (s *SetIndexOptionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetIndexOptionContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *SetIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetIndexOption(s)
	}
}

func (s *SetIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetIndexOption(s)
	}
}

func (s *SetIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetIndexOption() (localctx ISetIndexOptionContext) {
	this := p
	_ = this

	localctx = NewSetIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, SQLServerStatementParserRULE_setIndexOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4447)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALLOW_ROW_LOCKS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4426)
			p.Match(SQLServerStatementParserALLOW_ROW_LOCKS)
		}
		{
			p.SetState(4427)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4428)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserALLOW_PAGE_LOCKS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4429)
			p.Match(SQLServerStatementParserALLOW_PAGE_LOCKS)
		}
		{
			p.SetState(4430)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4431)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4432)
			p.Match(SQLServerStatementParserOPTIMIZE_FOR_SEQUENTIAL_KEY)
		}
		{
			p.SetState(4433)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4434)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserIGNORE_DUP_KEY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4435)
			p.Match(SQLServerStatementParserIGNORE_DUP_KEY)
		}
		{
			p.SetState(4436)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4437)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSTATISTICS_NORECOMPUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4438)
			p.Match(SQLServerStatementParserSTATISTICS_NORECOMPUTE)
		}
		{
			p.SetState(4439)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4440)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCOMPRESSION_DELAY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4441)
			p.Match(SQLServerStatementParserCOMPRESSION_DELAY)
		}
		{
			p.SetState(4442)
			p.Match(SQLServerStatementParserEQ_)
		}

		{
			p.SetState(4443)
			p.expr(0)
		}
		p.SetState(4445)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserMINUTES {
			{
				p.SetState(4444)
				p.Match(SQLServerStatementParserMINUTES)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IResumableIndexOptionsContext is an interface to support dynamic dispatch.
type IResumableIndexOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResumableIndexOptionsContext differentiates from other interfaces.
	IsResumableIndexOptionsContext()
}

type ResumableIndexOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumableIndexOptionsContext() *ResumableIndexOptionsContext {
	var p = new(ResumableIndexOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_resumableIndexOptions
	return p
}

func (*ResumableIndexOptionsContext) IsResumableIndexOptionsContext() {}

func NewResumableIndexOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumableIndexOptionsContext {
	var p = new(ResumableIndexOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_resumableIndexOptions

	return p
}

func (s *ResumableIndexOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumableIndexOptionsContext) MAXDOP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXDOP, 0)
}

func (s *ResumableIndexOptionsContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ResumableIndexOptionsContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ResumableIndexOptionsContext) MAX_DURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_DURATION, 0)
}

func (s *ResumableIndexOptionsContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *ResumableIndexOptionsContext) LowPriorityLockWait() ILowPriorityLockWaitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILowPriorityLockWaitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILowPriorityLockWaitContext)
}

func (s *ResumableIndexOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumableIndexOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumableIndexOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterResumableIndexOptions(s)
	}
}

func (s *ResumableIndexOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitResumableIndexOptions(s)
	}
}

func (s *ResumableIndexOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitResumableIndexOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ResumableIndexOptions() (localctx IResumableIndexOptionsContext) {
	this := p
	_ = this

	localctx = NewResumableIndexOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, SQLServerStatementParserRULE_resumableIndexOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4459)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserMAXDOP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4449)
			p.Match(SQLServerStatementParserMAXDOP)
		}
		{
			p.SetState(4450)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4451)
			p.expr(0)
		}

	case SQLServerStatementParserMAX_DURATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4452)
			p.Match(SQLServerStatementParserMAX_DURATION)
		}
		{
			p.SetState(4453)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4454)
			p.expr(0)
		}
		p.SetState(4456)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserMINUTES {
			{
				p.SetState(4455)
				p.Match(SQLServerStatementParserMINUTES)
			}

		}

	case SQLServerStatementParserWAIT_AT_LOW_PRIORITY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4458)
			p.LowPriorityLockWait()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterDatabaseClauseContext is an interface to support dynamic dispatch.
type IAlterDatabaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDatabaseClauseContext differentiates from other interfaces.
	IsAlterDatabaseClauseContext()
}

type AlterDatabaseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseClauseContext() *AlterDatabaseClauseContext {
	var p = new(AlterDatabaseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabaseClause
	return p
}

func (*AlterDatabaseClauseContext) IsAlterDatabaseClauseContext() {}

func NewAlterDatabaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseClauseContext {
	var p = new(AlterDatabaseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabaseClause

	return p
}

func (s *AlterDatabaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMODIFY, 0)
}

func (s *AlterDatabaseClauseContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *AlterDatabaseClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AlterDatabaseClauseContext) DatabaseName() IDatabaseNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *AlterDatabaseClauseContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLATE, 0)
}

func (s *AlterDatabaseClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AlterDatabaseClauseContext) FileAndFilegroupOptions() IFileAndFilegroupOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileAndFilegroupOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileAndFilegroupOptionsContext)
}

func (s *AlterDatabaseClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *AlterDatabaseClauseContext) AllAlterDatabaseOptionSpec() []IAlterDatabaseOptionSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterDatabaseOptionSpecContext)(nil)).Elem())
	var tst = make([]IAlterDatabaseOptionSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterDatabaseOptionSpecContext)
		}
	}

	return tst
}

func (s *AlterDatabaseClauseContext) AlterDatabaseOptionSpec(i int) IAlterDatabaseOptionSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDatabaseOptionSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseOptionSpecContext)
}

func (s *AlterDatabaseClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterDatabaseClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterDatabaseClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *AlterDatabaseClauseContext) Termination() ITerminationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminationContext)
}

func (s *AlterDatabaseClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterDatabaseClauseContext) AllEditionOptions() []IEditionOptionsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEditionOptionsContext)(nil)).Elem())
	var tst = make([]IEditionOptionsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEditionOptionsContext)
		}
	}

	return tst
}

func (s *AlterDatabaseClauseContext) EditionOptions(i int) IEditionOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEditionOptionsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEditionOptionsContext)
}

func (s *AlterDatabaseClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterDatabaseClauseContext) BACKUP_STORAGE_REDUNDANCY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, 0)
}

func (s *AlterDatabaseClauseContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *AlterDatabaseClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADD, 0)
}

func (s *AlterDatabaseClauseContext) SECONDARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECONDARY, 0)
}

func (s *AlterDatabaseClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterDatabaseClauseContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *AlterDatabaseClauseContext) AllAddSecondaryOption() []IAddSecondaryOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddSecondaryOptionContext)(nil)).Elem())
	var tst = make([]IAddSecondaryOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddSecondaryOptionContext)
		}
	}

	return tst
}

func (s *AlterDatabaseClauseContext) AddSecondaryOption(i int) IAddSecondaryOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddSecondaryOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddSecondaryOptionContext)
}

func (s *AlterDatabaseClauseContext) FAILOVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFAILOVER, 0)
}

func (s *AlterDatabaseClauseContext) FORCE_FAILOVER_ALLOW_DATA_LOSS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, 0)
}

func (s *AlterDatabaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterDatabaseClause(s)
	}
}

func (s *AlterDatabaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterDatabaseClause(s)
	}
}

func (s *AlterDatabaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterDatabaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterDatabaseClause() (localctx IAlterDatabaseClauseContext) {
	this := p
	_ = this

	localctx = NewAlterDatabaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, SQLServerStatementParserRULE_alterDatabaseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4515)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 523, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4461)
			p.Match(SQLServerStatementParserMODIFY)
		}
		{
			p.SetState(4462)
			p.Match(SQLServerStatementParserNAME)
		}
		{
			p.SetState(4463)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4464)
			p.DatabaseName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4465)
			p.Match(SQLServerStatementParserCOLLATE)
		}
		{
			p.SetState(4466)
			p.IgnoredIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4467)
			p.FileAndFilegroupOptions()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4468)
			p.Match(SQLServerStatementParserSET)
		}
		{
			p.SetState(4469)
			p.AlterDatabaseOptionSpec()
		}
		p.SetState(4474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4470)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4471)
				p.AlterDatabaseOptionSpec()
			}

			p.SetState(4476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(4477)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(4478)
				p.Termination()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4481)
			p.Match(SQLServerStatementParserMODIFY)
		}
		{
			p.SetState(4482)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4483)
			p.EditionOptions()
		}
		p.SetState(4488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4484)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4485)
				p.EditionOptions()
			}

			p.SetState(4490)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4491)
			p.Match(SQLServerStatementParserRP_)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4493)
			p.Match(SQLServerStatementParserMODIFY)
		}
		{
			p.SetState(4494)
			p.Match(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY)
		}
		{
			p.SetState(4495)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4496)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4497)
			p.Match(SQLServerStatementParserADD)
		}
		{
			p.SetState(4498)
			p.Match(SQLServerStatementParserSECONDARY)
		}
		{
			p.SetState(4499)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(4500)
			p.Match(SQLServerStatementParserSERVER)
		}
		{
			p.SetState(4501)
			p.IgnoredIdentifier()
		}
		p.SetState(4511)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(4502)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(4503)
				p.AddSecondaryOption()
			}
			p.SetState(4508)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(4504)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(4505)
					p.AddSecondaryOption()
				}

				p.SetState(4510)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4513)
			p.Match(SQLServerStatementParserFAILOVER)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4514)
			p.Match(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS)
		}

	}

	return localctx
}

// IAddSecondaryOptionContext is an interface to support dynamic dispatch.
type IAddSecondaryOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSECONDARY_TYPE returns the SECONDARY_TYPE token.
	GetSECONDARY_TYPE() antlr.Token

	// SetSECONDARY_TYPE sets the SECONDARY_TYPE token.
	SetSECONDARY_TYPE(antlr.Token)

	// IsAddSecondaryOptionContext differentiates from other interfaces.
	IsAddSecondaryOptionContext()
}

type AddSecondaryOptionContext struct {
	*antlr.BaseParserRuleContext
	parser         antlr.Parser
	SECONDARY_TYPE antlr.Token
}

func NewEmptyAddSecondaryOptionContext() *AddSecondaryOptionContext {
	var p = new(AddSecondaryOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_addSecondaryOption
	return p
}

func (*AddSecondaryOptionContext) IsAddSecondaryOptionContext() {}

func NewAddSecondaryOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSecondaryOptionContext {
	var p = new(AddSecondaryOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_addSecondaryOption

	return p
}

func (s *AddSecondaryOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSecondaryOptionContext) GetSECONDARY_TYPE() antlr.Token { return s.SECONDARY_TYPE }

func (s *AddSecondaryOptionContext) SetSECONDARY_TYPE(v antlr.Token) { s.SECONDARY_TYPE = v }

func (s *AddSecondaryOptionContext) ALLOW_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_CONNECTIONS, 0)
}

func (s *AddSecondaryOptionContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *AddSecondaryOptionContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *AddSecondaryOptionContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *AddSecondaryOptionContext) NO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO, 0)
}

func (s *AddSecondaryOptionContext) SERVICE_OBJECTIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE_OBJECTIVE, 0)
}

func (s *AddSecondaryOptionContext) ServiceObjective() IServiceObjectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceObjectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceObjectiveContext)
}

func (s *AddSecondaryOptionContext) DATABASE_NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE_NAME, 0)
}

func (s *AddSecondaryOptionContext) DatabaseName() IDatabaseNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabaseNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabaseNameContext)
}

func (s *AddSecondaryOptionContext) GEO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGEO, 0)
}

func (s *AddSecondaryOptionContext) NAMED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAMED, 0)
}

func (s *AddSecondaryOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSecondaryOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSecondaryOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAddSecondaryOption(s)
	}
}

func (s *AddSecondaryOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAddSecondaryOption(s)
	}
}

func (s *AddSecondaryOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAddSecondaryOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AddSecondaryOption() (localctx IAddSecondaryOptionContext) {
	this := p
	_ = this

	localctx = NewAddSecondaryOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, SQLServerStatementParserRULE_addSecondaryOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4529)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALLOW_CONNECTIONS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4517)
			p.Match(SQLServerStatementParserALLOW_CONNECTIONS)
		}
		{
			p.SetState(4518)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4519)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserALL || _la == SQLServerStatementParserNO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserSERVICE_OBJECTIVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4520)
			p.Match(SQLServerStatementParserSERVICE_OBJECTIVE)
		}
		{
			p.SetState(4521)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(4527)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSTRING_:
			{
				p.SetState(4522)
				p.ServiceObjective()
			}

		case SQLServerStatementParserDATABASE_NAME:
			{
				p.SetState(4523)
				p.Match(SQLServerStatementParserDATABASE_NAME)
			}
			{
				p.SetState(4524)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(4525)
				p.DatabaseName()
			}

		case SQLServerStatementParserGEO, SQLServerStatementParserNAMED:
			{
				p.SetState(4526)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AddSecondaryOptionContext).SECONDARY_TYPE = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserGEO || _la == SQLServerStatementParserNAMED) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AddSecondaryOptionContext).SECONDARY_TYPE = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEditionOptionsContext is an interface to support dynamic dispatch.
type IEditionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEditionOptionsContext differentiates from other interfaces.
	IsEditionOptionsContext()
}

type EditionOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEditionOptionsContext() *EditionOptionsContext {
	var p = new(EditionOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_editionOptions
	return p
}

func (*EditionOptionsContext) IsEditionOptionsContext() {}

func NewEditionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EditionOptionsContext {
	var p = new(EditionOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_editionOptions

	return p
}

func (s *EditionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *EditionOptionsContext) MAXSIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAXSIZE, 0)
}

func (s *EditionOptionsContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *EditionOptionsContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *EditionOptionsContext) MB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMB, 0)
}

func (s *EditionOptionsContext) GB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGB, 0)
}

func (s *EditionOptionsContext) EDITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEDITION, 0)
}

func (s *EditionOptionsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *EditionOptionsContext) SERVICE_OBJECTIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE_OBJECTIVE, 0)
}

func (s *EditionOptionsContext) ServiceObjective() IServiceObjectiveContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceObjectiveContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceObjectiveContext)
}

func (s *EditionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EditionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EditionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEditionOptions(s)
	}
}

func (s *EditionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEditionOptions(s)
	}
}

func (s *EditionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEditionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EditionOptions() (localctx IEditionOptionsContext) {
	this := p
	_ = this

	localctx = NewEditionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, SQLServerStatementParserRULE_editionOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4544)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserMAXSIZE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4531)
			p.Match(SQLServerStatementParserMAXSIZE)
		}
		{
			p.SetState(4532)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4533)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(4534)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserMB || _la == SQLServerStatementParserGB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserEDITION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4535)
			p.Match(SQLServerStatementParserEDITION)
		}
		{
			p.SetState(4536)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4537)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case SQLServerStatementParserSERVICE_OBJECTIVE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4538)
			p.Match(SQLServerStatementParserSERVICE_OBJECTIVE)
		}
		{
			p.SetState(4539)
			p.Match(SQLServerStatementParserEQ_)
		}
		p.SetState(4542)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 526, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4540)
				p.Match(SQLServerStatementParserSTRING_)
			}

		case 2:
			{
				p.SetState(4541)
				p.ServiceObjective()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IServiceObjectiveContext is an interface to support dynamic dispatch.
type IServiceObjectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServiceObjectiveContext differentiates from other interfaces.
	IsServiceObjectiveContext()
}

type ServiceObjectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceObjectiveContext() *ServiceObjectiveContext {
	var p = new(ServiceObjectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serviceObjective
	return p
}

func (*ServiceObjectiveContext) IsServiceObjectiveContext() {}

func NewServiceObjectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceObjectiveContext {
	var p = new(ServiceObjectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serviceObjective

	return p
}

func (s *ServiceObjectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceObjectiveContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *ServiceObjectiveContext) ELASTIC_POOL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserELASTIC_POOL, 0)
}

func (s *ServiceObjectiveContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ServiceObjectiveContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *ServiceObjectiveContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ServiceObjectiveContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ServiceObjectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceObjectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceObjectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServiceObjective(s)
	}
}

func (s *ServiceObjectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServiceObjective(s)
	}
}

func (s *ServiceObjectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServiceObjective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServiceObjective() (localctx IServiceObjectiveContext) {
	this := p
	_ = this

	localctx = NewServiceObjectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, SQLServerStatementParserRULE_serviceObjective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4554)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserSTRING_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4546)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case SQLServerStatementParserELASTIC_POOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4547)
			p.Match(SQLServerStatementParserELASTIC_POOL)
		}
		{
			p.SetState(4548)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4549)
			p.IgnoredIdentifier()
		}
		{
			p.SetState(4550)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4551)
			p.Match(SQLServerStatementParserSTRING_)
		}
		{
			p.SetState(4552)
			p.Match(SQLServerStatementParserRP_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlterDatabaseOptionSpecContext is an interface to support dynamic dispatch.
type IAlterDatabaseOptionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDatabaseOptionSpecContext differentiates from other interfaces.
	IsAlterDatabaseOptionSpecContext()
}

type AlterDatabaseOptionSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseOptionSpecContext() *AlterDatabaseOptionSpecContext {
	var p = new(AlterDatabaseOptionSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabaseOptionSpec
	return p
}

func (*AlterDatabaseOptionSpecContext) IsAlterDatabaseOptionSpecContext() {}

func NewAlterDatabaseOptionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseOptionSpecContext {
	var p = new(AlterDatabaseOptionSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterDatabaseOptionSpec

	return p
}

func (s *AlterDatabaseOptionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseOptionSpecContext) AcceleratedDatabaseRecovery() IAcceleratedDatabaseRecoveryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAcceleratedDatabaseRecoveryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAcceleratedDatabaseRecoveryContext)
}

func (s *AlterDatabaseOptionSpecContext) AutoOption() IAutoOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAutoOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAutoOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) AutomaticTuningOption() IAutomaticTuningOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAutomaticTuningOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAutomaticTuningOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) ChangeTrackingOption() IChangeTrackingOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChangeTrackingOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChangeTrackingOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) CONTAINMENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTAINMENT, 0)
}

func (s *AlterDatabaseOptionSpecContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AlterDatabaseOptionSpecContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *AlterDatabaseOptionSpecContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARTIAL, 0)
}

func (s *AlterDatabaseOptionSpecContext) CursorOption() ICursorOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICursorOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICursorOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) DATE_CORRELATION_OPTIMIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, 0)
}

func (s *AlterDatabaseOptionSpecContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AlterDatabaseOptionSpecContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *AlterDatabaseOptionSpecContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *AlterDatabaseOptionSpecContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUSPEND, 0)
}

func (s *AlterDatabaseOptionSpecContext) RESUME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESUME, 0)
}

func (s *AlterDatabaseOptionSpecContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserONLINE, 0)
}

func (s *AlterDatabaseOptionSpecContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFFLINE, 0)
}

func (s *AlterDatabaseOptionSpecContext) EMERGENCY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEMERGENCY, 0)
}

func (s *AlterDatabaseOptionSpecContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *AlterDatabaseOptionSpecContext) READ_WRITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_WRITE, 0)
}

func (s *AlterDatabaseOptionSpecContext) SINGLE_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSINGLE_USER, 0)
}

func (s *AlterDatabaseOptionSpecContext) RESTRICTED_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESTRICTED_USER, 0)
}

func (s *AlterDatabaseOptionSpecContext) MULTI_USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMULTI_USER, 0)
}

func (s *AlterDatabaseOptionSpecContext) DELAYED_DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELAYED_DURABILITY, 0)
}

func (s *AlterDatabaseOptionSpecContext) DISABLED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLED, 0)
}

func (s *AlterDatabaseOptionSpecContext) ALLOWED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOWED, 0)
}

func (s *AlterDatabaseOptionSpecContext) FORCED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCED, 0)
}

func (s *AlterDatabaseOptionSpecContext) ExternalAccessOption() IExternalAccessOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExternalAccessOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExternalAccessOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *AlterDatabaseOptionSpecContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterDatabaseOptionSpecContext) FileStreamOption() IFileStreamOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileStreamOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileStreamOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterDatabaseOptionSpecContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterDatabaseOptionSpecContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *AlterDatabaseOptionSpecContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *AlterDatabaseOptionSpecContext) HADR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHADR, 0)
}

func (s *AlterDatabaseOptionSpecContext) MIXED_PAGE_ALLOCATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMIXED_PAGE_ALLOCATION, 0)
}

func (s *AlterDatabaseOptionSpecContext) PARAMETERIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPARAMETERIZATION, 0)
}

func (s *AlterDatabaseOptionSpecContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIMPLE, 0)
}

func (s *AlterDatabaseOptionSpecContext) QueryStoreOptions() IQueryStoreOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryStoreOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryStoreOptionsContext)
}

func (s *AlterDatabaseOptionSpecContext) RecoveryOption() IRecoveryOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRecoveryOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRecoveryOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) ServiceBrokerOption() IServiceBrokerOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceBrokerOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceBrokerOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) SnapshotOption() ISnapshotOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISnapshotOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISnapshotOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) SqlOption() ISqlOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqlOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqlOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) TargetRecoveryTimeOption() ITargetRecoveryTimeOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITargetRecoveryTimeOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITargetRecoveryTimeOptionContext)
}

func (s *AlterDatabaseOptionSpecContext) Termination() ITerminationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITerminationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITerminationContext)
}

func (s *AlterDatabaseOptionSpecContext) TEMPORAL_HISTORY_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, 0)
}

func (s *AlterDatabaseOptionSpecContext) DATA_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_RETENTION, 0)
}

func (s *AlterDatabaseOptionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseOptionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseOptionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterDatabaseOptionSpec(s)
	}
}

func (s *AlterDatabaseOptionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterDatabaseOptionSpec(s)
	}
}

func (s *AlterDatabaseOptionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterDatabaseOptionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterDatabaseOptionSpec() (localctx IAlterDatabaseOptionSpecContext) {
	this := p
	_ = this

	localctx = NewAlterDatabaseOptionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, SQLServerStatementParserRULE_alterDatabaseOptionSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4599)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserACCELERATED_DATABASE_RECOVERY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4556)
			p.AcceleratedDatabaseRecovery()
		}

	case SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserAUTO_CLOSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4557)
			p.AutoOption()
		}

	case SQLServerStatementParserAUTOMATIC_TUNING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4558)
			p.AutomaticTuningOption()
		}

	case SQLServerStatementParserCHANGE_TRACKING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4559)
			p.ChangeTrackingOption()
		}

	case SQLServerStatementParserCONTAINMENT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4560)
			p.Match(SQLServerStatementParserCONTAINMENT)
		}
		{
			p.SetState(4561)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4562)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserNONE || _la == SQLServerStatementParserPARTIAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4563)
			p.CursorOption()
		}

	case SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4564)
			p.Match(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION)
		}
		{
			p.SetState(4565)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserENCRYPTION:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4566)
			p.Match(SQLServerStatementParserENCRYPTION)
		}
		{
			p.SetState(4567)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF || _la == SQLServerStatementParserRESUME || _la == SQLServerStatementParserSUSPEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserONLINE, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4568)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserONLINE || _la == SQLServerStatementParserOFFLINE || _la == SQLServerStatementParserEMERGENCY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserREAD_ONLY, SQLServerStatementParserREAD_WRITE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4569)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserREAD_WRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4570)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-609)&-(0x1f+1)) == 0 && ((1<<uint((_la-609)))&((1<<(SQLServerStatementParserMULTI_USER-609))|(1<<(SQLServerStatementParserRESTRICTED_USER-609))|(1<<(SQLServerStatementParserSINGLE_USER-609)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDELAYED_DURABILITY:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4571)
			p.Match(SQLServerStatementParserDELAYED_DURABILITY)
		}
		{
			p.SetState(4572)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4573)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserFORCED || _la == SQLServerStatementParserDISABLED || _la == SQLServerStatementParserALLOWED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4574)
			p.ExternalAccessOption()
		}

	case SQLServerStatementParserFILESTREAM:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4575)
			p.Match(SQLServerStatementParserFILESTREAM)
		}
		{
			p.SetState(4576)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4577)
			p.FileStreamOption()
		}
		{
			p.SetState(4578)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4580)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(4581)
			p.Match(SQLServerStatementParserDATABASE)
		}
		{
			p.SetState(4582)
			p.Match(SQLServerStatementParserSET)
		}
		{
			p.SetState(4583)
			p.Match(SQLServerStatementParserHADR)
		}

	case SQLServerStatementParserMIXED_PAGE_ALLOCATION:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4584)
			p.Match(SQLServerStatementParserMIXED_PAGE_ALLOCATION)
		}
		{
			p.SetState(4585)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserPARAMETERIZATION:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4586)
			p.Match(SQLServerStatementParserPARAMETERIZATION)
		}
		{
			p.SetState(4587)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserSIMPLE || _la == SQLServerStatementParserFORCED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserQUERY_STORE:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4588)
			p.QueryStoreOptions()
		}

	case SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserRECOVERY:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4589)
			p.RecoveryOption()
		}

	case SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4590)
			p.ServiceBrokerOption()
		}

	case SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4591)
			p.SnapshotOption()
		}

	case SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4592)
			p.SqlOption()
		}

	case SQLServerStatementParserTARGET_RECOVERY_TIME:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4593)
			p.TargetRecoveryTimeOption()
		}

	case SQLServerStatementParserROLLBACK, SQLServerStatementParserNO_WAIT:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4594)
			p.Termination()
		}

	case SQLServerStatementParserTEMPORAL_HISTORY_RETENTION:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4595)
			p.Match(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION)
		}
		{
			p.SetState(4596)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDATA_RETENTION:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(4597)
			p.Match(SQLServerStatementParserDATA_RETENTION)
		}
		{
			p.SetState(4598)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileAndFilegroupOptionsContext is an interface to support dynamic dispatch.
type IFileAndFilegroupOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileAndFilegroupOptionsContext differentiates from other interfaces.
	IsFileAndFilegroupOptionsContext()
}

type FileAndFilegroupOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileAndFilegroupOptionsContext() *FileAndFilegroupOptionsContext {
	var p = new(FileAndFilegroupOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fileAndFilegroupOptions
	return p
}

func (*FileAndFilegroupOptionsContext) IsFileAndFilegroupOptionsContext() {}

func NewFileAndFilegroupOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileAndFilegroupOptionsContext {
	var p = new(FileAndFilegroupOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fileAndFilegroupOptions

	return p
}

func (s *FileAndFilegroupOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FileAndFilegroupOptionsContext) AddOrModifyFiles() IAddOrModifyFilesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrModifyFilesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrModifyFilesContext)
}

func (s *FileAndFilegroupOptionsContext) FileSpec() IFileSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSpecContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFileSpecContext)
}

func (s *FileAndFilegroupOptionsContext) AddOrModifyFilegroups() IAddOrModifyFilegroupsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddOrModifyFilegroupsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddOrModifyFilegroupsContext)
}

func (s *FileAndFilegroupOptionsContext) FilegroupUpdatabilityOption() IFilegroupUpdatabilityOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilegroupUpdatabilityOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilegroupUpdatabilityOptionContext)
}

func (s *FileAndFilegroupOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileAndFilegroupOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileAndFilegroupOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFileAndFilegroupOptions(s)
	}
}

func (s *FileAndFilegroupOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFileAndFilegroupOptions(s)
	}
}

func (s *FileAndFilegroupOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFileAndFilegroupOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FileAndFilegroupOptions() (localctx IFileAndFilegroupOptionsContext) {
	this := p
	_ = this

	localctx = NewFileAndFilegroupOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, SQLServerStatementParserRULE_fileAndFilegroupOptions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4601)
			p.AddOrModifyFiles()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4602)
			p.FileSpec()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4603)
			p.AddOrModifyFilegroups()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4604)
			p.FilegroupUpdatabilityOption()
		}

	}

	return localctx
}

// IAddOrModifyFilegroupsContext is an interface to support dynamic dispatch.
type IAddOrModifyFilegroupsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOrModifyFilegroupsContext differentiates from other interfaces.
	IsAddOrModifyFilegroupsContext()
}

type AddOrModifyFilegroupsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOrModifyFilegroupsContext() *AddOrModifyFilegroupsContext {
	var p = new(AddOrModifyFilegroupsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_addOrModifyFilegroups
	return p
}

func (*AddOrModifyFilegroupsContext) IsAddOrModifyFilegroupsContext() {}

func NewAddOrModifyFilegroupsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOrModifyFilegroupsContext {
	var p = new(AddOrModifyFilegroupsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_addOrModifyFilegroups

	return p
}

func (s *AddOrModifyFilegroupsContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOrModifyFilegroupsContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADD, 0)
}

func (s *AddOrModifyFilegroupsContext) FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROUP, 0)
}

func (s *AddOrModifyFilegroupsContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AddOrModifyFilegroupsContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTAINS, 0)
}

func (s *AddOrModifyFilegroupsContext) FILESTREAM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILESTREAM, 0)
}

func (s *AddOrModifyFilegroupsContext) MEMORY_OPTIMIZED_DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED_DATA, 0)
}

func (s *AddOrModifyFilegroupsContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOVE, 0)
}

func (s *AddOrModifyFilegroupsContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMODIFY, 0)
}

func (s *AddOrModifyFilegroupsContext) FilegroupUpdatabilityOption() IFilegroupUpdatabilityOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilegroupUpdatabilityOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilegroupUpdatabilityOptionContext)
}

func (s *AddOrModifyFilegroupsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *AddOrModifyFilegroupsContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNAME, 0)
}

func (s *AddOrModifyFilegroupsContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AddOrModifyFilegroupsContext) AUTOGROW_SINGLE_FILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTOGROW_SINGLE_FILE, 0)
}

func (s *AddOrModifyFilegroupsContext) AUTOGROW_ALL_FILES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTOGROW_ALL_FILES, 0)
}

func (s *AddOrModifyFilegroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOrModifyFilegroupsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOrModifyFilegroupsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAddOrModifyFilegroups(s)
	}
}

func (s *AddOrModifyFilegroupsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAddOrModifyFilegroups(s)
	}
}

func (s *AddOrModifyFilegroupsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAddOrModifyFilegroups(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AddOrModifyFilegroups() (localctx IAddOrModifyFilegroupsContext) {
	this := p
	_ = this

	localctx = NewAddOrModifyFilegroupsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, SQLServerStatementParserRULE_addOrModifyFilegroups)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4629)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4607)
			p.Match(SQLServerStatementParserADD)
		}
		{
			p.SetState(4608)
			p.Match(SQLServerStatementParserFILEGROUP)
		}
		{
			p.SetState(4609)
			p.IgnoredIdentifier()
		}
		p.SetState(4614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 531, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4610)
				p.Match(SQLServerStatementParserCONTAINS)
			}
			{
				p.SetState(4611)
				p.Match(SQLServerStatementParserFILESTREAM)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 531, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4612)
				p.Match(SQLServerStatementParserCONTAINS)
			}
			{
				p.SetState(4613)
				p.Match(SQLServerStatementParserMEMORY_OPTIMIZED_DATA)
			}

		}

	case SQLServerStatementParserREMOVE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4616)
			p.Match(SQLServerStatementParserREMOVE)
		}
		{
			p.SetState(4617)
			p.Match(SQLServerStatementParserFILEGROUP)
		}
		{
			p.SetState(4618)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserMODIFY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4619)
			p.Match(SQLServerStatementParserMODIFY)
		}
		{
			p.SetState(4620)
			p.Match(SQLServerStatementParserFILEGROUP)
		}
		{
			p.SetState(4621)
			p.IgnoredIdentifier()
		}
		{
			p.SetState(4622)
			p.FilegroupUpdatabilityOption()
		}

	case SQLServerStatementParserDEFAULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4624)
			p.Match(SQLServerStatementParserDEFAULT)
		}

	case SQLServerStatementParserNAME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4625)
			p.Match(SQLServerStatementParserNAME)
		}
		{
			p.SetState(4626)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4627)
			p.IgnoredIdentifier()
		}

	case SQLServerStatementParserAUTOGROW_SINGLE_FILE, SQLServerStatementParserAUTOGROW_ALL_FILES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4628)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserAUTOGROW_SINGLE_FILE || _la == SQLServerStatementParserAUTOGROW_ALL_FILES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFilegroupUpdatabilityOptionContext is an interface to support dynamic dispatch.
type IFilegroupUpdatabilityOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilegroupUpdatabilityOptionContext differentiates from other interfaces.
	IsFilegroupUpdatabilityOptionContext()
}

type FilegroupUpdatabilityOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilegroupUpdatabilityOptionContext() *FilegroupUpdatabilityOptionContext {
	var p = new(FilegroupUpdatabilityOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_filegroupUpdatabilityOption
	return p
}

func (*FilegroupUpdatabilityOptionContext) IsFilegroupUpdatabilityOptionContext() {}

func NewFilegroupUpdatabilityOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilegroupUpdatabilityOptionContext {
	var p = new(FilegroupUpdatabilityOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_filegroupUpdatabilityOption

	return p
}

func (s *FilegroupUpdatabilityOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilegroupUpdatabilityOptionContext) READONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREADONLY, 0)
}

func (s *FilegroupUpdatabilityOptionContext) READWRITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREADWRITE, 0)
}

func (s *FilegroupUpdatabilityOptionContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *FilegroupUpdatabilityOptionContext) READ_WRITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_WRITE, 0)
}

func (s *FilegroupUpdatabilityOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilegroupUpdatabilityOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilegroupUpdatabilityOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFilegroupUpdatabilityOption(s)
	}
}

func (s *FilegroupUpdatabilityOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFilegroupUpdatabilityOption(s)
	}
}

func (s *FilegroupUpdatabilityOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFilegroupUpdatabilityOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FilegroupUpdatabilityOption() (localctx IFilegroupUpdatabilityOptionContext) {
	this := p
	_ = this

	localctx = NewFilegroupUpdatabilityOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, SQLServerStatementParserRULE_filegroupUpdatabilityOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4633)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserREADONLY, SQLServerStatementParserREADWRITE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4631)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREADONLY || _la == SQLServerStatementParserREADWRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserREAD_ONLY, SQLServerStatementParserREAD_WRITE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4632)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserREAD_WRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAddOrModifyFilesContext is an interface to support dynamic dispatch.
type IAddOrModifyFilesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddOrModifyFilesContext differentiates from other interfaces.
	IsAddOrModifyFilesContext()
}

type AddOrModifyFilesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddOrModifyFilesContext() *AddOrModifyFilesContext {
	var p = new(AddOrModifyFilesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_addOrModifyFiles
	return p
}

func (*AddOrModifyFilesContext) IsAddOrModifyFilesContext() {}

func NewAddOrModifyFilesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddOrModifyFilesContext {
	var p = new(AddOrModifyFilesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_addOrModifyFiles

	return p
}

func (s *AddOrModifyFilesContext) GetParser() antlr.Parser { return s.parser }

func (s *AddOrModifyFilesContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADD, 0)
}

func (s *AddOrModifyFilesContext) FILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILE, 0)
}

func (s *AddOrModifyFilesContext) AllFileSpec() []IFileSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFileSpecContext)(nil)).Elem())
	var tst = make([]IFileSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFileSpecContext)
		}
	}

	return tst
}

func (s *AddOrModifyFilesContext) FileSpec(i int) IFileSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFileSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFileSpecContext)
}

func (s *AddOrModifyFilesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AddOrModifyFilesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AddOrModifyFilesContext) TO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTO, 0)
}

func (s *AddOrModifyFilesContext) FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILEGROUP, 0)
}

func (s *AddOrModifyFilesContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AddOrModifyFilesContext) LOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOG, 0)
}

func (s *AddOrModifyFilesContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOVE, 0)
}

func (s *AddOrModifyFilesContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *AddOrModifyFilesContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMODIFY, 0)
}

func (s *AddOrModifyFilesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddOrModifyFilesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddOrModifyFilesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAddOrModifyFiles(s)
	}
}

func (s *AddOrModifyFilesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAddOrModifyFiles(s)
	}
}

func (s *AddOrModifyFilesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAddOrModifyFiles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AddOrModifyFiles() (localctx IAddOrModifyFilesContext) {
	this := p
	_ = this

	localctx = NewAddOrModifyFilesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, SQLServerStatementParserRULE_addOrModifyFiles)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4667)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4635)
			p.Match(SQLServerStatementParserADD)
		}
		{
			p.SetState(4636)
			p.Match(SQLServerStatementParserFILE)
		}
		{
			p.SetState(4637)
			p.FileSpec()
		}
		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4638)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4639)
				p.FileSpec()
			}

			p.SetState(4644)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4648)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserTO {
			{
				p.SetState(4645)
				p.Match(SQLServerStatementParserTO)
			}
			{
				p.SetState(4646)
				p.Match(SQLServerStatementParserFILEGROUP)
			}
			{
				p.SetState(4647)
				p.IgnoredIdentifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4650)
			p.Match(SQLServerStatementParserADD)
		}
		{
			p.SetState(4651)
			p.Match(SQLServerStatementParserLOG)
		}
		{
			p.SetState(4652)
			p.Match(SQLServerStatementParserFILE)
		}
		{
			p.SetState(4653)
			p.FileSpec()
		}
		p.SetState(4658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4654)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4655)
				p.FileSpec()
			}

			p.SetState(4660)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4661)
			p.Match(SQLServerStatementParserREMOVE)
		}
		{
			p.SetState(4662)
			p.Match(SQLServerStatementParserFILE)
		}
		{
			p.SetState(4663)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4664)
			p.Match(SQLServerStatementParserMODIFY)
		}
		{
			p.SetState(4665)
			p.Match(SQLServerStatementParserFILE)
		}
		{
			p.SetState(4666)
			p.FileSpec()
		}

	}

	return localctx
}

// IAcceleratedDatabaseRecoveryContext is an interface to support dynamic dispatch.
type IAcceleratedDatabaseRecoveryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceleratedDatabaseRecoveryContext differentiates from other interfaces.
	IsAcceleratedDatabaseRecoveryContext()
}

type AcceleratedDatabaseRecoveryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceleratedDatabaseRecoveryContext() *AcceleratedDatabaseRecoveryContext {
	var p = new(AcceleratedDatabaseRecoveryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_acceleratedDatabaseRecovery
	return p
}

func (*AcceleratedDatabaseRecoveryContext) IsAcceleratedDatabaseRecoveryContext() {}

func NewAcceleratedDatabaseRecoveryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceleratedDatabaseRecoveryContext {
	var p = new(AcceleratedDatabaseRecoveryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_acceleratedDatabaseRecovery

	return p
}

func (s *AcceleratedDatabaseRecoveryContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceleratedDatabaseRecoveryContext) ACCELERATED_DATABASE_RECOVERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *AcceleratedDatabaseRecoveryContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *AcceleratedDatabaseRecoveryContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) PERSISTENT_VERSION_STORE_FILEGROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *AcceleratedDatabaseRecoveryContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AcceleratedDatabaseRecoveryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceleratedDatabaseRecoveryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceleratedDatabaseRecoveryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAcceleratedDatabaseRecovery(s)
	}
}

func (s *AcceleratedDatabaseRecoveryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAcceleratedDatabaseRecovery(s)
	}
}

func (s *AcceleratedDatabaseRecoveryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAcceleratedDatabaseRecovery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AcceleratedDatabaseRecovery() (localctx IAcceleratedDatabaseRecoveryContext) {
	this := p
	_ = this

	localctx = NewAcceleratedDatabaseRecoveryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, SQLServerStatementParserRULE_acceleratedDatabaseRecovery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4669)
		p.Match(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY)
	}
	{
		p.SetState(4670)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(4671)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4678)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 538, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4672)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4673)
			p.Match(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP)
		}
		{
			p.SetState(4674)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4675)
			p.IgnoredIdentifier()
		}
		{
			p.SetState(4676)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IAutoOptionContext is an interface to support dynamic dispatch.
type IAutoOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAutoOptionContext differentiates from other interfaces.
	IsAutoOptionContext()
}

type AutoOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAutoOptionContext() *AutoOptionContext {
	var p = new(AutoOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_autoOption
	return p
}

func (*AutoOptionContext) IsAutoOptionContext() {}

func NewAutoOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AutoOptionContext {
	var p = new(AutoOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_autoOption

	return p
}

func (s *AutoOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AutoOptionContext) AUTO_CLOSE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CLOSE, 0)
}

func (s *AutoOptionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserON)
}

func (s *AutoOptionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, i)
}

func (s *AutoOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *AutoOptionContext) AUTO_CREATE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CREATE_STATISTICS, 0)
}

func (s *AutoOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AutoOptionContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINCREMENTAL, 0)
}

func (s *AutoOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AutoOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AutoOptionContext) AUTO_SHRINK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_SHRINK, 0)
}

func (s *AutoOptionContext) AUTO_UPDATE_STATISTICS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_UPDATE_STATISTICS, 0)
}

func (s *AutoOptionContext) AUTO_UPDATE_STATISTICS_ASYNC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, 0)
}

func (s *AutoOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutoOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AutoOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAutoOption(s)
	}
}

func (s *AutoOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAutoOption(s)
	}
}

func (s *AutoOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAutoOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AutoOption() (localctx IAutoOptionContext) {
	this := p
	_ = this

	localctx = NewAutoOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, SQLServerStatementParserRULE_autoOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserAUTO_CLOSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4680)
			p.Match(SQLServerStatementParserAUTO_CLOSE)
		}
		{
			p.SetState(4681)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserAUTO_CREATE_STATISTICS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4682)
			p.Match(SQLServerStatementParserAUTO_CREATE_STATISTICS)
		}
		p.SetState(4692)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserOFF:
			{
				p.SetState(4683)
				p.Match(SQLServerStatementParserOFF)
			}

		case SQLServerStatementParserON:
			{
				p.SetState(4684)
				p.Match(SQLServerStatementParserON)
			}
			p.SetState(4690)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4685)
					p.Match(SQLServerStatementParserLP_)
				}
				{
					p.SetState(4686)
					p.Match(SQLServerStatementParserINCREMENTAL)
				}
				{
					p.SetState(4687)
					p.Match(SQLServerStatementParserEQ_)
				}
				{
					p.SetState(4688)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(4689)
					p.Match(SQLServerStatementParserRP_)
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case SQLServerStatementParserAUTO_SHRINK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4694)
			p.Match(SQLServerStatementParserAUTO_SHRINK)
		}
		{
			p.SetState(4695)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserAUTO_UPDATE_STATISTICS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4696)
			p.Match(SQLServerStatementParserAUTO_UPDATE_STATISTICS)
		}
		{
			p.SetState(4697)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4698)
			p.Match(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC)
		}
		{
			p.SetState(4699)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAutomaticTuningOptionContext is an interface to support dynamic dispatch.
type IAutomaticTuningOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAutomaticTuningOptionContext differentiates from other interfaces.
	IsAutomaticTuningOptionContext()
}

type AutomaticTuningOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAutomaticTuningOptionContext() *AutomaticTuningOptionContext {
	var p = new(AutomaticTuningOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_automaticTuningOption
	return p
}

func (*AutomaticTuningOptionContext) IsAutomaticTuningOptionContext() {}

func NewAutomaticTuningOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AutomaticTuningOptionContext {
	var p = new(AutomaticTuningOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_automaticTuningOption

	return p
}

func (s *AutomaticTuningOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AutomaticTuningOptionContext) AUTOMATIC_TUNING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTOMATIC_TUNING, 0)
}

func (s *AutomaticTuningOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AutomaticTuningOptionContext) FORCE_LAST_GOOD_PLAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORCE_LAST_GOOD_PLAN, 0)
}

func (s *AutomaticTuningOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *AutomaticTuningOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AutomaticTuningOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *AutomaticTuningOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *AutomaticTuningOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AutomaticTuningOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AutomaticTuningOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAutomaticTuningOption(s)
	}
}

func (s *AutomaticTuningOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAutomaticTuningOption(s)
	}
}

func (s *AutomaticTuningOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAutomaticTuningOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AutomaticTuningOption() (localctx IAutomaticTuningOptionContext) {
	this := p
	_ = this

	localctx = NewAutomaticTuningOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, SQLServerStatementParserRULE_automaticTuningOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4702)
		p.Match(SQLServerStatementParserAUTOMATIC_TUNING)
	}
	{
		p.SetState(4703)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4704)
		p.Match(SQLServerStatementParserFORCE_LAST_GOOD_PLAN)
	}
	{
		p.SetState(4705)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(4706)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4707)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IChangeTrackingOptionContext is an interface to support dynamic dispatch.
type IChangeTrackingOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChangeTrackingOptionContext differentiates from other interfaces.
	IsChangeTrackingOptionContext()
}

type ChangeTrackingOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeTrackingOptionContext() *ChangeTrackingOptionContext {
	var p = new(ChangeTrackingOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_changeTrackingOption
	return p
}

func (*ChangeTrackingOptionContext) IsChangeTrackingOptionContext() {}

func NewChangeTrackingOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeTrackingOptionContext {
	var p = new(ChangeTrackingOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_changeTrackingOption

	return p
}

func (s *ChangeTrackingOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeTrackingOptionContext) CHANGE_TRACKING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE_TRACKING, 0)
}

func (s *ChangeTrackingOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ChangeTrackingOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ChangeTrackingOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ChangeTrackingOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *ChangeTrackingOptionContext) AllChangeTrackingOptionList() []IChangeTrackingOptionListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChangeTrackingOptionListContext)(nil)).Elem())
	var tst = make([]IChangeTrackingOptionListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChangeTrackingOptionListContext)
		}
	}

	return tst
}

func (s *ChangeTrackingOptionContext) ChangeTrackingOptionList(i int) IChangeTrackingOptionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChangeTrackingOptionListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChangeTrackingOptionListContext)
}

func (s *ChangeTrackingOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *ChangeTrackingOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ChangeTrackingOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ChangeTrackingOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeTrackingOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeTrackingOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterChangeTrackingOption(s)
	}
}

func (s *ChangeTrackingOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitChangeTrackingOption(s)
	}
}

func (s *ChangeTrackingOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitChangeTrackingOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ChangeTrackingOption() (localctx IChangeTrackingOptionContext) {
	this := p
	_ = this

	localctx = NewChangeTrackingOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, SQLServerStatementParserRULE_changeTrackingOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4709)
		p.Match(SQLServerStatementParserCHANGE_TRACKING)
	}
	p.SetState(4729)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 545, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4710)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4711)
			p.Match(SQLServerStatementParserOFF)
		}

	case 2:
		p.SetState(4714)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEQ_ {
			{
				p.SetState(4712)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(4713)
				p.Match(SQLServerStatementParserON)
			}

		}
		p.SetState(4727)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 544, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4716)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4717)
				p.ChangeTrackingOptionList()
			}
			p.SetState(4722)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(4718)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(4719)
					p.ChangeTrackingOptionList()
				}

				p.SetState(4724)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4725)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	}

	return localctx
}

// IChangeTrackingOptionListContext is an interface to support dynamic dispatch.
type IChangeTrackingOptionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChangeTrackingOptionListContext differentiates from other interfaces.
	IsChangeTrackingOptionListContext()
}

type ChangeTrackingOptionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeTrackingOptionListContext() *ChangeTrackingOptionListContext {
	var p = new(ChangeTrackingOptionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_changeTrackingOptionList
	return p
}

func (*ChangeTrackingOptionListContext) IsChangeTrackingOptionListContext() {}

func NewChangeTrackingOptionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeTrackingOptionListContext {
	var p = new(ChangeTrackingOptionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_changeTrackingOptionList

	return p
}

func (s *ChangeTrackingOptionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeTrackingOptionListContext) AUTO_CLEANUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO_CLEANUP, 0)
}

func (s *ChangeTrackingOptionListContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ChangeTrackingOptionListContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ChangeTrackingOptionListContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ChangeTrackingOptionListContext) CHANGE_RETENTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE_RETENTION, 0)
}

func (s *ChangeTrackingOptionListContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *ChangeTrackingOptionListContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAYS, 0)
}

func (s *ChangeTrackingOptionListContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHOURS, 0)
}

func (s *ChangeTrackingOptionListContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *ChangeTrackingOptionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeTrackingOptionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeTrackingOptionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterChangeTrackingOptionList(s)
	}
}

func (s *ChangeTrackingOptionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitChangeTrackingOptionList(s)
	}
}

func (s *ChangeTrackingOptionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitChangeTrackingOptionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ChangeTrackingOptionList() (localctx IChangeTrackingOptionListContext) {
	this := p
	_ = this

	localctx = NewChangeTrackingOptionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, SQLServerStatementParserRULE_changeTrackingOptionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4738)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserAUTO_CLEANUP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.Match(SQLServerStatementParserAUTO_CLEANUP)
		}
		{
			p.SetState(4732)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4733)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCHANGE_RETENTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4734)
			p.Match(SQLServerStatementParserCHANGE_RETENTION)
		}
		{
			p.SetState(4735)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4736)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(4737)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDAYS || _la == SQLServerStatementParserMINUTES || _la == SQLServerStatementParserHOURS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICursorOptionContext is an interface to support dynamic dispatch.
type ICursorOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCursorOptionContext differentiates from other interfaces.
	IsCursorOptionContext()
}

type CursorOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorOptionContext() *CursorOptionContext {
	var p = new(CursorOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_cursorOption
	return p
}

func (*CursorOptionContext) IsCursorOptionContext() {}

func NewCursorOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorOptionContext {
	var p = new(CursorOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_cursorOption

	return p
}

func (s *CursorOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorOptionContext) CURSOR_CLOSE_ON_COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, 0)
}

func (s *CursorOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CursorOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *CursorOptionContext) CURSOR_DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCURSOR_DEFAULT, 0)
}

func (s *CursorOptionContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOCAL, 0)
}

func (s *CursorOptionContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGLOBAL, 0)
}

func (s *CursorOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCursorOption(s)
	}
}

func (s *CursorOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCursorOption(s)
	}
}

func (s *CursorOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCursorOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CursorOption() (localctx ICursorOptionContext) {
	this := p
	_ = this

	localctx = NewCursorOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, SQLServerStatementParserRULE_cursorOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4740)
			p.Match(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT)
		}
		{
			p.SetState(4741)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCURSOR_DEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4742)
			p.Match(SQLServerStatementParserCURSOR_DEFAULT)
		}
		{
			p.SetState(4743)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserLOCAL || _la == SQLServerStatementParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExternalAccessOptionContext is an interface to support dynamic dispatch.
type IExternalAccessOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalAccessOptionContext differentiates from other interfaces.
	IsExternalAccessOptionContext()
}

type ExternalAccessOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalAccessOptionContext() *ExternalAccessOptionContext {
	var p = new(ExternalAccessOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_externalAccessOption
	return p
}

func (*ExternalAccessOptionContext) IsExternalAccessOptionContext() {}

func NewExternalAccessOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalAccessOptionContext {
	var p = new(ExternalAccessOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_externalAccessOption

	return p
}

func (s *ExternalAccessOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalAccessOptionContext) DB_CHAINING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDB_CHAINING, 0)
}

func (s *ExternalAccessOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ExternalAccessOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ExternalAccessOptionContext) TRUSTWORTHY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRUSTWORTHY, 0)
}

func (s *ExternalAccessOptionContext) DEFAULT_FULLTEXT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, 0)
}

func (s *ExternalAccessOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *ExternalAccessOptionContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTRING_, 0)
}

func (s *ExternalAccessOptionContext) DEFAULT_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT_LANGUAGE, 0)
}

func (s *ExternalAccessOptionContext) NESTED_TRIGGERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNESTED_TRIGGERS, 0)
}

func (s *ExternalAccessOptionContext) TRANSFORM_NOISE_WORDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSFORM_NOISE_WORDS, 0)
}

func (s *ExternalAccessOptionContext) TWO_DIGIT_YEAR_CUTOFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, 0)
}

func (s *ExternalAccessOptionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *ExternalAccessOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalAccessOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalAccessOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExternalAccessOption(s)
	}
}

func (s *ExternalAccessOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExternalAccessOption(s)
	}
}

func (s *ExternalAccessOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExternalAccessOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ExternalAccessOption() (localctx IExternalAccessOptionContext) {
	this := p
	_ = this

	localctx = NewExternalAccessOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, SQLServerStatementParserRULE_externalAccessOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4765)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserDB_CHAINING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4746)
			p.Match(SQLServerStatementParserDB_CHAINING)
		}
		{
			p.SetState(4747)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTRUSTWORTHY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4748)
			p.Match(SQLServerStatementParserTRUSTWORTHY)
		}
		{
			p.SetState(4749)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4750)
			p.Match(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE)
		}
		{
			p.SetState(4751)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4752)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case SQLServerStatementParserDEFAULT_LANGUAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4753)
			p.Match(SQLServerStatementParserDEFAULT_LANGUAGE)
		}
		{
			p.SetState(4754)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4755)
			p.Match(SQLServerStatementParserSTRING_)
		}

	case SQLServerStatementParserNESTED_TRIGGERS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4756)
			p.Match(SQLServerStatementParserNESTED_TRIGGERS)
		}
		{
			p.SetState(4757)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4758)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTRANSFORM_NOISE_WORDS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4759)
			p.Match(SQLServerStatementParserTRANSFORM_NOISE_WORDS)
		}
		{
			p.SetState(4760)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4761)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4762)
			p.Match(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF)
		}
		{
			p.SetState(4763)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4764)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryStoreOptionsContext is an interface to support dynamic dispatch.
type IQueryStoreOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryStoreOptionsContext differentiates from other interfaces.
	IsQueryStoreOptionsContext()
}

type QueryStoreOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStoreOptionsContext() *QueryStoreOptionsContext {
	var p = new(QueryStoreOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_queryStoreOptions
	return p
}

func (*QueryStoreOptionsContext) IsQueryStoreOptionsContext() {}

func NewQueryStoreOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStoreOptionsContext {
	var p = new(QueryStoreOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_queryStoreOptions

	return p
}

func (s *QueryStoreOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStoreOptionsContext) QUERY_STORE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_STORE, 0)
}

func (s *QueryStoreOptionsContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *QueryStoreOptionsContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *QueryStoreOptionsContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *QueryStoreOptionsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *QueryStoreOptionsContext) AllQueryStoreOptionList() []IQueryStoreOptionListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryStoreOptionListContext)(nil)).Elem())
	var tst = make([]IQueryStoreOptionListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryStoreOptionListContext)
		}
	}

	return tst
}

func (s *QueryStoreOptionsContext) QueryStoreOptionList(i int) IQueryStoreOptionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryStoreOptionListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryStoreOptionListContext)
}

func (s *QueryStoreOptionsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *QueryStoreOptionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *QueryStoreOptionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *QueryStoreOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStoreOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStoreOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQueryStoreOptions(s)
	}
}

func (s *QueryStoreOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQueryStoreOptions(s)
	}
}

func (s *QueryStoreOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQueryStoreOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QueryStoreOptions() (localctx IQueryStoreOptionsContext) {
	this := p
	_ = this

	localctx = NewQueryStoreOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, SQLServerStatementParserRULE_queryStoreOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4767)
		p.Match(SQLServerStatementParserQUERY_STORE)
	}
	p.SetState(4787)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4768)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4769)
			p.Match(SQLServerStatementParserOFF)
		}

	case 2:
		p.SetState(4772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserEQ_ {
			{
				p.SetState(4770)
				p.Match(SQLServerStatementParserEQ_)
			}
			{
				p.SetState(4771)
				p.Match(SQLServerStatementParserON)
			}

		}
		p.SetState(4785)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 551, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4774)
				p.Match(SQLServerStatementParserLP_)
			}
			{
				p.SetState(4775)
				p.QueryStoreOptionList()
			}
			p.SetState(4780)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == SQLServerStatementParserCOMMA_ {
				{
					p.SetState(4776)
					p.Match(SQLServerStatementParserCOMMA_)
				}
				{
					p.SetState(4777)
					p.QueryStoreOptionList()
				}

				p.SetState(4782)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(4783)
				p.Match(SQLServerStatementParserRP_)
			}

		}

	}

	return localctx
}

// IQueryStoreOptionListContext is an interface to support dynamic dispatch.
type IQueryStoreOptionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryStoreOptionListContext differentiates from other interfaces.
	IsQueryStoreOptionListContext()
}

type QueryStoreOptionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStoreOptionListContext() *QueryStoreOptionListContext {
	var p = new(QueryStoreOptionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_queryStoreOptionList
	return p
}

func (*QueryStoreOptionListContext) IsQueryStoreOptionListContext() {}

func NewQueryStoreOptionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStoreOptionListContext {
	var p = new(QueryStoreOptionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_queryStoreOptionList

	return p
}

func (s *QueryStoreOptionListContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStoreOptionListContext) OPERATION_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPERATION_MODE, 0)
}

func (s *QueryStoreOptionListContext) AllEQ_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserEQ_)
}

func (s *QueryStoreOptionListContext) EQ_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, i)
}

func (s *QueryStoreOptionListContext) READ_WRITE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_WRITE, 0)
}

func (s *QueryStoreOptionListContext) READ_ONLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_ONLY, 0)
}

func (s *QueryStoreOptionListContext) CLEANUP_POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCLEANUP_POLICY, 0)
}

func (s *QueryStoreOptionListContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *QueryStoreOptionListContext) STALE_QUERY_THRESHOLD_DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, 0)
}

func (s *QueryStoreOptionListContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *QueryStoreOptionListContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *QueryStoreOptionListContext) DATA_FLUSH_INTERVAL_SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, 0)
}

func (s *QueryStoreOptionListContext) MAX_STORAGE_SIZE_MB() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_STORAGE_SIZE_MB, 0)
}

func (s *QueryStoreOptionListContext) INTERVAL_LENGTH_MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINTERVAL_LENGTH_MINUTES, 0)
}

func (s *QueryStoreOptionListContext) SIZE_BASED_CLEANUP_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, 0)
}

func (s *QueryStoreOptionListContext) AUTO() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTO, 0)
}

func (s *QueryStoreOptionListContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *QueryStoreOptionListContext) QUERY_CAPTURE_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_CAPTURE_MODE, 0)
}

func (s *QueryStoreOptionListContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *QueryStoreOptionListContext) CUSTOM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCUSTOM, 0)
}

func (s *QueryStoreOptionListContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *QueryStoreOptionListContext) MAX_PLANS_PER_QUERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMAX_PLANS_PER_QUERY, 0)
}

func (s *QueryStoreOptionListContext) WAIT_STATS_CAPTURE_MODE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, 0)
}

func (s *QueryStoreOptionListContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *QueryStoreOptionListContext) QUERY_CAPTURE_POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY_CAPTURE_POLICY, 0)
}

func (s *QueryStoreOptionListContext) AllQueryCapturePolicyOptionList() []IQueryCapturePolicyOptionListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryCapturePolicyOptionListContext)(nil)).Elem())
	var tst = make([]IQueryCapturePolicyOptionListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryCapturePolicyOptionListContext)
		}
	}

	return tst
}

func (s *QueryStoreOptionListContext) QueryCapturePolicyOptionList(i int) IQueryCapturePolicyOptionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryCapturePolicyOptionListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryCapturePolicyOptionListContext)
}

func (s *QueryStoreOptionListContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *QueryStoreOptionListContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *QueryStoreOptionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStoreOptionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStoreOptionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQueryStoreOptionList(s)
	}
}

func (s *QueryStoreOptionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQueryStoreOptionList(s)
	}
}

func (s *QueryStoreOptionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQueryStoreOptionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QueryStoreOptionList() (localctx IQueryStoreOptionListContext) {
	this := p
	_ = this

	localctx = NewQueryStoreOptionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, SQLServerStatementParserRULE_queryStoreOptionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4833)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserOPERATION_MODE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4789)
			p.Match(SQLServerStatementParserOPERATION_MODE)
		}
		{
			p.SetState(4790)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4791)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserREAD_ONLY || _la == SQLServerStatementParserREAD_WRITE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCLEANUP_POLICY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4792)
			p.Match(SQLServerStatementParserCLEANUP_POLICY)
		}
		{
			p.SetState(4793)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4794)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4795)
			p.Match(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS)
		}
		{
			p.SetState(4796)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4797)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(4798)
			p.Match(SQLServerStatementParserRP_)
		}

	case SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4799)
			p.Match(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS)
		}
		{
			p.SetState(4800)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4801)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserMAX_STORAGE_SIZE_MB:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4802)
			p.Match(SQLServerStatementParserMAX_STORAGE_SIZE_MB)
		}
		{
			p.SetState(4803)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4804)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserINTERVAL_LENGTH_MINUTES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4805)
			p.Match(SQLServerStatementParserINTERVAL_LENGTH_MINUTES)
		}
		{
			p.SetState(4806)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4807)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserSIZE_BASED_CLEANUP_MODE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4808)
			p.Match(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE)
		}
		{
			p.SetState(4809)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4810)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserAUTO || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserQUERY_CAPTURE_MODE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4811)
			p.Match(SQLServerStatementParserQUERY_CAPTURE_MODE)
		}
		{
			p.SetState(4812)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4813)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserALL || _la == SQLServerStatementParserAUTO || _la == SQLServerStatementParserNONE || _la == SQLServerStatementParserCUSTOM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserMAX_PLANS_PER_QUERY:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4814)
			p.Match(SQLServerStatementParserMAX_PLANS_PER_QUERY)
		}
		{
			p.SetState(4815)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4816)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserWAIT_STATS_CAPTURE_MODE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4817)
			p.Match(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE)
		}
		{
			p.SetState(4818)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4819)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserQUERY_CAPTURE_POLICY:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4820)
			p.Match(SQLServerStatementParserQUERY_CAPTURE_POLICY)
		}
		{
			p.SetState(4821)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4822)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4823)
			p.QueryCapturePolicyOptionList()
		}
		p.SetState(4828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4824)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(4825)
				p.QueryCapturePolicyOptionList()
			}

			p.SetState(4830)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4831)
			p.Match(SQLServerStatementParserRP_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryCapturePolicyOptionListContext is an interface to support dynamic dispatch.
type IQueryCapturePolicyOptionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryCapturePolicyOptionListContext differentiates from other interfaces.
	IsQueryCapturePolicyOptionListContext()
}

type QueryCapturePolicyOptionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryCapturePolicyOptionListContext() *QueryCapturePolicyOptionListContext {
	var p = new(QueryCapturePolicyOptionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_queryCapturePolicyOptionList
	return p
}

func (*QueryCapturePolicyOptionListContext) IsQueryCapturePolicyOptionListContext() {}

func NewQueryCapturePolicyOptionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryCapturePolicyOptionListContext {
	var p = new(QueryCapturePolicyOptionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_queryCapturePolicyOptionList

	return p
}

func (s *QueryCapturePolicyOptionListContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryCapturePolicyOptionListContext) STALE_CAPTURE_POLICY_THRESHOLD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, 0)
}

func (s *QueryCapturePolicyOptionListContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *QueryCapturePolicyOptionListContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *QueryCapturePolicyOptionListContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDAYS, 0)
}

func (s *QueryCapturePolicyOptionListContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHOURS, 0)
}

func (s *QueryCapturePolicyOptionListContext) EXECUTION_COUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXECUTION_COUNT, 0)
}

func (s *QueryCapturePolicyOptionListContext) TOTAL_COMPILE_CPU_TIME_MS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, 0)
}

func (s *QueryCapturePolicyOptionListContext) TOTAL_EXECUTION_CPU_TIME_MS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, 0)
}

func (s *QueryCapturePolicyOptionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryCapturePolicyOptionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryCapturePolicyOptionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterQueryCapturePolicyOptionList(s)
	}
}

func (s *QueryCapturePolicyOptionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitQueryCapturePolicyOptionList(s)
	}
}

func (s *QueryCapturePolicyOptionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitQueryCapturePolicyOptionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) QueryCapturePolicyOptionList() (localctx IQueryCapturePolicyOptionListContext) {
	this := p
	_ = this

	localctx = NewQueryCapturePolicyOptionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, SQLServerStatementParserRULE_queryCapturePolicyOptionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4835)
			p.Match(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD)
		}
		{
			p.SetState(4836)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4837)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(4838)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDAYS || _la == SQLServerStatementParserHOURS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserEXECUTION_COUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4839)
			p.Match(SQLServerStatementParserEXECUTION_COUNT)
		}
		{
			p.SetState(4840)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4841)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4842)
			p.Match(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS)
		}
		{
			p.SetState(4843)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4844)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4845)
			p.Match(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS)
		}
		{
			p.SetState(4846)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4847)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecoveryOptionContext is an interface to support dynamic dispatch.
type IRecoveryOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecoveryOptionContext differentiates from other interfaces.
	IsRecoveryOptionContext()
}

type RecoveryOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoveryOptionContext() *RecoveryOptionContext {
	var p = new(RecoveryOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_recoveryOption
	return p
}

func (*RecoveryOptionContext) IsRecoveryOptionContext() {}

func NewRecoveryOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoveryOptionContext {
	var p = new(RecoveryOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_recoveryOption

	return p
}

func (s *RecoveryOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoveryOptionContext) RECOVERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECOVERY, 0)
}

func (s *RecoveryOptionContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULL, 0)
}

func (s *RecoveryOptionContext) BULK_LOGGED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBULK_LOGGED, 0)
}

func (s *RecoveryOptionContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSIMPLE, 0)
}

func (s *RecoveryOptionContext) TORN_PAGE_DETECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTORN_PAGE_DETECTION, 0)
}

func (s *RecoveryOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *RecoveryOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *RecoveryOptionContext) PAGE_VERIFY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPAGE_VERIFY, 0)
}

func (s *RecoveryOptionContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECKSUM, 0)
}

func (s *RecoveryOptionContext) NONE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNONE, 0)
}

func (s *RecoveryOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoveryOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoveryOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRecoveryOption(s)
	}
}

func (s *RecoveryOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRecoveryOption(s)
	}
}

func (s *RecoveryOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRecoveryOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RecoveryOption() (localctx IRecoveryOptionContext) {
	this := p
	_ = this

	localctx = NewRecoveryOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, SQLServerStatementParserRULE_recoveryOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4856)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserRECOVERY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4850)
			p.Match(SQLServerStatementParserRECOVERY)
		}
		{
			p.SetState(4851)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserFULL || _la == SQLServerStatementParserSIMPLE || _la == SQLServerStatementParserBULK_LOGGED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserTORN_PAGE_DETECTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4852)
			p.Match(SQLServerStatementParserTORN_PAGE_DETECTION)
		}
		{
			p.SetState(4853)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserPAGE_VERIFY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4854)
			p.Match(SQLServerStatementParserPAGE_VERIFY)
		}
		{
			p.SetState(4855)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserNONE || _la == SQLServerStatementParserCHECKSUM || _la == SQLServerStatementParserTORN_PAGE_DETECTION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISqlOptionContext is an interface to support dynamic dispatch.
type ISqlOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqlOptionContext differentiates from other interfaces.
	IsSqlOptionContext()
}

type SqlOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlOptionContext() *SqlOptionContext {
	var p = new(SqlOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_sqlOption
	return p
}

func (*SqlOptionContext) IsSqlOptionContext() {}

func NewSqlOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlOptionContext {
	var p = new(SqlOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_sqlOption

	return p
}

func (s *SqlOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlOptionContext) ANSI_NULL_DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_NULL_DEFAULT, 0)
}

func (s *SqlOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *SqlOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *SqlOptionContext) ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_NULLS, 0)
}

func (s *SqlOptionContext) ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_PADDING, 0)
}

func (s *SqlOptionContext) ANSI_WARNINGS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANSI_WARNINGS, 0)
}

func (s *SqlOptionContext) ARITHABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserARITHABORT, 0)
}

func (s *SqlOptionContext) COMPATIBILITY_LEVEL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMPATIBILITY_LEVEL, 0)
}

func (s *SqlOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SqlOptionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *SqlOptionContext) CONCAT_NULL_YIELDS_NULL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, 0)
}

func (s *SqlOptionContext) NUMERIC_ROUNDABORT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMERIC_ROUNDABORT, 0)
}

func (s *SqlOptionContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUOTED_IDENTIFIER, 0)
}

func (s *SqlOptionContext) RECURSIVE_TRIGGERS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECURSIVE_TRIGGERS, 0)
}

func (s *SqlOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSqlOption(s)
	}
}

func (s *SqlOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSqlOption(s)
	}
}

func (s *SqlOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSqlOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SqlOption() (localctx ISqlOptionContext) {
	this := p
	_ = this

	localctx = NewSqlOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, SQLServerStatementParserRULE_sqlOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4879)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserANSI_NULL_DEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4858)
			p.Match(SQLServerStatementParserANSI_NULL_DEFAULT)
		}
		{
			p.SetState(4859)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserANSI_NULLS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4860)
			p.Match(SQLServerStatementParserANSI_NULLS)
		}
		{
			p.SetState(4861)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserANSI_PADDING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4862)
			p.Match(SQLServerStatementParserANSI_PADDING)
		}
		{
			p.SetState(4863)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserANSI_WARNINGS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4864)
			p.Match(SQLServerStatementParserANSI_WARNINGS)
		}
		{
			p.SetState(4865)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserARITHABORT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4866)
			p.Match(SQLServerStatementParserARITHABORT)
		}
		{
			p.SetState(4867)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserCOMPATIBILITY_LEVEL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4868)
			p.Match(SQLServerStatementParserCOMPATIBILITY_LEVEL)
		}
		{
			p.SetState(4869)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4870)
			p.Match(SQLServerStatementParserNUMBER_)
		}

	case SQLServerStatementParserCONCAT_NULL_YIELDS_NULL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4871)
			p.Match(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL)
		}
		{
			p.SetState(4872)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserNUMERIC_ROUNDABORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4873)
			p.Match(SQLServerStatementParserNUMERIC_ROUNDABORT)
		}
		{
			p.SetState(4874)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4875)
			p.Match(SQLServerStatementParserQUOTED_IDENTIFIER)
		}
		{
			p.SetState(4876)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserRECURSIVE_TRIGGERS:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4877)
			p.Match(SQLServerStatementParserRECURSIVE_TRIGGERS)
		}
		{
			p.SetState(4878)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISnapshotOptionContext is an interface to support dynamic dispatch.
type ISnapshotOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSnapshotOptionContext differentiates from other interfaces.
	IsSnapshotOptionContext()
}

type SnapshotOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotOptionContext() *SnapshotOptionContext {
	var p = new(SnapshotOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_snapshotOption
	return p
}

func (*SnapshotOptionContext) IsSnapshotOptionContext() {}

func NewSnapshotOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotOptionContext {
	var p = new(SnapshotOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_snapshotOption

	return p
}

func (s *SnapshotOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotOptionContext) ALLOW_SNAPSHOT_ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, 0)
}

func (s *SnapshotOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *SnapshotOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *SnapshotOptionContext) READ_COMMITTED_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, 0)
}

func (s *SnapshotOptionContext) MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, 0)
}

func (s *SnapshotOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *SnapshotOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSnapshotOption(s)
	}
}

func (s *SnapshotOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSnapshotOption(s)
	}
}

func (s *SnapshotOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSnapshotOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SnapshotOption() (localctx ISnapshotOptionContext) {
	this := p
	_ = this

	localctx = NewSnapshotOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, SQLServerStatementParserRULE_snapshotOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4888)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4881)
			p.Match(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION)
		}
		{
			p.SetState(4882)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserREAD_COMMITTED_SNAPSHOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4883)
			p.Match(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT)
		}
		{
			p.SetState(4884)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4885)
			p.Match(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT)
		}
		{
			p.SetState(4886)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4887)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IServiceBrokerOptionContext is an interface to support dynamic dispatch.
type IServiceBrokerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServiceBrokerOptionContext differentiates from other interfaces.
	IsServiceBrokerOptionContext()
}

type ServiceBrokerOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceBrokerOptionContext() *ServiceBrokerOptionContext {
	var p = new(ServiceBrokerOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serviceBrokerOption
	return p
}

func (*ServiceBrokerOptionContext) IsServiceBrokerOptionContext() {}

func NewServiceBrokerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceBrokerOptionContext {
	var p = new(ServiceBrokerOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serviceBrokerOption

	return p
}

func (s *ServiceBrokerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceBrokerOptionContext) ENABLE_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENABLE_BROKER, 0)
}

func (s *ServiceBrokerOptionContext) DISABLE_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISABLE_BROKER, 0)
}

func (s *ServiceBrokerOptionContext) NEW_BROKER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNEW_BROKER, 0)
}

func (s *ServiceBrokerOptionContext) ERROR_BROKER_CONVERSATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserERROR_BROKER_CONVERSATIONS, 0)
}

func (s *ServiceBrokerOptionContext) HONOR_BROKER_PRIORITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserHONOR_BROKER_PRIORITY, 0)
}

func (s *ServiceBrokerOptionContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ServiceBrokerOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ServiceBrokerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceBrokerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceBrokerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServiceBrokerOption(s)
	}
}

func (s *ServiceBrokerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServiceBrokerOption(s)
	}
}

func (s *ServiceBrokerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServiceBrokerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServiceBrokerOption() (localctx IServiceBrokerOptionContext) {
	this := p
	_ = this

	localctx = NewServiceBrokerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, SQLServerStatementParserRULE_serviceBrokerOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4896)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserENABLE_BROKER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4890)
			p.Match(SQLServerStatementParserENABLE_BROKER)
		}

	case SQLServerStatementParserDISABLE_BROKER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4891)
			p.Match(SQLServerStatementParserDISABLE_BROKER)
		}

	case SQLServerStatementParserNEW_BROKER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4892)
			p.Match(SQLServerStatementParserNEW_BROKER)
		}

	case SQLServerStatementParserERROR_BROKER_CONVERSATIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4893)
			p.Match(SQLServerStatementParserERROR_BROKER_CONVERSATIONS)
		}

	case SQLServerStatementParserHONOR_BROKER_PRIORITY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4894)
			p.Match(SQLServerStatementParserHONOR_BROKER_PRIORITY)
		}
		{
			p.SetState(4895)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITargetRecoveryTimeOptionContext is an interface to support dynamic dispatch.
type ITargetRecoveryTimeOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTargetRecoveryTimeOptionContext differentiates from other interfaces.
	IsTargetRecoveryTimeOptionContext()
}

type TargetRecoveryTimeOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetRecoveryTimeOptionContext() *TargetRecoveryTimeOptionContext {
	var p = new(TargetRecoveryTimeOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_targetRecoveryTimeOption
	return p
}

func (*TargetRecoveryTimeOptionContext) IsTargetRecoveryTimeOptionContext() {}

func NewTargetRecoveryTimeOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetRecoveryTimeOptionContext {
	var p = new(TargetRecoveryTimeOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_targetRecoveryTimeOption

	return p
}

func (s *TargetRecoveryTimeOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetRecoveryTimeOptionContext) TARGET_RECOVERY_TIME() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTARGET_RECOVERY_TIME, 0)
}

func (s *TargetRecoveryTimeOptionContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *TargetRecoveryTimeOptionContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *TargetRecoveryTimeOptionContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECONDS, 0)
}

func (s *TargetRecoveryTimeOptionContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMINUTES, 0)
}

func (s *TargetRecoveryTimeOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetRecoveryTimeOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetRecoveryTimeOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTargetRecoveryTimeOption(s)
	}
}

func (s *TargetRecoveryTimeOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTargetRecoveryTimeOption(s)
	}
}

func (s *TargetRecoveryTimeOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTargetRecoveryTimeOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) TargetRecoveryTimeOption() (localctx ITargetRecoveryTimeOptionContext) {
	this := p
	_ = this

	localctx = NewTargetRecoveryTimeOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, SQLServerStatementParserRULE_targetRecoveryTimeOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4898)
		p.Match(SQLServerStatementParserTARGET_RECOVERY_TIME)
	}
	{
		p.SetState(4899)
		p.Match(SQLServerStatementParserEQ_)
	}
	{
		p.SetState(4900)
		p.Match(SQLServerStatementParserNUMBER_)
	}
	{
		p.SetState(4901)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserMINUTES || _la == SQLServerStatementParserSECONDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITerminationContext is an interface to support dynamic dispatch.
type ITerminationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminationContext differentiates from other interfaces.
	IsTerminationContext()
}

type TerminationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminationContext() *TerminationContext {
	var p = new(TerminationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_termination
	return p
}

func (*TerminationContext) IsTerminationContext() {}

func NewTerminationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminationContext {
	var p = new(TerminationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_termination

	return p
}

func (s *TerminationContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminationContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLLBACK, 0)
}

func (s *TerminationContext) AFTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAFTER, 0)
}

func (s *TerminationContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *TerminationContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECONDS, 0)
}

func (s *TerminationContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMMEDIATE, 0)
}

func (s *TerminationContext) NO_WAIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNO_WAIT, 0)
}

func (s *TerminationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterTermination(s)
	}
}

func (s *TerminationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitTermination(s)
	}
}

func (s *TerminationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitTermination(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Termination() (localctx ITerminationContext) {
	this := p
	_ = this

	localctx = NewTerminationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, SQLServerStatementParserRULE_termination)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4912)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4903)
			p.Match(SQLServerStatementParserROLLBACK)
		}
		{
			p.SetState(4904)
			p.Match(SQLServerStatementParserAFTER)
		}
		{
			p.SetState(4905)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		p.SetState(4907)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserSECONDS {
			{
				p.SetState(4906)
				p.Match(SQLServerStatementParserSECONDS)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4909)
			p.Match(SQLServerStatementParserROLLBACK)
		}
		{
			p.SetState(4910)
			p.Match(SQLServerStatementParserIMMEDIATE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4911)
			p.Match(SQLServerStatementParserNO_WAIT)
		}

	}

	return localctx
}

// ICreateServiceClauseContext is an interface to support dynamic dispatch.
type ICreateServiceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateServiceClauseContext differentiates from other interfaces.
	IsCreateServiceClauseContext()
}

type CreateServiceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateServiceClauseContext() *CreateServiceClauseContext {
	var p = new(CreateServiceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createServiceClause
	return p
}

func (*CreateServiceClauseContext) IsCreateServiceClauseContext() {}

func NewCreateServiceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServiceClauseContext {
	var p = new(CreateServiceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createServiceClause

	return p
}

func (s *CreateServiceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServiceClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CreateServiceClauseContext) AllContractName() []IContractNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IContractNameContext)(nil)).Elem())
	var tst = make([]IContractNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IContractNameContext)
		}
	}

	return tst
}

func (s *CreateServiceClauseContext) ContractName(i int) IContractNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContractNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IContractNameContext)
}

func (s *CreateServiceClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CreateServiceClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *CreateServiceClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *CreateServiceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServiceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServiceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateServiceClause(s)
	}
}

func (s *CreateServiceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateServiceClause(s)
	}
}

func (s *CreateServiceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateServiceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateServiceClause() (localctx ICreateServiceClauseContext) {
	this := p
	_ = this

	localctx = NewCreateServiceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, SQLServerStatementParserRULE_createServiceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4914)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4915)
		p.ContractName()
	}
	p.SetState(4920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(4916)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4917)
			p.ContractName()
		}

		p.SetState(4922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4923)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IAlterServiceClauseContext is an interface to support dynamic dispatch.
type IAlterServiceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterServiceClauseContext differentiates from other interfaces.
	IsAlterServiceClauseContext()
}

type AlterServiceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServiceClauseContext() *AlterServiceClauseContext {
	var p = new(AlterServiceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterServiceClause
	return p
}

func (*AlterServiceClauseContext) IsAlterServiceClauseContext() {}

func NewAlterServiceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServiceClauseContext {
	var p = new(AlterServiceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterServiceClause

	return p
}

func (s *AlterServiceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServiceClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *AlterServiceClauseContext) AllAlterServiceOptArg() []IAlterServiceOptArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterServiceOptArgContext)(nil)).Elem())
	var tst = make([]IAlterServiceOptArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterServiceOptArgContext)
		}
	}

	return tst
}

func (s *AlterServiceClauseContext) AlterServiceOptArg(i int) IAlterServiceOptArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterServiceOptArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterServiceOptArgContext)
}

func (s *AlterServiceClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *AlterServiceClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *AlterServiceClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *AlterServiceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServiceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServiceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterServiceClause(s)
	}
}

func (s *AlterServiceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterServiceClause(s)
	}
}

func (s *AlterServiceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterServiceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterServiceClause() (localctx IAlterServiceClauseContext) {
	this := p
	_ = this

	localctx = NewAlterServiceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, SQLServerStatementParserRULE_alterServiceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4925)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4926)
		p.AlterServiceOptArg()
	}
	p.SetState(4931)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(4927)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4928)
			p.AlterServiceOptArg()
		}

		p.SetState(4933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4934)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IAlterServiceOptArgContext is an interface to support dynamic dispatch.
type IAlterServiceOptArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterServiceOptArgContext differentiates from other interfaces.
	IsAlterServiceOptArgContext()
}

type AlterServiceOptArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServiceOptArgContext() *AlterServiceOptArgContext {
	var p = new(AlterServiceOptArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterServiceOptArg
	return p
}

func (*AlterServiceOptArgContext) IsAlterServiceOptArgContext() {}

func NewAlterServiceOptArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServiceOptArgContext {
	var p = new(AlterServiceOptArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterServiceOptArg

	return p
}

func (s *AlterServiceOptArgContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServiceOptArgContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADD, 0)
}

func (s *AlterServiceOptArgContext) CONTRACT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTRACT, 0)
}

func (s *AlterServiceOptArgContext) ContractName() IContractNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContractNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContractNameContext)
}

func (s *AlterServiceOptArgContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *AlterServiceOptArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServiceOptArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServiceOptArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterServiceOptArg(s)
	}
}

func (s *AlterServiceOptArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterServiceOptArg(s)
	}
}

func (s *AlterServiceOptArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterServiceOptArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterServiceOptArg() (localctx IAlterServiceOptArgContext) {
	this := p
	_ = this

	localctx = NewAlterServiceOptArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, SQLServerStatementParserRULE_alterServiceOptArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4942)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserADD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4936)
			p.Match(SQLServerStatementParserADD)
		}
		{
			p.SetState(4937)
			p.Match(SQLServerStatementParserCONTRACT)
		}
		{
			p.SetState(4938)
			p.ContractName()
		}

	case SQLServerStatementParserDROP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4939)
			p.Match(SQLServerStatementParserDROP)
		}
		{
			p.SetState(4940)
			p.Match(SQLServerStatementParserCONTRACT)
		}
		{
			p.SetState(4941)
			p.ContractName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISchemaNameClauseContext is an interface to support dynamic dispatch.
type ISchemaNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaNameClauseContext differentiates from other interfaces.
	IsSchemaNameClauseContext()
}

type SchemaNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameClauseContext() *SchemaNameClauseContext {
	var p = new(SchemaNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_schemaNameClause
	return p
}

func (*SchemaNameClauseContext) IsSchemaNameClauseContext() {}

func NewSchemaNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameClauseContext {
	var p = new(SchemaNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_schemaNameClause

	return p
}

func (s *SchemaNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameClauseContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *SchemaNameClauseContext) AUTHORIZATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTHORIZATION, 0)
}

func (s *SchemaNameClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *SchemaNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSchemaNameClause(s)
	}
}

func (s *SchemaNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSchemaNameClause(s)
	}
}

func (s *SchemaNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSchemaNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SchemaNameClause() (localctx ISchemaNameClauseContext) {
	this := p
	_ = this

	localctx = NewSchemaNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, SQLServerStatementParserRULE_schemaNameClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4951)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 565, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4944)
			p.SchemaName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4945)
			p.Match(SQLServerStatementParserAUTHORIZATION)
		}
		{
			p.SetState(4946)
			p.IgnoredIdentifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4947)
			p.SchemaName()
		}
		{
			p.SetState(4948)
			p.Match(SQLServerStatementParserAUTHORIZATION)
		}
		{
			p.SetState(4949)
			p.IgnoredIdentifier()
		}

	}

	return localctx
}

// ISchemaElementContext is an interface to support dynamic dispatch.
type ISchemaElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaElementContext differentiates from other interfaces.
	IsSchemaElementContext()
}

type SchemaElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaElementContext() *SchemaElementContext {
	var p = new(SchemaElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_schemaElement
	return p
}

func (*SchemaElementContext) IsSchemaElementContext() {}

func NewSchemaElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaElementContext {
	var p = new(SchemaElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_schemaElement

	return p
}

func (s *SchemaElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaElementContext) CreateTable() ICreateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *SchemaElementContext) CreateView() ICreateViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateViewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *SchemaElementContext) Grant() IGrantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *SchemaElementContext) Revoke() IRevokeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRevokeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *SchemaElementContext) Deny() IDenyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDenyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDenyContext)
}

func (s *SchemaElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSchemaElement(s)
	}
}

func (s *SchemaElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSchemaElement(s)
	}
}

func (s *SchemaElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSchemaElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SchemaElement() (localctx ISchemaElementContext) {
	this := p
	_ = this

	localctx = NewSchemaElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, SQLServerStatementParserRULE_schemaElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4958)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 566, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4953)
			p.CreateTable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4954)
			p.CreateView()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4955)
			p.Grant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4956)
			p.Revoke()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4957)
			p.Deny()
		}

	}

	return localctx
}

// ICreateTableAsSelectClauseContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableAsSelectClauseContext differentiates from other interfaces.
	IsCreateTableAsSelectClauseContext()
}

type CreateTableAsSelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectClauseContext() *CreateTableAsSelectClauseContext {
	var p = new(CreateTableAsSelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTableAsSelectClause
	return p
}

func (*CreateTableAsSelectClauseContext) IsCreateTableAsSelectClauseContext() {}

func NewCreateTableAsSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectClauseContext {
	var p = new(CreateTableAsSelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTableAsSelectClause

	return p
}

func (s *CreateTableAsSelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectClauseContext) CreateTableAsSelect() ICreateTableAsSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableAsSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectContext)
}

func (s *CreateTableAsSelectClauseContext) CreateRemoteTableAsSelect() ICreateRemoteTableAsSelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateRemoteTableAsSelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateRemoteTableAsSelectContext)
}

func (s *CreateTableAsSelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTableAsSelectClause(s)
	}
}

func (s *CreateTableAsSelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTableAsSelectClause(s)
	}
}

func (s *CreateTableAsSelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTableAsSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTableAsSelectClause() (localctx ICreateTableAsSelectClauseContext) {
	this := p
	_ = this

	localctx = NewCreateTableAsSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, SQLServerStatementParserRULE_createTableAsSelectClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4962)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 567, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4960)
			p.CreateTableAsSelect()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4961)
			p.CreateRemoteTableAsSelect()
		}

	}

	return localctx
}

// ICreateTableAsSelectContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableAsSelectContext differentiates from other interfaces.
	IsCreateTableAsSelectContext()
}

type CreateTableAsSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectContext() *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createTableAsSelect
	return p
}

func (*CreateTableAsSelectContext) IsCreateTableAsSelectContext() {}

func NewCreateTableAsSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectContext {
	var p = new(CreateTableAsSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createTableAsSelect

	return p
}

func (s *CreateTableAsSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *CreateTableAsSelectContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableAsSelectContext) WithDistributionOption() IWithDistributionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithDistributionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithDistributionOptionContext)
}

func (s *CreateTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateTableAsSelectContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CreateTableAsSelectContext) OptionQueryHintClause() IOptionQueryHintClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionQueryHintClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionQueryHintClauseContext)
}

func (s *CreateTableAsSelectContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *CreateTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateTableAsSelect(s)
	}
}

func (s *CreateTableAsSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateTableAsSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateTableAsSelect() (localctx ICreateTableAsSelectContext) {
	this := p
	_ = this

	localctx = NewCreateTableAsSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, SQLServerStatementParserRULE_createTableAsSelect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4964)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(4965)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(4966)
		p.TableName()
	}
	p.SetState(4968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(4967)
			p.ColumnNames()
		}

	}
	{
		p.SetState(4970)
		p.WithDistributionOption()
	}
	{
		p.SetState(4971)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(4972)
		p.Select()
	}
	{
		p.SetState(4973)
		p.OptionQueryHintClause()
	}

	return localctx
}

// ICreateRemoteTableAsSelectContext is an interface to support dynamic dispatch.
type ICreateRemoteTableAsSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateRemoteTableAsSelectContext differentiates from other interfaces.
	IsCreateRemoteTableAsSelectContext()
}

type CreateRemoteTableAsSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRemoteTableAsSelectContext() *CreateRemoteTableAsSelectContext {
	var p = new(CreateRemoteTableAsSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createRemoteTableAsSelect
	return p
}

func (*CreateRemoteTableAsSelectContext) IsCreateRemoteTableAsSelectContext() {}

func NewCreateRemoteTableAsSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRemoteTableAsSelectContext {
	var p = new(CreateRemoteTableAsSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createRemoteTableAsSelect

	return p
}

func (s *CreateRemoteTableAsSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRemoteTableAsSelectContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateRemoteTableAsSelectContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE, 0)
}

func (s *CreateRemoteTableAsSelectContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *CreateRemoteTableAsSelectContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateRemoteTableAsSelectContext) AT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAT, 0)
}

func (s *CreateRemoteTableAsSelectContext) AllLP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserLP_)
}

func (s *CreateRemoteTableAsSelectContext) LP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, i)
}

func (s *CreateRemoteTableAsSelectContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *CreateRemoteTableAsSelectContext) AllRP_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserRP_)
}

func (s *CreateRemoteTableAsSelectContext) RP_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, i)
}

func (s *CreateRemoteTableAsSelectContext) AS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAS, 0)
}

func (s *CreateRemoteTableAsSelectContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CreateRemoteTableAsSelectContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *CreateRemoteTableAsSelectContext) BATCH_SIZE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBATCH_SIZE, 0)
}

func (s *CreateRemoteTableAsSelectContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *CreateRemoteTableAsSelectContext) INT_NUM_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINT_NUM_, 0)
}

func (s *CreateRemoteTableAsSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRemoteTableAsSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRemoteTableAsSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateRemoteTableAsSelect(s)
	}
}

func (s *CreateRemoteTableAsSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateRemoteTableAsSelect(s)
	}
}

func (s *CreateRemoteTableAsSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateRemoteTableAsSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateRemoteTableAsSelect() (localctx ICreateRemoteTableAsSelectContext) {
	this := p
	_ = this

	localctx = NewCreateRemoteTableAsSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, SQLServerStatementParserRULE_createRemoteTableAsSelect)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4975)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(4976)
		p.Match(SQLServerStatementParserREMOTE)
	}
	{
		p.SetState(4977)
		p.Match(SQLServerStatementParserTABLE)
	}
	{
		p.SetState(4978)
		p.TableName()
	}
	{
		p.SetState(4979)
		p.Match(SQLServerStatementParserAT)
	}
	{
		p.SetState(4980)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4981)
		p.StringLiterals()
	}
	{
		p.SetState(4982)
		p.Match(SQLServerStatementParserRP_)
	}
	p.SetState(4989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(4983)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(4984)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(4985)
			p.Match(SQLServerStatementParserBATCH_SIZE)
		}
		{
			p.SetState(4986)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(4987)
			p.Match(SQLServerStatementParserINT_NUM_)
		}
		{
			p.SetState(4988)
			p.Match(SQLServerStatementParserRP_)
		}

	}
	{
		p.SetState(4991)
		p.Match(SQLServerStatementParserAS)
	}
	{
		p.SetState(4992)
		p.Select()
	}

	return localctx
}

// IWithDistributionOptionContext is an interface to support dynamic dispatch.
type IWithDistributionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithDistributionOptionContext differentiates from other interfaces.
	IsWithDistributionOptionContext()
}

type WithDistributionOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithDistributionOptionContext() *WithDistributionOptionContext {
	var p = new(WithDistributionOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_withDistributionOption
	return p
}

func (*WithDistributionOptionContext) IsWithDistributionOptionContext() {}

func NewWithDistributionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithDistributionOptionContext {
	var p = new(WithDistributionOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_withDistributionOption

	return p
}

func (s *WithDistributionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithDistributionOptionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *WithDistributionOptionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *WithDistributionOptionContext) DistributionOption() IDistributionOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistributionOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistributionOptionContext)
}

func (s *WithDistributionOptionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *WithDistributionOptionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *WithDistributionOptionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *WithDistributionOptionContext) AllTableOption() []ITableOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableOptionContext)(nil)).Elem())
	var tst = make([]ITableOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableOptionContext)
		}
	}

	return tst
}

func (s *WithDistributionOptionContext) TableOption(i int) ITableOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableOptionContext)
}

func (s *WithDistributionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithDistributionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithDistributionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterWithDistributionOption(s)
	}
}

func (s *WithDistributionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitWithDistributionOption(s)
	}
}

func (s *WithDistributionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitWithDistributionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) WithDistributionOption() (localctx IWithDistributionOptionContext) {
	this := p
	_ = this

	localctx = NewWithDistributionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, SQLServerStatementParserRULE_withDistributionOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4994)
		p.Match(SQLServerStatementParserWITH)
	}
	{
		p.SetState(4995)
		p.Match(SQLServerStatementParserLP_)
	}
	{
		p.SetState(4996)
		p.DistributionOption()
	}
	p.SetState(5006)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(4997)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(4998)
			p.TableOption()
		}
		p.SetState(5003)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(4999)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(5000)
				p.TableOption()
			}

			p.SetState(5005)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5008)
		p.Match(SQLServerStatementParserRP_)
	}

	return localctx
}

// IOptionQueryHintClauseContext is an interface to support dynamic dispatch.
type IOptionQueryHintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionQueryHintClauseContext differentiates from other interfaces.
	IsOptionQueryHintClauseContext()
}

type OptionQueryHintClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionQueryHintClauseContext() *OptionQueryHintClauseContext {
	var p = new(OptionQueryHintClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_optionQueryHintClause
	return p
}

func (*OptionQueryHintClauseContext) IsOptionQueryHintClauseContext() {}

func NewOptionQueryHintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionQueryHintClauseContext {
	var p = new(OptionQueryHintClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_optionQueryHintClause

	return p
}

func (s *OptionQueryHintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionQueryHintClauseContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTION, 0)
}

func (s *OptionQueryHintClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *OptionQueryHintClauseContext) AllQueryHint() []IQueryHintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQueryHintContext)(nil)).Elem())
	var tst = make([]IQueryHintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQueryHintContext)
		}
	}

	return tst
}

func (s *OptionQueryHintClauseContext) QueryHint(i int) IQueryHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryHintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQueryHintContext)
}

func (s *OptionQueryHintClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *OptionQueryHintClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *OptionQueryHintClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *OptionQueryHintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionQueryHintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionQueryHintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOptionQueryHintClause(s)
	}
}

func (s *OptionQueryHintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOptionQueryHintClause(s)
	}
}

func (s *OptionQueryHintClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOptionQueryHintClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OptionQueryHintClause() (localctx IOptionQueryHintClauseContext) {
	this := p
	_ = this

	localctx = NewOptionQueryHintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, SQLServerStatementParserRULE_optionQueryHintClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserOPTION {
		{
			p.SetState(5010)
			p.Match(SQLServerStatementParserOPTION)
		}
		{
			p.SetState(5011)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(5012)
			p.QueryHint()
		}
		p.SetState(5017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQLServerStatementParserCOMMA_ {
			{
				p.SetState(5013)
				p.Match(SQLServerStatementParserCOMMA_)
			}
			{
				p.SetState(5014)
				p.QueryHint()
			}

			p.SetState(5019)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5020)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_grant
	return p
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGRANT, 0)
}

func (s *GrantContext) ClassPrivilegesClause() IClassPrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassPrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassPrivilegesClauseContext)
}

func (s *GrantContext) ClassTypePrivilegesClause() IClassTypePrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypePrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypePrivilegesClauseContext)
}

func (s *GrantContext) RoleClause() IRoleClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoleClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoleClauseContext)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Grant() (localctx IGrantContext) {
	this := p
	_ = this

	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, SQLServerStatementParserRULE_grant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5024)
		p.Match(SQLServerStatementParserGRANT)
	}
	p.SetState(5028)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5025)
			p.ClassPrivilegesClause()
		}

	case 2:
		{
			p.SetState(5026)
			p.ClassTypePrivilegesClause()
		}

	case 3:
		{
			p.SetState(5027)
			p.RoleClause()
		}

	}

	return localctx
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_revoke
	return p
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREVOKE, 0)
}

func (s *RevokeContext) ClassPrivilegesClause() IClassPrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassPrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassPrivilegesClauseContext)
}

func (s *RevokeContext) ClassTypePrivilegesClause() IClassTypePrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypePrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypePrivilegesClauseContext)
}

func (s *RevokeContext) RoleClause() IRoleClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoleClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoleClauseContext)
}

func (s *RevokeContext) OptionForClause() IOptionForClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionForClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionForClauseContext)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Revoke() (localctx IRevokeContext) {
	this := p
	_ = this

	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, SQLServerStatementParserRULE_revoke)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5030)
		p.Match(SQLServerStatementParserREVOKE)
	}
	p.SetState(5037)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 576, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5032)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserGRANT {
			{
				p.SetState(5031)
				p.OptionForClause()
			}

		}
		{
			p.SetState(5034)
			p.ClassPrivilegesClause()
		}

	case 2:
		{
			p.SetState(5035)
			p.ClassTypePrivilegesClause()
		}

	case 3:
		{
			p.SetState(5036)
			p.RoleClause()
		}

	}

	return localctx
}

// IDenyContext is an interface to support dynamic dispatch.
type IDenyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDenyContext differentiates from other interfaces.
	IsDenyContext()
}

type DenyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDenyContext() *DenyContext {
	var p = new(DenyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_deny
	return p
}

func (*DenyContext) IsDenyContext() {}

func NewDenyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DenyContext {
	var p = new(DenyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_deny

	return p
}

func (s *DenyContext) GetParser() antlr.Parser { return s.parser }

func (s *DenyContext) DENY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDENY, 0)
}

func (s *DenyContext) ClassPrivilegesClause() IClassPrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassPrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassPrivilegesClauseContext)
}

func (s *DenyContext) ClassTypePrivilegesClause() IClassTypePrivilegesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypePrivilegesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypePrivilegesClauseContext)
}

func (s *DenyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DenyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DenyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDeny(s)
	}
}

func (s *DenyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDeny(s)
	}
}

func (s *DenyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDeny(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Deny() (localctx IDenyContext) {
	this := p
	_ = this

	localctx = NewDenyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, SQLServerStatementParserRULE_deny)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5039)
		p.Match(SQLServerStatementParserDENY)
	}
	p.SetState(5042)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 577, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5040)
			p.ClassPrivilegesClause()
		}

	case 2:
		{
			p.SetState(5041)
			p.ClassTypePrivilegesClause()
		}

	}

	return localctx
}

// IClassPrivilegesClauseContext is an interface to support dynamic dispatch.
type IClassPrivilegesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassPrivilegesClauseContext differentiates from other interfaces.
	IsClassPrivilegesClauseContext()
}

type ClassPrivilegesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPrivilegesClauseContext() *ClassPrivilegesClauseContext {
	var p = new(ClassPrivilegesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_classPrivilegesClause
	return p
}

func (*ClassPrivilegesClauseContext) IsClassPrivilegesClauseContext() {}

func NewClassPrivilegesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPrivilegesClauseContext {
	var p = new(ClassPrivilegesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_classPrivilegesClause

	return p
}

func (s *ClassPrivilegesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPrivilegesClauseContext) ClassPrivileges() IClassPrivilegesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassPrivilegesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassPrivilegesContext)
}

func (s *ClassPrivilegesClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ClassPrivilegesClauseContext) OnClassClause() IOnClassClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnClassClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnClassClauseContext)
}

func (s *ClassPrivilegesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPrivilegesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPrivilegesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClassPrivilegesClause(s)
	}
}

func (s *ClassPrivilegesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClassPrivilegesClause(s)
	}
}

func (s *ClassPrivilegesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClassPrivilegesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClassPrivilegesClause() (localctx IClassPrivilegesClauseContext) {
	this := p
	_ = this

	localctx = NewClassPrivilegesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, SQLServerStatementParserRULE_classPrivilegesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5044)
		p.ClassPrivileges()
	}
	p.SetState(5047)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(5045)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(5046)
			p.OnClassClause()
		}

	}

	return localctx
}

// IClassTypePrivilegesClauseContext is an interface to support dynamic dispatch.
type IClassTypePrivilegesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTypePrivilegesClauseContext differentiates from other interfaces.
	IsClassTypePrivilegesClauseContext()
}

type ClassTypePrivilegesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypePrivilegesClauseContext() *ClassTypePrivilegesClauseContext {
	var p = new(ClassTypePrivilegesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_classTypePrivilegesClause
	return p
}

func (*ClassTypePrivilegesClauseContext) IsClassTypePrivilegesClauseContext() {}

func NewClassTypePrivilegesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypePrivilegesClauseContext {
	var p = new(ClassTypePrivilegesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_classTypePrivilegesClause

	return p
}

func (s *ClassTypePrivilegesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypePrivilegesClauseContext) ClassTypePrivileges() IClassTypePrivilegesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypePrivilegesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypePrivilegesContext)
}

func (s *ClassTypePrivilegesClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ClassTypePrivilegesClauseContext) OnClassTypeClause() IOnClassTypeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnClassTypeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnClassTypeClauseContext)
}

func (s *ClassTypePrivilegesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypePrivilegesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypePrivilegesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClassTypePrivilegesClause(s)
	}
}

func (s *ClassTypePrivilegesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClassTypePrivilegesClause(s)
	}
}

func (s *ClassTypePrivilegesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClassTypePrivilegesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClassTypePrivilegesClause() (localctx IClassTypePrivilegesClauseContext) {
	this := p
	_ = this

	localctx = NewClassTypePrivilegesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, SQLServerStatementParserRULE_classTypePrivilegesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5049)
		p.ClassTypePrivileges()
	}
	p.SetState(5052)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserON {
		{
			p.SetState(5050)
			p.Match(SQLServerStatementParserON)
		}
		{
			p.SetState(5051)
			p.OnClassTypeClause()
		}

	}

	return localctx
}

// IOptionForClauseContext is an interface to support dynamic dispatch.
type IOptionForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionForClauseContext differentiates from other interfaces.
	IsOptionForClauseContext()
}

type OptionForClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionForClauseContext() *OptionForClauseContext {
	var p = new(OptionForClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_optionForClause
	return p
}

func (*OptionForClauseContext) IsOptionForClauseContext() {}

func NewOptionForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionForClauseContext {
	var p = new(OptionForClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_optionForClause

	return p
}

func (s *OptionForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionForClauseContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGRANT, 0)
}

func (s *OptionForClauseContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPTION, 0)
}

func (s *OptionForClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFOR, 0)
}

func (s *OptionForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOptionForClause(s)
	}
}

func (s *OptionForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOptionForClause(s)
	}
}

func (s *OptionForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOptionForClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OptionForClause() (localctx IOptionForClauseContext) {
	this := p
	_ = this

	localctx = NewOptionForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, SQLServerStatementParserRULE_optionForClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5054)
		p.Match(SQLServerStatementParserGRANT)
	}
	{
		p.SetState(5055)
		p.Match(SQLServerStatementParserOPTION)
	}
	{
		p.SetState(5056)
		p.Match(SQLServerStatementParserFOR)
	}

	return localctx
}

// IClassPrivilegesContext is an interface to support dynamic dispatch.
type IClassPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassPrivilegesContext differentiates from other interfaces.
	IsClassPrivilegesContext()
}

type ClassPrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassPrivilegesContext() *ClassPrivilegesContext {
	var p = new(ClassPrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_classPrivileges
	return p
}

func (*ClassPrivilegesContext) IsClassPrivilegesContext() {}

func NewClassPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassPrivilegesContext {
	var p = new(ClassPrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_classPrivileges

	return p
}

func (s *ClassPrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassPrivilegesContext) AllPrivilegeType() []IPrivilegeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeTypeContext)(nil)).Elem())
	var tst = make([]IPrivilegeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeTypeContext)
		}
	}

	return tst
}

func (s *ClassPrivilegesContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *ClassPrivilegesContext) AllColumnNames() []IColumnNamesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem())
	var tst = make([]IColumnNamesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNamesContext)
		}
	}

	return tst
}

func (s *ClassPrivilegesContext) ColumnNames(i int) IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *ClassPrivilegesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ClassPrivilegesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ClassPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassPrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassPrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClassPrivileges(s)
	}
}

func (s *ClassPrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClassPrivileges(s)
	}
}

func (s *ClassPrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClassPrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClassPrivileges() (localctx IClassPrivilegesContext) {
	this := p
	_ = this

	localctx = NewClassPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, SQLServerStatementParserRULE_classPrivileges)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5058)
		p.PrivilegeType()
	}
	p.SetState(5060)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserLP_ {
		{
			p.SetState(5059)
			p.ColumnNames()
		}

	}
	p.SetState(5069)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(5062)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(5063)
			p.PrivilegeType()
		}
		p.SetState(5065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserLP_ {
			{
				p.SetState(5064)
				p.ColumnNames()
			}

		}

		p.SetState(5071)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOnClassClauseContext is an interface to support dynamic dispatch.
type IOnClassClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnClassClauseContext differentiates from other interfaces.
	IsOnClassClauseContext()
}

type OnClassClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnClassClauseContext() *OnClassClauseContext {
	var p = new(OnClassClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onClassClause
	return p
}

func (*OnClassClauseContext) IsOnClassClauseContext() {}

func NewOnClassClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnClassClauseContext {
	var p = new(OnClassClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onClassClause

	return p
}

func (s *OnClassClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnClassClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *OnClassClauseContext) Class_() IClass_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_Context)
}

func (s *OnClassClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnClassClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnClassClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnClassClause(s)
	}
}

func (s *OnClassClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnClassClause(s)
	}
}

func (s *OnClassClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnClassClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnClassClause() (localctx IOnClassClauseContext) {
	this := p
	_ = this

	localctx = NewOnClassClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, SQLServerStatementParserRULE_onClassClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5073)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5072)
			p.Class_()
		}

	}
	{
		p.SetState(5075)
		p.TableName()
	}

	return localctx
}

// IClassTypePrivilegesContext is an interface to support dynamic dispatch.
type IClassTypePrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTypePrivilegesContext differentiates from other interfaces.
	IsClassTypePrivilegesContext()
}

type ClassTypePrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypePrivilegesContext() *ClassTypePrivilegesContext {
	var p = new(ClassTypePrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_classTypePrivileges
	return p
}

func (*ClassTypePrivilegesContext) IsClassTypePrivilegesContext() {}

func NewClassTypePrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypePrivilegesContext {
	var p = new(ClassTypePrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_classTypePrivileges

	return p
}

func (s *ClassTypePrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypePrivilegesContext) AllPrivilegeType() []IPrivilegeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPrivilegeTypeContext)(nil)).Elem())
	var tst = make([]IPrivilegeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPrivilegeTypeContext)
		}
	}

	return tst
}

func (s *ClassTypePrivilegesContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *ClassTypePrivilegesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOMMA_)
}

func (s *ClassTypePrivilegesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMA_, i)
}

func (s *ClassTypePrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypePrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypePrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClassTypePrivileges(s)
	}
}

func (s *ClassTypePrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClassTypePrivileges(s)
	}
}

func (s *ClassTypePrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClassTypePrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClassTypePrivileges() (localctx IClassTypePrivilegesContext) {
	this := p
	_ = this

	localctx = NewClassTypePrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, SQLServerStatementParserRULE_classTypePrivileges)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5077)
		p.PrivilegeType()
	}
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQLServerStatementParserCOMMA_ {
		{
			p.SetState(5078)
			p.Match(SQLServerStatementParserCOMMA_)
		}
		{
			p.SetState(5079)
			p.PrivilegeType()
		}

		p.SetState(5084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOnClassTypeClauseContext is an interface to support dynamic dispatch.
type IOnClassTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnClassTypeClauseContext differentiates from other interfaces.
	IsOnClassTypeClauseContext()
}

type OnClassTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnClassTypeClauseContext() *OnClassTypeClauseContext {
	var p = new(OnClassTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_onClassTypeClause
	return p
}

func (*OnClassTypeClauseContext) IsOnClassTypeClauseContext() {}

func NewOnClassTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnClassTypeClauseContext {
	var p = new(OnClassTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_onClassTypeClause

	return p
}

func (s *OnClassTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnClassTypeClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *OnClassTypeClauseContext) ClassType() IClassTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassTypeContext)
}

func (s *OnClassTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnClassTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnClassTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterOnClassTypeClause(s)
	}
}

func (s *OnClassTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitOnClassTypeClause(s)
	}
}

func (s *OnClassTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitOnClassTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) OnClassTypeClause() (localctx IOnClassTypeClauseContext) {
	this := p
	_ = this

	localctx = NewOnClassTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, SQLServerStatementParserRULE_onClassTypeClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 585, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5085)
			p.ClassType()
		}

	}
	{
		p.SetState(5088)
		p.TableName()
	}

	return localctx
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_privilegeType
	return p
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) BasicPermission() IBasicPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBasicPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBasicPermissionContext)
}

func (s *PrivilegeTypeContext) ObjectPermission() IObjectPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectPermissionContext)
}

func (s *PrivilegeTypeContext) ServerPermission() IServerPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServerPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServerPermissionContext)
}

func (s *PrivilegeTypeContext) ServerPrincipalPermission() IServerPrincipalPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServerPrincipalPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServerPrincipalPermissionContext)
}

func (s *PrivilegeTypeContext) DatabasePermission() IDatabasePermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabasePermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabasePermissionContext)
}

func (s *PrivilegeTypeContext) DatabasePrincipalPermission() IDatabasePrincipalPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatabasePrincipalPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatabasePrincipalPermissionContext)
}

func (s *PrivilegeTypeContext) SchemaPermission() ISchemaPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaPermissionContext)
}

func (s *PrivilegeTypeContext) ServiceBrokerPermission() IServiceBrokerPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IServiceBrokerPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IServiceBrokerPermissionContext)
}

func (s *PrivilegeTypeContext) EndpointPermission() IEndpointPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEndpointPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEndpointPermissionContext)
}

func (s *PrivilegeTypeContext) CertificatePermission() ICertificatePermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICertificatePermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICertificatePermissionContext)
}

func (s *PrivilegeTypeContext) SymmetricKeyPermission() ISymmetricKeyPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISymmetricKeyPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISymmetricKeyPermissionContext)
}

func (s *PrivilegeTypeContext) AsymmetricKeyPermission() IAsymmetricKeyPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAsymmetricKeyPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAsymmetricKeyPermissionContext)
}

func (s *PrivilegeTypeContext) AssemblyPermission() IAssemblyPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssemblyPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssemblyPermissionContext)
}

func (s *PrivilegeTypeContext) AvailabilityGroupPermission() IAvailabilityGroupPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAvailabilityGroupPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAvailabilityGroupPermissionContext)
}

func (s *PrivilegeTypeContext) FullTextPermission() IFullTextPermissionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullTextPermissionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullTextPermissionContext)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	this := p
	_ = this

	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, SQLServerStatementParserRULE_privilegeType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5109)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5090)
			p.Match(SQLServerStatementParserALL)
		}
		p.SetState(5092)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserPRIVILEGES {
			{
				p.SetState(5091)
				p.Match(SQLServerStatementParserPRIVILEGES)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5094)
			p.BasicPermission()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5095)
			p.ObjectPermission()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5096)
			p.ServerPermission()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5097)
			p.ServerPrincipalPermission()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5098)
			p.DatabasePermission()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5099)
			p.DatabasePrincipalPermission()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5100)
			p.SchemaPermission()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5101)
			p.ServiceBrokerPermission()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5102)
			p.EndpointPermission()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5103)
			p.CertificatePermission()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5104)
			p.SymmetricKeyPermission()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5105)
			p.AsymmetricKeyPermission()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5106)
			p.AssemblyPermission()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5107)
			p.AvailabilityGroupPermission()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5108)
			p.FullTextPermission()
		}

	}

	return localctx
}

// IBasicPermissionContext is an interface to support dynamic dispatch.
type IBasicPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasicPermissionContext differentiates from other interfaces.
	IsBasicPermissionContext()
}

type BasicPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasicPermissionContext() *BasicPermissionContext {
	var p = new(BasicPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_basicPermission
	return p
}

func (*BasicPermissionContext) IsBasicPermissionContext() {}

func NewBasicPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasicPermissionContext {
	var p = new(BasicPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_basicPermission

	return p
}

func (s *BasicPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *BasicPermissionContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTROL, 0)
}

func (s *BasicPermissionContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *BasicPermissionContext) TAKE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTAKE, 0)
}

func (s *BasicPermissionContext) OWNERSHIP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOWNERSHIP, 0)
}

func (s *BasicPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *BasicPermissionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *BasicPermissionContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFINITION, 0)
}

func (s *BasicPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *BasicPermissionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREFERENCES, 0)
}

func (s *BasicPermissionContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELECT, 0)
}

func (s *BasicPermissionContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserINSERT, 0)
}

func (s *BasicPermissionContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUPDATE, 0)
}

func (s *BasicPermissionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELETE, 0)
}

func (s *BasicPermissionContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXECUTE, 0)
}

func (s *BasicPermissionContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRECEIVE, 0)
}

func (s *BasicPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasicPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasicPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBasicPermission(s)
	}
}

func (s *BasicPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBasicPermission(s)
	}
}

func (s *BasicPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBasicPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BasicPermission() (localctx IBasicPermissionContext) {
	this := p
	_ = this

	localctx = NewBasicPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, SQLServerStatementParserRULE_basicPermission)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5130)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCONTROL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5111)
			p.Match(SQLServerStatementParserCONTROL)
		}
		p.SetState(5113)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserSERVER {
			{
				p.SetState(5112)
				p.Match(SQLServerStatementParserSERVER)
			}

		}

	case SQLServerStatementParserTAKE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5115)
			p.Match(SQLServerStatementParserTAKE)
		}
		{
			p.SetState(5116)
			p.Match(SQLServerStatementParserOWNERSHIP)
		}

	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5117)
			p.Match(SQLServerStatementParserALTER)
		}

	case SQLServerStatementParserVIEW:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5118)
			p.Match(SQLServerStatementParserVIEW)
		}
		p.SetState(5120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserANY {
			{
				p.SetState(5119)
				p.Match(SQLServerStatementParserANY)
			}

		}
		{
			p.SetState(5122)
			p.Match(SQLServerStatementParserDEFINITION)
		}

	case SQLServerStatementParserREFERENCES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5123)
			p.Match(SQLServerStatementParserREFERENCES)
		}

	case SQLServerStatementParserSELECT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5124)
			p.Match(SQLServerStatementParserSELECT)
		}

	case SQLServerStatementParserINSERT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5125)
			p.Match(SQLServerStatementParserINSERT)
		}

	case SQLServerStatementParserUPDATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5126)
			p.Match(SQLServerStatementParserUPDATE)
		}

	case SQLServerStatementParserDELETE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5127)
			p.Match(SQLServerStatementParserDELETE)
		}

	case SQLServerStatementParserEXECUTE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5128)
			p.Match(SQLServerStatementParserEXECUTE)
		}

	case SQLServerStatementParserRECEIVE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5129)
			p.Match(SQLServerStatementParserRECEIVE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObjectPermissionContext is an interface to support dynamic dispatch.
type IObjectPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectPermissionContext differentiates from other interfaces.
	IsObjectPermissionContext()
}

type ObjectPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectPermissionContext() *ObjectPermissionContext {
	var p = new(ObjectPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_objectPermission
	return p
}

func (*ObjectPermissionContext) IsObjectPermissionContext() {}

func NewObjectPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectPermissionContext {
	var p = new(ObjectPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_objectPermission

	return p
}

func (s *ObjectPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectPermissionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *ObjectPermissionContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE, 0)
}

func (s *ObjectPermissionContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACKING, 0)
}

func (s *ObjectPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterObjectPermission(s)
	}
}

func (s *ObjectPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitObjectPermission(s)
	}
}

func (s *ObjectPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitObjectPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ObjectPermission() (localctx IObjectPermissionContext) {
	this := p
	_ = this

	localctx = NewObjectPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, SQLServerStatementParserRULE_objectPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5132)
		p.Match(SQLServerStatementParserVIEW)
	}
	{
		p.SetState(5133)
		p.Match(SQLServerStatementParserCHANGE)
	}
	{
		p.SetState(5134)
		p.Match(SQLServerStatementParserTRACKING)
	}

	return localctx
}

// IServerPermissionContext is an interface to support dynamic dispatch.
type IServerPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServerPermissionContext differentiates from other interfaces.
	IsServerPermissionContext()
}

type ServerPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerPermissionContext() *ServerPermissionContext {
	var p = new(ServerPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serverPermission
	return p
}

func (*ServerPermissionContext) IsServerPermissionContext() {}

func NewServerPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerPermissionContext {
	var p = new(ServerPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serverPermission

	return p
}

func (s *ServerPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *ServerPermissionContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRESOURCES, 0)
}

func (s *ServerPermissionContext) SETTINGS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSETTINGS, 0)
}

func (s *ServerPermissionContext) TRACE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACE, 0)
}

func (s *ServerPermissionContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *ServerPermissionContext) STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATE, 0)
}

func (s *ServerPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *ServerPermissionContext) AVAILABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAVAILABILITY, 0)
}

func (s *ServerPermissionContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGROUP, 0)
}

func (s *ServerPermissionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONNECTION, 0)
}

func (s *ServerPermissionContext) CREDENTIAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREDENTIAL, 0)
}

func (s *ServerPermissionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *ServerPermissionContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENDPOINT, 0)
}

func (s *ServerPermissionContext) EVENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEVENT, 0)
}

func (s *ServerPermissionContext) NOTIFICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOTIFICATION, 0)
}

func (s *ServerPermissionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSESSION, 0)
}

func (s *ServerPermissionContext) LINKED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLINKED, 0)
}

func (s *ServerPermissionContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *ServerPermissionContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUDIT, 0)
}

func (s *ServerPermissionContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *ServerPermissionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *ServerPermissionContext) DDL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDDL, 0)
}

func (s *ServerPermissionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *ServerPermissionContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFINITION, 0)
}

func (s *ServerPermissionContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONNECT, 0)
}

func (s *ServerPermissionContext) SQL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSQL, 0)
}

func (s *ServerPermissionContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPERSONATE, 0)
}

func (s *ServerPermissionContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSELECT, 0)
}

func (s *ServerPermissionContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALL, 0)
}

func (s *ServerPermissionContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *ServerPermissionContext) SECURABLES() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECURABLES, 0)
}

func (s *ServerPermissionContext) AUTHENTICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTHENTICATE, 0)
}

func (s *ServerPermissionContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNAL, 0)
}

func (s *ServerPermissionContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserACCESS, 0)
}

func (s *ServerPermissionContext) ASSEMBLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSEMBLY, 0)
}

func (s *ServerPermissionContext) ADMINISTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADMINISTER, 0)
}

func (s *ServerPermissionContext) BULK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBULK, 0)
}

func (s *ServerPermissionContext) OPERATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPERATIONS, 0)
}

func (s *ServerPermissionContext) UNSAFE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNSAFE, 0)
}

func (s *ServerPermissionContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSHUTDOWN, 0)
}

func (s *ServerPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServerPermission(s)
	}
}

func (s *ServerPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServerPermission(s)
	}
}

func (s *ServerPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServerPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServerPermission() (localctx IServerPermissionContext) {
	this := p
	_ = this

	localctx = NewServerPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, SQLServerStatementParserRULE_serverPermission)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 594, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5136)
			p.Match(SQLServerStatementParserALTER)
		}
		p.SetState(5142)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserRESOURCES:
			{
				p.SetState(5137)
				p.Match(SQLServerStatementParserRESOURCES)
			}

		case SQLServerStatementParserSETTINGS:
			{
				p.SetState(5138)
				p.Match(SQLServerStatementParserSETTINGS)
			}

		case SQLServerStatementParserTRACE:
			{
				p.SetState(5139)
				p.Match(SQLServerStatementParserTRACE)
			}

		case SQLServerStatementParserSERVER:
			{
				p.SetState(5140)
				p.Match(SQLServerStatementParserSERVER)
			}
			{
				p.SetState(5141)
				p.Match(SQLServerStatementParserSTATE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5144)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5145)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5163)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5146)
				p.Match(SQLServerStatementParserAVAILABILITY)
			}
			{
				p.SetState(5147)
				p.Match(SQLServerStatementParserGROUP)
			}

		case 2:
			{
				p.SetState(5148)
				p.Match(SQLServerStatementParserCONNECTION)
			}

		case 3:
			{
				p.SetState(5149)
				p.Match(SQLServerStatementParserCREDENTIAL)
			}

		case 4:
			{
				p.SetState(5150)
				p.Match(SQLServerStatementParserDATABASE)
			}

		case 5:
			{
				p.SetState(5151)
				p.Match(SQLServerStatementParserENDPOINT)
			}

		case 6:
			{
				p.SetState(5152)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5153)
				p.Match(SQLServerStatementParserNOTIFICATION)
			}

		case 7:
			{
				p.SetState(5154)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5155)
				p.Match(SQLServerStatementParserSESSION)
			}

		case 8:
			{
				p.SetState(5156)
				p.Match(SQLServerStatementParserLINKED)
			}
			{
				p.SetState(5157)
				p.Match(SQLServerStatementParserSERVER)
			}

		case 9:
			{
				p.SetState(5158)
				p.Match(SQLServerStatementParserLOGIN)
			}

		case 10:
			{
				p.SetState(5159)
				p.Match(SQLServerStatementParserSERVER)
			}
			{
				p.SetState(5160)
				p.Match(SQLServerStatementParserAUDIT)
			}

		case 11:
			{
				p.SetState(5161)
				p.Match(SQLServerStatementParserSERVER)
			}
			{
				p.SetState(5162)
				p.Match(SQLServerStatementParserROLE)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5165)
			p.Match(SQLServerStatementParserCREATE)
		}
		p.SetState(5177)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserAVAILABILITY:
			{
				p.SetState(5166)
				p.Match(SQLServerStatementParserAVAILABILITY)
			}
			{
				p.SetState(5167)
				p.Match(SQLServerStatementParserGROUP)
			}

		case SQLServerStatementParserDDL:
			{
				p.SetState(5168)
				p.Match(SQLServerStatementParserDDL)
			}
			{
				p.SetState(5169)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5170)
				p.Match(SQLServerStatementParserNOTIFICATION)
			}

		case SQLServerStatementParserENDPOINT:
			{
				p.SetState(5171)
				p.Match(SQLServerStatementParserENDPOINT)
			}

		case SQLServerStatementParserSERVER:
			{
				p.SetState(5172)
				p.Match(SQLServerStatementParserSERVER)
			}
			{
				p.SetState(5173)
				p.Match(SQLServerStatementParserROLE)
			}

		case SQLServerStatementParserTRACE:
			{
				p.SetState(5174)
				p.Match(SQLServerStatementParserTRACE)
			}
			{
				p.SetState(5175)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5176)
				p.Match(SQLServerStatementParserNOTIFICATION)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5179)
			p.Match(SQLServerStatementParserCREATE)
		}
		{
			p.SetState(5180)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5181)
			p.Match(SQLServerStatementParserDATABASE)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5182)
			p.Match(SQLServerStatementParserVIEW)
		}
		{
			p.SetState(5183)
			p.Match(SQLServerStatementParserSERVER)
		}
		{
			p.SetState(5184)
			p.Match(SQLServerStatementParserSTATE)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5185)
			p.Match(SQLServerStatementParserVIEW)
		}
		{
			p.SetState(5186)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5187)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDATABASE || _la == SQLServerStatementParserDEFINITION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5188)
			p.Match(SQLServerStatementParserCONNECT)
		}
		{
			p.SetState(5189)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5190)
			p.Match(SQLServerStatementParserDATABASE)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5191)
			p.Match(SQLServerStatementParserCONNECT)
		}
		{
			p.SetState(5192)
			p.Match(SQLServerStatementParserSQL)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5193)
			p.Match(SQLServerStatementParserIMPERSONATE)
		}
		{
			p.SetState(5194)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5195)
			p.Match(SQLServerStatementParserLOGIN)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5196)
			p.Match(SQLServerStatementParserSELECT)
		}
		{
			p.SetState(5197)
			p.Match(SQLServerStatementParserALL)
		}
		{
			p.SetState(5198)
			p.Match(SQLServerStatementParserUSER)
		}
		{
			p.SetState(5199)
			p.Match(SQLServerStatementParserSECURABLES)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5200)
			p.Match(SQLServerStatementParserAUTHENTICATE)
		}
		{
			p.SetState(5201)
			p.Match(SQLServerStatementParserSERVER)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5202)
			p.Match(SQLServerStatementParserEXTERNAL)
		}
		{
			p.SetState(5203)
			p.Match(SQLServerStatementParserACCESS)
		}
		{
			p.SetState(5204)
			p.Match(SQLServerStatementParserASSEMBLY)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5205)
			p.Match(SQLServerStatementParserADMINISTER)
		}
		{
			p.SetState(5206)
			p.Match(SQLServerStatementParserBULK)
		}
		{
			p.SetState(5207)
			p.Match(SQLServerStatementParserOPERATIONS)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5208)
			p.Match(SQLServerStatementParserUNSAFE)
		}
		{
			p.SetState(5209)
			p.Match(SQLServerStatementParserASSEMBLY)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5210)
			p.Match(SQLServerStatementParserSHUTDOWN)
		}

	}

	return localctx
}

// IServerPrincipalPermissionContext is an interface to support dynamic dispatch.
type IServerPrincipalPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServerPrincipalPermissionContext differentiates from other interfaces.
	IsServerPrincipalPermissionContext()
}

type ServerPrincipalPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerPrincipalPermissionContext() *ServerPrincipalPermissionContext {
	var p = new(ServerPrincipalPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serverPrincipalPermission
	return p
}

func (*ServerPrincipalPermissionContext) IsServerPrincipalPermissionContext() {}

func NewServerPrincipalPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerPrincipalPermissionContext {
	var p = new(ServerPrincipalPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serverPrincipalPermission

	return p
}

func (s *ServerPrincipalPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerPrincipalPermissionContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPERSONATE, 0)
}

func (s *ServerPrincipalPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *ServerPrincipalPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *ServerPrincipalPermissionContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *ServerPrincipalPermissionContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *ServerPrincipalPermissionContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *ServerPrincipalPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerPrincipalPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerPrincipalPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServerPrincipalPermission(s)
	}
}

func (s *ServerPrincipalPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServerPrincipalPermission(s)
	}
}

func (s *ServerPrincipalPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServerPrincipalPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServerPrincipalPermission() (localctx IServerPrincipalPermissionContext) {
	this := p
	_ = this

	localctx = NewServerPrincipalPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, SQLServerStatementParserRULE_serverPrincipalPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5221)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5213)
			p.Match(SQLServerStatementParserIMPERSONATE)
		}

	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5214)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5215)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5219)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserLOGIN:
			{
				p.SetState(5216)
				p.Match(SQLServerStatementParserLOGIN)
			}

		case SQLServerStatementParserSERVER:
			{
				p.SetState(5217)
				p.Match(SQLServerStatementParserSERVER)
			}
			{
				p.SetState(5218)
				p.Match(SQLServerStatementParserROLE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDatabasePermissionContext is an interface to support dynamic dispatch.
type IDatabasePermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabasePermissionContext differentiates from other interfaces.
	IsDatabasePermissionContext()
}

type DatabasePermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabasePermissionContext() *DatabasePermissionContext {
	var p = new(DatabasePermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databasePermission
	return p
}

func (*DatabasePermissionContext) IsDatabasePermissionContext() {}

func NewDatabasePermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabasePermissionContext {
	var p = new(DatabasePermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databasePermission

	return p
}

func (s *DatabasePermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabasePermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *DatabasePermissionContext) TRACE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACE, 0)
}

func (s *DatabasePermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *DatabasePermissionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *DatabasePermissionContext) DATASPACE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATASPACE, 0)
}

func (s *DatabasePermissionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *DatabasePermissionContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *DatabasePermissionContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *DatabasePermissionContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *DatabasePermissionContext) CERTIFICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCERTIFICATE, 0)
}

func (s *DatabasePermissionContext) CONTRACT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTRACT, 0)
}

func (s *DatabasePermissionContext) ASSEMBLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSEMBLY, 0)
}

func (s *DatabasePermissionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONNECTION, 0)
}

func (s *DatabasePermissionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *DatabasePermissionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLUMN, 0)
}

func (s *DatabasePermissionContext) MASTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASTER, 0)
}

func (s *DatabasePermissionContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFINITION, 0)
}

func (s *DatabasePermissionContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXTERNAL, 0)
}

func (s *DatabasePermissionContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULLTEXT, 0)
}

func (s *DatabasePermissionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCATALOG, 0)
}

func (s *DatabasePermissionContext) MASK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMASK, 0)
}

func (s *DatabasePermissionContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMESSAGE, 0)
}

func (s *DatabasePermissionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE, 0)
}

func (s *DatabasePermissionContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE, 0)
}

func (s *DatabasePermissionContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINDING, 0)
}

func (s *DatabasePermissionContext) ROUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROUTE, 0)
}

func (s *DatabasePermissionContext) EVENT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEVENT, 0)
}

func (s *DatabasePermissionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSESSION, 0)
}

func (s *DatabasePermissionContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSECURITY, 0)
}

func (s *DatabasePermissionContext) POLICY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPOLICY, 0)
}

func (s *DatabasePermissionContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYMMETRIC, 0)
}

func (s *DatabasePermissionContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASYMMETRIC, 0)
}

func (s *DatabasePermissionContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENCRYPTION, 0)
}

func (s *DatabasePermissionContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATA, 0)
}

func (s *DatabasePermissionContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSOURCE, 0)
}

func (s *DatabasePermissionContext) FILE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFILE, 0)
}

func (s *DatabasePermissionContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFORMAT, 0)
}

func (s *DatabasePermissionContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLIBRARY, 0)
}

func (s *DatabasePermissionContext) AUDIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUDIT, 0)
}

func (s *DatabasePermissionContext) DDL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDDL, 0)
}

func (s *DatabasePermissionContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRIGGER, 0)
}

func (s *DatabasePermissionContext) NOTIFICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOTIFICATION, 0)
}

func (s *DatabasePermissionContext) SCOPED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCOPED, 0)
}

func (s *DatabasePermissionContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONFIGURATION, 0)
}

func (s *DatabasePermissionContext) APPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAPPLICATION, 0)
}

func (s *DatabasePermissionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *DatabasePermissionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTABLE, 0)
}

func (s *DatabasePermissionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *DatabasePermissionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDEFAULT, 0)
}

func (s *DatabasePermissionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAGGREGATE, 0)
}

func (s *DatabasePermissionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFUNCTION, 0)
}

func (s *DatabasePermissionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserPROCEDURE, 0)
}

func (s *DatabasePermissionContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUEUE, 0)
}

func (s *DatabasePermissionContext) RULE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRULE, 0)
}

func (s *DatabasePermissionContext) SYNONYM() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYNONYM, 0)
}

func (s *DatabasePermissionContext) XML() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserXML, 0)
}

func (s *DatabasePermissionContext) COLLECTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLLECTION, 0)
}

func (s *DatabasePermissionContext) STATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSTATE, 0)
}

func (s *DatabasePermissionContext) SERVER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVER, 0)
}

func (s *DatabasePermissionContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXECUTE, 0)
}

func (s *DatabasePermissionContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCRIPT, 0)
}

func (s *DatabasePermissionContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONNECT, 0)
}

func (s *DatabasePermissionContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREPLICATION, 0)
}

func (s *DatabasePermissionContext) KILL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKILL, 0)
}

func (s *DatabasePermissionContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBACKUP, 0)
}

func (s *DatabasePermissionContext) LOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOG, 0)
}

func (s *DatabasePermissionContext) AUTHENTICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAUTHENTICATE, 0)
}

func (s *DatabasePermissionContext) SHOWPLAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSHOWPLAN, 0)
}

func (s *DatabasePermissionContext) SUBSCRIBE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSUBSCRIBE, 0)
}

func (s *DatabasePermissionContext) QUERY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserQUERY, 0)
}

func (s *DatabasePermissionContext) NOTIFICATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNOTIFICATIONS, 0)
}

func (s *DatabasePermissionContext) UNMASK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUNMASK, 0)
}

func (s *DatabasePermissionContext) CHECKPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHECKPOINT, 0)
}

func (s *DatabasePermissionContext) ADMINISTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserADMINISTER, 0)
}

func (s *DatabasePermissionContext) BULK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBULK, 0)
}

func (s *DatabasePermissionContext) OPERATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOPERATIONS, 0)
}

func (s *DatabasePermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabasePermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabasePermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabasePermission(s)
	}
}

func (s *DatabasePermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabasePermission(s)
	}
}

func (s *DatabasePermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabasePermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabasePermission() (localctx IDatabasePermissionContext) {
	this := p
	_ = this

	localctx = NewDatabasePermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, SQLServerStatementParserRULE_databasePermission)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5376)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5223)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5224)
			p.Match(SQLServerStatementParserTRACE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5225)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5226)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5286)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 602, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5227)
				p.Match(SQLServerStatementParserDATABASE)
			}
			p.SetState(5237)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5228)
					p.Match(SQLServerStatementParserAUDIT)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(5229)
					p.Match(SQLServerStatementParserDDL)
				}
				{
					p.SetState(5230)
					p.Match(SQLServerStatementParserTRIGGER)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 3 {
				{
					p.SetState(5231)
					p.Match(SQLServerStatementParserEVENT)
				}
				{
					p.SetState(5232)
					p.Match(SQLServerStatementParserNOTIFICATION)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 4 {
				{
					p.SetState(5233)
					p.Match(SQLServerStatementParserEVENT)
				}
				{
					p.SetState(5234)
					p.Match(SQLServerStatementParserSESSION)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 597, p.GetParserRuleContext()) == 5 {
				{
					p.SetState(5235)
					p.Match(SQLServerStatementParserSCOPED)
				}
				{
					p.SetState(5236)
					p.Match(SQLServerStatementParserCONFIGURATION)
				}

			}

		case 2:
			{
				p.SetState(5239)
				p.Match(SQLServerStatementParserDATASPACE)
			}

		case 3:
			{
				p.SetState(5240)
				p.Match(SQLServerStatementParserSCHEMA)
			}

		case 4:
			{
				p.SetState(5241)
				p.Match(SQLServerStatementParserSERVICE)
			}
			p.SetState(5243)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserAUDIT {
				{
					p.SetState(5242)
					p.Match(SQLServerStatementParserAUDIT)
				}

			}

		case 5:
			{
				p.SetState(5245)
				p.Match(SQLServerStatementParserUSER)
			}

		case 6:
			p.SetState(5247)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserAPPLICATION {
				{
					p.SetState(5246)
					p.Match(SQLServerStatementParserAPPLICATION)
				}

			}
			{
				p.SetState(5249)
				p.Match(SQLServerStatementParserROLE)
			}

		case 7:
			{
				p.SetState(5250)
				p.Match(SQLServerStatementParserCERTIFICATE)
			}

		case 8:
			{
				p.SetState(5251)
				p.Match(SQLServerStatementParserCONTRACT)
			}

		case 9:
			{
				p.SetState(5252)
				p.Match(SQLServerStatementParserASSEMBLY)
			}

		case 10:
			{
				p.SetState(5253)
				p.Match(SQLServerStatementParserCONNECTION)
			}

		case 11:
			p.SetState(5258)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQLServerStatementParserSYMMETRIC:
				{
					p.SetState(5254)
					p.Match(SQLServerStatementParserSYMMETRIC)
				}

			case SQLServerStatementParserASYMMETRIC:
				{
					p.SetState(5255)
					p.Match(SQLServerStatementParserASYMMETRIC)
				}

			case SQLServerStatementParserCOLUMN:
				{
					p.SetState(5256)
					p.Match(SQLServerStatementParserCOLUMN)
				}
				{
					p.SetState(5257)
					p.Match(SQLServerStatementParserENCRYPTION)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(5260)
				p.Match(SQLServerStatementParserKEY)
			}

		case 12:
			{
				p.SetState(5261)
				p.Match(SQLServerStatementParserCOLUMN)
			}
			{
				p.SetState(5262)
				p.Match(SQLServerStatementParserMASTER)
			}
			{
				p.SetState(5263)
				p.Match(SQLServerStatementParserKEY)
			}
			{
				p.SetState(5264)
				p.Match(SQLServerStatementParserDEFINITION)
			}

		case 13:
			{
				p.SetState(5265)
				p.Match(SQLServerStatementParserEXTERNAL)
			}
			p.SetState(5271)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQLServerStatementParserDATA:
				{
					p.SetState(5266)
					p.Match(SQLServerStatementParserDATA)
				}
				{
					p.SetState(5267)
					p.Match(SQLServerStatementParserSOURCE)
				}

			case SQLServerStatementParserFILE:
				{
					p.SetState(5268)
					p.Match(SQLServerStatementParserFILE)
				}
				{
					p.SetState(5269)
					p.Match(SQLServerStatementParserFORMAT)
				}

			case SQLServerStatementParserLIBRARY:
				{
					p.SetState(5270)
					p.Match(SQLServerStatementParserLIBRARY)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 14:
			{
				p.SetState(5273)
				p.Match(SQLServerStatementParserFULLTEXT)
			}
			{
				p.SetState(5274)
				p.Match(SQLServerStatementParserCATALOG)
			}

		case 15:
			{
				p.SetState(5275)
				p.Match(SQLServerStatementParserMASK)
			}

		case 16:
			{
				p.SetState(5276)
				p.Match(SQLServerStatementParserMESSAGE)
			}
			{
				p.SetState(5277)
				p.Match(SQLServerStatementParserTYPE)
			}

		case 17:
			{
				p.SetState(5278)
				p.Match(SQLServerStatementParserREMOTE)
			}
			{
				p.SetState(5279)
				p.Match(SQLServerStatementParserSERVICE)
			}
			{
				p.SetState(5280)
				p.Match(SQLServerStatementParserBINDING)
			}

		case 18:
			{
				p.SetState(5281)
				p.Match(SQLServerStatementParserROUTE)
			}

		case 19:
			{
				p.SetState(5282)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5283)
				p.Match(SQLServerStatementParserSESSION)
			}

		case 20:
			{
				p.SetState(5284)
				p.Match(SQLServerStatementParserSECURITY)
			}
			{
				p.SetState(5285)
				p.Match(SQLServerStatementParserPOLICY)
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5288)
			p.Match(SQLServerStatementParserCREATE)
		}
		p.SetState(5323)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 603, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5289)
				p.Match(SQLServerStatementParserDATABASE)
			}

		case 2:
			{
				p.SetState(5290)
				p.Match(SQLServerStatementParserDATABASE)
			}
			{
				p.SetState(5291)
				p.Match(SQLServerStatementParserDDL)
			}
			{
				p.SetState(5292)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5293)
				p.Match(SQLServerStatementParserNOTIFICATION)
			}

		case 3:
			{
				p.SetState(5294)
				p.Match(SQLServerStatementParserSCHEMA)
			}

		case 4:
			{
				p.SetState(5295)
				p.Match(SQLServerStatementParserTABLE)
			}

		case 5:
			{
				p.SetState(5296)
				p.Match(SQLServerStatementParserVIEW)
			}

		case 6:
			{
				p.SetState(5297)
				p.Match(SQLServerStatementParserSERVICE)
			}

		case 7:
			{
				p.SetState(5298)
				p.Match(SQLServerStatementParserTYPE)
			}

		case 8:
			{
				p.SetState(5299)
				p.Match(SQLServerStatementParserDEFAULT)
			}

		case 9:
			{
				p.SetState(5300)
				p.Match(SQLServerStatementParserAGGREGATE)
			}

		case 10:
			{
				p.SetState(5301)
				p.Match(SQLServerStatementParserASSEMBLY)
			}

		case 11:
			{
				p.SetState(5302)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserSYMMETRIC || _la == SQLServerStatementParserASYMMETRIC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5303)
				p.Match(SQLServerStatementParserKEY)
			}

		case 12:
			{
				p.SetState(5304)
				p.Match(SQLServerStatementParserCERTIFICATE)
			}

		case 13:
			{
				p.SetState(5305)
				p.Match(SQLServerStatementParserCONTRACT)
			}

		case 14:
			{
				p.SetState(5306)
				p.Match(SQLServerStatementParserFULLTEXT)
			}
			{
				p.SetState(5307)
				p.Match(SQLServerStatementParserCATALOG)
			}

		case 15:
			{
				p.SetState(5308)
				p.Match(SQLServerStatementParserFUNCTION)
			}

		case 16:
			{
				p.SetState(5309)
				p.Match(SQLServerStatementParserMESSAGE)
			}
			{
				p.SetState(5310)
				p.Match(SQLServerStatementParserTYPE)
			}

		case 17:
			{
				p.SetState(5311)
				p.Match(SQLServerStatementParserPROCEDURE)
			}

		case 18:
			{
				p.SetState(5312)
				p.Match(SQLServerStatementParserQUEUE)
			}

		case 19:
			{
				p.SetState(5313)
				p.Match(SQLServerStatementParserREMOTE)
			}
			{
				p.SetState(5314)
				p.Match(SQLServerStatementParserSERVICE)
			}
			{
				p.SetState(5315)
				p.Match(SQLServerStatementParserBINDING)
			}

		case 20:
			{
				p.SetState(5316)
				p.Match(SQLServerStatementParserROLE)
			}

		case 21:
			{
				p.SetState(5317)
				p.Match(SQLServerStatementParserROUTE)
			}

		case 22:
			{
				p.SetState(5318)
				p.Match(SQLServerStatementParserRULE)
			}

		case 23:
			{
				p.SetState(5319)
				p.Match(SQLServerStatementParserSYNONYM)
			}

		case 24:
			{
				p.SetState(5320)
				p.Match(SQLServerStatementParserXML)
			}
			{
				p.SetState(5321)
				p.Match(SQLServerStatementParserSCHEMA)
			}
			{
				p.SetState(5322)
				p.Match(SQLServerStatementParserCOLLECTION)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5325)
			p.Match(SQLServerStatementParserCREATE)
		}
		{
			p.SetState(5326)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5330)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserDATABASE:
			{
				p.SetState(5327)
				p.Match(SQLServerStatementParserDATABASE)
			}

		case SQLServerStatementParserEXTERNAL:
			{
				p.SetState(5328)
				p.Match(SQLServerStatementParserEXTERNAL)
			}
			{
				p.SetState(5329)
				p.Match(SQLServerStatementParserLIBRARY)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5332)
			p.Match(SQLServerStatementParserVIEW)
		}
		p.SetState(5338)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserDATABASE, SQLServerStatementParserSERVER:
			{
				p.SetState(5333)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserDATABASE || _la == SQLServerStatementParserSERVER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5334)
				p.Match(SQLServerStatementParserSTATE)
			}

		case SQLServerStatementParserDDL:
			{
				p.SetState(5335)
				p.Match(SQLServerStatementParserDDL)
			}
			{
				p.SetState(5336)
				p.Match(SQLServerStatementParserEVENT)
			}
			{
				p.SetState(5337)
				p.Match(SQLServerStatementParserNOTIFICATION)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5340)
			p.Match(SQLServerStatementParserVIEW)
		}
		{
			p.SetState(5341)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5347)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserCOLUMN:
			{
				p.SetState(5342)
				p.Match(SQLServerStatementParserCOLUMN)
			}
			{
				p.SetState(5343)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQLServerStatementParserENCRYPTION || _la == SQLServerStatementParserMASTER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5344)
				p.Match(SQLServerStatementParserKEY)
			}
			{
				p.SetState(5345)
				p.Match(SQLServerStatementParserDEFINITION)
			}

		case SQLServerStatementParserDEFINITION:
			{
				p.SetState(5346)
				p.Match(SQLServerStatementParserDEFINITION)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5349)
			p.Match(SQLServerStatementParserEXECUTE)
		}
		{
			p.SetState(5350)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5351)
			p.Match(SQLServerStatementParserEXTERNAL)
		}
		{
			p.SetState(5352)
			p.Match(SQLServerStatementParserSCRIPT)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5353)
			p.Match(SQLServerStatementParserCONNECT)
		}
		p.SetState(5355)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserREPLICATION {
			{
				p.SetState(5354)
				p.Match(SQLServerStatementParserREPLICATION)
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5357)
			p.Match(SQLServerStatementParserKILL)
		}
		{
			p.SetState(5358)
			p.Match(SQLServerStatementParserDATABASE)
		}
		{
			p.SetState(5359)
			p.Match(SQLServerStatementParserCONNECTION)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5360)
			p.Match(SQLServerStatementParserBACKUP)
		}
		{
			p.SetState(5361)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserDATABASE || _la == SQLServerStatementParserLOG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5362)
			p.Match(SQLServerStatementParserAUTHENTICATE)
		}
		p.SetState(5364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserSERVER {
			{
				p.SetState(5363)
				p.Match(SQLServerStatementParserSERVER)
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5366)
			p.Match(SQLServerStatementParserSHOWPLAN)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5367)
			p.Match(SQLServerStatementParserSUBSCRIBE)
		}
		{
			p.SetState(5368)
			p.Match(SQLServerStatementParserQUERY)
		}
		{
			p.SetState(5369)
			p.Match(SQLServerStatementParserNOTIFICATIONS)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5370)
			p.Match(SQLServerStatementParserUNMASK)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5371)
			p.Match(SQLServerStatementParserCHECKPOINT)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5372)
			p.Match(SQLServerStatementParserADMINISTER)
		}
		{
			p.SetState(5373)
			p.Match(SQLServerStatementParserDATABASE)
		}
		{
			p.SetState(5374)
			p.Match(SQLServerStatementParserBULK)
		}
		{
			p.SetState(5375)
			p.Match(SQLServerStatementParserOPERATIONS)
		}

	}

	return localctx
}

// IDatabasePrincipalPermissionContext is an interface to support dynamic dispatch.
type IDatabasePrincipalPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatabasePrincipalPermissionContext differentiates from other interfaces.
	IsDatabasePrincipalPermissionContext()
}

type DatabasePrincipalPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabasePrincipalPermissionContext() *DatabasePrincipalPermissionContext {
	var p = new(DatabasePrincipalPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_databasePrincipalPermission
	return p
}

func (*DatabasePrincipalPermissionContext) IsDatabasePrincipalPermissionContext() {}

func NewDatabasePrincipalPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabasePrincipalPermissionContext {
	var p = new(DatabasePrincipalPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_databasePrincipalPermission

	return p
}

func (s *DatabasePrincipalPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabasePrincipalPermissionContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPERSONATE, 0)
}

func (s *DatabasePrincipalPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *DatabasePrincipalPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *DatabasePrincipalPermissionContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *DatabasePrincipalPermissionContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *DatabasePrincipalPermissionContext) APPLICATION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAPPLICATION, 0)
}

func (s *DatabasePrincipalPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabasePrincipalPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabasePrincipalPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDatabasePrincipalPermission(s)
	}
}

func (s *DatabasePrincipalPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDatabasePrincipalPermission(s)
	}
}

func (s *DatabasePrincipalPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDatabasePrincipalPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DatabasePrincipalPermission() (localctx IDatabasePrincipalPermissionContext) {
	this := p
	_ = this

	localctx = NewDatabasePrincipalPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, SQLServerStatementParserRULE_databasePrincipalPermission)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5388)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5378)
			p.Match(SQLServerStatementParserIMPERSONATE)
		}

	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5379)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5380)
			p.Match(SQLServerStatementParserANY)
		}
		p.SetState(5386)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserUSER:
			{
				p.SetState(5381)
				p.Match(SQLServerStatementParserUSER)
			}

		case SQLServerStatementParserROLE, SQLServerStatementParserAPPLICATION:
			p.SetState(5383)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQLServerStatementParserAPPLICATION {
				{
					p.SetState(5382)
					p.Match(SQLServerStatementParserAPPLICATION)
				}

			}
			{
				p.SetState(5385)
				p.Match(SQLServerStatementParserROLE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISchemaPermissionContext is an interface to support dynamic dispatch.
type ISchemaPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaPermissionContext differentiates from other interfaces.
	IsSchemaPermissionContext()
}

type SchemaPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaPermissionContext() *SchemaPermissionContext {
	var p = new(SchemaPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_schemaPermission
	return p
}

func (*SchemaPermissionContext) IsSchemaPermissionContext() {}

func NewSchemaPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaPermissionContext {
	var p = new(SchemaPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_schemaPermission

	return p
}

func (s *SchemaPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *SchemaPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *SchemaPermissionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *SchemaPermissionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *SchemaPermissionContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSEQUENCE, 0)
}

func (s *SchemaPermissionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserVIEW, 0)
}

func (s *SchemaPermissionContext) CHANGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCHANGE, 0)
}

func (s *SchemaPermissionContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRACKING, 0)
}

func (s *SchemaPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSchemaPermission(s)
	}
}

func (s *SchemaPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSchemaPermission(s)
	}
}

func (s *SchemaPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSchemaPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SchemaPermission() (localctx ISchemaPermissionContext) {
	this := p
	_ = this

	localctx = NewSchemaPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, SQLServerStatementParserRULE_schemaPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5398)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5390)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5391)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5392)
			p.Match(SQLServerStatementParserSCHEMA)
		}

	case SQLServerStatementParserCREATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5393)
			p.Match(SQLServerStatementParserCREATE)
		}
		{
			p.SetState(5394)
			p.Match(SQLServerStatementParserSEQUENCE)
		}

	case SQLServerStatementParserVIEW:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5395)
			p.Match(SQLServerStatementParserVIEW)
		}
		{
			p.SetState(5396)
			p.Match(SQLServerStatementParserCHANGE)
		}
		{
			p.SetState(5397)
			p.Match(SQLServerStatementParserTRACKING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IServiceBrokerPermissionContext is an interface to support dynamic dispatch.
type IServiceBrokerPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsServiceBrokerPermissionContext differentiates from other interfaces.
	IsServiceBrokerPermissionContext()
}

type ServiceBrokerPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServiceBrokerPermissionContext() *ServiceBrokerPermissionContext {
	var p = new(ServiceBrokerPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_serviceBrokerPermission
	return p
}

func (*ServiceBrokerPermissionContext) IsServiceBrokerPermissionContext() {}

func NewServiceBrokerPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServiceBrokerPermissionContext {
	var p = new(ServiceBrokerPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_serviceBrokerPermission

	return p
}

func (s *ServiceBrokerPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServiceBrokerPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *ServiceBrokerPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *ServiceBrokerPermissionContext) CONTRACT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONTRACT, 0)
}

func (s *ServiceBrokerPermissionContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMESSAGE, 0)
}

func (s *ServiceBrokerPermissionContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTYPE, 0)
}

func (s *ServiceBrokerPermissionContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserREMOTE, 0)
}

func (s *ServiceBrokerPermissionContext) SERVICE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSERVICE, 0)
}

func (s *ServiceBrokerPermissionContext) BINDING() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBINDING, 0)
}

func (s *ServiceBrokerPermissionContext) ROUTE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROUTE, 0)
}

func (s *ServiceBrokerPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServiceBrokerPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServiceBrokerPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterServiceBrokerPermission(s)
	}
}

func (s *ServiceBrokerPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitServiceBrokerPermission(s)
	}
}

func (s *ServiceBrokerPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitServiceBrokerPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ServiceBrokerPermission() (localctx IServiceBrokerPermissionContext) {
	this := p
	_ = this

	localctx = NewServiceBrokerPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, SQLServerStatementParserRULE_serviceBrokerPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5400)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5401)
		p.Match(SQLServerStatementParserANY)
	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserCONTRACT:
		{
			p.SetState(5402)
			p.Match(SQLServerStatementParserCONTRACT)
		}

	case SQLServerStatementParserMESSAGE:
		{
			p.SetState(5403)
			p.Match(SQLServerStatementParserMESSAGE)
		}
		{
			p.SetState(5404)
			p.Match(SQLServerStatementParserTYPE)
		}

	case SQLServerStatementParserREMOTE:
		{
			p.SetState(5405)
			p.Match(SQLServerStatementParserREMOTE)
		}
		{
			p.SetState(5406)
			p.Match(SQLServerStatementParserSERVICE)
		}
		{
			p.SetState(5407)
			p.Match(SQLServerStatementParserBINDING)
		}

	case SQLServerStatementParserROUTE:
		{
			p.SetState(5408)
			p.Match(SQLServerStatementParserROUTE)
		}

	case SQLServerStatementParserSERVICE:
		{
			p.SetState(5409)
			p.Match(SQLServerStatementParserSERVICE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEndpointPermissionContext is an interface to support dynamic dispatch.
type IEndpointPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndpointPermissionContext differentiates from other interfaces.
	IsEndpointPermissionContext()
}

type EndpointPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndpointPermissionContext() *EndpointPermissionContext {
	var p = new(EndpointPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_endpointPermission
	return p
}

func (*EndpointPermissionContext) IsEndpointPermissionContext() {}

func NewEndpointPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndpointPermissionContext {
	var p = new(EndpointPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_endpointPermission

	return p
}

func (s *EndpointPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *EndpointPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *EndpointPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *EndpointPermissionContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserENDPOINT, 0)
}

func (s *EndpointPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndpointPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndpointPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterEndpointPermission(s)
	}
}

func (s *EndpointPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitEndpointPermission(s)
	}
}

func (s *EndpointPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitEndpointPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) EndpointPermission() (localctx IEndpointPermissionContext) {
	this := p
	_ = this

	localctx = NewEndpointPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, SQLServerStatementParserRULE_endpointPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5413)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5414)
		p.Match(SQLServerStatementParserENDPOINT)
	}

	return localctx
}

// ICertificatePermissionContext is an interface to support dynamic dispatch.
type ICertificatePermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCertificatePermissionContext differentiates from other interfaces.
	IsCertificatePermissionContext()
}

type CertificatePermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCertificatePermissionContext() *CertificatePermissionContext {
	var p = new(CertificatePermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_certificatePermission
	return p
}

func (*CertificatePermissionContext) IsCertificatePermissionContext() {}

func NewCertificatePermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CertificatePermissionContext {
	var p = new(CertificatePermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_certificatePermission

	return p
}

func (s *CertificatePermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *CertificatePermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *CertificatePermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *CertificatePermissionContext) CERTIFICATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCERTIFICATE, 0)
}

func (s *CertificatePermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CertificatePermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CertificatePermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCertificatePermission(s)
	}
}

func (s *CertificatePermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCertificatePermission(s)
	}
}

func (s *CertificatePermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCertificatePermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CertificatePermission() (localctx ICertificatePermissionContext) {
	this := p
	_ = this

	localctx = NewCertificatePermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, SQLServerStatementParserRULE_certificatePermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5416)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5417)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5418)
		p.Match(SQLServerStatementParserCERTIFICATE)
	}

	return localctx
}

// ISymmetricKeyPermissionContext is an interface to support dynamic dispatch.
type ISymmetricKeyPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymmetricKeyPermissionContext differentiates from other interfaces.
	IsSymmetricKeyPermissionContext()
}

type SymmetricKeyPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymmetricKeyPermissionContext() *SymmetricKeyPermissionContext {
	var p = new(SymmetricKeyPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_symmetricKeyPermission
	return p
}

func (*SymmetricKeyPermissionContext) IsSymmetricKeyPermissionContext() {}

func NewSymmetricKeyPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymmetricKeyPermissionContext {
	var p = new(SymmetricKeyPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_symmetricKeyPermission

	return p
}

func (s *SymmetricKeyPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *SymmetricKeyPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *SymmetricKeyPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *SymmetricKeyPermissionContext) SYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSYMMETRIC, 0)
}

func (s *SymmetricKeyPermissionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *SymmetricKeyPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymmetricKeyPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymmetricKeyPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSymmetricKeyPermission(s)
	}
}

func (s *SymmetricKeyPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSymmetricKeyPermission(s)
	}
}

func (s *SymmetricKeyPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSymmetricKeyPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SymmetricKeyPermission() (localctx ISymmetricKeyPermissionContext) {
	this := p
	_ = this

	localctx = NewSymmetricKeyPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, SQLServerStatementParserRULE_symmetricKeyPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5420)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5421)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5422)
		p.Match(SQLServerStatementParserSYMMETRIC)
	}
	{
		p.SetState(5423)
		p.Match(SQLServerStatementParserKEY)
	}

	return localctx
}

// IAsymmetricKeyPermissionContext is an interface to support dynamic dispatch.
type IAsymmetricKeyPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAsymmetricKeyPermissionContext differentiates from other interfaces.
	IsAsymmetricKeyPermissionContext()
}

type AsymmetricKeyPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsymmetricKeyPermissionContext() *AsymmetricKeyPermissionContext {
	var p = new(AsymmetricKeyPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_asymmetricKeyPermission
	return p
}

func (*AsymmetricKeyPermissionContext) IsAsymmetricKeyPermissionContext() {}

func NewAsymmetricKeyPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsymmetricKeyPermissionContext {
	var p = new(AsymmetricKeyPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_asymmetricKeyPermission

	return p
}

func (s *AsymmetricKeyPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsymmetricKeyPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AsymmetricKeyPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *AsymmetricKeyPermissionContext) ASYMMETRIC() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASYMMETRIC, 0)
}

func (s *AsymmetricKeyPermissionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserKEY, 0)
}

func (s *AsymmetricKeyPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsymmetricKeyPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsymmetricKeyPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAsymmetricKeyPermission(s)
	}
}

func (s *AsymmetricKeyPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAsymmetricKeyPermission(s)
	}
}

func (s *AsymmetricKeyPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAsymmetricKeyPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AsymmetricKeyPermission() (localctx IAsymmetricKeyPermissionContext) {
	this := p
	_ = this

	localctx = NewAsymmetricKeyPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, SQLServerStatementParserRULE_asymmetricKeyPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5425)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5426)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5427)
		p.Match(SQLServerStatementParserASYMMETRIC)
	}
	{
		p.SetState(5428)
		p.Match(SQLServerStatementParserKEY)
	}

	return localctx
}

// IAssemblyPermissionContext is an interface to support dynamic dispatch.
type IAssemblyPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssemblyPermissionContext differentiates from other interfaces.
	IsAssemblyPermissionContext()
}

type AssemblyPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssemblyPermissionContext() *AssemblyPermissionContext {
	var p = new(AssemblyPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_assemblyPermission
	return p
}

func (*AssemblyPermissionContext) IsAssemblyPermissionContext() {}

func NewAssemblyPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssemblyPermissionContext {
	var p = new(AssemblyPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_assemblyPermission

	return p
}

func (s *AssemblyPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssemblyPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AssemblyPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *AssemblyPermissionContext) ASSEMBLY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserASSEMBLY, 0)
}

func (s *AssemblyPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssemblyPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssemblyPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAssemblyPermission(s)
	}
}

func (s *AssemblyPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAssemblyPermission(s)
	}
}

func (s *AssemblyPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAssemblyPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AssemblyPermission() (localctx IAssemblyPermissionContext) {
	this := p
	_ = this

	localctx = NewAssemblyPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, SQLServerStatementParserRULE_assemblyPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5430)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5431)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5432)
		p.Match(SQLServerStatementParserASSEMBLY)
	}

	return localctx
}

// IAvailabilityGroupPermissionContext is an interface to support dynamic dispatch.
type IAvailabilityGroupPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAvailabilityGroupPermissionContext differentiates from other interfaces.
	IsAvailabilityGroupPermissionContext()
}

type AvailabilityGroupPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAvailabilityGroupPermissionContext() *AvailabilityGroupPermissionContext {
	var p = new(AvailabilityGroupPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_availabilityGroupPermission
	return p
}

func (*AvailabilityGroupPermissionContext) IsAvailabilityGroupPermissionContext() {}

func NewAvailabilityGroupPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AvailabilityGroupPermissionContext {
	var p = new(AvailabilityGroupPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_availabilityGroupPermission

	return p
}

func (s *AvailabilityGroupPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *AvailabilityGroupPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AvailabilityGroupPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *AvailabilityGroupPermissionContext) AVAILABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAVAILABILITY, 0)
}

func (s *AvailabilityGroupPermissionContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGROUP, 0)
}

func (s *AvailabilityGroupPermissionContext) CONNECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCONNECT, 0)
}

func (s *AvailabilityGroupPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AvailabilityGroupPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AvailabilityGroupPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAvailabilityGroupPermission(s)
	}
}

func (s *AvailabilityGroupPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAvailabilityGroupPermission(s)
	}
}

func (s *AvailabilityGroupPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAvailabilityGroupPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AvailabilityGroupPermission() (localctx IAvailabilityGroupPermissionContext) {
	this := p
	_ = this

	localctx = NewAvailabilityGroupPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, SQLServerStatementParserRULE_availabilityGroupPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5439)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserALTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5434)
			p.Match(SQLServerStatementParserALTER)
		}
		{
			p.SetState(5435)
			p.Match(SQLServerStatementParserANY)
		}
		{
			p.SetState(5436)
			p.Match(SQLServerStatementParserAVAILABILITY)
		}
		{
			p.SetState(5437)
			p.Match(SQLServerStatementParserGROUP)
		}

	case SQLServerStatementParserCONNECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5438)
			p.Match(SQLServerStatementParserCONNECT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFullTextPermissionContext is an interface to support dynamic dispatch.
type IFullTextPermissionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullTextPermissionContext differentiates from other interfaces.
	IsFullTextPermissionContext()
}

type FullTextPermissionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullTextPermissionContext() *FullTextPermissionContext {
	var p = new(FullTextPermissionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_fullTextPermission
	return p
}

func (*FullTextPermissionContext) IsFullTextPermissionContext() {}

func NewFullTextPermissionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullTextPermissionContext {
	var p = new(FullTextPermissionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_fullTextPermission

	return p
}

func (s *FullTextPermissionContext) GetParser() antlr.Parser { return s.parser }

func (s *FullTextPermissionContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *FullTextPermissionContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserANY, 0)
}

func (s *FullTextPermissionContext) FULLTEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserFULLTEXT, 0)
}

func (s *FullTextPermissionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCATALOG, 0)
}

func (s *FullTextPermissionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullTextPermissionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullTextPermissionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterFullTextPermission(s)
	}
}

func (s *FullTextPermissionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitFullTextPermission(s)
	}
}

func (s *FullTextPermissionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitFullTextPermission(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) FullTextPermission() (localctx IFullTextPermissionContext) {
	this := p
	_ = this

	localctx = NewFullTextPermissionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, SQLServerStatementParserRULE_fullTextPermission)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5441)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5442)
		p.Match(SQLServerStatementParserANY)
	}
	{
		p.SetState(5443)
		p.Match(SQLServerStatementParserFULLTEXT)
	}
	{
		p.SetState(5444)
		p.Match(SQLServerStatementParserCATALOG)
	}

	return localctx
}

// IClass_Context is an interface to support dynamic dispatch.
type IClass_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_Context differentiates from other interfaces.
	IsClass_Context()
}

type Class_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_Context() *Class_Context {
	var p = new(Class_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_class_
	return p
}

func (*Class_Context) IsClass_Context() {}

func NewClass_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_Context {
	var p = new(Class_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_class_

	return p
}

func (s *Class_Context) GetParser() antlr.Parser { return s.parser }

func (s *Class_Context) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIDENTIFIER_, 0)
}

func (s *Class_Context) AllCOLON_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOLON_)
}

func (s *Class_Context) COLON_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLON_, i)
}

func (s *Class_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClass_(s)
	}
}

func (s *Class_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClass_(s)
	}
}

func (s *Class_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClass_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Class_() (localctx IClass_Context) {
	this := p
	_ = this

	localctx = NewClass_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, SQLServerStatementParserRULE_class_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5446)
		p.Match(SQLServerStatementParserIDENTIFIER_)
	}
	{
		p.SetState(5447)
		p.Match(SQLServerStatementParserCOLON_)
	}
	{
		p.SetState(5448)
		p.Match(SQLServerStatementParserCOLON_)
	}

	return localctx
}

// IClassTypeContext is an interface to support dynamic dispatch.
type IClassTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassTypeContext differentiates from other interfaces.
	IsClassTypeContext()
}

type ClassTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassTypeContext() *ClassTypeContext {
	var p = new(ClassTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_classType
	return p
}

func (*ClassTypeContext) IsClassTypeContext() {}

func NewClassTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassTypeContext {
	var p = new(ClassTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_classType

	return p
}

func (s *ClassTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassTypeContext) AllCOLON_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserCOLON_)
}

func (s *ClassTypeContext) COLON_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOLON_, i)
}

func (s *ClassTypeContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *ClassTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDATABASE, 0)
}

func (s *ClassTypeContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOBJECT, 0)
}

func (s *ClassTypeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *ClassTypeContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSCHEMA, 0)
}

func (s *ClassTypeContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *ClassTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterClassType(s)
	}
}

func (s *ClassTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitClassType(s)
	}
}

func (s *ClassTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitClassType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ClassType() (localctx IClassTypeContext) {
	this := p
	_ = this

	localctx = NewClassTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, SQLServerStatementParserRULE_classType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5450)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserSCHEMA || (((_la-201)&-(0x1f+1)) == 0 && ((1<<uint((_la-201)))&((1<<(SQLServerStatementParserDATABASE-201))|(1<<(SQLServerStatementParserUSER-201))|(1<<(SQLServerStatementParserROLE-201)))) != 0) || _la == SQLServerStatementParserLOGIN || _la == SQLServerStatementParserOBJECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5451)
		p.Match(SQLServerStatementParserCOLON_)
	}
	{
		p.SetState(5452)
		p.Match(SQLServerStatementParserCOLON_)
	}

	return localctx
}

// IRoleClauseContext is an interface to support dynamic dispatch.
type IRoleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoleClauseContext differentiates from other interfaces.
	IsRoleClauseContext()
}

type RoleClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleClauseContext() *RoleClauseContext {
	var p = new(RoleClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_roleClause
	return p
}

func (*RoleClauseContext) IsRoleClauseContext() {}

func NewRoleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleClauseContext {
	var p = new(RoleClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_roleClause

	return p
}

func (s *RoleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleClauseContext) IgnoredIdentifiers() IIgnoredIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifiersContext)
}

func (s *RoleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRoleClause(s)
	}
}

func (s *RoleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRoleClause(s)
	}
}

func (s *RoleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRoleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RoleClause() (localctx IRoleClauseContext) {
	this := p
	_ = this

	localctx = NewRoleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, SQLServerStatementParserRULE_roleClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5454)
		p.IgnoredIdentifiers()
	}

	return localctx
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createUser
	return p
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (s *CreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateUser() (localctx ICreateUserContext) {
	this := p
	_ = this

	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, SQLServerStatementParserRULE_createUser)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5456)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(5457)
		p.Match(SQLServerStatementParserUSER)
	}

	return localctx
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropUser
	return p
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropUser() (localctx IDropUserContext) {
	this := p
	_ = this

	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, SQLServerStatementParserRULE_dropUser)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5459)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(5460)
		p.Match(SQLServerStatementParserUSER)
	}

	return localctx
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterUser
	return p
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserUSER, 0)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (s *AlterUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterUser() (localctx IAlterUserContext) {
	this := p
	_ = this

	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, SQLServerStatementParserRULE_alterUser)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5462)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5463)
		p.Match(SQLServerStatementParserUSER)
	}

	return localctx
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createRole
	return p
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateRole() (localctx ICreateRoleContext) {
	this := p
	_ = this

	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, SQLServerStatementParserRULE_createRole)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5465)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(5466)
		p.Match(SQLServerStatementParserROLE)
	}

	return localctx
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropRole
	return p
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropRole() (localctx IDropRoleContext) {
	this := p
	_ = this

	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, SQLServerStatementParserRULE_dropRole)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5468)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(5469)
		p.Match(SQLServerStatementParserROLE)
	}

	return localctx
}

// IAlterRoleContext is an interface to support dynamic dispatch.
type IAlterRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterRoleContext differentiates from other interfaces.
	IsAlterRoleContext()
}

type AlterRoleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleContext() *AlterRoleContext {
	var p = new(AlterRoleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterRole
	return p
}

func (*AlterRoleContext) IsAlterRoleContext() {}

func NewAlterRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleContext {
	var p = new(AlterRoleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterRole

	return p
}

func (s *AlterRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLE, 0)
}

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterRole(s)
	}
}

func (s *AlterRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterRole(s)
	}
}

func (s *AlterRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterRole() (localctx IAlterRoleContext) {
	this := p
	_ = this

	localctx = NewAlterRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, SQLServerStatementParserRULE_alterRole)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5471)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5472)
		p.Match(SQLServerStatementParserROLE)
	}

	return localctx
}

// ICreateLoginContext is an interface to support dynamic dispatch.
type ICreateLoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateLoginContext differentiates from other interfaces.
	IsCreateLoginContext()
}

type CreateLoginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateLoginContext() *CreateLoginContext {
	var p = new(CreateLoginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_createLogin
	return p
}

func (*CreateLoginContext) IsCreateLoginContext() {}

func NewCreateLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLoginContext {
	var p = new(CreateLoginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_createLogin

	return p
}

func (s *CreateLoginContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLoginContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCREATE, 0)
}

func (s *CreateLoginContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *CreateLoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCreateLogin(s)
	}
}

func (s *CreateLoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCreateLogin(s)
	}
}

func (s *CreateLoginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCreateLogin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CreateLogin() (localctx ICreateLoginContext) {
	this := p
	_ = this

	localctx = NewCreateLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, SQLServerStatementParserRULE_createLogin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5474)
		p.Match(SQLServerStatementParserCREATE)
	}
	{
		p.SetState(5475)
		p.Match(SQLServerStatementParserLOGIN)
	}

	return localctx
}

// IDropLoginContext is an interface to support dynamic dispatch.
type IDropLoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropLoginContext differentiates from other interfaces.
	IsDropLoginContext()
}

type DropLoginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLoginContext() *DropLoginContext {
	var p = new(DropLoginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_dropLogin
	return p
}

func (*DropLoginContext) IsDropLoginContext() {}

func NewDropLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLoginContext {
	var p = new(DropLoginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_dropLogin

	return p
}

func (s *DropLoginContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLoginContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDROP, 0)
}

func (s *DropLoginContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *DropLoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterDropLogin(s)
	}
}

func (s *DropLoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitDropLogin(s)
	}
}

func (s *DropLoginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitDropLogin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) DropLogin() (localctx IDropLoginContext) {
	this := p
	_ = this

	localctx = NewDropLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, SQLServerStatementParserRULE_dropLogin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5477)
		p.Match(SQLServerStatementParserDROP)
	}
	{
		p.SetState(5478)
		p.Match(SQLServerStatementParserLOGIN)
	}

	return localctx
}

// IAlterLoginContext is an interface to support dynamic dispatch.
type IAlterLoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterLoginContext differentiates from other interfaces.
	IsAlterLoginContext()
}

type AlterLoginContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLoginContext() *AlterLoginContext {
	var p = new(AlterLoginContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_alterLogin
	return p
}

func (*AlterLoginContext) IsAlterLoginContext() {}

func NewAlterLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoginContext {
	var p = new(AlterLoginContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_alterLogin

	return p
}

func (s *AlterLoginContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoginContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserALTER, 0)
}

func (s *AlterLoginContext) LOGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLOGIN, 0)
}

func (s *AlterLoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterAlterLogin(s)
	}
}

func (s *AlterLoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitAlterLogin(s)
	}
}

func (s *AlterLoginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitAlterLogin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) AlterLogin() (localctx IAlterLoginContext) {
	this := p
	_ = this

	localctx = NewAlterLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, SQLServerStatementParserRULE_alterLogin)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5480)
		p.Match(SQLServerStatementParserALTER)
	}
	{
		p.SetState(5481)
		p.Match(SQLServerStatementParserLOGIN)
	}

	return localctx
}

// ISetTransactionContext is an interface to support dynamic dispatch.
type ISetTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTransactionContext differentiates from other interfaces.
	IsSetTransactionContext()
}

type SetTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTransactionContext() *SetTransactionContext {
	var p = new(SetTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setTransaction
	return p
}

func (*SetTransactionContext) IsSetTransactionContext() {}

func NewSetTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionContext {
	var p = new(SetTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setTransaction

	return p
}

func (s *SetTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetTransaction() (localctx ISetTransactionContext) {
	this := p
	_ = this

	localctx = NewSetTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, SQLServerStatementParserRULE_setTransaction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5483)
		p.Match(SQLServerStatementParserSET)
	}
	{
		p.SetState(5484)
		p.Match(SQLServerStatementParserTRANSACTION)
	}

	return localctx
}

// ISetImplicitTransactionsContext is an interface to support dynamic dispatch.
type ISetImplicitTransactionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetImplicitTransactionsContext differentiates from other interfaces.
	IsSetImplicitTransactionsContext()
}

type SetImplicitTransactionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetImplicitTransactionsContext() *SetImplicitTransactionsContext {
	var p = new(SetImplicitTransactionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_setImplicitTransactions
	return p
}

func (*SetImplicitTransactionsContext) IsSetImplicitTransactionsContext() {}

func NewSetImplicitTransactionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetImplicitTransactionsContext {
	var p = new(SetImplicitTransactionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_setImplicitTransactions

	return p
}

func (s *SetImplicitTransactionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SetImplicitTransactionsContext) SET() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSET, 0)
}

func (s *SetImplicitTransactionsContext) IMPLICIT_TRANSACTIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIMPLICIT_TRANSACTIONS, 0)
}

func (s *SetImplicitTransactionsContext) ImplicitTransactionsValue() IImplicitTransactionsValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplicitTransactionsValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplicitTransactionsValueContext)
}

func (s *SetImplicitTransactionsContext) IF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserIF, 0)
}

func (s *SetImplicitTransactionsContext) AllAT_() []antlr.TerminalNode {
	return s.GetTokens(SQLServerStatementParserAT_)
}

func (s *SetImplicitTransactionsContext) AT_(i int) antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserAT_, i)
}

func (s *SetImplicitTransactionsContext) TRANCOUNT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANCOUNT, 0)
}

func (s *SetImplicitTransactionsContext) GT_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserGT_, 0)
}

func (s *SetImplicitTransactionsContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNUMBER_, 0)
}

func (s *SetImplicitTransactionsContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMIT, 0)
}

func (s *SetImplicitTransactionsContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *SetImplicitTransactionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetImplicitTransactionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetImplicitTransactionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSetImplicitTransactions(s)
	}
}

func (s *SetImplicitTransactionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSetImplicitTransactions(s)
	}
}

func (s *SetImplicitTransactionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSetImplicitTransactions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) SetImplicitTransactions() (localctx ISetImplicitTransactionsContext) {
	this := p
	_ = this

	localctx = NewSetImplicitTransactionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, SQLServerStatementParserRULE_setImplicitTransactions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserIF {
		{
			p.SetState(5486)
			p.Match(SQLServerStatementParserIF)
		}
		{
			p.SetState(5487)
			p.Match(SQLServerStatementParserAT_)
		}
		{
			p.SetState(5488)
			p.Match(SQLServerStatementParserAT_)
		}
		{
			p.SetState(5489)
			p.Match(SQLServerStatementParserTRANCOUNT)
		}
		{
			p.SetState(5490)
			p.Match(SQLServerStatementParserGT_)
		}
		{
			p.SetState(5491)
			p.Match(SQLServerStatementParserNUMBER_)
		}
		{
			p.SetState(5492)
			p.Match(SQLServerStatementParserCOMMIT)
		}
		{
			p.SetState(5493)
			p.Match(SQLServerStatementParserTRAN)
		}

	}
	{
		p.SetState(5496)
		p.Match(SQLServerStatementParserSET)
	}
	{
		p.SetState(5497)
		p.Match(SQLServerStatementParserIMPLICIT_TRANSACTIONS)
	}
	{
		p.SetState(5498)
		p.ImplicitTransactionsValue()
	}

	return localctx
}

// IImplicitTransactionsValueContext is an interface to support dynamic dispatch.
type IImplicitTransactionsValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplicitTransactionsValueContext differentiates from other interfaces.
	IsImplicitTransactionsValueContext()
}

type ImplicitTransactionsValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplicitTransactionsValueContext() *ImplicitTransactionsValueContext {
	var p = new(ImplicitTransactionsValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_implicitTransactionsValue
	return p
}

func (*ImplicitTransactionsValueContext) IsImplicitTransactionsValueContext() {}

func NewImplicitTransactionsValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplicitTransactionsValueContext {
	var p = new(ImplicitTransactionsValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_implicitTransactionsValue

	return p
}

func (s *ImplicitTransactionsValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplicitTransactionsValueContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *ImplicitTransactionsValueContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *ImplicitTransactionsValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplicitTransactionsValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplicitTransactionsValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterImplicitTransactionsValue(s)
	}
}

func (s *ImplicitTransactionsValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitImplicitTransactionsValue(s)
	}
}

func (s *ImplicitTransactionsValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitImplicitTransactionsValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ImplicitTransactionsValue() (localctx IImplicitTransactionsValueContext) {
	this := p
	_ = this

	localctx = NewImplicitTransactionsValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, SQLServerStatementParserRULE_implicitTransactionsValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5500)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBeginTransactionContext is an interface to support dynamic dispatch.
type IBeginTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBeginTransactionContext differentiates from other interfaces.
	IsBeginTransactionContext()
}

type BeginTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginTransactionContext() *BeginTransactionContext {
	var p = new(BeginTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_beginTransaction
	return p
}

func (*BeginTransactionContext) IsBeginTransactionContext() {}

func NewBeginTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginTransactionContext {
	var p = new(BeginTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_beginTransaction

	return p
}

func (s *BeginTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBEGIN, 0)
}

func (s *BeginTransactionContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *BeginTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *BeginTransactionContext) TransactionName() ITransactionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionNameContext)
}

func (s *BeginTransactionContext) TransactionVariableName() ITransactionVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionVariableNameContext)
}

func (s *BeginTransactionContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *BeginTransactionContext) MARK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserMARK, 0)
}

func (s *BeginTransactionContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *BeginTransactionContext) NCHAR_TEXT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserNCHAR_TEXT, 0)
}

func (s *BeginTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBeginTransaction(s)
	}
}

func (s *BeginTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBeginTransaction(s)
	}
}

func (s *BeginTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBeginTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BeginTransaction() (localctx IBeginTransactionContext) {
	this := p
	_ = this

	localctx = NewBeginTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, SQLServerStatementParserRULE_beginTransaction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5502)
		p.Match(SQLServerStatementParserBEGIN)
	}
	{
		p.SetState(5503)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-40)&-(0x1f+1)) == 0 && ((1<<uint((_la-40)))&((1<<(SQLServerStatementParserAT_-40))|(1<<(SQLServerStatementParserTRUNCATE-40))|(1<<(SQLServerStatementParserFUNCTION-40))|(1<<(SQLServerStatementParserTRIGGER-40)))) != 0) || _la == SQLServerStatementParserCAST || (((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(SQLServerStatementParserGROUP-115))|(1<<(SQLServerStatementParserLIMIT-115))|(1<<(SQLServerStatementParserOFFSET-115))|(1<<(SQLServerStatementParserSAVEPOINT-115))|(1<<(SQLServerStatementParserBOOLEAN-115))|(1<<(SQLServerStatementParserARRAY-115))|(1<<(SQLServerStatementParserDATE-115))|(1<<(SQLServerStatementParserLOCALTIME-115))|(1<<(SQLServerStatementParserLOCALTIMESTAMP-115))|(1<<(SQLServerStatementParserQUARTER-115))|(1<<(SQLServerStatementParserWEEK-115))|(1<<(SQLServerStatementParserDAY-115))|(1<<(SQLServerStatementParserMICROSECOND-115))|(1<<(SQLServerStatementParserMAX-115)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(SQLServerStatementParserMIN-147))|(1<<(SQLServerStatementParserSUM-147))|(1<<(SQLServerStatementParserCOUNT-147))|(1<<(SQLServerStatementParserAVG-147))|(1<<(SQLServerStatementParserENABLE-147))|(1<<(SQLServerStatementParserDISABLE-147))|(1<<(SQLServerStatementParserINSTANCE-147))|(1<<(SQLServerStatementParserDO-147))|(1<<(SQLServerStatementParserDEFINER-147))|(1<<(SQLServerStatementParserSQL-147))|(1<<(SQLServerStatementParserCASCADED-147))|(1<<(SQLServerStatementParserLOCAL-147))|(1<<(SQLServerStatementParserNEXT-147))|(1<<(SQLServerStatementParserNAME-147))|(1<<(SQLServerStatementParserINTEGER-147))|(1<<(SQLServerStatementParserTYPE-147)))) != 0) || (((_la-200)&-(0x1f+1)) == 0 && ((1<<uint((_la-200)))&((1<<(SQLServerStatementParserREAD_ONLY-200))|(1<<(SQLServerStatementParserDATABASE-200))|(1<<(SQLServerStatementParserDATEPART-200))|(1<<(SQLServerStatementParserBINARY-200))|(1<<(SQLServerStatementParserHIDDEN_-200))|(1<<(SQLServerStatementParserMOD-200))|(1<<(SQLServerStatementParserPARTITION-200))|(1<<(SQLServerStatementParserPARTITIONS-200))|(1<<(SQLServerStatementParserTOP-200))|(1<<(SQLServerStatementParserROW-200))|(1<<(SQLServerStatementParserROWS-200))|(1<<(SQLServerStatementParserXOR-200))|(1<<(SQLServerStatementParserALWAYS-200))|(1<<(SQLServerStatementParserROLE-200)))) != 0) || (((_la-232)&-(0x1f+1)) == 0 && ((1<<uint((_la-232)))&((1<<(SQLServerStatementParserSTART-232))|(1<<(SQLServerStatementParserALGORITHM-232))|(1<<(SQLServerStatementParserAUTO-232))|(1<<(SQLServerStatementParserBLOCKERS-232))|(1<<(SQLServerStatementParserCLUSTERED-232))|(1<<(SQLServerStatementParserNONCLUSTERED-232))|(1<<(SQLServerStatementParserCOLUMNSTORE-232))|(1<<(SQLServerStatementParserCONTENT-232))|(1<<(SQLServerStatementParserYEARS-232))|(1<<(SQLServerStatementParserMONTHS-232))|(1<<(SQLServerStatementParserWEEKS-232))|(1<<(SQLServerStatementParserDAYS-232))|(1<<(SQLServerStatementParserMINUTES-232))|(1<<(SQLServerStatementParserDENY-232))|(1<<(SQLServerStatementParserDETERMINISTIC-232))|(1<<(SQLServerStatementParserDISTRIBUTION-232))|(1<<(SQLServerStatementParserDOCUMENT-232))|(1<<(SQLServerStatementParserDURABILITY-232))|(1<<(SQLServerStatementParserENCRYPTED-232))|(1<<(SQLServerStatementParserFILESTREAM-232))|(1<<(SQLServerStatementParserFILETABLE-232))|(1<<(SQLServerStatementParserFILLFACTOR-232))|(1<<(SQLServerStatementParserFOLLOWING-232))|(1<<(SQLServerStatementParserHASH-232))|(1<<(SQLServerStatementParserHEAP-232))|(1<<(SQLServerStatementParserINBOUND-232)))) != 0) || (((_la-264)&-(0x1f+1)) == 0 && ((1<<uint((_la-264)))&((1<<(SQLServerStatementParserOUTBOUND-264))|(1<<(SQLServerStatementParserUNBOUNDED-264))|(1<<(SQLServerStatementParserINFINITE-264))|(1<<(SQLServerStatementParserLOGIN-264))|(1<<(SQLServerStatementParserMASKED-264))|(1<<(SQLServerStatementParserMAXDOP-264))|(1<<(SQLServerStatementParserMOVE-264))|(1<<(SQLServerStatementParserNOCHECK-264))|(1<<(SQLServerStatementParserOBJECT-264))|(1<<(SQLServerStatementParserOFF-264))|(1<<(SQLServerStatementParserONLINE-264))|(1<<(SQLServerStatementParserOVER-264))|(1<<(SQLServerStatementParserPAGE-264))|(1<<(SQLServerStatementParserPAUSED-264))|(1<<(SQLServerStatementParserPERIOD-264))|(1<<(SQLServerStatementParserPERSISTED-264))|(1<<(SQLServerStatementParserPRECEDING-264))|(1<<(SQLServerStatementParserRANDOMIZED-264))|(1<<(SQLServerStatementParserRANGE-264))|(1<<(SQLServerStatementParserREBUILD-264))|(1<<(SQLServerStatementParserREPLICATE-264))|(1<<(SQLServerStatementParserREPLICATION-264))|(1<<(SQLServerStatementParserRESUMABLE-264))|(1<<(SQLServerStatementParserROWGUIDCOL-264))|(1<<(SQLServerStatementParserSAVE-264))|(1<<(SQLServerStatementParserSELF-264))|(1<<(SQLServerStatementParserSPARSE-264))|(1<<(SQLServerStatementParserSWITCH-264))|(1<<(SQLServerStatementParserTRAN-264))|(1<<(SQLServerStatementParserTRANCOUNT-264)))) != 0) || (((_la-302)&-(0x1f+1)) == 0 && ((1<<uint((_la-302)))&((1<<(SQLServerStatementParserCONTROL-302))|(1<<(SQLServerStatementParserCONCAT-302))|(1<<(SQLServerStatementParserTAKE-302))|(1<<(SQLServerStatementParserOWNERSHIP-302))|(1<<(SQLServerStatementParserDEFINITION-302))|(1<<(SQLServerStatementParserAPPLICATION-302))|(1<<(SQLServerStatementParserASSEMBLY-302))|(1<<(SQLServerStatementParserSYMMETRIC-302))|(1<<(SQLServerStatementParserASYMMETRIC-302))|(1<<(SQLServerStatementParserSERVER-302))|(1<<(SQLServerStatementParserRECEIVE-302))|(1<<(SQLServerStatementParserCHANGE-302))|(1<<(SQLServerStatementParserTRACE-302))|(1<<(SQLServerStatementParserTRACKING-302))|(1<<(SQLServerStatementParserRESOURCES-302))|(1<<(SQLServerStatementParserSETTINGS-302))|(1<<(SQLServerStatementParserSTATE-302))|(1<<(SQLServerStatementParserAVAILABILITY-302))|(1<<(SQLServerStatementParserCREDENTIAL-302))|(1<<(SQLServerStatementParserENDPOINT-302))|(1<<(SQLServerStatementParserEVENT-302))|(1<<(SQLServerStatementParserNOTIFICATION-302))|(1<<(SQLServerStatementParserLINKED-302))|(1<<(SQLServerStatementParserAUDIT-302))|(1<<(SQLServerStatementParserDDL-302))|(1<<(SQLServerStatementParserXML-302))|(1<<(SQLServerStatementParserIMPERSONATE-302))|(1<<(SQLServerStatementParserSECURABLES-302))|(1<<(SQLServerStatementParserAUTHENTICATE-302))|(1<<(SQLServerStatementParserEXTERNAL-302))|(1<<(SQLServerStatementParserACCESS-302))|(1<<(SQLServerStatementParserADMINISTER-302)))) != 0) || (((_la-334)&-(0x1f+1)) == 0 && ((1<<uint((_la-334)))&((1<<(SQLServerStatementParserBULK-334))|(1<<(SQLServerStatementParserOPERATIONS-334))|(1<<(SQLServerStatementParserUNSAFE-334))|(1<<(SQLServerStatementParserSHUTDOWN-334))|(1<<(SQLServerStatementParserSCOPED-334))|(1<<(SQLServerStatementParserCONFIGURATION-334))|(1<<(SQLServerStatementParserDATASPACE-334))|(1<<(SQLServerStatementParserSERVICE-334))|(1<<(SQLServerStatementParserCERTIFICATE-334))|(1<<(SQLServerStatementParserCONTRACT-334))|(1<<(SQLServerStatementParserENCRYPTION-334))|(1<<(SQLServerStatementParserMASTER-334))|(1<<(SQLServerStatementParserDATA-334))|(1<<(SQLServerStatementParserSOURCE-334))|(1<<(SQLServerStatementParserFILE-334))|(1<<(SQLServerStatementParserFORMAT-334))|(1<<(SQLServerStatementParserLIBRARY-334))|(1<<(SQLServerStatementParserFULLTEXT-334))|(1<<(SQLServerStatementParserMASK-334))|(1<<(SQLServerStatementParserUNMASK-334))|(1<<(SQLServerStatementParserMESSAGE-334))|(1<<(SQLServerStatementParserREMOTE-334))|(1<<(SQLServerStatementParserBINDING-334))|(1<<(SQLServerStatementParserROUTE-334))|(1<<(SQLServerStatementParserSECURITY-334))|(1<<(SQLServerStatementParserPOLICY-334))|(1<<(SQLServerStatementParserAGGREGATE-334))|(1<<(SQLServerStatementParserQUEUE-334))|(1<<(SQLServerStatementParserRULE-334))|(1<<(SQLServerStatementParserSYNONYM-334))|(1<<(SQLServerStatementParserCOLLECTION-334))|(1<<(SQLServerStatementParserSCRIPT-334)))) != 0) || (((_la-366)&-(0x1f+1)) == 0 && ((1<<uint((_la-366)))&((1<<(SQLServerStatementParserKILL-366))|(1<<(SQLServerStatementParserBACKUP-366))|(1<<(SQLServerStatementParserLOG-366))|(1<<(SQLServerStatementParserSHOWPLAN-366))|(1<<(SQLServerStatementParserSUBSCRIBE-366))|(1<<(SQLServerStatementParserQUERY-366))|(1<<(SQLServerStatementParserNOTIFICATIONS-366))|(1<<(SQLServerStatementParserCHECKPOINT-366))|(1<<(SQLServerStatementParserSEQUENCE-366))|(1<<(SQLServerStatementParserABORT_AFTER_WAIT-366))|(1<<(SQLServerStatementParserALLOW_PAGE_LOCKS-366))|(1<<(SQLServerStatementParserALLOW_ROW_LOCKS-366))|(1<<(SQLServerStatementParserALL_SPARSE_COLUMNS-366))|(1<<(SQLServerStatementParserBUCKET_COUNT-366))|(1<<(SQLServerStatementParserCOLUMNSTORE_ARCHIVE-366))|(1<<(SQLServerStatementParserCOLUMN_ENCRYPTION_KEY-366))|(1<<(SQLServerStatementParserCOLUMN_SET-366))|(1<<(SQLServerStatementParserCOMPRESSION_DELAY-366))|(1<<(SQLServerStatementParserDATABASE_DEAULT-366))|(1<<(SQLServerStatementParserDATA_COMPRESSION-366))|(1<<(SQLServerStatementParserDATA_CONSISTENCY_CHECK-366))|(1<<(SQLServerStatementParserENCRYPTION_TYPE-366))|(1<<(SQLServerStatementParserSYSTEM_TIME-366))|(1<<(SQLServerStatementParserSYSTEM_VERSIONING-366))|(1<<(SQLServerStatementParserTEXTIMAGE_ON-366))|(1<<(SQLServerStatementParserWAIT_AT_LOW_PRIORITY-366))|(1<<(SQLServerStatementParserSTATISTICS_INCREMENTAL-366))|(1<<(SQLServerStatementParserSTATISTICS_NORECOMPUTE-366))|(1<<(SQLServerStatementParserROUND_ROBIN-366))|(1<<(SQLServerStatementParserSCHEMA_AND_DATA-366))|(1<<(SQLServerStatementParserSCHEMA_ONLY-366))|(1<<(SQLServerStatementParserSORT_IN_TEMPDB-366)))) != 0) || (((_la-398)&-(0x1f+1)) == 0 && ((1<<uint((_la-398)))&((1<<(SQLServerStatementParserIGNORE_DUP_KEY-398))|(1<<(SQLServerStatementParserIMPLICIT_TRANSACTIONS-398))|(1<<(SQLServerStatementParserMAX_DURATION-398))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED-398))|(1<<(SQLServerStatementParserMIGRATION_STATE-398))|(1<<(SQLServerStatementParserPAD_INDEX-398))|(1<<(SQLServerStatementParserREMOTE_DATA_ARCHIVE-398))|(1<<(SQLServerStatementParserFILESTREAM_ON-398))|(1<<(SQLServerStatementParserFILETABLE_COLLATE_FILENAME-398))|(1<<(SQLServerStatementParserFILETABLE_DIRECTORY-398))|(1<<(SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME-398))|(1<<(SQLServerStatementParserFILTER_PREDICATE-398))|(1<<(SQLServerStatementParserHISTORY_RETENTION_PERIOD-398))|(1<<(SQLServerStatementParserHISTORY_TABLE-398))|(1<<(SQLServerStatementParserLOCK_ESCALATION-398))|(1<<(SQLServerStatementParserDROP_EXISTING-398))|(1<<(SQLServerStatementParserROW_NUMBER-398))|(1<<(SQLServerStatementParserFIRST-398))|(1<<(SQLServerStatementParserDATETIME2-398)))) != 0) || (((_la-436)&-(0x1f+1)) == 0 && ((1<<uint((_la-436)))&((1<<(SQLServerStatementParserOUTPUT-436))|(1<<(SQLServerStatementParserINSERTED-436))|(1<<(SQLServerStatementParserDELETED-436)))) != 0) || (((_la-475)&-(0x1f+1)) == 0 && ((1<<uint((_la-475)))&((1<<(SQLServerStatementParserFILENAME-475))|(1<<(SQLServerStatementParserMAXSIZE-475))|(1<<(SQLServerStatementParserFILEGROWTH-475))|(1<<(SQLServerStatementParserUNLIMITED-475))|(1<<(SQLServerStatementParserKB-475))|(1<<(SQLServerStatementParserMB-475))|(1<<(SQLServerStatementParserGB-475))|(1<<(SQLServerStatementParserTB-475))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_DATA-475))|(1<<(SQLServerStatementParserFILEGROUP-475))|(1<<(SQLServerStatementParserNON_TRANSACTED_ACCESS-475))|(1<<(SQLServerStatementParserDB_CHAINING-475))|(1<<(SQLServerStatementParserTRUSTWORTHY-475))|(1<<(SQLServerStatementParserFORWARD_ONLY-475))|(1<<(SQLServerStatementParserKEYSET-475))|(1<<(SQLServerStatementParserFAST_FORWARD-475))|(1<<(SQLServerStatementParserSCROLL_LOCKS-475))|(1<<(SQLServerStatementParserOPTIMISTIC-475))|(1<<(SQLServerStatementParserTYPE_WARNING-475))|(1<<(SQLServerStatementParserSCHEMABINDING-475))|(1<<(SQLServerStatementParserCALLER-475))|(1<<(SQLServerStatementParserOWNER-475)))) != 0) || (((_la-510)&-(0x1f+1)) == 0 && ((1<<uint((_la-510)))&((1<<(SQLServerStatementParserSNAPSHOT-510))|(1<<(SQLServerStatementParserREPEATABLE-510))|(1<<(SQLServerStatementParserSERIALIZABLE-510))|(1<<(SQLServerStatementParserNATIVE_COMPILATION-510))|(1<<(SQLServerStatementParserVIEW_METADATA-510))|(1<<(SQLServerStatementParserINSTEAD-510))|(1<<(SQLServerStatementParserAPPEND-510))|(1<<(SQLServerStatementParserINCREMENT-510))|(1<<(SQLServerStatementParserCACHE-510))|(1<<(SQLServerStatementParserMINVALUE-510))|(1<<(SQLServerStatementParserMAXVALUE-510))|(1<<(SQLServerStatementParserRESTART-510))|(1<<(SQLServerStatementParserLOB_COMPACTION-510))|(1<<(SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS-510))|(1<<(SQLServerStatementParserREORGANIZE-510))|(1<<(SQLServerStatementParserRESUME-510))|(1<<(SQLServerStatementParserPAUSE-510))|(1<<(SQLServerStatementParserABORT-510))|(1<<(SQLServerStatementParserACCELERATED_DATABASE_RECOVERY-510)))) != 0) || (((_la-542)&-(0x1f+1)) == 0 && ((1<<uint((_la-542)))&((1<<(SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP-542))|(1<<(SQLServerStatementParserIMMEDIATE-542))|(1<<(SQLServerStatementParserNO_WAIT-542))|(1<<(SQLServerStatementParserTARGET_RECOVERY_TIME-542))|(1<<(SQLServerStatementParserSECONDS-542))|(1<<(SQLServerStatementParserHONOR_BROKER_PRIORITY-542))|(1<<(SQLServerStatementParserERROR_BROKER_CONVERSATIONS-542))|(1<<(SQLServerStatementParserNEW_BROKER-542))|(1<<(SQLServerStatementParserDISABLE_BROKER-542))|(1<<(SQLServerStatementParserENABLE_BROKER-542))|(1<<(SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT-542))|(1<<(SQLServerStatementParserREAD_COMMITTED_SNAPSHOT-542))|(1<<(SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION-542))|(1<<(SQLServerStatementParserRECURSIVE_TRIGGERS-542))|(1<<(SQLServerStatementParserQUOTED_IDENTIFIER-542))|(1<<(SQLServerStatementParserNUMERIC_ROUNDABORT-542))|(1<<(SQLServerStatementParserCONCAT_NULL_YIELDS_NULL-542))|(1<<(SQLServerStatementParserCOMPATIBILITY_LEVEL-542))|(1<<(SQLServerStatementParserARITHABORT-542))|(1<<(SQLServerStatementParserANSI_WARNINGS-542))|(1<<(SQLServerStatementParserANSI_PADDING-542))|(1<<(SQLServerStatementParserANSI_NULLS-542))|(1<<(SQLServerStatementParserANSI_NULL_DEFAULT-542))|(1<<(SQLServerStatementParserPAGE_VERIFY-542))|(1<<(SQLServerStatementParserCHECKSUM-542))|(1<<(SQLServerStatementParserTORN_PAGE_DETECTION-542))|(1<<(SQLServerStatementParserBULK_LOGGED-542))|(1<<(SQLServerStatementParserRECOVERY-542))|(1<<(SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS-542))|(1<<(SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD-542))|(1<<(SQLServerStatementParserEXECUTION_COUNT-542)))) != 0) || (((_la-574)&-(0x1f+1)) == 0 && ((1<<uint((_la-574)))&((1<<(SQLServerStatementParserQUERY_CAPTURE_POLICY-574))|(1<<(SQLServerStatementParserWAIT_STATS_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserMAX_PLANS_PER_QUERY-574))|(1<<(SQLServerStatementParserQUERY_CAPTURE_MODE-574))|(1<<(SQLServerStatementParserSIZE_BASED_CLEANUP_MODE-574))|(1<<(SQLServerStatementParserINTERVAL_LENGTH_MINUTES-574))|(1<<(SQLServerStatementParserMAX_STORAGE_SIZE_MB-574))|(1<<(SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS-574))|(1<<(SQLServerStatementParserCLEANUP_POLICY-574))|(1<<(SQLServerStatementParserCUSTOM-574))|(1<<(SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS-574))|(1<<(SQLServerStatementParserOPERATION_MODE-574))|(1<<(SQLServerStatementParserQUERY_STORE-574))|(1<<(SQLServerStatementParserCURSOR_DEFAULT-574))|(1<<(SQLServerStatementParserGLOBAL-574))|(1<<(SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT-574))|(1<<(SQLServerStatementParserHOURS-574))|(1<<(SQLServerStatementParserCHANGE_RETENTION-574))|(1<<(SQLServerStatementParserAUTO_CLEANUP-574))|(1<<(SQLServerStatementParserCHANGE_TRACKING-574))|(1<<(SQLServerStatementParserAUTOMATIC_TUNING-574))|(1<<(SQLServerStatementParserFORCE_LAST_GOOD_PLAN-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC-574))|(1<<(SQLServerStatementParserAUTO_UPDATE_STATISTICS-574))|(1<<(SQLServerStatementParserAUTO_SHRINK-574))|(1<<(SQLServerStatementParserAUTO_CREATE_STATISTICS-574))|(1<<(SQLServerStatementParserINCREMENTAL-574))|(1<<(SQLServerStatementParserAUTO_CLOSE-574))|(1<<(SQLServerStatementParserDATA_RETENTION-574))|(1<<(SQLServerStatementParserTEMPORAL_HISTORY_RETENTION-574))|(1<<(SQLServerStatementParserEDITION-574))|(1<<(SQLServerStatementParserMIXED_PAGE_ALLOCATION-574)))) != 0) || (((_la-606)&-(0x1f+1)) == 0 && ((1<<uint((_la-606)))&((1<<(SQLServerStatementParserDISABLED-606))|(1<<(SQLServerStatementParserALLOWED-606))|(1<<(SQLServerStatementParserHADR-606))|(1<<(SQLServerStatementParserMULTI_USER-606))|(1<<(SQLServerStatementParserRESTRICTED_USER-606))|(1<<(SQLServerStatementParserSINGLE_USER-606))|(1<<(SQLServerStatementParserOFFLINE-606))|(1<<(SQLServerStatementParserEMERGENCY-606))|(1<<(SQLServerStatementParserSUSPEND-606))|(1<<(SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION-606))|(1<<(SQLServerStatementParserELASTIC_POOL-606))|(1<<(SQLServerStatementParserSERVICE_OBJECTIVE-606))|(1<<(SQLServerStatementParserDATABASE_NAME-606))|(1<<(SQLServerStatementParserALLOW_CONNECTIONS-606))|(1<<(SQLServerStatementParserGEO-606))|(1<<(SQLServerStatementParserNAMED-606))|(1<<(SQLServerStatementParserDATEFIRST-606))|(1<<(SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY-606))|(1<<(SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS-606))|(1<<(SQLServerStatementParserSECONDARY-606))|(1<<(SQLServerStatementParserFAILOVER-606))|(1<<(SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE-606))|(1<<(SQLServerStatementParserDEFAULT_LANGUAGE-606))|(1<<(SQLServerStatementParserINLINE-606))|(1<<(SQLServerStatementParserNESTED_TRIGGERS-606))|(1<<(SQLServerStatementParserTRANSFORM_NOISE_WORDS-606))|(1<<(SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF-606))|(1<<(SQLServerStatementParserPERSISTENT_LOG_BUFFER-606))|(1<<(SQLServerStatementParserDIRECTORY_NAME-606))|(1<<(SQLServerStatementParserDATEFORMAT-606))|(1<<(SQLServerStatementParserDELAYED_DURABILITY-606)))) != 0) || _la == SQLServerStatementParserTRANSFER || _la == SQLServerStatementParserIDENTIFIER_ {
		p.SetState(5506)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(5504)
				p.TransactionName()
			}

		case SQLServerStatementParserAT_:
			{
				p.SetState(5505)
				p.TransactionVariableName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(5514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQLServerStatementParserWITH {
			{
				p.SetState(5508)
				p.Match(SQLServerStatementParserWITH)
			}
			{
				p.SetState(5509)
				p.Match(SQLServerStatementParserMARK)
			}
			p.SetState(5512)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQLServerStatementParserSTRING_:
				{
					p.SetState(5510)
					p.StringLiterals()
				}

			case SQLServerStatementParserNCHAR_TEXT:
				{
					p.SetState(5511)
					p.Match(SQLServerStatementParserNCHAR_TEXT)
				}

			case SQLServerStatementParserEOF, SQLServerStatementParserSEMI_:

			default:
			}

		}

	}

	return localctx
}

// IBeginDistributedTransactionContext is an interface to support dynamic dispatch.
type IBeginDistributedTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBeginDistributedTransactionContext differentiates from other interfaces.
	IsBeginDistributedTransactionContext()
}

type BeginDistributedTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginDistributedTransactionContext() *BeginDistributedTransactionContext {
	var p = new(BeginDistributedTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_beginDistributedTransaction
	return p
}

func (*BeginDistributedTransactionContext) IsBeginDistributedTransactionContext() {}

func NewBeginDistributedTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginDistributedTransactionContext {
	var p = new(BeginDistributedTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_beginDistributedTransaction

	return p
}

func (s *BeginDistributedTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginDistributedTransactionContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserBEGIN, 0)
}

func (s *BeginDistributedTransactionContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDISTRIBUTED, 0)
}

func (s *BeginDistributedTransactionContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *BeginDistributedTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *BeginDistributedTransactionContext) TransactionName() ITransactionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionNameContext)
}

func (s *BeginDistributedTransactionContext) TransactionVariableName() ITransactionVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionVariableNameContext)
}

func (s *BeginDistributedTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginDistributedTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginDistributedTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterBeginDistributedTransaction(s)
	}
}

func (s *BeginDistributedTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitBeginDistributedTransaction(s)
	}
}

func (s *BeginDistributedTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitBeginDistributedTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) BeginDistributedTransaction() (localctx IBeginDistributedTransactionContext) {
	this := p
	_ = this

	localctx = NewBeginDistributedTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, SQLServerStatementParserRULE_beginDistributedTransaction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5518)
		p.Match(SQLServerStatementParserBEGIN)
	}
	{
		p.SetState(5519)
		p.Match(SQLServerStatementParserDISTRIBUTED)
	}
	{
		p.SetState(5520)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(5521)
			p.TransactionName()
		}

	case SQLServerStatementParserAT_:
		{
			p.SetState(5522)
			p.TransactionVariableName()
		}

	case SQLServerStatementParserEOF, SQLServerStatementParserSEMI_:

	default:
	}

	return localctx
}

// ICommitContext is an interface to support dynamic dispatch.
type ICommitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitContext differentiates from other interfaces.
	IsCommitContext()
}

type CommitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitContext() *CommitContext {
	var p = new(CommitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_commit
	return p
}

func (*CommitContext) IsCommitContext() {}

func NewCommitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitContext {
	var p = new(CommitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_commit

	return p
}

func (s *CommitContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMIT, 0)
}

func (s *CommitContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH, 0)
}

func (s *CommitContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserLP_, 0)
}

func (s *CommitContext) DELAYED_DURABILITY() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserDELAYED_DURABILITY, 0)
}

func (s *CommitContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEQ_, 0)
}

func (s *CommitContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserRP_, 0)
}

func (s *CommitContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *CommitContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *CommitContext) OFF() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserOFF, 0)
}

func (s *CommitContext) ON() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserON, 0)
}

func (s *CommitContext) TransactionName() ITransactionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionNameContext)
}

func (s *CommitContext) TransactionVariableName() ITransactionVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionVariableNameContext)
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCommit(s)
	}
}

func (s *CommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Commit() (localctx ICommitContext) {
	this := p
	_ = this

	localctx = NewCommitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, SQLServerStatementParserRULE_commit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5525)
		p.Match(SQLServerStatementParserCOMMIT)
	}
	p.SetState(5531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN {
		{
			p.SetState(5526)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5529)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
			{
				p.SetState(5527)
				p.TransactionName()
			}

		case SQLServerStatementParserAT_:
			{
				p.SetState(5528)
				p.TransactionVariableName()
			}

		case SQLServerStatementParserEOF, SQLServerStatementParserSEMI_, SQLServerStatementParserWITH:

		default:
		}

	}
	p.SetState(5539)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH {
		{
			p.SetState(5533)
			p.Match(SQLServerStatementParserWITH)
		}
		{
			p.SetState(5534)
			p.Match(SQLServerStatementParserLP_)
		}
		{
			p.SetState(5535)
			p.Match(SQLServerStatementParserDELAYED_DURABILITY)
		}
		{
			p.SetState(5536)
			p.Match(SQLServerStatementParserEQ_)
		}
		{
			p.SetState(5537)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQLServerStatementParserON || _la == SQLServerStatementParserOFF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5538)
			p.Match(SQLServerStatementParserRP_)
		}

	}

	return localctx
}

// ICommitWorkContext is an interface to support dynamic dispatch.
type ICommitWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitWorkContext differentiates from other interfaces.
	IsCommitWorkContext()
}

type CommitWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitWorkContext() *CommitWorkContext {
	var p = new(CommitWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_commitWork
	return p
}

func (*CommitWorkContext) IsCommitWorkContext() {}

func NewCommitWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitWorkContext {
	var p = new(CommitWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_commitWork

	return p
}

func (s *CommitWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitWorkContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCOMMIT, 0)
}

func (s *CommitWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWORK, 0)
}

func (s *CommitWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCommitWork(s)
	}
}

func (s *CommitWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCommitWork(s)
	}
}

func (s *CommitWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCommitWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) CommitWork() (localctx ICommitWorkContext) {
	this := p
	_ = this

	localctx = NewCommitWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, SQLServerStatementParserRULE_commitWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5541)
		p.Match(SQLServerStatementParserCOMMIT)
	}
	p.SetState(5543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWORK {
		{
			p.SetState(5542)
			p.Match(SQLServerStatementParserWORK)
		}

	}

	return localctx
}

// IRollbackContext is an interface to support dynamic dispatch.
type IRollbackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollbackContext differentiates from other interfaces.
	IsRollbackContext()
}

type RollbackContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackContext() *RollbackContext {
	var p = new(RollbackContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_rollback
	return p
}

func (*RollbackContext) IsRollbackContext() {}

func NewRollbackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackContext {
	var p = new(RollbackContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_rollback

	return p
}

func (s *RollbackContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLLBACK, 0)
}

func (s *RollbackContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *RollbackContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *RollbackContext) TransactionName() ITransactionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionNameContext)
}

func (s *RollbackContext) TransactionVariableName() ITransactionVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionVariableNameContext)
}

func (s *RollbackContext) SavepointName() ISavepointNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepointNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepointNameContext)
}

func (s *RollbackContext) SavepointVariableName() ISavepointVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepointVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepointVariableNameContext)
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRollback(s)
	}
}

func (s *RollbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRollback(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Rollback() (localctx IRollbackContext) {
	this := p
	_ = this

	localctx = NewRollbackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, SQLServerStatementParserRULE_rollback)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5545)
		p.Match(SQLServerStatementParserROLLBACK)
	}
	{
		p.SetState(5546)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 626, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5547)
			p.TransactionName()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 626, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5548)
			p.TransactionVariableName()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 626, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(5549)
			p.SavepointName()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 626, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(5550)
			p.SavepointVariableName()
		}

	}

	return localctx
}

// IRollbackWorkContext is an interface to support dynamic dispatch.
type IRollbackWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollbackWorkContext differentiates from other interfaces.
	IsRollbackWorkContext()
}

type RollbackWorkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackWorkContext() *RollbackWorkContext {
	var p = new(RollbackWorkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_rollbackWork
	return p
}

func (*RollbackWorkContext) IsRollbackWorkContext() {}

func NewRollbackWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackWorkContext {
	var p = new(RollbackWorkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_rollbackWork

	return p
}

func (s *RollbackWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackWorkContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserROLLBACK, 0)
}

func (s *RollbackWorkContext) WORK() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWORK, 0)
}

func (s *RollbackWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterRollbackWork(s)
	}
}

func (s *RollbackWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitRollbackWork(s)
	}
}

func (s *RollbackWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitRollbackWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) RollbackWork() (localctx IRollbackWorkContext) {
	this := p
	_ = this

	localctx = NewRollbackWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, SQLServerStatementParserRULE_rollbackWork)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5553)
		p.Match(SQLServerStatementParserROLLBACK)
	}
	p.SetState(5555)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWORK {
		{
			p.SetState(5554)
			p.Match(SQLServerStatementParserWORK)
		}

	}

	return localctx
}

// ISavepointContext is an interface to support dynamic dispatch.
type ISavepointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSavepointContext differentiates from other interfaces.
	IsSavepointContext()
}

type SavepointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointContext() *SavepointContext {
	var p = new(SavepointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_savepoint
	return p
}

func (*SavepointContext) IsSavepointContext() {}

func NewSavepointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointContext {
	var p = new(SavepointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_savepoint

	return p
}

func (s *SavepointContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointContext) SAVE() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserSAVE, 0)
}

func (s *SavepointContext) TRAN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRAN, 0)
}

func (s *SavepointContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserTRANSACTION, 0)
}

func (s *SavepointContext) SavepointName() ISavepointNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepointNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepointNameContext)
}

func (s *SavepointContext) SavepointVariableName() ISavepointVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISavepointVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISavepointVariableNameContext)
}

func (s *SavepointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterSavepoint(s)
	}
}

func (s *SavepointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitSavepoint(s)
	}
}

func (s *SavepointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitSavepoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Savepoint() (localctx ISavepointContext) {
	this := p
	_ = this

	localctx = NewSavepointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, SQLServerStatementParserRULE_savepoint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5557)
		p.Match(SQLServerStatementParserSAVE)
	}
	{
		p.SetState(5558)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQLServerStatementParserTRANSACTION || _la == SQLServerStatementParserTRAN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5561)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQLServerStatementParserTRUNCATE, SQLServerStatementParserFUNCTION, SQLServerStatementParserTRIGGER, SQLServerStatementParserCAST, SQLServerStatementParserGROUP, SQLServerStatementParserLIMIT, SQLServerStatementParserOFFSET, SQLServerStatementParserSAVEPOINT, SQLServerStatementParserBOOLEAN, SQLServerStatementParserARRAY, SQLServerStatementParserDATE, SQLServerStatementParserLOCALTIME, SQLServerStatementParserLOCALTIMESTAMP, SQLServerStatementParserQUARTER, SQLServerStatementParserWEEK, SQLServerStatementParserDAY, SQLServerStatementParserMICROSECOND, SQLServerStatementParserMAX, SQLServerStatementParserMIN, SQLServerStatementParserSUM, SQLServerStatementParserCOUNT, SQLServerStatementParserAVG, SQLServerStatementParserENABLE, SQLServerStatementParserDISABLE, SQLServerStatementParserINSTANCE, SQLServerStatementParserDO, SQLServerStatementParserDEFINER, SQLServerStatementParserSQL, SQLServerStatementParserCASCADED, SQLServerStatementParserLOCAL, SQLServerStatementParserNEXT, SQLServerStatementParserNAME, SQLServerStatementParserINTEGER, SQLServerStatementParserTYPE, SQLServerStatementParserREAD_ONLY, SQLServerStatementParserDATABASE, SQLServerStatementParserDATEPART, SQLServerStatementParserBINARY, SQLServerStatementParserHIDDEN_, SQLServerStatementParserMOD, SQLServerStatementParserPARTITION, SQLServerStatementParserPARTITIONS, SQLServerStatementParserTOP, SQLServerStatementParserROW, SQLServerStatementParserROWS, SQLServerStatementParserXOR, SQLServerStatementParserALWAYS, SQLServerStatementParserROLE, SQLServerStatementParserSTART, SQLServerStatementParserALGORITHM, SQLServerStatementParserAUTO, SQLServerStatementParserBLOCKERS, SQLServerStatementParserCLUSTERED, SQLServerStatementParserNONCLUSTERED, SQLServerStatementParserCOLUMNSTORE, SQLServerStatementParserCONTENT, SQLServerStatementParserYEARS, SQLServerStatementParserMONTHS, SQLServerStatementParserWEEKS, SQLServerStatementParserDAYS, SQLServerStatementParserMINUTES, SQLServerStatementParserDENY, SQLServerStatementParserDETERMINISTIC, SQLServerStatementParserDISTRIBUTION, SQLServerStatementParserDOCUMENT, SQLServerStatementParserDURABILITY, SQLServerStatementParserENCRYPTED, SQLServerStatementParserFILESTREAM, SQLServerStatementParserFILETABLE, SQLServerStatementParserFILLFACTOR, SQLServerStatementParserFOLLOWING, SQLServerStatementParserHASH, SQLServerStatementParserHEAP, SQLServerStatementParserINBOUND, SQLServerStatementParserOUTBOUND, SQLServerStatementParserUNBOUNDED, SQLServerStatementParserINFINITE, SQLServerStatementParserLOGIN, SQLServerStatementParserMASKED, SQLServerStatementParserMAXDOP, SQLServerStatementParserMOVE, SQLServerStatementParserNOCHECK, SQLServerStatementParserOBJECT, SQLServerStatementParserOFF, SQLServerStatementParserONLINE, SQLServerStatementParserOVER, SQLServerStatementParserPAGE, SQLServerStatementParserPAUSED, SQLServerStatementParserPERIOD, SQLServerStatementParserPERSISTED, SQLServerStatementParserPRECEDING, SQLServerStatementParserRANDOMIZED, SQLServerStatementParserRANGE, SQLServerStatementParserREBUILD, SQLServerStatementParserREPLICATE, SQLServerStatementParserREPLICATION, SQLServerStatementParserRESUMABLE, SQLServerStatementParserROWGUIDCOL, SQLServerStatementParserSAVE, SQLServerStatementParserSELF, SQLServerStatementParserSPARSE, SQLServerStatementParserSWITCH, SQLServerStatementParserTRAN, SQLServerStatementParserTRANCOUNT, SQLServerStatementParserCONTROL, SQLServerStatementParserCONCAT, SQLServerStatementParserTAKE, SQLServerStatementParserOWNERSHIP, SQLServerStatementParserDEFINITION, SQLServerStatementParserAPPLICATION, SQLServerStatementParserASSEMBLY, SQLServerStatementParserSYMMETRIC, SQLServerStatementParserASYMMETRIC, SQLServerStatementParserSERVER, SQLServerStatementParserRECEIVE, SQLServerStatementParserCHANGE, SQLServerStatementParserTRACE, SQLServerStatementParserTRACKING, SQLServerStatementParserRESOURCES, SQLServerStatementParserSETTINGS, SQLServerStatementParserSTATE, SQLServerStatementParserAVAILABILITY, SQLServerStatementParserCREDENTIAL, SQLServerStatementParserENDPOINT, SQLServerStatementParserEVENT, SQLServerStatementParserNOTIFICATION, SQLServerStatementParserLINKED, SQLServerStatementParserAUDIT, SQLServerStatementParserDDL, SQLServerStatementParserXML, SQLServerStatementParserIMPERSONATE, SQLServerStatementParserSECURABLES, SQLServerStatementParserAUTHENTICATE, SQLServerStatementParserEXTERNAL, SQLServerStatementParserACCESS, SQLServerStatementParserADMINISTER, SQLServerStatementParserBULK, SQLServerStatementParserOPERATIONS, SQLServerStatementParserUNSAFE, SQLServerStatementParserSHUTDOWN, SQLServerStatementParserSCOPED, SQLServerStatementParserCONFIGURATION, SQLServerStatementParserDATASPACE, SQLServerStatementParserSERVICE, SQLServerStatementParserCERTIFICATE, SQLServerStatementParserCONTRACT, SQLServerStatementParserENCRYPTION, SQLServerStatementParserMASTER, SQLServerStatementParserDATA, SQLServerStatementParserSOURCE, SQLServerStatementParserFILE, SQLServerStatementParserFORMAT, SQLServerStatementParserLIBRARY, SQLServerStatementParserFULLTEXT, SQLServerStatementParserMASK, SQLServerStatementParserUNMASK, SQLServerStatementParserMESSAGE, SQLServerStatementParserREMOTE, SQLServerStatementParserBINDING, SQLServerStatementParserROUTE, SQLServerStatementParserSECURITY, SQLServerStatementParserPOLICY, SQLServerStatementParserAGGREGATE, SQLServerStatementParserQUEUE, SQLServerStatementParserRULE, SQLServerStatementParserSYNONYM, SQLServerStatementParserCOLLECTION, SQLServerStatementParserSCRIPT, SQLServerStatementParserKILL, SQLServerStatementParserBACKUP, SQLServerStatementParserLOG, SQLServerStatementParserSHOWPLAN, SQLServerStatementParserSUBSCRIBE, SQLServerStatementParserQUERY, SQLServerStatementParserNOTIFICATIONS, SQLServerStatementParserCHECKPOINT, SQLServerStatementParserSEQUENCE, SQLServerStatementParserABORT_AFTER_WAIT, SQLServerStatementParserALLOW_PAGE_LOCKS, SQLServerStatementParserALLOW_ROW_LOCKS, SQLServerStatementParserALL_SPARSE_COLUMNS, SQLServerStatementParserBUCKET_COUNT, SQLServerStatementParserCOLUMNSTORE_ARCHIVE, SQLServerStatementParserCOLUMN_ENCRYPTION_KEY, SQLServerStatementParserCOLUMN_SET, SQLServerStatementParserCOMPRESSION_DELAY, SQLServerStatementParserDATABASE_DEAULT, SQLServerStatementParserDATA_COMPRESSION, SQLServerStatementParserDATA_CONSISTENCY_CHECK, SQLServerStatementParserENCRYPTION_TYPE, SQLServerStatementParserSYSTEM_TIME, SQLServerStatementParserSYSTEM_VERSIONING, SQLServerStatementParserTEXTIMAGE_ON, SQLServerStatementParserWAIT_AT_LOW_PRIORITY, SQLServerStatementParserSTATISTICS_INCREMENTAL, SQLServerStatementParserSTATISTICS_NORECOMPUTE, SQLServerStatementParserROUND_ROBIN, SQLServerStatementParserSCHEMA_AND_DATA, SQLServerStatementParserSCHEMA_ONLY, SQLServerStatementParserSORT_IN_TEMPDB, SQLServerStatementParserIGNORE_DUP_KEY, SQLServerStatementParserIMPLICIT_TRANSACTIONS, SQLServerStatementParserMAX_DURATION, SQLServerStatementParserMEMORY_OPTIMIZED, SQLServerStatementParserMIGRATION_STATE, SQLServerStatementParserPAD_INDEX, SQLServerStatementParserREMOTE_DATA_ARCHIVE, SQLServerStatementParserFILESTREAM_ON, SQLServerStatementParserFILETABLE_COLLATE_FILENAME, SQLServerStatementParserFILETABLE_DIRECTORY, SQLServerStatementParserFILETABLE_FULLPATH_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_PRIMARY_KEY_CONSTRAINT_NAME, SQLServerStatementParserFILETABLE_STREAMID_UNIQUE_CONSTRAINT_NAME, SQLServerStatementParserFILTER_PREDICATE, SQLServerStatementParserHISTORY_RETENTION_PERIOD, SQLServerStatementParserHISTORY_TABLE, SQLServerStatementParserLOCK_ESCALATION, SQLServerStatementParserDROP_EXISTING, SQLServerStatementParserROW_NUMBER, SQLServerStatementParserFIRST, SQLServerStatementParserDATETIME2, SQLServerStatementParserOUTPUT, SQLServerStatementParserINSERTED, SQLServerStatementParserDELETED, SQLServerStatementParserFILENAME, SQLServerStatementParserMAXSIZE, SQLServerStatementParserFILEGROWTH, SQLServerStatementParserUNLIMITED, SQLServerStatementParserKB, SQLServerStatementParserMB, SQLServerStatementParserGB, SQLServerStatementParserTB, SQLServerStatementParserMEMORY_OPTIMIZED_DATA, SQLServerStatementParserFILEGROUP, SQLServerStatementParserNON_TRANSACTED_ACCESS, SQLServerStatementParserDB_CHAINING, SQLServerStatementParserTRUSTWORTHY, SQLServerStatementParserFORWARD_ONLY, SQLServerStatementParserKEYSET, SQLServerStatementParserFAST_FORWARD, SQLServerStatementParserSCROLL_LOCKS, SQLServerStatementParserOPTIMISTIC, SQLServerStatementParserTYPE_WARNING, SQLServerStatementParserSCHEMABINDING, SQLServerStatementParserCALLER, SQLServerStatementParserOWNER, SQLServerStatementParserSNAPSHOT, SQLServerStatementParserREPEATABLE, SQLServerStatementParserSERIALIZABLE, SQLServerStatementParserNATIVE_COMPILATION, SQLServerStatementParserVIEW_METADATA, SQLServerStatementParserINSTEAD, SQLServerStatementParserAPPEND, SQLServerStatementParserINCREMENT, SQLServerStatementParserCACHE, SQLServerStatementParserMINVALUE, SQLServerStatementParserMAXVALUE, SQLServerStatementParserRESTART, SQLServerStatementParserLOB_COMPACTION, SQLServerStatementParserCOMPRESS_ALL_ROW_GROUPS, SQLServerStatementParserREORGANIZE, SQLServerStatementParserRESUME, SQLServerStatementParserPAUSE, SQLServerStatementParserABORT, SQLServerStatementParserACCELERATED_DATABASE_RECOVERY, SQLServerStatementParserPERSISTENT_VERSION_STORE_FILEGROUP, SQLServerStatementParserIMMEDIATE, SQLServerStatementParserNO_WAIT, SQLServerStatementParserTARGET_RECOVERY_TIME, SQLServerStatementParserSECONDS, SQLServerStatementParserHONOR_BROKER_PRIORITY, SQLServerStatementParserERROR_BROKER_CONVERSATIONS, SQLServerStatementParserNEW_BROKER, SQLServerStatementParserDISABLE_BROKER, SQLServerStatementParserENABLE_BROKER, SQLServerStatementParserMEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT, SQLServerStatementParserREAD_COMMITTED_SNAPSHOT, SQLServerStatementParserALLOW_SNAPSHOT_ISOLATION, SQLServerStatementParserRECURSIVE_TRIGGERS, SQLServerStatementParserQUOTED_IDENTIFIER, SQLServerStatementParserNUMERIC_ROUNDABORT, SQLServerStatementParserCONCAT_NULL_YIELDS_NULL, SQLServerStatementParserCOMPATIBILITY_LEVEL, SQLServerStatementParserARITHABORT, SQLServerStatementParserANSI_WARNINGS, SQLServerStatementParserANSI_PADDING, SQLServerStatementParserANSI_NULLS, SQLServerStatementParserANSI_NULL_DEFAULT, SQLServerStatementParserPAGE_VERIFY, SQLServerStatementParserCHECKSUM, SQLServerStatementParserTORN_PAGE_DETECTION, SQLServerStatementParserBULK_LOGGED, SQLServerStatementParserRECOVERY, SQLServerStatementParserTOTAL_EXECUTION_CPU_TIME_MS, SQLServerStatementParserTOTAL_COMPILE_CPU_TIME_MS, SQLServerStatementParserSTALE_CAPTURE_POLICY_THRESHOLD, SQLServerStatementParserEXECUTION_COUNT, SQLServerStatementParserQUERY_CAPTURE_POLICY, SQLServerStatementParserWAIT_STATS_CAPTURE_MODE, SQLServerStatementParserMAX_PLANS_PER_QUERY, SQLServerStatementParserQUERY_CAPTURE_MODE, SQLServerStatementParserSIZE_BASED_CLEANUP_MODE, SQLServerStatementParserINTERVAL_LENGTH_MINUTES, SQLServerStatementParserMAX_STORAGE_SIZE_MB, SQLServerStatementParserDATA_FLUSH_INTERVAL_SECONDS, SQLServerStatementParserCLEANUP_POLICY, SQLServerStatementParserCUSTOM, SQLServerStatementParserSTALE_QUERY_THRESHOLD_DAYS, SQLServerStatementParserOPERATION_MODE, SQLServerStatementParserQUERY_STORE, SQLServerStatementParserCURSOR_DEFAULT, SQLServerStatementParserGLOBAL, SQLServerStatementParserCURSOR_CLOSE_ON_COMMIT, SQLServerStatementParserHOURS, SQLServerStatementParserCHANGE_RETENTION, SQLServerStatementParserAUTO_CLEANUP, SQLServerStatementParserCHANGE_TRACKING, SQLServerStatementParserAUTOMATIC_TUNING, SQLServerStatementParserFORCE_LAST_GOOD_PLAN, SQLServerStatementParserAUTO_UPDATE_STATISTICS_ASYNC, SQLServerStatementParserAUTO_UPDATE_STATISTICS, SQLServerStatementParserAUTO_SHRINK, SQLServerStatementParserAUTO_CREATE_STATISTICS, SQLServerStatementParserINCREMENTAL, SQLServerStatementParserAUTO_CLOSE, SQLServerStatementParserDATA_RETENTION, SQLServerStatementParserTEMPORAL_HISTORY_RETENTION, SQLServerStatementParserEDITION, SQLServerStatementParserMIXED_PAGE_ALLOCATION, SQLServerStatementParserDISABLED, SQLServerStatementParserALLOWED, SQLServerStatementParserHADR, SQLServerStatementParserMULTI_USER, SQLServerStatementParserRESTRICTED_USER, SQLServerStatementParserSINGLE_USER, SQLServerStatementParserOFFLINE, SQLServerStatementParserEMERGENCY, SQLServerStatementParserSUSPEND, SQLServerStatementParserDATE_CORRELATION_OPTIMIZATION, SQLServerStatementParserELASTIC_POOL, SQLServerStatementParserSERVICE_OBJECTIVE, SQLServerStatementParserDATABASE_NAME, SQLServerStatementParserALLOW_CONNECTIONS, SQLServerStatementParserGEO, SQLServerStatementParserNAMED, SQLServerStatementParserDATEFIRST, SQLServerStatementParserBACKUP_STORAGE_REDUNDANCY, SQLServerStatementParserFORCE_FAILOVER_ALLOW_DATA_LOSS, SQLServerStatementParserSECONDARY, SQLServerStatementParserFAILOVER, SQLServerStatementParserDEFAULT_FULLTEXT_LANGUAGE, SQLServerStatementParserDEFAULT_LANGUAGE, SQLServerStatementParserINLINE, SQLServerStatementParserNESTED_TRIGGERS, SQLServerStatementParserTRANSFORM_NOISE_WORDS, SQLServerStatementParserTWO_DIGIT_YEAR_CUTOFF, SQLServerStatementParserPERSISTENT_LOG_BUFFER, SQLServerStatementParserDIRECTORY_NAME, SQLServerStatementParserDATEFORMAT, SQLServerStatementParserDELAYED_DURABILITY, SQLServerStatementParserTRANSFER, SQLServerStatementParserIDENTIFIER_:
		{
			p.SetState(5559)
			p.SavepointName()
		}

	case SQLServerStatementParserAT_:
		{
			p.SetState(5560)
			p.SavepointVariableName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallContext is an interface to support dynamic dispatch.
type ICallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallContext differentiates from other interfaces.
	IsCallContext()
}

type CallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallContext() *CallContext {
	var p = new(CallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_call
	return p
}

func (*CallContext) IsCallContext() {}

func NewCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallContext {
	var p = new(CallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_call

	return p
}

func (s *CallContext) GetParser() antlr.Parser { return s.parser }

func (s *CallContext) CALL() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserCALL, 0)
}

func (s *CallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterCall(s)
	}
}

func (s *CallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitCall(s)
	}
}

func (s *CallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Call() (localctx ICallContext) {
	this := p
	_ = this

	localctx = NewCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, SQLServerStatementParserRULE_call)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5563)
		p.Match(SQLServerStatementParserCALL)
	}

	return localctx
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_explain
	return p
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserEXPLAIN, 0)
}

func (s *ExplainContext) ExplainableStatement() IExplainableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplainableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplainableStatementContext)
}

func (s *ExplainContext) WITH_RECOMMENDATIONS() antlr.TerminalNode {
	return s.GetToken(SQLServerStatementParserWITH_RECOMMENDATIONS, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExplain(s)
	}
}

func (s *ExplainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExplain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) Explain() (localctx IExplainContext) {
	this := p
	_ = this

	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, SQLServerStatementParserRULE_explain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5565)
		p.Match(SQLServerStatementParserEXPLAIN)
	}
	p.SetState(5567)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQLServerStatementParserWITH_RECOMMENDATIONS {
		{
			p.SetState(5566)
			p.Match(SQLServerStatementParserWITH_RECOMMENDATIONS)
		}

	}
	{
		p.SetState(5569)
		p.ExplainableStatement()
	}

	return localctx
}

// IExplainableStatementContext is an interface to support dynamic dispatch.
type IExplainableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplainableStatementContext differentiates from other interfaces.
	IsExplainableStatementContext()
}

type ExplainableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainableStatementContext() *ExplainableStatementContext {
	var p = new(ExplainableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQLServerStatementParserRULE_explainableStatement
	return p
}

func (*ExplainableStatementContext) IsExplainableStatementContext() {}

func NewExplainableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainableStatementContext {
	var p = new(ExplainableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQLServerStatementParserRULE_explainableStatement

	return p
}

func (s *ExplainableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainableStatementContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *ExplainableStatementContext) Insert() IInsertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *ExplainableStatementContext) Update() IUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *ExplainableStatementContext) Delete() IDeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteContext)
}

func (s *ExplainableStatementContext) CreateTableAsSelectClause() ICreateTableAsSelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableAsSelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectClauseContext)
}

func (s *ExplainableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.EnterExplainableStatement(s)
	}
}

func (s *ExplainableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQLServerStatementListener); ok {
		listenerT.ExitExplainableStatement(s)
	}
}

func (s *ExplainableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQLServerStatementVisitor:
		return t.VisitExplainableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQLServerStatementParser) ExplainableStatement() (localctx IExplainableStatementContext) {
	this := p
	_ = this

	localctx = NewExplainableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, SQLServerStatementParserRULE_explainableStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5576)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 630, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5571)
			p.Select()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5572)
			p.Insert()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5573)
			p.Update()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5574)
			p.Delete()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5575)
			p.CreateTableAsSelectClause()
		}

	}

	return localctx
}

func (p *SQLServerStatementParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 77:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 81:
		var t *BooleanPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*BooleanPrimaryContext)
		}
		return p.BooleanPrimary_Sempred(t, predIndex)

	case 84:
		var t *BitExprContext = nil
		if localctx != nil {
			t = localctx.(*BitExprContext)
		}
		return p.BitExpr_Sempred(t, predIndex)

	case 85:
		var t *SimpleExprContext = nil
		if localctx != nil {
			t = localctx.(*SimpleExprContext)
		}
		return p.SimpleExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SQLServerStatementParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLServerStatementParser) BooleanPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLServerStatementParser) BitExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQLServerStatementParser) SimpleExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
