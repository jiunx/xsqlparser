// Code generated from E:/GoProject/src/github.com/jiunx/xsqlparser/dialect/sql92/grammer\SQL92Statement.g4 by ANTLR 4.9.3. DO NOT EDIT.

package parser // SQL92Statement

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 346, 1498,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 295, 10, 2, 3, 2,
	5, 2, 298, 10, 2, 3, 3, 3, 3, 5, 3, 302, 10, 3, 3, 3, 3, 3, 3, 3, 5, 3,
	307, 10, 3, 3, 4, 5, 4, 310, 10, 4, 3, 4, 3, 4, 3, 4, 3, 4, 7, 4, 316,
	10, 4, 12, 4, 14, 4, 319, 11, 4, 3, 5, 5, 5, 322, 10, 5, 3, 5, 3, 5, 3,
	6, 3, 6, 3, 6, 3, 6, 5, 6, 330, 10, 6, 3, 7, 3, 7, 3, 7, 5, 7, 335, 10,
	7, 3, 7, 5, 7, 338, 10, 7, 3, 7, 3, 7, 5, 7, 342, 10, 7, 3, 8, 3, 8, 3,
	8, 3, 8, 7, 8, 348, 10, 8, 12, 8, 14, 8, 351, 11, 8, 3, 9, 3, 9, 3, 9,
	3, 9, 7, 9, 357, 10, 9, 12, 9, 14, 9, 360, 11, 9, 3, 9, 3, 9, 3, 9, 3,
	9, 5, 9, 366, 10, 9, 3, 10, 3, 10, 3, 10, 5, 10, 371, 10, 10, 3, 11, 3,
	11, 3, 12, 3, 12, 3, 12, 5, 12, 378, 10, 12, 3, 13, 3, 13, 3, 13, 5, 13,
	383, 10, 13, 3, 13, 5, 13, 386, 10, 13, 3, 14, 3, 14, 3, 15, 3, 15, 3,
	15, 5, 15, 393, 10, 15, 3, 15, 7, 15, 396, 10, 15, 12, 15, 14, 15, 399,
	11, 15, 3, 16, 3, 16, 7, 16, 403, 10, 16, 12, 16, 14, 16, 406, 11, 16,
	3, 16, 3, 16, 5, 16, 410, 10, 16, 3, 16, 5, 16, 413, 10, 16, 3, 16, 5,
	16, 416, 10, 16, 3, 16, 5, 16, 419, 10, 16, 3, 16, 5, 16, 422, 10, 16,
	3, 16, 5, 16, 425, 10, 16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 19, 3, 19, 5,
	19, 433, 10, 19, 3, 19, 3, 19, 7, 19, 437, 10, 19, 12, 19, 14, 19, 440,
	11, 19, 3, 20, 3, 20, 5, 20, 444, 10, 20, 3, 20, 5, 20, 447, 10, 20, 3,
	20, 5, 20, 450, 10, 20, 3, 20, 5, 20, 453, 10, 20, 3, 21, 3, 21, 5, 21,
	457, 10, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3,
	25, 3, 25, 3, 25, 7, 25, 470, 10, 25, 12, 25, 14, 25, 473, 11, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 480, 10, 26, 3, 27, 3, 27, 7, 27, 484,
	10, 27, 12, 27, 14, 27, 487, 11, 27, 3, 28, 3, 28, 5, 28, 491, 10, 28,
	3, 28, 5, 28, 494, 10, 28, 3, 28, 3, 28, 5, 28, 498, 10, 28, 3, 28, 3,
	28, 5, 28, 502, 10, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 508, 10, 28,
	3, 29, 5, 29, 511, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 517, 10,
	29, 3, 29, 3, 29, 5, 29, 521, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	3, 29, 3, 29, 3, 29, 5, 29, 531, 10, 29, 3, 29, 3, 29, 5, 29, 535, 10,
	29, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 541, 10, 30, 3, 31, 3, 31, 3, 31,
	3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 7, 32, 551, 10, 32, 12, 32, 14, 32,
	554, 11, 32, 3, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 563,
	10, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 570, 10, 34, 3, 35, 3,
	35, 5, 35, 574, 10, 35, 3, 36, 3, 36, 5, 36, 578, 10, 36, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 5, 39, 593, 10, 39, 3, 40, 5, 40, 596, 10, 40, 3, 40, 3, 40, 5, 40,
	600, 10, 40, 3, 41, 5, 41, 603, 10, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 614, 10, 42, 3, 43, 5, 43, 617,
	10, 43, 3, 43, 3, 43, 5, 43, 621, 10, 43, 3, 44, 5, 44, 624, 10, 44, 3,
	44, 3, 44, 5, 44, 628, 10, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 47, 3, 47,
	5, 47, 636, 10, 47, 3, 48, 3, 48, 3, 49, 5, 49, 641, 10, 49, 3, 49, 5,
	49, 644, 10, 49, 3, 49, 5, 49, 647, 10, 49, 3, 49, 5, 49, 650, 10, 49,
	3, 49, 3, 49, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 5, 51, 659, 10, 51, 3,
	51, 3, 51, 3, 52, 3, 52, 3, 52, 5, 52, 666, 10, 52, 3, 52, 3, 52, 3, 53,
	3, 53, 3, 53, 3, 53, 5, 53, 674, 10, 53, 3, 53, 5, 53, 677, 10, 53, 3,
	54, 3, 54, 3, 55, 3, 55, 3, 56, 3, 56, 3, 57, 5, 57, 686, 10, 57, 3, 57,
	3, 57, 3, 57, 7, 57, 691, 10, 57, 12, 57, 14, 57, 694, 11, 57, 3, 57, 5,
	57, 697, 10, 57, 3, 58, 5, 58, 700, 10, 58, 3, 58, 3, 58, 3, 58, 7, 58,
	705, 10, 58, 12, 58, 14, 58, 708, 11, 58, 3, 58, 5, 58, 711, 10, 58, 3,
	59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60,
	5, 60, 724, 10, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 7, 60, 734, 10, 60, 12, 60, 14, 60, 737, 11, 60, 3, 61, 3, 61, 3, 62,
	3, 62, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 751,
	10, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 64, 3, 64, 3, 64, 3, 64, 7, 64, 766, 10, 64, 12, 64, 14, 64, 769, 11,
	64, 3, 65, 3, 65, 3, 66, 3, 66, 5, 66, 775, 10, 66, 3, 66, 3, 66, 3, 66,
	3, 66, 3, 66, 5, 66, 782, 10, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 7,
	66, 789, 10, 66, 12, 66, 14, 66, 792, 11, 66, 3, 66, 3, 66, 3, 66, 3, 66,
	5, 66, 798, 10, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5,
	66, 807, 10, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 813, 10, 66, 3, 66,
	5, 66, 816, 10, 66, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 67,
	7, 67, 857, 10, 67, 12, 67, 14, 67, 860, 11, 67, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 7, 68, 874,
	10, 68, 12, 68, 14, 68, 877, 11, 68, 3, 68, 3, 68, 3, 68, 5, 68, 882, 10,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68,
	893, 10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 899, 10, 68, 7, 68, 901,
	10, 68, 12, 68, 14, 68, 904, 11, 68, 3, 69, 3, 69, 3, 69, 5, 69, 909, 10,
	69, 3, 70, 3, 70, 3, 70, 5, 70, 914, 10, 70, 3, 70, 3, 70, 3, 70, 7, 70,
	919, 10, 70, 12, 70, 14, 70, 922, 11, 70, 3, 70, 5, 70, 925, 10, 70, 3,
	70, 3, 70, 3, 71, 3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 5, 73, 939, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 945, 10,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 3,
	77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 972, 10, 77, 3, 77, 3, 77, 3, 78,
	3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3,
	79, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 7, 80, 996,
	10, 80, 12, 80, 14, 80, 999, 11, 80, 3, 80, 5, 80, 1002, 10, 80, 3, 80,
	3, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 1012, 10, 81, 3,
	82, 3, 82, 3, 82, 5, 82, 1017, 10, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83,
	5, 83, 1024, 10, 83, 3, 83, 6, 83, 1027, 10, 83, 13, 83, 14, 83, 1028,
	3, 83, 5, 83, 1032, 10, 83, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3,
	84, 3, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 88,
	3, 88, 3, 88, 3, 88, 3, 88, 7, 88, 1055, 10, 88, 12, 88, 14, 88, 1058,
	11, 88, 3, 89, 3, 89, 5, 89, 1062, 10, 89, 3, 89, 5, 89, 1065, 10, 89,
	3, 90, 3, 90, 5, 90, 1069, 10, 90, 3, 90, 5, 90, 1072, 10, 90, 3, 90, 5,
	90, 1075, 10, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 7, 90, 1082, 10, 90,
	12, 90, 14, 90, 1085, 11, 90, 3, 90, 3, 90, 5, 90, 1089, 10, 90, 3, 90,
	5, 90, 1092, 10, 90, 5, 90, 1094, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91,
	3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91,
	3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 5, 91, 1137, 10, 91, 3, 92, 3, 92, 3,
	92, 3, 92, 5, 92, 1143, 10, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 5, 93,
	1150, 10, 93, 3, 93, 3, 93, 3, 94, 3, 94, 5, 94, 1156, 10, 94, 3, 94, 3,
	94, 5, 94, 1160, 10, 94, 3, 95, 3, 95, 3, 95, 5, 95, 1165, 10, 95, 3, 96,
	5, 96, 1168, 10, 96, 3, 97, 3, 97, 5, 97, 1172, 10, 97, 3, 97, 3, 97, 3,
	97, 3, 97, 5, 97, 1178, 10, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99,
	3, 99, 3, 99, 3, 99, 3, 99, 3, 100, 3, 100, 3, 100, 3, 100, 7, 100, 1194,
	10, 100, 12, 100, 14, 100, 1197, 11, 100, 3, 101, 3, 101, 3, 101, 3, 101,
	3, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 7, 102,
	1211, 10, 102, 12, 102, 14, 102, 1214, 11, 102, 3, 102, 3, 102, 5, 102,
	1218, 10, 102, 3, 102, 3, 102, 3, 102, 3, 102, 5, 102, 1224, 10, 102, 3,
	102, 3, 102, 5, 102, 1228, 10, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3,
	103, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 3, 105, 7, 105, 1242,
	10, 105, 12, 105, 14, 105, 1245, 11, 105, 3, 105, 3, 105, 3, 106, 3, 106,
	3, 106, 3, 106, 5, 106, 1253, 10, 106, 3, 106, 3, 106, 3, 107, 3, 107,
	3, 107, 5, 107, 1260, 10, 107, 3, 108, 3, 108, 3, 108, 7, 108, 1265, 10,
	108, 12, 108, 14, 108, 1268, 11, 108, 3, 109, 3, 109, 3, 109, 5, 109, 1273,
	10, 109, 3, 109, 5, 109, 1276, 10, 109, 3, 109, 3, 109, 3, 109, 3, 109,
	3, 109, 3, 109, 3, 109, 5, 109, 1285, 10, 109, 3, 109, 5, 109, 1288, 10,
	109, 3, 110, 3, 110, 5, 110, 1292, 10, 110, 5, 110, 1294, 10, 110, 3, 110,
	3, 110, 3, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111,
	3, 111, 3, 111, 5, 111, 1308, 10, 111, 3, 111, 3, 111, 3, 111, 7, 111,
	1313, 10, 111, 12, 111, 14, 111, 1316, 11, 111, 3, 112, 3, 112, 3, 112,
	3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 5, 112, 1326, 10, 112, 3, 113,
	3, 113, 3, 113, 3, 113, 7, 113, 1332, 10, 113, 12, 113, 14, 113, 1335,
	11, 113, 3, 113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 5, 114, 1343,
	10, 114, 3, 114, 5, 114, 1346, 10, 114, 3, 114, 5, 114, 1349, 10, 114,
	3, 115, 3, 115, 5, 115, 1353, 10, 115, 5, 115, 1355, 10, 115, 3, 115, 3,
	115, 3, 115, 5, 115, 1360, 10, 115, 3, 116, 3, 116, 3, 116, 3, 117, 3,
	117, 3, 117, 3, 118, 3, 118, 3, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3,
	119, 3, 120, 5, 120, 1377, 10, 120, 3, 120, 3, 120, 3, 120, 5, 120, 1382,
	10, 120, 3, 121, 3, 121, 3, 121, 3, 121, 3, 121, 5, 121, 1389, 10, 121,
	3, 122, 3, 122, 5, 122, 1393, 10, 122, 3, 122, 3, 122, 3, 123, 3, 123,
	5, 123, 1399, 10, 123, 3, 123, 3, 123, 3, 124, 3, 124, 5, 124, 1405, 10,
	124, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3, 126, 3,
	127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 127, 3, 128, 3, 128, 3, 129, 3,
	129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 5, 130, 1432,
	10, 130, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 3, 131, 7, 131, 1440,
	10, 131, 12, 131, 14, 131, 1443, 11, 131, 3, 131, 3, 131, 3, 131, 5, 131,
	1448, 10, 131, 3, 132, 3, 132, 3, 132, 3, 132, 5, 132, 1454, 10, 132, 3,
	132, 3, 132, 3, 132, 3, 132, 3, 132, 7, 132, 1461, 10, 132, 12, 132, 14,
	132, 1464, 11, 132, 3, 132, 3, 132, 3, 133, 3, 133, 3, 133, 3, 133, 3,
	134, 3, 134, 3, 134, 3, 135, 3, 135, 3, 135, 3, 135, 3, 135, 3, 135, 3,
	135, 3, 135, 5, 135, 1483, 10, 135, 3, 136, 3, 136, 5, 136, 1487, 10, 136,
	3, 137, 5, 137, 1490, 10, 137, 3, 137, 3, 137, 3, 138, 3, 138, 3, 139,
	3, 139, 3, 139, 2, 6, 118, 126, 132, 134, 140, 2, 4, 6, 8, 10, 12, 14,
	16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
	52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
	88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
	120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
	150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178,
	180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208,
	210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238,
	240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268,
	270, 272, 274, 276, 2, 25, 4, 2, 72, 72, 336, 336, 4, 2, 75, 75, 109, 109,
	4, 2, 85, 85, 89, 89, 3, 2, 87, 88, 3, 2, 130, 132, 3, 2, 104, 105, 5,
	2, 165, 165, 171, 171, 175, 222, 4, 2, 161, 161, 273, 273, 4, 2, 3, 3,
	99, 99, 4, 2, 5, 5, 102, 102, 4, 2, 103, 105, 332, 332, 3, 2, 109, 110,
	3, 2, 23, 28, 4, 2, 5, 6, 14, 15, 3, 2, 144, 148, 5, 2, 232, 232, 286,
	286, 328, 328, 4, 2, 84, 84, 303, 303, 3, 2, 135, 143, 3, 2, 115, 116,
	3, 2, 126, 127, 4, 2, 233, 233, 311, 311, 3, 2, 160, 161, 3, 2, 46, 47,
	2, 1635, 2, 294, 3, 2, 2, 2, 4, 299, 3, 2, 2, 2, 6, 309, 3, 2, 2, 2, 8,
	321, 3, 2, 2, 2, 10, 325, 3, 2, 2, 2, 12, 331, 3, 2, 2, 2, 14, 343, 3,
	2, 2, 2, 16, 365, 3, 2, 2, 2, 18, 370, 3, 2, 2, 2, 20, 372, 3, 2, 2, 2,
	22, 374, 3, 2, 2, 2, 24, 379, 3, 2, 2, 2, 26, 387, 3, 2, 2, 2, 28, 389,
	3, 2, 2, 2, 30, 400, 3, 2, 2, 2, 32, 426, 3, 2, 2, 2, 34, 428, 3, 2, 2,
	2, 36, 432, 3, 2, 2, 2, 38, 452, 3, 2, 2, 2, 40, 456, 3, 2, 2, 2, 42, 458,
	3, 2, 2, 2, 44, 460, 3, 2, 2, 2, 46, 463, 3, 2, 2, 2, 48, 466, 3, 2, 2,
	2, 50, 479, 3, 2, 2, 2, 52, 481, 3, 2, 2, 2, 54, 507, 3, 2, 2, 2, 56, 534,
	3, 2, 2, 2, 58, 540, 3, 2, 2, 2, 60, 542, 3, 2, 2, 2, 62, 545, 3, 2, 2,
	2, 64, 555, 3, 2, 2, 2, 66, 558, 3, 2, 2, 2, 68, 573, 3, 2, 2, 2, 70, 577,
	3, 2, 2, 2, 72, 579, 3, 2, 2, 2, 74, 583, 3, 2, 2, 2, 76, 592, 3, 2, 2,
	2, 78, 595, 3, 2, 2, 2, 80, 602, 3, 2, 2, 2, 82, 613, 3, 2, 2, 2, 84, 616,
	3, 2, 2, 2, 86, 623, 3, 2, 2, 2, 88, 629, 3, 2, 2, 2, 90, 631, 3, 2, 2,
	2, 92, 635, 3, 2, 2, 2, 94, 637, 3, 2, 2, 2, 96, 643, 3, 2, 2, 2, 98, 653,
	3, 2, 2, 2, 100, 658, 3, 2, 2, 2, 102, 665, 3, 2, 2, 2, 104, 676, 3, 2,
	2, 2, 106, 678, 3, 2, 2, 2, 108, 680, 3, 2, 2, 2, 110, 682, 3, 2, 2, 2,
	112, 685, 3, 2, 2, 2, 114, 699, 3, 2, 2, 2, 116, 712, 3, 2, 2, 2, 118,
	723, 3, 2, 2, 2, 120, 738, 3, 2, 2, 2, 122, 740, 3, 2, 2, 2, 124, 742,
	3, 2, 2, 2, 126, 744, 3, 2, 2, 2, 128, 770, 3, 2, 2, 2, 130, 815, 3, 2,
	2, 2, 132, 817, 3, 2, 2, 2, 134, 892, 3, 2, 2, 2, 136, 908, 3, 2, 2, 2,
	138, 910, 3, 2, 2, 2, 140, 928, 3, 2, 2, 2, 142, 930, 3, 2, 2, 2, 144,
	938, 3, 2, 2, 2, 146, 940, 3, 2, 2, 2, 148, 950, 3, 2, 2, 2, 150, 957,
	3, 2, 2, 2, 152, 964, 3, 2, 2, 2, 154, 975, 3, 2, 2, 2, 156, 982, 3, 2,
	2, 2, 158, 990, 3, 2, 2, 2, 160, 1011, 3, 2, 2, 2, 162, 1013, 3, 2, 2,
	2, 164, 1021, 3, 2, 2, 2, 166, 1035, 3, 2, 2, 2, 168, 1040, 3, 2, 2, 2,
	170, 1043, 3, 2, 2, 2, 172, 1047, 3, 2, 2, 2, 174, 1049, 3, 2, 2, 2, 176,
	1061, 3, 2, 2, 2, 178, 1093, 3, 2, 2, 2, 180, 1136, 3, 2, 2, 2, 182, 1138,
	3, 2, 2, 2, 184, 1146, 3, 2, 2, 2, 186, 1153, 3, 2, 2, 2, 188, 1161, 3,
	2, 2, 2, 190, 1167, 3, 2, 2, 2, 192, 1169, 3, 2, 2, 2, 194, 1179, 3, 2,
	2, 2, 196, 1184, 3, 2, 2, 2, 198, 1189, 3, 2, 2, 2, 200, 1198, 3, 2, 2,
	2, 202, 1203, 3, 2, 2, 2, 204, 1229, 3, 2, 2, 2, 206, 1234, 3, 2, 2, 2,
	208, 1237, 3, 2, 2, 2, 210, 1248, 3, 2, 2, 2, 212, 1259, 3, 2, 2, 2, 214,
	1261, 3, 2, 2, 2, 216, 1287, 3, 2, 2, 2, 218, 1293, 3, 2, 2, 2, 220, 1298,
	3, 2, 2, 2, 222, 1325, 3, 2, 2, 2, 224, 1327, 3, 2, 2, 2, 226, 1345, 3,
	2, 2, 2, 228, 1354, 3, 2, 2, 2, 230, 1361, 3, 2, 2, 2, 232, 1364, 3, 2,
	2, 2, 234, 1367, 3, 2, 2, 2, 236, 1370, 3, 2, 2, 2, 238, 1376, 3, 2, 2,
	2, 240, 1388, 3, 2, 2, 2, 242, 1390, 3, 2, 2, 2, 244, 1396, 3, 2, 2, 2,
	246, 1402, 3, 2, 2, 2, 248, 1408, 3, 2, 2, 2, 250, 1411, 3, 2, 2, 2, 252,
	1414, 3, 2, 2, 2, 254, 1420, 3, 2, 2, 2, 256, 1422, 3, 2, 2, 2, 258, 1431,
	3, 2, 2, 2, 260, 1433, 3, 2, 2, 2, 262, 1449, 3, 2, 2, 2, 264, 1467, 3,
	2, 2, 2, 266, 1471, 3, 2, 2, 2, 268, 1482, 3, 2, 2, 2, 270, 1486, 3, 2,
	2, 2, 272, 1489, 3, 2, 2, 2, 274, 1493, 3, 2, 2, 2, 276, 1495, 3, 2, 2,
	2, 278, 295, 5, 26, 14, 2, 279, 295, 5, 4, 3, 2, 280, 295, 5, 10, 6, 2,
	281, 295, 5, 22, 12, 2, 282, 295, 5, 198, 100, 2, 283, 295, 5, 200, 101,
	2, 284, 295, 5, 192, 97, 2, 285, 295, 5, 194, 98, 2, 286, 295, 5, 196,
	99, 2, 287, 295, 5, 202, 102, 2, 288, 295, 5, 204, 103, 2, 289, 295, 5,
	252, 127, 2, 290, 295, 5, 254, 128, 2, 291, 295, 5, 256, 129, 2, 292, 295,
	5, 260, 131, 2, 293, 295, 5, 262, 132, 2, 294, 278, 3, 2, 2, 2, 294, 279,
	3, 2, 2, 2, 294, 280, 3, 2, 2, 2, 294, 281, 3, 2, 2, 2, 294, 282, 3, 2,
	2, 2, 294, 283, 3, 2, 2, 2, 294, 284, 3, 2, 2, 2, 294, 285, 3, 2, 2, 2,
	294, 286, 3, 2, 2, 2, 294, 287, 3, 2, 2, 2, 294, 288, 3, 2, 2, 2, 294,
	289, 3, 2, 2, 2, 294, 290, 3, 2, 2, 2, 294, 291, 3, 2, 2, 2, 294, 292,
	3, 2, 2, 2, 294, 293, 3, 2, 2, 2, 295, 297, 3, 2, 2, 2, 296, 298, 7, 41,
	2, 2, 297, 296, 3, 2, 2, 2, 297, 298, 3, 2, 2, 2, 298, 3, 3, 2, 2, 2, 299,
	301, 7, 45, 2, 2, 300, 302, 7, 71, 2, 2, 301, 300, 3, 2, 2, 2, 301, 302,
	3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 306, 5, 100, 51, 2, 304, 307, 5,
	6, 4, 2, 305, 307, 5, 8, 5, 2, 306, 304, 3, 2, 2, 2, 306, 305, 3, 2, 2,
	2, 307, 5, 3, 2, 2, 2, 308, 310, 5, 112, 57, 2, 309, 308, 3, 2, 2, 2, 309,
	310, 3, 2, 2, 2, 310, 311, 3, 2, 2, 2, 311, 312, 9, 2, 2, 2, 312, 317,
	5, 16, 9, 2, 313, 314, 7, 36, 2, 2, 314, 316, 5, 16, 9, 2, 315, 313, 3,
	2, 2, 2, 316, 319, 3, 2, 2, 2, 317, 315, 3, 2, 2, 2, 317, 318, 3, 2, 2,
	2, 318, 7, 3, 2, 2, 2, 319, 317, 3, 2, 2, 2, 320, 322, 5, 112, 57, 2, 321,
	320, 3, 2, 2, 2, 321, 322, 3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323, 324,
	5, 26, 14, 2, 324, 9, 3, 2, 2, 2, 325, 326, 7, 46, 2, 2, 326, 327, 5, 48,
	25, 2, 327, 329, 5, 14, 8, 2, 328, 330, 5, 60, 31, 2, 329, 328, 3, 2, 2,
	2, 329, 330, 3, 2, 2, 2, 330, 11, 3, 2, 2, 2, 331, 332, 5, 102, 52, 2,
	332, 334, 7, 23, 2, 2, 333, 335, 7, 72, 2, 2, 334, 333, 3, 2, 2, 2, 334,
	335, 3, 2, 2, 2, 335, 337, 3, 2, 2, 2, 336, 338, 7, 30, 2, 2, 337, 336,
	3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338, 339, 3, 2, 2, 2, 339, 341, 5, 18,
	10, 2, 340, 342, 7, 31, 2, 2, 341, 340, 3, 2, 2, 2, 341, 342, 3, 2, 2,
	2, 342, 13, 3, 2, 2, 2, 343, 344, 7, 56, 2, 2, 344, 349, 5, 12, 7, 2, 345,
	346, 7, 36, 2, 2, 346, 348, 5, 12, 7, 2, 347, 345, 3, 2, 2, 2, 348, 351,
	3, 2, 2, 2, 349, 347, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 15, 3, 2,
	2, 2, 351, 349, 3, 2, 2, 2, 352, 353, 7, 30, 2, 2, 353, 358, 5, 18, 10,
	2, 354, 355, 7, 36, 2, 2, 355, 357, 5, 18, 10, 2, 356, 354, 3, 2, 2, 2,
	357, 360, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359,
	361, 3, 2, 2, 2, 360, 358, 3, 2, 2, 2, 361, 362, 7, 31, 2, 2, 362, 366,
	3, 2, 2, 2, 363, 364, 7, 30, 2, 2, 364, 366, 7, 31, 2, 2, 365, 352, 3,
	2, 2, 2, 365, 363, 3, 2, 2, 2, 366, 17, 3, 2, 2, 2, 367, 371, 5, 118, 60,
	2, 368, 371, 7, 149, 2, 2, 369, 371, 5, 20, 11, 2, 370, 367, 3, 2, 2, 2,
	370, 368, 3, 2, 2, 2, 370, 369, 3, 2, 2, 2, 371, 19, 3, 2, 2, 2, 372, 373,
	7, 343, 2, 2, 373, 21, 3, 2, 2, 2, 374, 375, 7, 47, 2, 2, 375, 377, 5,
	24, 13, 2, 376, 378, 5, 60, 31, 2, 377, 376, 3, 2, 2, 2, 377, 378, 3, 2,
	2, 2, 378, 23, 3, 2, 2, 2, 379, 380, 7, 81, 2, 2, 380, 385, 5, 100, 51,
	2, 381, 383, 7, 92, 2, 2, 382, 381, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2, 383,
	384, 3, 2, 2, 2, 384, 386, 5, 40, 21, 2, 385, 382, 3, 2, 2, 2, 385, 386,
	3, 2, 2, 2, 386, 25, 3, 2, 2, 2, 387, 388, 5, 28, 15, 2, 388, 27, 3, 2,
	2, 2, 389, 397, 5, 30, 16, 2, 390, 392, 7, 74, 2, 2, 391, 393, 7, 109,
	2, 2, 392, 391, 3, 2, 2, 2, 392, 393, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2,
	394, 396, 5, 30, 16, 2, 395, 390, 3, 2, 2, 2, 396, 399, 3, 2, 2, 2, 397,
	395, 3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 29, 3, 2, 2, 2, 399, 397, 3,
	2, 2, 2, 400, 404, 7, 44, 2, 2, 401, 403, 5, 32, 17, 2, 402, 401, 3, 2,
	2, 2, 403, 406, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2, 404, 405, 3, 2, 2, 2,
	405, 407, 3, 2, 2, 2, 406, 404, 3, 2, 2, 2, 407, 409, 5, 36, 19, 2, 408,
	410, 5, 46, 24, 2, 409, 408, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 412,
	3, 2, 2, 2, 411, 413, 5, 60, 31, 2, 412, 411, 3, 2, 2, 2, 412, 413, 3,
	2, 2, 2, 413, 415, 3, 2, 2, 2, 414, 416, 5, 62, 32, 2, 415, 414, 3, 2,
	2, 2, 415, 416, 3, 2, 2, 2, 416, 418, 3, 2, 2, 2, 417, 419, 5, 64, 33,
	2, 418, 417, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419, 421, 3, 2, 2, 2, 420,
	422, 5, 174, 88, 2, 421, 420, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 424,
	3, 2, 2, 2, 423, 425, 5, 66, 34, 2, 424, 423, 3, 2, 2, 2, 424, 425, 3,
	2, 2, 2, 425, 31, 3, 2, 2, 2, 426, 427, 5, 34, 18, 2, 427, 33, 3, 2, 2,
	2, 428, 429, 9, 3, 2, 2, 429, 35, 3, 2, 2, 2, 430, 433, 5, 42, 22, 2, 431,
	433, 5, 38, 20, 2, 432, 430, 3, 2, 2, 2, 432, 431, 3, 2, 2, 2, 433, 438,
	3, 2, 2, 2, 434, 435, 7, 36, 2, 2, 435, 437, 5, 38, 20, 2, 436, 434, 3,
	2, 2, 2, 437, 440, 3, 2, 2, 2, 438, 436, 3, 2, 2, 2, 438, 439, 3, 2, 2,
	2, 439, 37, 3, 2, 2, 2, 440, 438, 3, 2, 2, 2, 441, 444, 5, 102, 52, 2,
	442, 444, 5, 118, 60, 2, 443, 441, 3, 2, 2, 2, 443, 442, 3, 2, 2, 2, 444,
	449, 3, 2, 2, 2, 445, 447, 7, 92, 2, 2, 446, 445, 3, 2, 2, 2, 446, 447,
	3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 450, 5, 40, 21, 2, 449, 446, 3,
	2, 2, 2, 449, 450, 3, 2, 2, 2, 450, 453, 3, 2, 2, 2, 451, 453, 5, 44, 23,
	2, 452, 443, 3, 2, 2, 2, 452, 451, 3, 2, 2, 2, 453, 39, 3, 2, 2, 2, 454,
	457, 5, 92, 47, 2, 455, 457, 7, 343, 2, 2, 456, 454, 3, 2, 2, 2, 456, 455,
	3, 2, 2, 2, 457, 41, 3, 2, 2, 2, 458, 459, 7, 16, 2, 2, 459, 43, 3, 2,
	2, 2, 460, 461, 5, 92, 47, 2, 461, 462, 7, 20, 2, 2, 462, 45, 3, 2, 2,
	2, 463, 464, 7, 81, 2, 2, 464, 465, 5, 48, 25, 2, 465, 47, 3, 2, 2, 2,
	466, 471, 5, 50, 26, 2, 467, 468, 7, 36, 2, 2, 468, 470, 5, 50, 26, 2,
	469, 467, 3, 2, 2, 2, 470, 473, 3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 471,
	472, 3, 2, 2, 2, 472, 49, 3, 2, 2, 2, 473, 471, 3, 2, 2, 2, 474, 480, 5,
	52, 27, 2, 475, 476, 7, 32, 2, 2, 476, 477, 5, 52, 27, 2, 477, 478, 7,
	33, 2, 2, 478, 480, 3, 2, 2, 2, 479, 474, 3, 2, 2, 2, 479, 475, 3, 2, 2,
	2, 480, 51, 3, 2, 2, 2, 481, 485, 5, 54, 28, 2, 482, 484, 5, 56, 29, 2,
	483, 482, 3, 2, 2, 2, 484, 487, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 485,
	486, 3, 2, 2, 2, 486, 53, 3, 2, 2, 2, 487, 485, 3, 2, 2, 2, 488, 493, 5,
	100, 51, 2, 489, 491, 7, 92, 2, 2, 490, 489, 3, 2, 2, 2, 490, 491, 3, 2,
	2, 2, 491, 492, 3, 2, 2, 2, 492, 494, 5, 40, 21, 2, 493, 490, 3, 2, 2,
	2, 493, 494, 3, 2, 2, 2, 494, 508, 3, 2, 2, 2, 495, 497, 5, 72, 37, 2,
	496, 498, 7, 92, 2, 2, 497, 496, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498,
	499, 3, 2, 2, 2, 499, 501, 5, 40, 21, 2, 500, 502, 5, 112, 57, 2, 501,
	500, 3, 2, 2, 2, 501, 502, 3, 2, 2, 2, 502, 508, 3, 2, 2, 2, 503, 504,
	7, 30, 2, 2, 504, 505, 5, 48, 25, 2, 505, 506, 7, 31, 2, 2, 506, 508, 3,
	2, 2, 2, 507, 488, 3, 2, 2, 2, 507, 495, 3, 2, 2, 2, 507, 503, 3, 2, 2,
	2, 508, 55, 3, 2, 2, 2, 509, 511, 9, 4, 2, 2, 510, 509, 3, 2, 2, 2, 510,
	511, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 513, 7, 83, 2, 2, 513, 514,
	3, 2, 2, 2, 514, 516, 5, 54, 28, 2, 515, 517, 5, 58, 30, 2, 516, 515, 3,
	2, 2, 2, 516, 517, 3, 2, 2, 2, 517, 535, 3, 2, 2, 2, 518, 520, 9, 5, 2,
	2, 519, 521, 7, 86, 2, 2, 520, 519, 3, 2, 2, 2, 520, 521, 3, 2, 2, 2, 521,
	522, 3, 2, 2, 2, 522, 523, 7, 83, 2, 2, 523, 524, 5, 54, 28, 2, 524, 525,
	5, 58, 30, 2, 525, 535, 3, 2, 2, 2, 526, 530, 7, 82, 2, 2, 527, 531, 7,
	85, 2, 2, 528, 529, 9, 5, 2, 2, 529, 531, 7, 86, 2, 2, 530, 527, 3, 2,
	2, 2, 530, 528, 3, 2, 2, 2, 530, 531, 3, 2, 2, 2, 531, 532, 3, 2, 2, 2,
	532, 533, 7, 83, 2, 2, 533, 535, 5, 54, 28, 2, 534, 510, 3, 2, 2, 2, 534,
	518, 3, 2, 2, 2, 534, 526, 3, 2, 2, 2, 535, 57, 3, 2, 2, 2, 536, 537, 7,
	93, 2, 2, 537, 541, 5, 118, 60, 2, 538, 539, 7, 90, 2, 2, 539, 541, 5,
	112, 57, 2, 540, 536, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 541, 59, 3, 2,
	2, 2, 542, 543, 7, 91, 2, 2, 543, 544, 5, 118, 60, 2, 544, 61, 3, 2, 2,
	2, 545, 546, 7, 113, 2, 2, 546, 547, 7, 114, 2, 2, 547, 552, 5, 176, 89,
	2, 548, 549, 7, 36, 2, 2, 549, 551, 5, 176, 89, 2, 550, 548, 3, 2, 2, 2,
	551, 554, 3, 2, 2, 2, 552, 550, 3, 2, 2, 2, 552, 553, 3, 2, 2, 2, 553,
	63, 3, 2, 2, 2, 554, 552, 3, 2, 2, 2, 555, 556, 7, 117, 2, 2, 556, 557,
	5, 118, 60, 2, 557, 65, 3, 2, 2, 2, 558, 569, 7, 118, 2, 2, 559, 560, 5,
	70, 36, 2, 560, 561, 7, 36, 2, 2, 561, 563, 3, 2, 2, 2, 562, 559, 3, 2,
	2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 3, 2, 2, 2, 564, 570, 5, 68, 35,
	2, 565, 566, 5, 68, 35, 2, 566, 567, 7, 119, 2, 2, 567, 568, 5, 70, 36,
	2, 568, 570, 3, 2, 2, 2, 569, 562, 3, 2, 2, 2, 569, 565, 3, 2, 2, 2, 570,
	67, 3, 2, 2, 2, 571, 574, 5, 80, 41, 2, 572, 574, 5, 74, 38, 2, 573, 571,
	3, 2, 2, 2, 573, 572, 3, 2, 2, 2, 574, 69, 3, 2, 2, 2, 575, 578, 5, 80,
	41, 2, 576, 578, 5, 74, 38, 2, 577, 575, 3, 2, 2, 2, 577, 576, 3, 2, 2,
	2, 578, 71, 3, 2, 2, 2, 579, 580, 7, 30, 2, 2, 580, 581, 5, 28, 15, 2,
	581, 582, 7, 31, 2, 2, 582, 73, 3, 2, 2, 2, 583, 584, 7, 39, 2, 2, 584,
	75, 3, 2, 2, 2, 585, 593, 5, 78, 40, 2, 586, 593, 5, 80, 41, 2, 587, 593,
	5, 82, 42, 2, 588, 593, 5, 84, 43, 2, 589, 593, 5, 86, 44, 2, 590, 593,
	5, 88, 45, 2, 591, 593, 5, 90, 46, 2, 592, 585, 3, 2, 2, 2, 592, 586, 3,
	2, 2, 2, 592, 587, 3, 2, 2, 2, 592, 588, 3, 2, 2, 2, 592, 589, 3, 2, 2,
	2, 592, 590, 3, 2, 2, 2, 592, 591, 3, 2, 2, 2, 593, 77, 3, 2, 2, 2, 594,
	596, 5, 116, 59, 2, 595, 594, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2, 596, 597,
	3, 2, 2, 2, 597, 599, 7, 343, 2, 2, 598, 600, 5, 186, 94, 2, 599, 598,
	3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 79, 3, 2, 2, 2, 601, 603, 7, 15,
	2, 2, 602, 601, 3, 2, 2, 2, 602, 603, 3, 2, 2, 2, 603, 604, 3, 2, 2, 2,
	604, 605, 7, 344, 2, 2, 605, 81, 3, 2, 2, 2, 606, 607, 9, 6, 2, 2, 607,
	614, 7, 343, 2, 2, 608, 609, 7, 32, 2, 2, 609, 610, 5, 92, 47, 2, 610,
	611, 7, 343, 2, 2, 611, 612, 7, 33, 2, 2, 612, 614, 3, 2, 2, 2, 613, 606,
	3, 2, 2, 2, 613, 608, 3, 2, 2, 2, 614, 83, 3, 2, 2, 2, 615, 617, 5, 116,
	59, 2, 616, 615, 3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2,
	618, 620, 7, 345, 2, 2, 619, 621, 5, 186, 94, 2, 620, 619, 3, 2, 2, 2,
	620, 621, 3, 2, 2, 2, 621, 85, 3, 2, 2, 2, 622, 624, 5, 116, 59, 2, 623,
	622, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 627,
	7, 346, 2, 2, 626, 628, 5, 186, 94, 2, 627, 626, 3, 2, 2, 2, 627, 628,
	3, 2, 2, 2, 628, 87, 3, 2, 2, 2, 629, 630, 9, 7, 2, 2, 630, 89, 3, 2, 2,
	2, 631, 632, 7, 103, 2, 2, 632, 91, 3, 2, 2, 2, 633, 636, 7, 342, 2, 2,
	634, 636, 5, 94, 48, 2, 635, 633, 3, 2, 2, 2, 635, 634, 3, 2, 2, 2, 636,
	93, 3, 2, 2, 2, 637, 638, 9, 8, 2, 2, 638, 95, 3, 2, 2, 2, 639, 641, 7,
	40, 2, 2, 640, 639, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 642, 3, 2, 2,
	2, 642, 644, 7, 40, 2, 2, 643, 640, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644,
	646, 3, 2, 2, 2, 645, 647, 9, 9, 2, 2, 646, 645, 3, 2, 2, 2, 646, 647,
	3, 2, 2, 2, 647, 649, 3, 2, 2, 2, 648, 650, 7, 19, 2, 2, 649, 648, 3, 2,
	2, 2, 649, 650, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 5, 92, 47,
	2, 652, 97, 3, 2, 2, 2, 653, 654, 5, 92, 47, 2, 654, 99, 3, 2, 2, 2, 655,
	656, 5, 106, 54, 2, 656, 657, 7, 19, 2, 2, 657, 659, 3, 2, 2, 2, 658, 655,
	3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 660, 3, 2, 2, 2, 660, 661, 5, 108,
	55, 2, 661, 101, 3, 2, 2, 2, 662, 663, 5, 106, 54, 2, 663, 664, 7, 19,
	2, 2, 664, 666, 3, 2, 2, 2, 665, 662, 3, 2, 2, 2, 665, 666, 3, 2, 2, 2,
	666, 667, 3, 2, 2, 2, 667, 668, 5, 108, 55, 2, 668, 103, 3, 2, 2, 2, 669,
	677, 5, 92, 47, 2, 670, 671, 5, 106, 54, 2, 671, 672, 7, 19, 2, 2, 672,
	674, 3, 2, 2, 2, 673, 670, 3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674, 675,
	3, 2, 2, 2, 675, 677, 5, 92, 47, 2, 676, 669, 3, 2, 2, 2, 676, 673, 3,
	2, 2, 2, 677, 105, 3, 2, 2, 2, 678, 679, 5, 92, 47, 2, 679, 107, 3, 2,
	2, 2, 680, 681, 5, 92, 47, 2, 681, 109, 3, 2, 2, 2, 682, 683, 5, 92, 47,
	2, 683, 111, 3, 2, 2, 2, 684, 686, 7, 30, 2, 2, 685, 684, 3, 2, 2, 2, 685,
	686, 3, 2, 2, 2, 686, 687, 3, 2, 2, 2, 687, 692, 5, 102, 52, 2, 688, 689,
	7, 36, 2, 2, 689, 691, 5, 102, 52, 2, 690, 688, 3, 2, 2, 2, 691, 694, 3,
	2, 2, 2, 692, 690, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 696, 3, 2, 2,
	2, 694, 692, 3, 2, 2, 2, 695, 697, 7, 31, 2, 2, 696, 695, 3, 2, 2, 2, 696,
	697, 3, 2, 2, 2, 697, 113, 3, 2, 2, 2, 698, 700, 7, 30, 2, 2, 699, 698,
	3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 701, 3, 2, 2, 2, 701, 706, 5, 100,
	51, 2, 702, 703, 7, 36, 2, 2, 703, 705, 5, 100, 51, 2, 704, 702, 3, 2,
	2, 2, 705, 708, 3, 2, 2, 2, 706, 704, 3, 2, 2, 2, 706, 707, 3, 2, 2, 2,
	707, 710, 3, 2, 2, 2, 708, 706, 3, 2, 2, 2, 709, 711, 7, 31, 2, 2, 710,
	709, 3, 2, 2, 2, 710, 711, 3, 2, 2, 2, 711, 115, 3, 2, 2, 2, 712, 713,
	7, 342, 2, 2, 713, 117, 3, 2, 2, 2, 714, 715, 8, 60, 1, 2, 715, 716, 5,
	124, 63, 2, 716, 717, 5, 118, 60, 5, 717, 724, 3, 2, 2, 2, 718, 719, 7,
	30, 2, 2, 719, 720, 5, 118, 60, 2, 720, 721, 7, 31, 2, 2, 721, 724, 3,
	2, 2, 2, 722, 724, 5, 126, 64, 2, 723, 714, 3, 2, 2, 2, 723, 718, 3, 2,
	2, 2, 723, 722, 3, 2, 2, 2, 724, 735, 3, 2, 2, 2, 725, 726, 12, 7, 2, 2,
	726, 727, 5, 120, 61, 2, 727, 728, 5, 118, 60, 8, 728, 734, 3, 2, 2, 2,
	729, 730, 12, 6, 2, 2, 730, 731, 5, 122, 62, 2, 731, 732, 5, 118, 60, 7,
	732, 734, 3, 2, 2, 2, 733, 725, 3, 2, 2, 2, 733, 729, 3, 2, 2, 2, 734,
	737, 3, 2, 2, 2, 735, 733, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 119,
	3, 2, 2, 2, 737, 735, 3, 2, 2, 2, 738, 739, 9, 10, 2, 2, 739, 121, 3, 2,
	2, 2, 740, 741, 7, 100, 2, 2, 741, 123, 3, 2, 2, 2, 742, 743, 9, 11, 2,
	2, 743, 125, 3, 2, 2, 2, 744, 745, 8, 64, 1, 2, 745, 746, 5, 130, 66, 2,
	746, 767, 3, 2, 2, 2, 747, 748, 12, 7, 2, 2, 748, 750, 7, 101, 2, 2, 749,
	751, 7, 102, 2, 2, 750, 749, 3, 2, 2, 2, 750, 751, 3, 2, 2, 2, 751, 752,
	3, 2, 2, 2, 752, 766, 9, 12, 2, 2, 753, 754, 12, 6, 2, 2, 754, 755, 7,
	21, 2, 2, 755, 766, 5, 130, 66, 2, 756, 757, 12, 5, 2, 2, 757, 758, 5,
	128, 65, 2, 758, 759, 5, 130, 66, 2, 759, 766, 3, 2, 2, 2, 760, 761, 12,
	4, 2, 2, 761, 762, 5, 128, 65, 2, 762, 763, 9, 13, 2, 2, 763, 764, 5, 72,
	37, 2, 764, 766, 3, 2, 2, 2, 765, 747, 3, 2, 2, 2, 765, 753, 3, 2, 2, 2,
	765, 756, 3, 2, 2, 2, 765, 760, 3, 2, 2, 2, 766, 769, 3, 2, 2, 2, 767,
	765, 3, 2, 2, 2, 767, 768, 3, 2, 2, 2, 768, 127, 3, 2, 2, 2, 769, 767,
	3, 2, 2, 2, 770, 771, 9, 14, 2, 2, 771, 129, 3, 2, 2, 2, 772, 774, 5, 132,
	67, 2, 773, 775, 7, 102, 2, 2, 774, 773, 3, 2, 2, 2, 774, 775, 3, 2, 2,
	2, 775, 776, 3, 2, 2, 2, 776, 777, 7, 108, 2, 2, 777, 778, 5, 72, 37, 2,
	778, 816, 3, 2, 2, 2, 779, 781, 5, 132, 67, 2, 780, 782, 7, 102, 2, 2,
	781, 780, 3, 2, 2, 2, 781, 782, 3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783,
	784, 7, 108, 2, 2, 784, 785, 7, 30, 2, 2, 785, 790, 5, 118, 60, 2, 786,
	787, 7, 36, 2, 2, 787, 789, 5, 118, 60, 2, 788, 786, 3, 2, 2, 2, 789, 792,
	3, 2, 2, 2, 790, 788, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 793, 3, 2,
	2, 2, 792, 790, 3, 2, 2, 2, 793, 794, 7, 31, 2, 2, 794, 816, 3, 2, 2, 2,
	795, 797, 5, 132, 67, 2, 796, 798, 7, 102, 2, 2, 797, 796, 3, 2, 2, 2,
	797, 798, 3, 2, 2, 2, 798, 799, 3, 2, 2, 2, 799, 800, 7, 107, 2, 2, 800,
	801, 5, 132, 67, 2, 801, 802, 7, 99, 2, 2, 802, 803, 5, 130, 66, 2, 803,
	816, 3, 2, 2, 2, 804, 806, 5, 132, 67, 2, 805, 807, 7, 102, 2, 2, 806,
	805, 3, 2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 809,
	7, 111, 2, 2, 809, 812, 5, 134, 68, 2, 810, 811, 7, 262, 2, 2, 811, 813,
	5, 134, 68, 2, 812, 810, 3, 2, 2, 2, 812, 813, 3, 2, 2, 2, 813, 816, 3,
	2, 2, 2, 814, 816, 5, 132, 67, 2, 815, 772, 3, 2, 2, 2, 815, 779, 3, 2,
	2, 2, 815, 795, 3, 2, 2, 2, 815, 804, 3, 2, 2, 2, 815, 814, 3, 2, 2, 2,
	816, 131, 3, 2, 2, 2, 817, 818, 8, 67, 1, 2, 818, 819, 5, 134, 68, 2, 819,
	858, 3, 2, 2, 2, 820, 821, 12, 15, 2, 2, 821, 822, 7, 7, 2, 2, 822, 857,
	5, 132, 67, 16, 823, 824, 12, 14, 2, 2, 824, 825, 7, 8, 2, 2, 825, 857,
	5, 132, 67, 15, 826, 827, 12, 13, 2, 2, 827, 828, 7, 9, 2, 2, 828, 857,
	5, 132, 67, 14, 829, 830, 12, 12, 2, 2, 830, 831, 7, 10, 2, 2, 831, 857,
	5, 132, 67, 13, 832, 833, 12, 11, 2, 2, 833, 834, 7, 14, 2, 2, 834, 857,
	5, 132, 67, 12, 835, 836, 12, 10, 2, 2, 836, 837, 7, 15, 2, 2, 837, 857,
	5, 132, 67, 11, 838, 839, 12, 9, 2, 2, 839, 840, 7, 16, 2, 2, 840, 857,
	5, 132, 67, 10, 841, 842, 12, 8, 2, 2, 842, 843, 7, 17, 2, 2, 843, 857,
	5, 132, 67, 9, 844, 845, 12, 7, 2, 2, 845, 846, 7, 12, 2, 2, 846, 857,
	5, 132, 67, 8, 847, 848, 12, 6, 2, 2, 848, 849, 7, 11, 2, 2, 849, 857,
	5, 132, 67, 7, 850, 851, 12, 5, 2, 2, 851, 852, 7, 14, 2, 2, 852, 857,
	5, 170, 86, 2, 853, 854, 12, 4, 2, 2, 854, 855, 7, 15, 2, 2, 855, 857,
	5, 170, 86, 2, 856, 820, 3, 2, 2, 2, 856, 823, 3, 2, 2, 2, 856, 826, 3,
	2, 2, 2, 856, 829, 3, 2, 2, 2, 856, 832, 3, 2, 2, 2, 856, 835, 3, 2, 2,
	2, 856, 838, 3, 2, 2, 2, 856, 841, 3, 2, 2, 2, 856, 844, 3, 2, 2, 2, 856,
	847, 3, 2, 2, 2, 856, 850, 3, 2, 2, 2, 856, 853, 3, 2, 2, 2, 857, 860,
	3, 2, 2, 2, 858, 856, 3, 2, 2, 2, 858, 859, 3, 2, 2, 2, 859, 133, 3, 2,
	2, 2, 860, 858, 3, 2, 2, 2, 861, 862, 8, 68, 1, 2, 862, 893, 5, 136, 69,
	2, 863, 893, 5, 74, 38, 2, 864, 893, 5, 76, 39, 2, 865, 893, 5, 102, 52,
	2, 866, 893, 5, 96, 49, 2, 867, 868, 9, 15, 2, 2, 868, 893, 5, 134, 68,
	9, 869, 870, 7, 30, 2, 2, 870, 875, 5, 118, 60, 2, 871, 872, 7, 36, 2,
	2, 872, 874, 5, 118, 60, 2, 873, 871, 3, 2, 2, 2, 874, 877, 3, 2, 2, 2,
	875, 873, 3, 2, 2, 2, 875, 876, 3, 2, 2, 2, 876, 878, 3, 2, 2, 2, 877,
	875, 3, 2, 2, 2, 878, 879, 7, 31, 2, 2, 879, 893, 3, 2, 2, 2, 880, 882,
	7, 106, 2, 2, 881, 880, 3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882, 883, 3,
	2, 2, 2, 883, 893, 5, 72, 37, 2, 884, 885, 7, 32, 2, 2, 885, 886, 5, 92,
	47, 2, 886, 887, 5, 118, 60, 2, 887, 888, 7, 33, 2, 2, 888, 893, 3, 2,
	2, 2, 889, 893, 5, 162, 82, 2, 890, 893, 5, 164, 83, 2, 891, 893, 5, 170,
	86, 2, 892, 861, 3, 2, 2, 2, 892, 863, 3, 2, 2, 2, 892, 864, 3, 2, 2, 2,
	892, 865, 3, 2, 2, 2, 892, 866, 3, 2, 2, 2, 892, 867, 3, 2, 2, 2, 892,
	869, 3, 2, 2, 2, 892, 881, 3, 2, 2, 2, 892, 884, 3, 2, 2, 2, 892, 889,
	3, 2, 2, 2, 892, 890, 3, 2, 2, 2, 892, 891, 3, 2, 2, 2, 893, 902, 3, 2,
	2, 2, 894, 895, 12, 11, 2, 2, 895, 898, 7, 239, 2, 2, 896, 899, 7, 343,
	2, 2, 897, 899, 5, 92, 47, 2, 898, 896, 3, 2, 2, 2, 898, 897, 3, 2, 2,
	2, 899, 901, 3, 2, 2, 2, 900, 894, 3, 2, 2, 2, 901, 904, 3, 2, 2, 2, 902,
	900, 3, 2, 2, 2, 902, 903, 3, 2, 2, 2, 903, 135, 3, 2, 2, 2, 904, 902,
	3, 2, 2, 2, 905, 909, 5, 138, 70, 2, 906, 909, 5, 144, 73, 2, 907, 909,
	5, 158, 80, 2, 908, 905, 3, 2, 2, 2, 908, 906, 3, 2, 2, 2, 908, 907, 3,
	2, 2, 2, 909, 137, 3, 2, 2, 2, 910, 911, 5, 140, 71, 2, 911, 913, 7, 30,
	2, 2, 912, 914, 5, 142, 72, 2, 913, 912, 3, 2, 2, 2, 913, 914, 3, 2, 2,
	2, 914, 924, 3, 2, 2, 2, 915, 920, 5, 118, 60, 2, 916, 917, 7, 36, 2, 2,
	917, 919, 5, 118, 60, 2, 918, 916, 3, 2, 2, 2, 919, 922, 3, 2, 2, 2, 920,
	918, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 925, 3, 2, 2, 2, 922, 920,
	3, 2, 2, 2, 923, 925, 7, 16, 2, 2, 924, 915, 3, 2, 2, 2, 924, 923, 3, 2,
	2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 3, 2, 2, 2, 926, 927, 7, 31, 2, 2,
	927, 139, 3, 2, 2, 2, 928, 929, 9, 16, 2, 2, 929, 141, 3, 2, 2, 2, 930,
	931, 7, 75, 2, 2, 931, 143, 3, 2, 2, 2, 932, 939, 5, 146, 74, 2, 933, 939,
	5, 148, 75, 2, 934, 939, 5, 150, 76, 2, 935, 939, 5, 152, 77, 2, 936, 939,
	5, 154, 78, 2, 937, 939, 5, 156, 79, 2, 938, 932, 3, 2, 2, 2, 938, 933,
	3, 2, 2, 2, 938, 934, 3, 2, 2, 2, 938, 935, 3, 2, 2, 2, 938, 936, 3, 2,
	2, 2, 938, 937, 3, 2, 2, 2, 939, 145, 3, 2, 2, 2, 940, 941, 7, 78, 2, 2,
	941, 944, 7, 30, 2, 2, 942, 945, 5, 118, 60, 2, 943, 945, 7, 103, 2, 2,
	944, 942, 3, 2, 2, 2, 944, 943, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946,
	947, 7, 92, 2, 2, 947, 948, 5, 178, 90, 2, 948, 949, 7, 31, 2, 2, 949,
	147, 3, 2, 2, 2, 950, 951, 7, 244, 2, 2, 951, 952, 7, 30, 2, 2, 952, 953,
	5, 118, 60, 2, 953, 954, 7, 90, 2, 2, 954, 955, 5, 92, 47, 2, 955, 956,
	7, 31, 2, 2, 956, 149, 3, 2, 2, 2, 957, 958, 7, 65, 2, 2, 958, 959, 7,
	30, 2, 2, 959, 960, 5, 118, 60, 2, 960, 961, 7, 108, 2, 2, 961, 962, 5,
	118, 60, 2, 962, 963, 7, 31, 2, 2, 963, 151, 3, 2, 2, 2, 964, 965, 7, 80,
	2, 2, 965, 966, 7, 30, 2, 2, 966, 967, 5, 118, 60, 2, 967, 968, 7, 81,
	2, 2, 968, 971, 7, 344, 2, 2, 969, 970, 7, 97, 2, 2, 970, 972, 7, 344,
	2, 2, 971, 969, 3, 2, 2, 2, 971, 972, 3, 2, 2, 2, 972, 973, 3, 2, 2, 2,
	973, 974, 7, 31, 2, 2, 974, 153, 3, 2, 2, 2, 975, 976, 7, 268, 2, 2, 976,
	977, 7, 30, 2, 2, 977, 978, 5, 92, 47, 2, 978, 979, 7, 81, 2, 2, 979, 980,
	5, 118, 60, 2, 980, 981, 7, 31, 2, 2, 981, 155, 3, 2, 2, 2, 982, 983, 7,
	79, 2, 2, 983, 984, 7, 30, 2, 2, 984, 985, 9, 17, 2, 2, 985, 986, 7, 343,
	2, 2, 986, 987, 7, 81, 2, 2, 987, 988, 7, 343, 2, 2, 988, 989, 7, 31, 2,
	2, 989, 157, 3, 2, 2, 2, 990, 991, 5, 160, 81, 2, 991, 1001, 7, 30, 2,
	2, 992, 997, 5, 118, 60, 2, 993, 994, 7, 36, 2, 2, 994, 996, 5, 118, 60,
	2, 995, 993, 3, 2, 2, 2, 996, 999, 3, 2, 2, 2, 997, 995, 3, 2, 2, 2, 997,
	998, 3, 2, 2, 2, 998, 1002, 3, 2, 2, 2, 999, 997, 3, 2, 2, 2, 1000, 1002,
	7, 16, 2, 2, 1001, 992, 3, 2, 2, 2, 1001, 1000, 3, 2, 2, 2, 1001, 1002,
	3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1004, 7, 31, 2, 2, 1004, 159,
	3, 2, 2, 2, 1005, 1012, 5, 92, 47, 2, 1006, 1012, 7, 94, 2, 2, 1007, 1012,
	7, 248, 2, 2, 1008, 1012, 7, 133, 2, 2, 1009, 1012, 7, 134, 2, 2, 1010,
	1012, 7, 129, 2, 2, 1011, 1005, 3, 2, 2, 2, 1011, 1006, 3, 2, 2, 2, 1011,
	1007, 3, 2, 2, 2, 1011, 1008, 3, 2, 2, 2, 1011, 1009, 3, 2, 2, 2, 1011,
	1010, 3, 2, 2, 2, 1012, 161, 3, 2, 2, 2, 1013, 1014, 5, 76, 39, 2, 1014,
	1016, 7, 289, 2, 2, 1015, 1017, 7, 62, 2, 2, 1016, 1015, 3, 2, 2, 2, 1016,
	1017, 3, 2, 2, 2, 1017, 1018, 3, 2, 2, 2, 1018, 1019, 9, 18, 2, 2, 1019,
	1020, 5, 72, 37, 2, 1020, 163, 3, 2, 2, 2, 1021, 1023, 7, 76, 2, 2, 1022,
	1024, 5, 134, 68, 2, 1023, 1022, 3, 2, 2, 2, 1023, 1024, 3, 2, 2, 2, 1024,
	1026, 3, 2, 2, 2, 1025, 1027, 5, 166, 84, 2, 1026, 1025, 3, 2, 2, 2, 1027,
	1028, 3, 2, 2, 2, 1028, 1026, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029,
	1031, 3, 2, 2, 2, 1030, 1032, 5, 168, 85, 2, 1031, 1030, 3, 2, 2, 2, 1031,
	1032, 3, 2, 2, 2, 1032, 1033, 3, 2, 2, 2, 1033, 1034, 7, 260, 2, 2, 1034,
	165, 3, 2, 2, 2, 1035, 1036, 7, 77, 2, 2, 1036, 1037, 5, 118, 60, 2, 1037,
	1038, 7, 96, 2, 2, 1038, 1039, 5, 118, 60, 2, 1039, 167, 3, 2, 2, 2, 1040,
	1041, 7, 95, 2, 2, 1041, 1042, 5, 118, 60, 2, 1042, 169, 3, 2, 2, 2, 1043,
	1044, 7, 129, 2, 2, 1044, 1045, 5, 118, 60, 2, 1045, 1046, 5, 172, 87,
	2, 1046, 171, 3, 2, 2, 2, 1047, 1048, 9, 19, 2, 2, 1048, 173, 3, 2, 2,
	2, 1049, 1050, 7, 112, 2, 2, 1050, 1051, 7, 114, 2, 2, 1051, 1056, 5, 176,
	89, 2, 1052, 1053, 7, 36, 2, 2, 1053, 1055, 5, 176, 89, 2, 1054, 1052,
	3, 2, 2, 2, 1055, 1058, 3, 2, 2, 2, 1056, 1054, 3, 2, 2, 2, 1056, 1057,
	3, 2, 2, 2, 1057, 175, 3, 2, 2, 2, 1058, 1056, 3, 2, 2, 2, 1059, 1062,
	5, 102, 52, 2, 1060, 1062, 5, 80, 41, 2, 1061, 1059, 3, 2, 2, 2, 1061,
	1060, 3, 2, 2, 2, 1062, 1064, 3, 2, 2, 2, 1063, 1065, 9, 20, 2, 2, 1064,
	1063, 3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065, 177, 3, 2, 2, 2, 1066,
	1068, 5, 180, 91, 2, 1067, 1069, 5, 182, 92, 2, 1068, 1067, 3, 2, 2, 2,
	1068, 1069, 3, 2, 2, 2, 1069, 1071, 3, 2, 2, 2, 1070, 1072, 5, 184, 93,
	2, 1071, 1070, 3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 1074, 3, 2, 2,
	2, 1073, 1075, 5, 186, 94, 2, 1074, 1073, 3, 2, 2, 2, 1074, 1075, 3, 2,
	2, 2, 1075, 1094, 3, 2, 2, 2, 1076, 1077, 5, 180, 91, 2, 1077, 1078, 7,
	30, 2, 2, 1078, 1083, 7, 343, 2, 2, 1079, 1080, 7, 36, 2, 2, 1080, 1082,
	7, 343, 2, 2, 1081, 1079, 3, 2, 2, 2, 1082, 1085, 3, 2, 2, 2, 1083, 1081,
	3, 2, 2, 2, 1083, 1084, 3, 2, 2, 2, 1084, 1086, 3, 2, 2, 2, 1085, 1083,
	3, 2, 2, 2, 1086, 1088, 7, 31, 2, 2, 1087, 1089, 5, 184, 93, 2, 1088, 1087,
	3, 2, 2, 2, 1088, 1089, 3, 2, 2, 2, 1089, 1091, 3, 2, 2, 2, 1090, 1092,
	5, 186, 94, 2, 1091, 1090, 3, 2, 2, 2, 1091, 1092, 3, 2, 2, 2, 1092, 1094,
	3, 2, 2, 2, 1093, 1066, 3, 2, 2, 2, 1093, 1076, 3, 2, 2, 2, 1094, 179,
	3, 2, 2, 2, 1095, 1137, 7, 127, 2, 2, 1096, 1097, 7, 127, 2, 2, 1097, 1137,
	7, 337, 2, 2, 1098, 1099, 7, 291, 2, 2, 1099, 1137, 7, 127, 2, 2, 1100,
	1101, 7, 291, 2, 2, 1101, 1102, 7, 127, 2, 2, 1102, 1137, 7, 337, 2, 2,
	1103, 1137, 7, 126, 2, 2, 1104, 1137, 7, 172, 2, 2, 1105, 1137, 7, 292,
	2, 2, 1106, 1107, 7, 291, 2, 2, 1107, 1137, 7, 126, 2, 2, 1108, 1109, 7,
	291, 2, 2, 1109, 1110, 7, 126, 2, 2, 1110, 1137, 7, 337, 2, 2, 1111, 1137,
	7, 230, 2, 2, 1112, 1113, 7, 230, 2, 2, 1113, 1137, 7, 337, 2, 2, 1114,
	1137, 7, 295, 2, 2, 1115, 1137, 7, 170, 2, 2, 1116, 1137, 7, 251, 2, 2,
	1117, 1137, 7, 168, 2, 2, 1118, 1137, 7, 318, 2, 2, 1119, 1137, 7, 173,
	2, 2, 1120, 1137, 7, 169, 2, 2, 1121, 1122, 7, 125, 2, 2, 1122, 1137, 7,
	66, 2, 2, 1123, 1137, 7, 130, 2, 2, 1124, 1137, 7, 131, 2, 2, 1125, 1137,
	7, 132, 2, 2, 1126, 1137, 7, 129, 2, 2, 1127, 1128, 7, 131, 2, 2, 1128,
	1129, 7, 73, 2, 2, 1129, 1130, 7, 131, 2, 2, 1130, 1137, 7, 341, 2, 2,
	1131, 1132, 7, 132, 2, 2, 1132, 1133, 7, 73, 2, 2, 1133, 1134, 7, 131,
	2, 2, 1134, 1137, 7, 341, 2, 2, 1135, 1137, 5, 92, 47, 2, 1136, 1095, 3,
	2, 2, 2, 1136, 1096, 3, 2, 2, 2, 1136, 1098, 3, 2, 2, 2, 1136, 1100, 3,
	2, 2, 2, 1136, 1103, 3, 2, 2, 2, 1136, 1104, 3, 2, 2, 2, 1136, 1105, 3,
	2, 2, 2, 1136, 1106, 3, 2, 2, 2, 1136, 1108, 3, 2, 2, 2, 1136, 1111, 3,
	2, 2, 2, 1136, 1112, 3, 2, 2, 2, 1136, 1114, 3, 2, 2, 2, 1136, 1115, 3,
	2, 2, 2, 1136, 1116, 3, 2, 2, 2, 1136, 1117, 3, 2, 2, 2, 1136, 1118, 3,
	2, 2, 2, 1136, 1119, 3, 2, 2, 2, 1136, 1120, 3, 2, 2, 2, 1136, 1121, 3,
	2, 2, 2, 1136, 1123, 3, 2, 2, 2, 1136, 1124, 3, 2, 2, 2, 1136, 1125, 3,
	2, 2, 2, 1136, 1126, 3, 2, 2, 2, 1136, 1127, 3, 2, 2, 2, 1136, 1131, 3,
	2, 2, 2, 1136, 1135, 3, 2, 2, 2, 1137, 181, 3, 2, 2, 2, 1138, 1139, 7,
	30, 2, 2, 1139, 1142, 7, 344, 2, 2, 1140, 1141, 7, 36, 2, 2, 1141, 1143,
	7, 344, 2, 2, 1142, 1140, 3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1144,
	3, 2, 2, 2, 1144, 1145, 7, 31, 2, 2, 1145, 183, 3, 2, 2, 2, 1146, 1147,
	9, 21, 2, 2, 1147, 1149, 7, 56, 2, 2, 1148, 1150, 7, 23, 2, 2, 1149, 1148,
	3, 2, 2, 2, 1149, 1150, 3, 2, 2, 2, 1150, 1151, 3, 2, 2, 2, 1151, 1152,
	5, 188, 95, 2, 1152, 185, 3, 2, 2, 2, 1153, 1155, 7, 239, 2, 2, 1154, 1156,
	7, 23, 2, 2, 1155, 1154, 3, 2, 2, 2, 1155, 1156, 3, 2, 2, 2, 1156, 1159,
	3, 2, 2, 2, 1157, 1160, 7, 343, 2, 2, 1158, 1160, 5, 188, 95, 2, 1159,
	1157, 3, 2, 2, 2, 1159, 1158, 3, 2, 2, 2, 1160, 187, 3, 2, 2, 2, 1161,
	1164, 5, 92, 47, 2, 1162, 1163, 7, 19, 2, 2, 1163, 1165, 5, 92, 47, 2,
	1164, 1162, 3, 2, 2, 2, 1164, 1165, 3, 2, 2, 2, 1165, 189, 3, 2, 2, 2,
	1166, 1168, 9, 22, 2, 2, 1167, 1166, 3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2,
	1168, 191, 3, 2, 2, 2, 1169, 1171, 7, 48, 2, 2, 1170, 1172, 5, 206, 104,
	2, 1171, 1170, 3, 2, 2, 2, 1171, 1172, 3, 2, 2, 2, 1172, 1173, 3, 2, 2,
	2, 1173, 1174, 7, 57, 2, 2, 1174, 1177, 5, 100, 51, 2, 1175, 1178, 5, 208,
	105, 2, 1176, 1178, 5, 238, 120, 2, 1177, 1175, 3, 2, 2, 2, 1177, 1176,
	3, 2, 2, 2, 1178, 193, 3, 2, 2, 2, 1179, 1180, 7, 49, 2, 2, 1180, 1181,
	7, 57, 2, 2, 1181, 1182, 5, 100, 51, 2, 1182, 1183, 5, 240, 121, 2, 1183,
	195, 3, 2, 2, 2, 1184, 1185, 7, 50, 2, 2, 1185, 1186, 7, 57, 2, 2, 1186,
	1187, 5, 114, 58, 2, 1187, 1188, 5, 190, 96, 2, 1188, 197, 3, 2, 2, 2,
	1189, 1190, 7, 48, 2, 2, 1190, 1191, 7, 52, 2, 2, 1191, 1195, 5, 98, 50,
	2, 1192, 1194, 5, 210, 106, 2, 1193, 1192, 3, 2, 2, 2, 1194, 1197, 3, 2,
	2, 2, 1195, 1193, 3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 199, 3, 2,
	2, 2, 1197, 1195, 3, 2, 2, 2, 1198, 1199, 7, 50, 2, 2, 1199, 1200, 7, 52,
	2, 2, 1200, 1201, 5, 98, 50, 2, 1201, 1202, 5, 190, 96, 2, 1202, 201, 3,
	2, 2, 2, 1203, 1204, 7, 48, 2, 2, 1204, 1205, 7, 70, 2, 2, 1205, 1217,
	5, 104, 53, 2, 1206, 1207, 7, 30, 2, 2, 1207, 1212, 5, 92, 47, 2, 1208,
	1209, 7, 36, 2, 2, 1209, 1211, 5, 92, 47, 2, 1210, 1208, 3, 2, 2, 2, 1211,
	1214, 3, 2, 2, 2, 1212, 1210, 3, 2, 2, 2, 1212, 1213, 3, 2, 2, 2, 1213,
	1215, 3, 2, 2, 2, 1214, 1212, 3, 2, 2, 2, 1215, 1216, 7, 31, 2, 2, 1216,
	1218, 3, 2, 2, 2, 1217, 1206, 3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2, 1218,
	1219, 3, 2, 2, 2, 1219, 1220, 7, 92, 2, 2, 1220, 1227, 5, 26, 14, 2, 1221,
	1223, 7, 73, 2, 2, 1222, 1224, 9, 23, 2, 2, 1223, 1222, 3, 2, 2, 2, 1223,
	1224, 3, 2, 2, 2, 1224, 1225, 3, 2, 2, 2, 1225, 1226, 7, 237, 2, 2, 1226,
	1228, 7, 299, 2, 2, 1227, 1221, 3, 2, 2, 2, 1227, 1228, 3, 2, 2, 2, 1228,
	203, 3, 2, 2, 2, 1229, 1230, 7, 50, 2, 2, 1230, 1231, 7, 70, 2, 2, 1231,
	1232, 5, 104, 53, 2, 1232, 1233, 5, 190, 96, 2, 1233, 205, 3, 2, 2, 2,
	1234, 1235, 9, 9, 2, 2, 1235, 1236, 7, 325, 2, 2, 1236, 207, 3, 2, 2, 2,
	1237, 1238, 7, 30, 2, 2, 1238, 1243, 5, 212, 107, 2, 1239, 1240, 7, 36,
	2, 2, 1240, 1242, 5, 212, 107, 2, 1241, 1239, 3, 2, 2, 2, 1242, 1245, 3,
	2, 2, 2, 1243, 1241, 3, 2, 2, 2, 1243, 1244, 3, 2, 2, 2, 1244, 1246, 3,
	2, 2, 2, 1245, 1243, 3, 2, 2, 2, 1246, 1247, 7, 31, 2, 2, 1247, 209, 3,
	2, 2, 2, 1248, 1249, 7, 149, 2, 2, 1249, 1250, 7, 127, 2, 2, 1250, 1252,
	7, 56, 2, 2, 1251, 1253, 7, 23, 2, 2, 1252, 1251, 3, 2, 2, 2, 1252, 1253,
	3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254, 1255, 5, 116, 59, 2, 1255, 211,
	3, 2, 2, 2, 1256, 1260, 5, 214, 108, 2, 1257, 1260, 5, 228, 115, 2, 1258,
	1260, 5, 218, 110, 2, 1259, 1256, 3, 2, 2, 2, 1259, 1257, 3, 2, 2, 2, 1259,
	1258, 3, 2, 2, 2, 1260, 213, 3, 2, 2, 2, 1261, 1262, 5, 102, 52, 2, 1262,
	1266, 5, 178, 90, 2, 1263, 1265, 5, 216, 109, 2, 1264, 1263, 3, 2, 2, 2,
	1265, 1268, 3, 2, 2, 2, 1266, 1264, 3, 2, 2, 2, 1266, 1267, 3, 2, 2, 2,
	1267, 215, 3, 2, 2, 2, 1268, 1266, 3, 2, 2, 2, 1269, 1288, 5, 232, 117,
	2, 1270, 1272, 7, 62, 2, 2, 1271, 1273, 7, 64, 2, 2, 1272, 1271, 3, 2,
	2, 2, 1272, 1273, 3, 2, 2, 2, 1273, 1288, 3, 2, 2, 2, 1274, 1276, 7, 102,
	2, 2, 1275, 1274, 3, 2, 2, 2, 1275, 1276, 3, 2, 2, 2, 1276, 1277, 3, 2,
	2, 2, 1277, 1288, 7, 103, 2, 2, 1278, 1288, 5, 186, 94, 2, 1279, 1288,
	5, 218, 110, 2, 1280, 1288, 5, 220, 111, 2, 1281, 1284, 7, 149, 2, 2, 1282,
	1285, 5, 76, 39, 2, 1283, 1285, 5, 118, 60, 2, 1284, 1282, 3, 2, 2, 2,
	1284, 1283, 3, 2, 2, 2, 1285, 1288, 3, 2, 2, 2, 1286, 1288, 7, 343, 2,
	2, 1287, 1269, 3, 2, 2, 2, 1287, 1270, 3, 2, 2, 2, 1287, 1275, 3, 2, 2,
	2, 1287, 1278, 3, 2, 2, 2, 1287, 1279, 3, 2, 2, 2, 1287, 1280, 3, 2, 2,
	2, 1287, 1281, 3, 2, 2, 2, 1287, 1286, 3, 2, 2, 2, 1288, 217, 3, 2, 2,
	2, 1289, 1291, 7, 60, 2, 2, 1290, 1292, 5, 188, 95, 2, 1291, 1290, 3, 2,
	2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 1294, 3, 2, 2, 2, 1293, 1289, 3, 2,
	2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2, 1295, 1296, 7, 237,
	2, 2, 1296, 1297, 5, 118, 60, 2, 1297, 219, 3, 2, 2, 2, 1298, 1299, 7,
	309, 2, 2, 1299, 1300, 5, 100, 51, 2, 1300, 1307, 5, 224, 113, 2, 1301,
	1302, 7, 289, 2, 2, 1302, 1308, 7, 84, 2, 2, 1303, 1304, 7, 289, 2, 2,
	1304, 1308, 7, 303, 2, 2, 1305, 1306, 7, 289, 2, 2, 1306, 1308, 7, 62,
	2, 2, 1307, 1301, 3, 2, 2, 2, 1307, 1303, 3, 2, 2, 2, 1307, 1305, 3, 2,
	2, 2, 1307, 1308, 3, 2, 2, 2, 1308, 1314, 3, 2, 2, 2, 1309, 1310, 7, 93,
	2, 2, 1310, 1311, 9, 24, 2, 2, 1311, 1313, 5, 222, 112, 2, 1312, 1309,
	3, 2, 2, 2, 1313, 1316, 3, 2, 2, 2, 1314, 1312, 3, 2, 2, 2, 1314, 1315,
	3, 2, 2, 2, 1315, 221, 3, 2, 2, 2, 1316, 1314, 3, 2, 2, 2, 1317, 1326,
	7, 311, 2, 2, 1318, 1326, 7, 233, 2, 2, 1319, 1320, 7, 56, 2, 2, 1320,
	1326, 7, 103, 2, 2, 1321, 1322, 7, 293, 2, 2, 1322, 1326, 7, 224, 2, 2,
	1323, 1324, 7, 56, 2, 2, 1324, 1326, 7, 149, 2, 2, 1325, 1317, 3, 2, 2,
	2, 1325, 1318, 3, 2, 2, 2, 1325, 1319, 3, 2, 2, 2, 1325, 1321, 3, 2, 2,
	2, 1325, 1323, 3, 2, 2, 2, 1326, 223, 3, 2, 2, 2, 1327, 1328, 7, 30, 2,
	2, 1328, 1333, 5, 226, 114, 2, 1329, 1330, 7, 36, 2, 2, 1330, 1332, 5,
	226, 114, 2, 1331, 1329, 3, 2, 2, 2, 1332, 1335, 3, 2, 2, 2, 1333, 1331,
	3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1336, 3, 2, 2, 2, 1335, 1333,
	3, 2, 2, 2, 1336, 1337, 7, 31, 2, 2, 1337, 225, 3, 2, 2, 2, 1338, 1342,
	5, 102, 52, 2, 1339, 1340, 7, 30, 2, 2, 1340, 1341, 7, 344, 2, 2, 1341,
	1343, 7, 31, 2, 2, 1342, 1339, 3, 2, 2, 2, 1342, 1343, 3, 2, 2, 2, 1343,
	1346, 3, 2, 2, 2, 1344, 1346, 5, 118, 60, 2, 1345, 1338, 3, 2, 2, 2, 1345,
	1344, 3, 2, 2, 2, 1346, 1348, 3, 2, 2, 2, 1347, 1349, 9, 20, 2, 2, 1348,
	1347, 3, 2, 2, 2, 1348, 1349, 3, 2, 2, 2, 1349, 227, 3, 2, 2, 2, 1350,
	1352, 7, 60, 2, 2, 1351, 1353, 5, 110, 56, 2, 1352, 1351, 3, 2, 2, 2, 1352,
	1353, 3, 2, 2, 2, 1353, 1355, 3, 2, 2, 2, 1354, 1350, 3, 2, 2, 2, 1354,
	1355, 3, 2, 2, 2, 1355, 1359, 3, 2, 2, 2, 1356, 1360, 5, 230, 116, 2, 1357,
	1360, 5, 234, 118, 2, 1358, 1360, 5, 236, 119, 2, 1359, 1356, 3, 2, 2,
	2, 1359, 1357, 3, 2, 2, 2, 1359, 1358, 3, 2, 2, 2, 1360, 229, 3, 2, 2,
	2, 1361, 1362, 5, 232, 117, 2, 1362, 1363, 5, 112, 57, 2, 1363, 231, 3,
	2, 2, 2, 1364, 1365, 7, 61, 2, 2, 1365, 1366, 7, 64, 2, 2, 1366, 233, 3,
	2, 2, 2, 1367, 1368, 7, 62, 2, 2, 1368, 1369, 5, 224, 113, 2, 1369, 235,
	3, 2, 2, 2, 1370, 1371, 7, 63, 2, 2, 1371, 1372, 7, 64, 2, 2, 1372, 1373,
	5, 112, 57, 2, 1373, 1374, 5, 220, 111, 2, 1374, 237, 3, 2, 2, 2, 1375,
	1377, 7, 30, 2, 2, 1376, 1375, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2, 1377,
	1378, 3, 2, 2, 2, 1378, 1379, 7, 111, 2, 2, 1379, 1381, 5, 100, 51, 2,
	1380, 1382, 7, 31, 2, 2, 1381, 1380, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2,
	1382, 239, 3, 2, 2, 2, 1383, 1389, 5, 242, 122, 2, 1384, 1389, 5, 244,
	123, 2, 1385, 1389, 5, 246, 124, 2, 1386, 1389, 5, 248, 125, 2, 1387, 1389,
	5, 250, 126, 2, 1388, 1383, 3, 2, 2, 2, 1388, 1384, 3, 2, 2, 2, 1388, 1385,
	3, 2, 2, 2, 1388, 1386, 3, 2, 2, 2, 1388, 1387, 3, 2, 2, 2, 1389, 241,
	3, 2, 2, 2, 1390, 1392, 7, 55, 2, 2, 1391, 1393, 7, 58, 2, 2, 1392, 1391,
	3, 2, 2, 2, 1392, 1393, 3, 2, 2, 2, 1393, 1394, 3, 2, 2, 2, 1394, 1395,
	5, 214, 108, 2, 1395, 243, 3, 2, 2, 2, 1396, 1398, 7, 49, 2, 2, 1397, 1399,
	7, 58, 2, 2, 1398, 1397, 3, 2, 2, 2, 1398, 1399, 3, 2, 2, 2, 1399, 1400,
	3, 2, 2, 2, 1400, 1401, 5, 214, 108, 2, 1401, 245, 3, 2, 2, 2, 1402, 1404,
	7, 50, 2, 2, 1403, 1405, 7, 58, 2, 2, 1404, 1403, 3, 2, 2, 2, 1404, 1405,
	3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406, 1407, 5, 102, 52, 2, 1407, 247,
	3, 2, 2, 2, 1408, 1409, 7, 55, 2, 2, 1409, 1410, 5, 228, 115, 2, 1410,
	249, 3, 2, 2, 2, 1411, 1412, 7, 50, 2, 2, 1412, 1413, 5, 228, 115, 2, 1413,
	251, 3, 2, 2, 2, 1414, 1415, 7, 56, 2, 2, 1415, 1416, 7, 329, 2, 2, 1416,
	1417, 7, 283, 2, 2, 1417, 1418, 7, 287, 2, 2, 1418, 1419, 5, 258, 130,
	2, 1419, 253, 3, 2, 2, 2, 1420, 1421, 7, 121, 2, 2, 1421, 255, 3, 2, 2,
	2, 1422, 1423, 7, 122, 2, 2, 1423, 257, 3, 2, 2, 2, 1424, 1425, 7, 308,
	2, 2, 1425, 1432, 7, 221, 2, 2, 1426, 1427, 7, 308, 2, 2, 1427, 1432, 7,
	188, 2, 2, 1428, 1429, 7, 210, 2, 2, 1429, 1432, 7, 308, 2, 2, 1430, 1432,
	7, 217, 2, 2, 1431, 1424, 3, 2, 2, 2, 1431, 1426, 3, 2, 2, 2, 1431, 1428,
	3, 2, 2, 2, 1431, 1430, 3, 2, 2, 2, 1432, 259, 3, 2, 2, 2, 1433, 1434,
	7, 53, 2, 2, 1434, 1435, 5, 264, 133, 2, 1435, 1436, 7, 98, 2, 2, 1436,
	1441, 5, 270, 136, 2, 1437, 1438, 7, 36, 2, 2, 1438, 1440, 5, 270, 136,
	2, 1439, 1437, 3, 2, 2, 2, 1440, 1443, 3, 2, 2, 2, 1441, 1439, 3, 2, 2,
	2, 1441, 1442, 3, 2, 2, 2, 1442, 1447, 3, 2, 2, 2, 1443, 1441, 3, 2, 2,
	2, 1444, 1445, 7, 73, 2, 2, 1445, 1446, 7, 53, 2, 2, 1446, 1448, 7, 299,
	2, 2, 1447, 1444, 3, 2, 2, 2, 1447, 1448, 3, 2, 2, 2, 1448, 261, 3, 2,
	2, 2, 1449, 1453, 7, 54, 2, 2, 1450, 1451, 7, 53, 2, 2, 1451, 1452, 7,
	299, 2, 2, 1452, 1454, 7, 97, 2, 2, 1453, 1450, 3, 2, 2, 2, 1453, 1454,
	3, 2, 2, 2, 1454, 1455, 3, 2, 2, 2, 1455, 1456, 5, 264, 133, 2, 1456, 1457,
	7, 81, 2, 2, 1457, 1462, 5, 270, 136, 2, 1458, 1459, 7, 36, 2, 2, 1459,
	1461, 5, 270, 136, 2, 1460, 1458, 3, 2, 2, 2, 1461, 1464, 3, 2, 2, 2, 1462,
	1460, 3, 2, 2, 2, 1462, 1463, 3, 2, 2, 2, 1463, 1465, 3, 2, 2, 2, 1464,
	1462, 3, 2, 2, 2, 1465, 1466, 5, 190, 96, 2, 1466, 263, 3, 2, 2, 2, 1467,
	1468, 5, 266, 134, 2, 1468, 1469, 7, 93, 2, 2, 1469, 1470, 5, 272, 137,
	2, 1470, 265, 3, 2, 2, 2, 1471, 1472, 5, 268, 135, 2, 1472, 1473, 5, 112,
	57, 2, 1473, 267, 3, 2, 2, 2, 1474, 1475, 7, 109, 2, 2, 1475, 1483, 7,
	306, 2, 2, 1476, 1483, 7, 44, 2, 2, 1477, 1483, 7, 47, 2, 2, 1478, 1483,
	7, 45, 2, 2, 1479, 1483, 7, 46, 2, 2, 1480, 1483, 7, 309, 2, 2, 1481, 1483,
	7, 334, 2, 2, 1482, 1474, 3, 2, 2, 2, 1482, 1476, 3, 2, 2, 2, 1482, 1477,
	3, 2, 2, 2, 1482, 1478, 3, 2, 2, 2, 1482, 1479, 3, 2, 2, 2, 1482, 1480,
	3, 2, 2, 2, 1482, 1481, 3, 2, 2, 2, 1483, 269, 3, 2, 2, 2, 1484, 1487,
	7, 307, 2, 2, 1485, 1487, 5, 92, 47, 2, 1486, 1484, 3, 2, 2, 2, 1486, 1485,
	3, 2, 2, 2, 1487, 271, 3, 2, 2, 2, 1488, 1490, 5, 274, 138, 2, 1489, 1488,
	3, 2, 2, 2, 1489, 1490, 3, 2, 2, 2, 1490, 1491, 3, 2, 2, 2, 1491, 1492,
	5, 276, 139, 2, 1492, 273, 3, 2, 2, 2, 1493, 1494, 7, 57, 2, 2, 1494, 275,
	3, 2, 2, 2, 1495, 1496, 5, 100, 51, 2, 1496, 277, 3, 2, 2, 2, 171, 294,
	297, 301, 306, 309, 317, 321, 329, 334, 337, 341, 349, 358, 365, 370, 377,
	382, 385, 392, 397, 404, 409, 412, 415, 418, 421, 424, 432, 438, 443, 446,
	449, 452, 456, 471, 479, 485, 490, 493, 497, 501, 507, 510, 516, 520, 530,
	534, 540, 552, 562, 569, 573, 577, 592, 595, 599, 602, 613, 616, 620, 623,
	627, 635, 640, 643, 646, 649, 658, 665, 673, 676, 685, 692, 696, 699, 706,
	710, 723, 733, 735, 750, 765, 767, 774, 781, 790, 797, 806, 812, 815, 856,
	858, 875, 881, 892, 898, 902, 908, 913, 920, 924, 938, 944, 971, 997, 1001,
	1011, 1016, 1023, 1028, 1031, 1056, 1061, 1064, 1068, 1071, 1074, 1083,
	1088, 1091, 1093, 1136, 1142, 1149, 1155, 1159, 1164, 1167, 1171, 1177,
	1195, 1212, 1217, 1223, 1227, 1243, 1252, 1259, 1266, 1272, 1275, 1284,
	1287, 1291, 1293, 1307, 1314, 1325, 1333, 1342, 1345, 1348, 1352, 1354,
	1359, 1376, 1381, 1388, 1392, 1398, 1404, 1431, 1441, 1447, 1453, 1462,
	1482, 1486, 1489,
}
var literalNames = []string{
	"", "'&&'", "'||'", "'!'", "'~'", "'|'", "'&'", "'<<'", "'>>'", "'^'",
	"'%'", "':'", "'+'", "'-'", "'*'", "'/'", "'\\'", "'.'", "'.*'", "'<=>'",
	"'=='", "'='", "", "'>'", "'>='", "'<'", "'<='", "'#'", "'('", "')'", "'{'",
	"'}'", "'['", "']'", "','", "'\"'", "'''", "'?'", "'@'", "';'", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "'DO NOT MATCH ANY THING, JUST FOR GENERATOR'",
}
var symbolicNames = []string{
	"", "AND_", "CONCAT_", "NOT_", "TILDE_", "VERTICAL_BAR_", "AMPERSAND_",
	"SIGNED_LEFT_SHIFT_", "SIGNED_RIGHT_SHIFT_", "CARET_", "MOD_", "COLON_",
	"PLUS_", "MINUS_", "ASTERISK_", "SLASH_", "BACKSLASH_", "DOT_", "DOT_ASTERISK_",
	"SAFE_EQ_", "DEQ_", "EQ_", "NEQ_", "GT_", "GTE_", "LT_", "LTE_", "POUND_",
	"LP_", "RP_", "LBE_", "RBE_", "LBT_", "RBT_", "COMMA_", "DQ_", "SQ_", "QUESTION_",
	"AT_", "SEMI_", "INLINE_COMMENT", "WS", "SELECT", "INSERT", "UPDATE", "DELETE",
	"CREATE", "ALTER", "DROP", "TRUNCATE", "SCHEMA", "GRANT", "REVOKE", "ADD",
	"SET", "TABLE", "COLUMN", "INDEX", "CONSTRAINT", "PRIMARY", "UNIQUE", "FOREIGN",
	"KEY", "POSITION", "PRECISION", "FUNCTION", "TRIGGER", "PROCEDURE", "VIEW",
	"INTO", "VALUES", "WITH", "UNION", "DISTINCT", "CASE", "WHEN", "CAST",
	"TRIM", "SUBSTRING", "FROM", "NATURAL", "JOIN", "FULL", "INNER", "OUTER",
	"LEFT", "RIGHT", "CROSS", "USING", "WHERE", "AS", "ON", "IF", "ELSE", "THEN",
	"FOR", "TO", "AND", "OR", "IS", "NOT", "NULL", "TRUE", "FALSE", "EXISTS",
	"BETWEEN", "IN", "ALL", "ANY", "LIKE", "ORDER", "GROUP", "BY", "ASC", "DESC",
	"HAVING", "LIMIT", "OFFSET", "BEGIN", "COMMIT", "ROLLBACK", "SAVEPOINT",
	"BOOLEAN", "DOUBLE", "CHAR", "CHARACTER", "ARRAY", "INTERVAL", "DATE",
	"TIME", "TIMESTAMP", "LOCALTIME", "LOCALTIMESTAMP", "YEAR", "QUARTER",
	"MONTH", "WEEK", "DAY", "HOUR", "MINUTE", "SECOND", "MICROSECOND", "MAX",
	"MIN", "SUM", "COUNT", "AVG", "DEFAULT", "CURRENT", "ENABLE", "DISABLE",
	"CALL", "INSTANCE", "PRESERVE", "DO", "DEFINER", "CURRENT_USER", "SQL",
	"CASCADED", "LOCAL", "CLOSE", "OPEN", "NEXT", "NAME", "COLLATION", "NAMES",
	"INTEGER", "REAL", "DECIMAL", "TYPE", "VARCHAR", "FLOAT", "FOR_GENERATOR",
	"ADA", "C92", "CATALOG_NAME", "CHARACTER_SET_CATALOG", "CHARACTER_SET_NAME",
	"CHARACTER_SET_SCHEMA", "CLASS_ORIGIN", "COBOL", "COLLATION_CATALOG", "COLLATION_NAME",
	"COLLATION_SCHEMA", "COLUMN_NAME", "COMMAND_FUNCTION", "COMMITTED", "CONDITION_NUMBER",
	"CONNECTION_NAME", "CONSTRAINT_CATALOG", "CONSTRAINT_NAME", "CONSTRAINT_SCHEMA",
	"CURSOR_NAME", "DATA", "DATETIME_INTERVAL_CODE", "DATETIME_INTERVAL_PRECISION",
	"DYNAMIC_FUNCTION", "FORTRAN", "LENGTH", "MESSAGE_LENGTH", "MESSAGE_OCTET_LENGTH",
	"MESSAGE_TEXT", "MORE92", "MUMPS", "NULLABLE", "NUMBER", "PASCAL", "PLI",
	"REPEATABLE", "RETURNED_LENGTH", "RETURNED_OCTET_LENGTH", "RETURNED_SQLSTATE",
	"ROW_COUNT", "SCALE", "SCHEMA_NAME", "SERIALIZABLE", "SERVER_NAME", "SUBCLASS_ORIGIN",
	"TABLE_NAME", "UNCOMMITTED", "UNNAMED", "ABSOLUTE", "ACTION", "ALLOCATE",
	"ARE", "ASSERTION", "AT", "AUTHORIZATION", "BIT", "BIT_LENGTH", "BOTH",
	"CASCADE", "CATALOG", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHECK", "COALESCE",
	"COLLATE", "CONNECT", "CONNECTION", "CONSTRAINTS", "CONTINUE", "CONVERT",
	"CORRESPONDING", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURSOR",
	"DEALLOCATE", "DEC", "DECLARE", "DEFERRABLE", "DEFERRED", "DESCRIBE", "DESCRIPTOR",
	"DIAGNOSTICS", "DISCONNECT", "DOMAIN", "END", "END_EXEC", "ESCAPE", "EXCEPT",
	"EXCEPTION", "EXEC", "EXECUTE", "EXTERNAL", "EXTRACT", "FETCH", "FIRST",
	"FOUND", "GET", "GLOBAL", "GO", "GOTO", "IDENTITY", "IMMEDIATE", "INDICATOR",
	"INITIALLY", "INPUT", "INSENSITIVE", "INTERSECT", "ISOLATION", "LANGUAGE",
	"LAST", "LEADING", "LEVEL", "LOWER", "MATCH", "MODULE", "NATIONAL", "NCHAR",
	"NO", "NULLIF", "NUMERIC", "OCTET_LENGTH", "OF", "ONLY", "OPTION", "OUTPUT",
	"OVERLAPS", "PAD", "PARTIAL", "PREPARE", "PRIOR", "PRIVILEGES", "PUBLIC",
	"READ", "REFERENCES", "RELATIVE", "RESTRICT", "ROWS", "SCROLL", "SECTION",
	"SESSION", "SESSION_USER", "SIZE", "SMALLINT", "SOME", "SPACE", "SQLCODE",
	"SQLERROR", "SQLSTATE", "SYSTEM_USER", "TEMPORARY", "TIMEZONE_HOUR", "TIMEZONE_MINUTE",
	"TRAILING", "TRANSACTION", "TRANSLATE", "TRANSLATION", "UNKNOWN", "UPPER",
	"USAGE", "USER", "VALUE", "VARYING", "WHENEVER", "WORK", "WRITE", "ZONE",
	"IDENTIFIER_", "STRING_", "NUMBER_", "HEX_DIGIT_", "BIT_NUM_",
}

var ruleNames = []string{
	"execute", "insert", "insertValuesClause", "insertSelectClause", "update",
	"assignment", "setAssignmentsClause", "assignmentValues", "assignmentValue",
	"blobValue", "delete", "singleTableClause", "select", "unionClause", "selectClause",
	"selectSpecification", "duplicateSpecification", "projections", "projection",
	"alias", "unqualifiedShorthand", "qualifiedShorthand", "fromClause", "tableReferences",
	"escapedTableReference", "tableReference", "tableFactor", "joinedTable",
	"joinSpecification", "whereClause", "groupByClause", "havingClause", "limitClause",
	"limitRowCount", "limitOffset", "subquery", "parameterMarker", "literals",
	"stringLiterals", "numberLiterals", "dateTimeLiterals", "hexadecimalLiterals",
	"bitValueLiterals", "booleanLiterals", "nullValueLiterals", "identifier",
	"unreservedWord", "variable", "schemaName", "tableName", "columnName",
	"viewName", "owner", "name", "constraintName", "columnNames", "tableNames",
	"characterSetName", "expr", "andOperator", "orOperator", "notOperator",
	"booleanPrimary", "comparisonOperator", "predicate", "bitExpr", "simpleExpr",
	"functionCall", "aggregationFunction", "aggregationFunctionName", "distinct",
	"specialFunction", "castFunction", "convertFunction", "positionFunction",
	"substringFunction", "extractFunction", "trimFunction", "regularFunction",
	"regularFunctionName", "matchExpression", "caseExpression", "caseWhen",
	"caseElse", "intervalExpression", "intervalUnit", "orderByClause", "orderByItem",
	"dataType", "dataTypeName", "dataTypeLength", "characterSet", "collateClause",
	"ignoredIdentifier", "dropBehaviour", "createTable", "alterTable", "dropTable",
	"createDatabase", "dropDatabase", "createView", "dropView", "createTableSpecification",
	"createDefinitionClause", "createDatabaseSpecification_", "createDefinition",
	"columnDefinition", "dataTypeOption", "checkConstraintDefinition", "referenceDefinition",
	"referenceOption", "keyParts", "keyPart", "constraintDefinition", "primaryKeyOption",
	"primaryKey", "uniqueOption", "foreignKeyOption", "createLikeClause", "alterDefinitionClause",
	"addColumnSpecification", "modifyColumnSpecification", "dropColumnSpecification",
	"addConstraintSpecification", "dropConstraintSpecification", "setTransaction",
	"commit", "rollback", "levelOfIsolation", "grant", "revoke", "privilegeClause",
	"privileges", "privilegeType", "grantee", "onObjectClause", "objectType",
	"privilegeLevel",
}

type SQL92StatementParser struct {
	*antlr.BaseParser
}

// NewSQL92StatementParser produces a new parser instance for the optional input antlr.TokenStream.
//
// The *SQL92StatementParser instance produced may be reused by calling the SetInputStream method.
// The initial parser configuration is expensive to construct, and the object is not thread-safe;
// however, if used within a Golang sync.Pool, the construction cost amortizes well and the
// objects can be used in a thread-safe manner.
func NewSQL92StatementParser(input antlr.TokenStream) *SQL92StatementParser {
	this := new(SQL92StatementParser)
	deserializer := antlr.NewATNDeserializer(nil)
	deserializedATN := deserializer.DeserializeFromUInt16(parserATN)
	decisionToDFA := make([]*antlr.DFA, len(deserializedATN.DecisionToState))
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "SQL92Statement.g4"

	return this
}

// SQL92StatementParser tokens.
const (
	SQL92StatementParserEOF                         = antlr.TokenEOF
	SQL92StatementParserAND_                        = 1
	SQL92StatementParserCONCAT_                     = 2
	SQL92StatementParserNOT_                        = 3
	SQL92StatementParserTILDE_                      = 4
	SQL92StatementParserVERTICAL_BAR_               = 5
	SQL92StatementParserAMPERSAND_                  = 6
	SQL92StatementParserSIGNED_LEFT_SHIFT_          = 7
	SQL92StatementParserSIGNED_RIGHT_SHIFT_         = 8
	SQL92StatementParserCARET_                      = 9
	SQL92StatementParserMOD_                        = 10
	SQL92StatementParserCOLON_                      = 11
	SQL92StatementParserPLUS_                       = 12
	SQL92StatementParserMINUS_                      = 13
	SQL92StatementParserASTERISK_                   = 14
	SQL92StatementParserSLASH_                      = 15
	SQL92StatementParserBACKSLASH_                  = 16
	SQL92StatementParserDOT_                        = 17
	SQL92StatementParserDOT_ASTERISK_               = 18
	SQL92StatementParserSAFE_EQ_                    = 19
	SQL92StatementParserDEQ_                        = 20
	SQL92StatementParserEQ_                         = 21
	SQL92StatementParserNEQ_                        = 22
	SQL92StatementParserGT_                         = 23
	SQL92StatementParserGTE_                        = 24
	SQL92StatementParserLT_                         = 25
	SQL92StatementParserLTE_                        = 26
	SQL92StatementParserPOUND_                      = 27
	SQL92StatementParserLP_                         = 28
	SQL92StatementParserRP_                         = 29
	SQL92StatementParserLBE_                        = 30
	SQL92StatementParserRBE_                        = 31
	SQL92StatementParserLBT_                        = 32
	SQL92StatementParserRBT_                        = 33
	SQL92StatementParserCOMMA_                      = 34
	SQL92StatementParserDQ_                         = 35
	SQL92StatementParserSQ_                         = 36
	SQL92StatementParserQUESTION_                   = 37
	SQL92StatementParserAT_                         = 38
	SQL92StatementParserSEMI_                       = 39
	SQL92StatementParserINLINE_COMMENT              = 40
	SQL92StatementParserWS                          = 41
	SQL92StatementParserSELECT                      = 42
	SQL92StatementParserINSERT                      = 43
	SQL92StatementParserUPDATE                      = 44
	SQL92StatementParserDELETE                      = 45
	SQL92StatementParserCREATE                      = 46
	SQL92StatementParserALTER                       = 47
	SQL92StatementParserDROP                        = 48
	SQL92StatementParserTRUNCATE                    = 49
	SQL92StatementParserSCHEMA                      = 50
	SQL92StatementParserGRANT                       = 51
	SQL92StatementParserREVOKE                      = 52
	SQL92StatementParserADD                         = 53
	SQL92StatementParserSET                         = 54
	SQL92StatementParserTABLE                       = 55
	SQL92StatementParserCOLUMN                      = 56
	SQL92StatementParserINDEX                       = 57
	SQL92StatementParserCONSTRAINT                  = 58
	SQL92StatementParserPRIMARY                     = 59
	SQL92StatementParserUNIQUE                      = 60
	SQL92StatementParserFOREIGN                     = 61
	SQL92StatementParserKEY                         = 62
	SQL92StatementParserPOSITION                    = 63
	SQL92StatementParserPRECISION                   = 64
	SQL92StatementParserFUNCTION                    = 65
	SQL92StatementParserTRIGGER                     = 66
	SQL92StatementParserPROCEDURE                   = 67
	SQL92StatementParserVIEW                        = 68
	SQL92StatementParserINTO                        = 69
	SQL92StatementParserVALUES                      = 70
	SQL92StatementParserWITH                        = 71
	SQL92StatementParserUNION                       = 72
	SQL92StatementParserDISTINCT                    = 73
	SQL92StatementParserCASE                        = 74
	SQL92StatementParserWHEN                        = 75
	SQL92StatementParserCAST                        = 76
	SQL92StatementParserTRIM                        = 77
	SQL92StatementParserSUBSTRING                   = 78
	SQL92StatementParserFROM                        = 79
	SQL92StatementParserNATURAL                     = 80
	SQL92StatementParserJOIN                        = 81
	SQL92StatementParserFULL                        = 82
	SQL92StatementParserINNER                       = 83
	SQL92StatementParserOUTER                       = 84
	SQL92StatementParserLEFT                        = 85
	SQL92StatementParserRIGHT                       = 86
	SQL92StatementParserCROSS                       = 87
	SQL92StatementParserUSING                       = 88
	SQL92StatementParserWHERE                       = 89
	SQL92StatementParserAS                          = 90
	SQL92StatementParserON                          = 91
	SQL92StatementParserIF                          = 92
	SQL92StatementParserELSE                        = 93
	SQL92StatementParserTHEN                        = 94
	SQL92StatementParserFOR                         = 95
	SQL92StatementParserTO                          = 96
	SQL92StatementParserAND                         = 97
	SQL92StatementParserOR                          = 98
	SQL92StatementParserIS                          = 99
	SQL92StatementParserNOT                         = 100
	SQL92StatementParserNULL                        = 101
	SQL92StatementParserTRUE                        = 102
	SQL92StatementParserFALSE                       = 103
	SQL92StatementParserEXISTS                      = 104
	SQL92StatementParserBETWEEN                     = 105
	SQL92StatementParserIN                          = 106
	SQL92StatementParserALL                         = 107
	SQL92StatementParserANY                         = 108
	SQL92StatementParserLIKE                        = 109
	SQL92StatementParserORDER                       = 110
	SQL92StatementParserGROUP                       = 111
	SQL92StatementParserBY                          = 112
	SQL92StatementParserASC                         = 113
	SQL92StatementParserDESC                        = 114
	SQL92StatementParserHAVING                      = 115
	SQL92StatementParserLIMIT                       = 116
	SQL92StatementParserOFFSET                      = 117
	SQL92StatementParserBEGIN                       = 118
	SQL92StatementParserCOMMIT                      = 119
	SQL92StatementParserROLLBACK                    = 120
	SQL92StatementParserSAVEPOINT                   = 121
	SQL92StatementParserBOOLEAN                     = 122
	SQL92StatementParserDOUBLE                      = 123
	SQL92StatementParserCHAR                        = 124
	SQL92StatementParserCHARACTER                   = 125
	SQL92StatementParserARRAY                       = 126
	SQL92StatementParserINTERVAL                    = 127
	SQL92StatementParserDATE                        = 128
	SQL92StatementParserTIME                        = 129
	SQL92StatementParserTIMESTAMP                   = 130
	SQL92StatementParserLOCALTIME                   = 131
	SQL92StatementParserLOCALTIMESTAMP              = 132
	SQL92StatementParserYEAR                        = 133
	SQL92StatementParserQUARTER                     = 134
	SQL92StatementParserMONTH                       = 135
	SQL92StatementParserWEEK                        = 136
	SQL92StatementParserDAY                         = 137
	SQL92StatementParserHOUR                        = 138
	SQL92StatementParserMINUTE                      = 139
	SQL92StatementParserSECOND                      = 140
	SQL92StatementParserMICROSECOND                 = 141
	SQL92StatementParserMAX                         = 142
	SQL92StatementParserMIN                         = 143
	SQL92StatementParserSUM                         = 144
	SQL92StatementParserCOUNT                       = 145
	SQL92StatementParserAVG                         = 146
	SQL92StatementParserDEFAULT                     = 147
	SQL92StatementParserCURRENT                     = 148
	SQL92StatementParserENABLE                      = 149
	SQL92StatementParserDISABLE                     = 150
	SQL92StatementParserCALL                        = 151
	SQL92StatementParserINSTANCE                    = 152
	SQL92StatementParserPRESERVE                    = 153
	SQL92StatementParserDO                          = 154
	SQL92StatementParserDEFINER                     = 155
	SQL92StatementParserCURRENT_USER                = 156
	SQL92StatementParserSQL                         = 157
	SQL92StatementParserCASCADED                    = 158
	SQL92StatementParserLOCAL                       = 159
	SQL92StatementParserCLOSE                       = 160
	SQL92StatementParserOPEN                        = 161
	SQL92StatementParserNEXT                        = 162
	SQL92StatementParserNAME                        = 163
	SQL92StatementParserCOLLATION                   = 164
	SQL92StatementParserNAMES                       = 165
	SQL92StatementParserINTEGER                     = 166
	SQL92StatementParserREAL                        = 167
	SQL92StatementParserDECIMAL                     = 168
	SQL92StatementParserTYPE                        = 169
	SQL92StatementParserVARCHAR                     = 170
	SQL92StatementParserFLOAT                       = 171
	SQL92StatementParserFOR_GENERATOR               = 172
	SQL92StatementParserADA                         = 173
	SQL92StatementParserC92                         = 174
	SQL92StatementParserCATALOG_NAME                = 175
	SQL92StatementParserCHARACTER_SET_CATALOG       = 176
	SQL92StatementParserCHARACTER_SET_NAME          = 177
	SQL92StatementParserCHARACTER_SET_SCHEMA        = 178
	SQL92StatementParserCLASS_ORIGIN                = 179
	SQL92StatementParserCOBOL                       = 180
	SQL92StatementParserCOLLATION_CATALOG           = 181
	SQL92StatementParserCOLLATION_NAME              = 182
	SQL92StatementParserCOLLATION_SCHEMA            = 183
	SQL92StatementParserCOLUMN_NAME                 = 184
	SQL92StatementParserCOMMAND_FUNCTION            = 185
	SQL92StatementParserCOMMITTED                   = 186
	SQL92StatementParserCONDITION_NUMBER            = 187
	SQL92StatementParserCONNECTION_NAME             = 188
	SQL92StatementParserCONSTRAINT_CATALOG          = 189
	SQL92StatementParserCONSTRAINT_NAME             = 190
	SQL92StatementParserCONSTRAINT_SCHEMA           = 191
	SQL92StatementParserCURSOR_NAME                 = 192
	SQL92StatementParserDATA                        = 193
	SQL92StatementParserDATETIME_INTERVAL_CODE      = 194
	SQL92StatementParserDATETIME_INTERVAL_PRECISION = 195
	SQL92StatementParserDYNAMIC_FUNCTION            = 196
	SQL92StatementParserFORTRAN                     = 197
	SQL92StatementParserLENGTH                      = 198
	SQL92StatementParserMESSAGE_LENGTH              = 199
	SQL92StatementParserMESSAGE_OCTET_LENGTH        = 200
	SQL92StatementParserMESSAGE_TEXT                = 201
	SQL92StatementParserMORE92                      = 202
	SQL92StatementParserMUMPS                       = 203
	SQL92StatementParserNULLABLE                    = 204
	SQL92StatementParserNUMBER                      = 205
	SQL92StatementParserPASCAL                      = 206
	SQL92StatementParserPLI                         = 207
	SQL92StatementParserREPEATABLE                  = 208
	SQL92StatementParserRETURNED_LENGTH             = 209
	SQL92StatementParserRETURNED_OCTET_LENGTH       = 210
	SQL92StatementParserRETURNED_SQLSTATE           = 211
	SQL92StatementParserROW_COUNT                   = 212
	SQL92StatementParserSCALE                       = 213
	SQL92StatementParserSCHEMA_NAME                 = 214
	SQL92StatementParserSERIALIZABLE                = 215
	SQL92StatementParserSERVER_NAME                 = 216
	SQL92StatementParserSUBCLASS_ORIGIN             = 217
	SQL92StatementParserTABLE_NAME                  = 218
	SQL92StatementParserUNCOMMITTED                 = 219
	SQL92StatementParserUNNAMED                     = 220
	SQL92StatementParserABSOLUTE                    = 221
	SQL92StatementParserACTION                      = 222
	SQL92StatementParserALLOCATE                    = 223
	SQL92StatementParserARE                         = 224
	SQL92StatementParserASSERTION                   = 225
	SQL92StatementParserAT                          = 226
	SQL92StatementParserAUTHORIZATION               = 227
	SQL92StatementParserBIT                         = 228
	SQL92StatementParserBIT_LENGTH                  = 229
	SQL92StatementParserBOTH                        = 230
	SQL92StatementParserCASCADE                     = 231
	SQL92StatementParserCATALOG                     = 232
	SQL92StatementParserCHAR_LENGTH                 = 233
	SQL92StatementParserCHARACTER_LENGTH            = 234
	SQL92StatementParserCHECK                       = 235
	SQL92StatementParserCOALESCE                    = 236
	SQL92StatementParserCOLLATE                     = 237
	SQL92StatementParserCONNECT                     = 238
	SQL92StatementParserCONNECTION                  = 239
	SQL92StatementParserCONSTRAINTS                 = 240
	SQL92StatementParserCONTINUE                    = 241
	SQL92StatementParserCONVERT                     = 242
	SQL92StatementParserCORRESPONDING               = 243
	SQL92StatementParserCURRENT_DATE                = 244
	SQL92StatementParserCURRENT_TIME                = 245
	SQL92StatementParserCURRENT_TIMESTAMP           = 246
	SQL92StatementParserCURSOR                      = 247
	SQL92StatementParserDEALLOCATE                  = 248
	SQL92StatementParserDEC                         = 249
	SQL92StatementParserDECLARE                     = 250
	SQL92StatementParserDEFERRABLE                  = 251
	SQL92StatementParserDEFERRED                    = 252
	SQL92StatementParserDESCRIBE                    = 253
	SQL92StatementParserDESCRIPTOR                  = 254
	SQL92StatementParserDIAGNOSTICS                 = 255
	SQL92StatementParserDISCONNECT                  = 256
	SQL92StatementParserDOMAIN                      = 257
	SQL92StatementParserEND                         = 258
	SQL92StatementParserEND_EXEC                    = 259
	SQL92StatementParserESCAPE                      = 260
	SQL92StatementParserEXCEPT                      = 261
	SQL92StatementParserEXCEPTION                   = 262
	SQL92StatementParserEXEC                        = 263
	SQL92StatementParserEXECUTE                     = 264
	SQL92StatementParserEXTERNAL                    = 265
	SQL92StatementParserEXTRACT                     = 266
	SQL92StatementParserFETCH                       = 267
	SQL92StatementParserFIRST                       = 268
	SQL92StatementParserFOUND                       = 269
	SQL92StatementParserGET                         = 270
	SQL92StatementParserGLOBAL                      = 271
	SQL92StatementParserGO                          = 272
	SQL92StatementParserGOTO                        = 273
	SQL92StatementParserIDENTITY                    = 274
	SQL92StatementParserIMMEDIATE                   = 275
	SQL92StatementParserINDICATOR                   = 276
	SQL92StatementParserINITIALLY                   = 277
	SQL92StatementParserINPUT                       = 278
	SQL92StatementParserINSENSITIVE                 = 279
	SQL92StatementParserINTERSECT                   = 280
	SQL92StatementParserISOLATION                   = 281
	SQL92StatementParserLANGUAGE                    = 282
	SQL92StatementParserLAST                        = 283
	SQL92StatementParserLEADING                     = 284
	SQL92StatementParserLEVEL                       = 285
	SQL92StatementParserLOWER                       = 286
	SQL92StatementParserMATCH                       = 287
	SQL92StatementParserMODULE                      = 288
	SQL92StatementParserNATIONAL                    = 289
	SQL92StatementParserNCHAR                       = 290
	SQL92StatementParserNO                          = 291
	SQL92StatementParserNULLIF                      = 292
	SQL92StatementParserNUMERIC                     = 293
	SQL92StatementParserOCTET_LENGTH                = 294
	SQL92StatementParserOF                          = 295
	SQL92StatementParserONLY                        = 296
	SQL92StatementParserOPTION                      = 297
	SQL92StatementParserOUTPUT                      = 298
	SQL92StatementParserOVERLAPS                    = 299
	SQL92StatementParserPAD                         = 300
	SQL92StatementParserPARTIAL                     = 301
	SQL92StatementParserPREPARE                     = 302
	SQL92StatementParserPRIOR                       = 303
	SQL92StatementParserPRIVILEGES                  = 304
	SQL92StatementParserPUBLIC                      = 305
	SQL92StatementParserREAD                        = 306
	SQL92StatementParserREFERENCES                  = 307
	SQL92StatementParserRELATIVE                    = 308
	SQL92StatementParserRESTRICT                    = 309
	SQL92StatementParserROWS                        = 310
	SQL92StatementParserSCROLL                      = 311
	SQL92StatementParserSECTION                     = 312
	SQL92StatementParserSESSION                     = 313
	SQL92StatementParserSESSION_USER                = 314
	SQL92StatementParserSIZE                        = 315
	SQL92StatementParserSMALLINT                    = 316
	SQL92StatementParserSOME                        = 317
	SQL92StatementParserSPACE                       = 318
	SQL92StatementParserSQLCODE                     = 319
	SQL92StatementParserSQLERROR                    = 320
	SQL92StatementParserSQLSTATE                    = 321
	SQL92StatementParserSYSTEM_USER                 = 322
	SQL92StatementParserTEMPORARY                   = 323
	SQL92StatementParserTIMEZONE_HOUR               = 324
	SQL92StatementParserTIMEZONE_MINUTE             = 325
	SQL92StatementParserTRAILING                    = 326
	SQL92StatementParserTRANSACTION                 = 327
	SQL92StatementParserTRANSLATE                   = 328
	SQL92StatementParserTRANSLATION                 = 329
	SQL92StatementParserUNKNOWN                     = 330
	SQL92StatementParserUPPER                       = 331
	SQL92StatementParserUSAGE                       = 332
	SQL92StatementParserUSER                        = 333
	SQL92StatementParserVALUE                       = 334
	SQL92StatementParserVARYING                     = 335
	SQL92StatementParserWHENEVER                    = 336
	SQL92StatementParserWORK                        = 337
	SQL92StatementParserWRITE                       = 338
	SQL92StatementParserZONE                        = 339
	SQL92StatementParserIDENTIFIER_                 = 340
	SQL92StatementParserSTRING_                     = 341
	SQL92StatementParserNUMBER_                     = 342
	SQL92StatementParserHEX_DIGIT_                  = 343
	SQL92StatementParserBIT_NUM_                    = 344
)

// SQL92StatementParser rules.
const (
	SQL92StatementParserRULE_execute                      = 0
	SQL92StatementParserRULE_insert                       = 1
	SQL92StatementParserRULE_insertValuesClause           = 2
	SQL92StatementParserRULE_insertSelectClause           = 3
	SQL92StatementParserRULE_update                       = 4
	SQL92StatementParserRULE_assignment                   = 5
	SQL92StatementParserRULE_setAssignmentsClause         = 6
	SQL92StatementParserRULE_assignmentValues             = 7
	SQL92StatementParserRULE_assignmentValue              = 8
	SQL92StatementParserRULE_blobValue                    = 9
	SQL92StatementParserRULE_delete                       = 10
	SQL92StatementParserRULE_singleTableClause            = 11
	SQL92StatementParserRULE_select                       = 12
	SQL92StatementParserRULE_unionClause                  = 13
	SQL92StatementParserRULE_selectClause                 = 14
	SQL92StatementParserRULE_selectSpecification          = 15
	SQL92StatementParserRULE_duplicateSpecification       = 16
	SQL92StatementParserRULE_projections                  = 17
	SQL92StatementParserRULE_projection                   = 18
	SQL92StatementParserRULE_alias                        = 19
	SQL92StatementParserRULE_unqualifiedShorthand         = 20
	SQL92StatementParserRULE_qualifiedShorthand           = 21
	SQL92StatementParserRULE_fromClause                   = 22
	SQL92StatementParserRULE_tableReferences              = 23
	SQL92StatementParserRULE_escapedTableReference        = 24
	SQL92StatementParserRULE_tableReference               = 25
	SQL92StatementParserRULE_tableFactor                  = 26
	SQL92StatementParserRULE_joinedTable                  = 27
	SQL92StatementParserRULE_joinSpecification            = 28
	SQL92StatementParserRULE_whereClause                  = 29
	SQL92StatementParserRULE_groupByClause                = 30
	SQL92StatementParserRULE_havingClause                 = 31
	SQL92StatementParserRULE_limitClause                  = 32
	SQL92StatementParserRULE_limitRowCount                = 33
	SQL92StatementParserRULE_limitOffset                  = 34
	SQL92StatementParserRULE_subquery                     = 35
	SQL92StatementParserRULE_parameterMarker              = 36
	SQL92StatementParserRULE_literals                     = 37
	SQL92StatementParserRULE_stringLiterals               = 38
	SQL92StatementParserRULE_numberLiterals               = 39
	SQL92StatementParserRULE_dateTimeLiterals             = 40
	SQL92StatementParserRULE_hexadecimalLiterals          = 41
	SQL92StatementParserRULE_bitValueLiterals             = 42
	SQL92StatementParserRULE_booleanLiterals              = 43
	SQL92StatementParserRULE_nullValueLiterals            = 44
	SQL92StatementParserRULE_identifier                   = 45
	SQL92StatementParserRULE_unreservedWord               = 46
	SQL92StatementParserRULE_variable                     = 47
	SQL92StatementParserRULE_schemaName                   = 48
	SQL92StatementParserRULE_tableName                    = 49
	SQL92StatementParserRULE_columnName                   = 50
	SQL92StatementParserRULE_viewName                     = 51
	SQL92StatementParserRULE_owner                        = 52
	SQL92StatementParserRULE_name                         = 53
	SQL92StatementParserRULE_constraintName               = 54
	SQL92StatementParserRULE_columnNames                  = 55
	SQL92StatementParserRULE_tableNames                   = 56
	SQL92StatementParserRULE_characterSetName             = 57
	SQL92StatementParserRULE_expr                         = 58
	SQL92StatementParserRULE_andOperator                  = 59
	SQL92StatementParserRULE_orOperator                   = 60
	SQL92StatementParserRULE_notOperator                  = 61
	SQL92StatementParserRULE_booleanPrimary               = 62
	SQL92StatementParserRULE_comparisonOperator           = 63
	SQL92StatementParserRULE_predicate                    = 64
	SQL92StatementParserRULE_bitExpr                      = 65
	SQL92StatementParserRULE_simpleExpr                   = 66
	SQL92StatementParserRULE_functionCall                 = 67
	SQL92StatementParserRULE_aggregationFunction          = 68
	SQL92StatementParserRULE_aggregationFunctionName      = 69
	SQL92StatementParserRULE_distinct                     = 70
	SQL92StatementParserRULE_specialFunction              = 71
	SQL92StatementParserRULE_castFunction                 = 72
	SQL92StatementParserRULE_convertFunction              = 73
	SQL92StatementParserRULE_positionFunction             = 74
	SQL92StatementParserRULE_substringFunction            = 75
	SQL92StatementParserRULE_extractFunction              = 76
	SQL92StatementParserRULE_trimFunction                 = 77
	SQL92StatementParserRULE_regularFunction              = 78
	SQL92StatementParserRULE_regularFunctionName          = 79
	SQL92StatementParserRULE_matchExpression              = 80
	SQL92StatementParserRULE_caseExpression               = 81
	SQL92StatementParserRULE_caseWhen                     = 82
	SQL92StatementParserRULE_caseElse                     = 83
	SQL92StatementParserRULE_intervalExpression           = 84
	SQL92StatementParserRULE_intervalUnit                 = 85
	SQL92StatementParserRULE_orderByClause                = 86
	SQL92StatementParserRULE_orderByItem                  = 87
	SQL92StatementParserRULE_dataType                     = 88
	SQL92StatementParserRULE_dataTypeName                 = 89
	SQL92StatementParserRULE_dataTypeLength               = 90
	SQL92StatementParserRULE_characterSet                 = 91
	SQL92StatementParserRULE_collateClause                = 92
	SQL92StatementParserRULE_ignoredIdentifier            = 93
	SQL92StatementParserRULE_dropBehaviour                = 94
	SQL92StatementParserRULE_createTable                  = 95
	SQL92StatementParserRULE_alterTable                   = 96
	SQL92StatementParserRULE_dropTable                    = 97
	SQL92StatementParserRULE_createDatabase               = 98
	SQL92StatementParserRULE_dropDatabase                 = 99
	SQL92StatementParserRULE_createView                   = 100
	SQL92StatementParserRULE_dropView                     = 101
	SQL92StatementParserRULE_createTableSpecification     = 102
	SQL92StatementParserRULE_createDefinitionClause       = 103
	SQL92StatementParserRULE_createDatabaseSpecification_ = 104
	SQL92StatementParserRULE_createDefinition             = 105
	SQL92StatementParserRULE_columnDefinition             = 106
	SQL92StatementParserRULE_dataTypeOption               = 107
	SQL92StatementParserRULE_checkConstraintDefinition    = 108
	SQL92StatementParserRULE_referenceDefinition          = 109
	SQL92StatementParserRULE_referenceOption              = 110
	SQL92StatementParserRULE_keyParts                     = 111
	SQL92StatementParserRULE_keyPart                      = 112
	SQL92StatementParserRULE_constraintDefinition         = 113
	SQL92StatementParserRULE_primaryKeyOption             = 114
	SQL92StatementParserRULE_primaryKey                   = 115
	SQL92StatementParserRULE_uniqueOption                 = 116
	SQL92StatementParserRULE_foreignKeyOption             = 117
	SQL92StatementParserRULE_createLikeClause             = 118
	SQL92StatementParserRULE_alterDefinitionClause        = 119
	SQL92StatementParserRULE_addColumnSpecification       = 120
	SQL92StatementParserRULE_modifyColumnSpecification    = 121
	SQL92StatementParserRULE_dropColumnSpecification      = 122
	SQL92StatementParserRULE_addConstraintSpecification   = 123
	SQL92StatementParserRULE_dropConstraintSpecification  = 124
	SQL92StatementParserRULE_setTransaction               = 125
	SQL92StatementParserRULE_commit                       = 126
	SQL92StatementParserRULE_rollback                     = 127
	SQL92StatementParserRULE_levelOfIsolation             = 128
	SQL92StatementParserRULE_grant                        = 129
	SQL92StatementParserRULE_revoke                       = 130
	SQL92StatementParserRULE_privilegeClause              = 131
	SQL92StatementParserRULE_privileges                   = 132
	SQL92StatementParserRULE_privilegeType                = 133
	SQL92StatementParserRULE_grantee                      = 134
	SQL92StatementParserRULE_onObjectClause               = 135
	SQL92StatementParserRULE_objectType                   = 136
	SQL92StatementParserRULE_privilegeLevel               = 137
)

// IExecuteContext is an interface to support dynamic dispatch.
type IExecuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecuteContext differentiates from other interfaces.
	IsExecuteContext()
}

type ExecuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteContext() *ExecuteContext {
	var p = new(ExecuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_execute
	return p
}

func (*ExecuteContext) IsExecuteContext() {}

func NewExecuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteContext {
	var p = new(ExecuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_execute

	return p
}

func (s *ExecuteContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *ExecuteContext) Insert() IInsertContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *ExecuteContext) Update() IUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *ExecuteContext) Delete() IDeleteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeleteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeleteContext)
}

func (s *ExecuteContext) CreateDatabase() ICreateDatabaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDatabaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *ExecuteContext) DropDatabase() IDropDatabaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropDatabaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *ExecuteContext) CreateTable() ICreateTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *ExecuteContext) AlterTable() IAlterTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *ExecuteContext) DropTable() IDropTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropTableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *ExecuteContext) CreateView() ICreateViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateViewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *ExecuteContext) DropView() IDropViewContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropViewContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *ExecuteContext) SetTransaction() ISetTransactionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetTransactionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetTransactionContext)
}

func (s *ExecuteContext) Commit() ICommitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommitContext)
}

func (s *ExecuteContext) Rollback() IRollbackContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRollbackContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRollbackContext)
}

func (s *ExecuteContext) Grant() IGrantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGrantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *ExecuteContext) Revoke() IRevokeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRevokeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *ExecuteContext) SEMI_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSEMI_, 0)
}

func (s *ExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterExecute(s)
	}
}

func (s *ExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitExecute(s)
	}
}

func (s *ExecuteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitExecute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Execute() (localctx IExecuteContext) {
	this := p
	_ = this

	localctx = NewExecuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SQL92StatementParserRULE_execute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(276)
			p.Select()
		}

	case 2:
		{
			p.SetState(277)
			p.Insert()
		}

	case 3:
		{
			p.SetState(278)
			p.Update()
		}

	case 4:
		{
			p.SetState(279)
			p.Delete()
		}

	case 5:
		{
			p.SetState(280)
			p.CreateDatabase()
		}

	case 6:
		{
			p.SetState(281)
			p.DropDatabase()
		}

	case 7:
		{
			p.SetState(282)
			p.CreateTable()
		}

	case 8:
		{
			p.SetState(283)
			p.AlterTable()
		}

	case 9:
		{
			p.SetState(284)
			p.DropTable()
		}

	case 10:
		{
			p.SetState(285)
			p.CreateView()
		}

	case 11:
		{
			p.SetState(286)
			p.DropView()
		}

	case 12:
		{
			p.SetState(287)
			p.SetTransaction()
		}

	case 13:
		{
			p.SetState(288)
			p.Commit()
		}

	case 14:
		{
			p.SetState(289)
			p.Rollback()
		}

	case 15:
		{
			p.SetState(290)
			p.Grant()
		}

	case 16:
		{
			p.SetState(291)
			p.Revoke()
		}

	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserSEMI_ {
		{
			p.SetState(294)
			p.Match(SQL92StatementParserSEMI_)
		}

	}

	return localctx
}

// IInsertContext is an interface to support dynamic dispatch.
type IInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertContext differentiates from other interfaces.
	IsInsertContext()
}

type InsertContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertContext() *InsertContext {
	var p = new(InsertContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_insert
	return p
}

func (*InsertContext) IsInsertContext() {}

func NewInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertContext {
	var p = new(InsertContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_insert

	return p
}

func (s *InsertContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINSERT, 0)
}

func (s *InsertContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *InsertContext) InsertValuesClause() IInsertValuesClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertValuesClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertValuesClauseContext)
}

func (s *InsertContext) InsertSelectClause() IInsertSelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInsertSelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInsertSelectClauseContext)
}

func (s *InsertContext) INTO() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINTO, 0)
}

func (s *InsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterInsert(s)
	}
}

func (s *InsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitInsert(s)
	}
}

func (s *InsertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitInsert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Insert() (localctx IInsertContext) {
	this := p
	_ = this

	localctx = NewInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SQL92StatementParserRULE_insert)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(297)
		p.Match(SQL92StatementParserINSERT)
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserINTO {
		{
			p.SetState(298)
			p.Match(SQL92StatementParserINTO)
		}

	}
	{
		p.SetState(301)
		p.TableName()
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(302)
			p.InsertValuesClause()
		}

	case 2:
		{
			p.SetState(303)
			p.InsertSelectClause()
		}

	}

	return localctx
}

// IInsertValuesClauseContext is an interface to support dynamic dispatch.
type IInsertValuesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertValuesClauseContext differentiates from other interfaces.
	IsInsertValuesClauseContext()
}

type InsertValuesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesClauseContext() *InsertValuesClauseContext {
	var p = new(InsertValuesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_insertValuesClause
	return p
}

func (*InsertValuesClauseContext) IsInsertValuesClauseContext() {}

func NewInsertValuesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesClauseContext {
	var p = new(InsertValuesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_insertValuesClause

	return p
}

func (s *InsertValuesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesClauseContext) AllAssignmentValues() []IAssignmentValuesContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentValuesContext)(nil)).Elem())
	var tst = make([]IAssignmentValuesContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentValuesContext)
		}
	}

	return tst
}

func (s *InsertValuesClauseContext) AssignmentValues(i int) IAssignmentValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValuesContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValuesContext)
}

func (s *InsertValuesClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVALUES, 0)
}

func (s *InsertValuesClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVALUE, 0)
}

func (s *InsertValuesClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *InsertValuesClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *InsertValuesClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *InsertValuesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterInsertValuesClause(s)
	}
}

func (s *InsertValuesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitInsertValuesClause(s)
	}
}

func (s *InsertValuesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitInsertValuesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) InsertValuesClause() (localctx IInsertValuesClauseContext) {
	this := p
	_ = this

	localctx = NewInsertValuesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SQL92StatementParserRULE_insertValuesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ {
		{
			p.SetState(306)
			p.ColumnNames()
		}

	}
	{
		p.SetState(309)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserVALUES || _la == SQL92StatementParserVALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(310)
		p.AssignmentValues()
	}
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(311)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(312)
			p.AssignmentValues()
		}

		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInsertSelectClauseContext is an interface to support dynamic dispatch.
type IInsertSelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInsertSelectClauseContext differentiates from other interfaces.
	IsInsertSelectClauseContext()
}

type InsertSelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertSelectClauseContext() *InsertSelectClauseContext {
	var p = new(InsertSelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_insertSelectClause
	return p
}

func (*InsertSelectClauseContext) IsInsertSelectClauseContext() {}

func NewInsertSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertSelectClauseContext {
	var p = new(InsertSelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_insertSelectClause

	return p
}

func (s *InsertSelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertSelectClauseContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *InsertSelectClauseContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *InsertSelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertSelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertSelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterInsertSelectClause(s)
	}
}

func (s *InsertSelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitInsertSelectClause(s)
	}
}

func (s *InsertSelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitInsertSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) InsertSelectClause() (localctx IInsertSelectClauseContext) {
	this := p
	_ = this

	localctx = NewInsertSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SQL92StatementParserRULE_insertSelectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ {
		{
			p.SetState(318)
			p.ColumnNames()
		}

	}
	{
		p.SetState(321)
		p.Select()
	}

	return localctx
}

// IUpdateContext is an interface to support dynamic dispatch.
type IUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUpdateContext differentiates from other interfaces.
	IsUpdateContext()
}

type UpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateContext() *UpdateContext {
	var p = new(UpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_update
	return p
}

func (*UpdateContext) IsUpdateContext() {}

func NewUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateContext {
	var p = new(UpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_update

	return p
}

func (s *UpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUPDATE, 0)
}

func (s *UpdateContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *UpdateContext) SetAssignmentsClause() ISetAssignmentsClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetAssignmentsClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetAssignmentsClauseContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitUpdate(s)
	}
}

func (s *UpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Update() (localctx IUpdateContext) {
	this := p
	_ = this

	localctx = NewUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SQL92StatementParserRULE_update)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(323)
		p.Match(SQL92StatementParserUPDATE)
	}
	{
		p.SetState(324)
		p.TableReferences()
	}
	{
		p.SetState(325)
		p.SetAssignmentsClause()
	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserWHERE {
		{
			p.SetState(326)
			p.WhereClause()
		}

	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *AssignmentContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEQ_, 0)
}

func (s *AssignmentContext) AssignmentValue() IAssignmentValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValueContext)
}

func (s *AssignmentContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVALUES, 0)
}

func (s *AssignmentContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *AssignmentContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SQL92StatementParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		p.ColumnName()
	}
	{
		p.SetState(330)
		p.Match(SQL92StatementParserEQ_)
	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserVALUES {
		{
			p.SetState(331)
			p.Match(SQL92StatementParserVALUES)
		}

	}
	p.SetState(335)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(334)
			p.Match(SQL92StatementParserLP_)
		}

	}
	{
		p.SetState(337)
		p.AssignmentValue()
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserRP_ {
		{
			p.SetState(338)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// ISetAssignmentsClauseContext is an interface to support dynamic dispatch.
type ISetAssignmentsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetAssignmentsClauseContext differentiates from other interfaces.
	IsSetAssignmentsClauseContext()
}

type SetAssignmentsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetAssignmentsClauseContext() *SetAssignmentsClauseContext {
	var p = new(SetAssignmentsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_setAssignmentsClause
	return p
}

func (*SetAssignmentsClauseContext) IsSetAssignmentsClauseContext() {}

func NewSetAssignmentsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetAssignmentsClauseContext {
	var p = new(SetAssignmentsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_setAssignmentsClause

	return p
}

func (s *SetAssignmentsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SetAssignmentsClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSET, 0)
}

func (s *SetAssignmentsClauseContext) AllAssignment() []IAssignmentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentContext)(nil)).Elem())
	var tst = make([]IAssignmentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentContext)
		}
	}

	return tst
}

func (s *SetAssignmentsClauseContext) Assignment(i int) IAssignmentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *SetAssignmentsClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *SetAssignmentsClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *SetAssignmentsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAssignmentsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetAssignmentsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSetAssignmentsClause(s)
	}
}

func (s *SetAssignmentsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSetAssignmentsClause(s)
	}
}

func (s *SetAssignmentsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSetAssignmentsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SetAssignmentsClause() (localctx ISetAssignmentsClauseContext) {
	this := p
	_ = this

	localctx = NewSetAssignmentsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SQL92StatementParserRULE_setAssignmentsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(341)
		p.Match(SQL92StatementParserSET)
	}
	{
		p.SetState(342)
		p.Assignment()
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(343)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(344)
			p.Assignment()
		}

		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentValuesContext is an interface to support dynamic dispatch.
type IAssignmentValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentValuesContext differentiates from other interfaces.
	IsAssignmentValuesContext()
}

type AssignmentValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValuesContext() *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_assignmentValues
	return p
}

func (*AssignmentValuesContext) IsAssignmentValuesContext() {}

func NewAssignmentValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValuesContext {
	var p = new(AssignmentValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_assignmentValues

	return p
}

func (s *AssignmentValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValuesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *AssignmentValuesContext) AllAssignmentValue() []IAssignmentValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem())
	var tst = make([]IAssignmentValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentValueContext)
		}
	}

	return tst
}

func (s *AssignmentValuesContext) AssignmentValue(i int) IAssignmentValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentValueContext)
}

func (s *AssignmentValuesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *AssignmentValuesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *AssignmentValuesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *AssignmentValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAssignmentValues(s)
	}
}

func (s *AssignmentValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAssignmentValues(s)
	}
}

func (s *AssignmentValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAssignmentValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AssignmentValues() (localctx IAssignmentValuesContext) {
	this := p
	_ = this

	localctx = NewAssignmentValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SQL92StatementParserRULE_assignmentValues)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(350)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(351)
			p.AssignmentValue()
		}
		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(352)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(353)
				p.AssignmentValue()
			}

			p.SetState(358)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(359)
			p.Match(SQL92StatementParserRP_)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(361)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(362)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// IAssignmentValueContext is an interface to support dynamic dispatch.
type IAssignmentValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentValueContext differentiates from other interfaces.
	IsAssignmentValueContext()
}

type AssignmentValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentValueContext() *AssignmentValueContext {
	var p = new(AssignmentValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_assignmentValue
	return p
}

func (*AssignmentValueContext) IsAssignmentValueContext() {}

func NewAssignmentValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentValueContext {
	var p = new(AssignmentValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_assignmentValue

	return p
}

func (s *AssignmentValueContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentValueContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AssignmentValueContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDEFAULT, 0)
}

func (s *AssignmentValueContext) BlobValue() IBlobValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlobValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlobValueContext)
}

func (s *AssignmentValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAssignmentValue(s)
	}
}

func (s *AssignmentValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAssignmentValue(s)
	}
}

func (s *AssignmentValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAssignmentValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AssignmentValue() (localctx IAssignmentValueContext) {
	this := p
	_ = this

	localctx = NewAssignmentValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SQL92StatementParserRULE_assignmentValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(365)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(366)
			p.Match(SQL92StatementParserDEFAULT)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(367)
			p.BlobValue()
		}

	}

	return localctx
}

// IBlobValueContext is an interface to support dynamic dispatch.
type IBlobValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlobValueContext differentiates from other interfaces.
	IsBlobValueContext()
}

type BlobValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlobValueContext() *BlobValueContext {
	var p = new(BlobValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_blobValue
	return p
}

func (*BlobValueContext) IsBlobValueContext() {}

func NewBlobValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlobValueContext {
	var p = new(BlobValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_blobValue

	return p
}

func (s *BlobValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BlobValueContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *BlobValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlobValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlobValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterBlobValue(s)
	}
}

func (s *BlobValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitBlobValue(s)
	}
}

func (s *BlobValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitBlobValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) BlobValue() (localctx IBlobValueContext) {
	this := p
	_ = this

	localctx = NewBlobValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SQL92StatementParserRULE_blobValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.Match(SQL92StatementParserSTRING_)
	}

	return localctx
}

// IDeleteContext is an interface to support dynamic dispatch.
type IDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteContext differentiates from other interfaces.
	IsDeleteContext()
}

type DeleteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteContext() *DeleteContext {
	var p = new(DeleteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_delete
	return p
}

func (*DeleteContext) IsDeleteContext() {}

func NewDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteContext {
	var p = new(DeleteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_delete

	return p
}

func (s *DeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDELETE, 0)
}

func (s *DeleteContext) SingleTableClause() ISingleTableClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTableClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleTableClauseContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDelete(s)
	}
}

func (s *DeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDelete(s)
	}
}

func (s *DeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Delete() (localctx IDeleteContext) {
	this := p
	_ = this

	localctx = NewDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SQL92StatementParserRULE_delete)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(SQL92StatementParserDELETE)
	}
	{
		p.SetState(373)
		p.SingleTableClause()
	}
	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserWHERE {
		{
			p.SetState(374)
			p.WhereClause()
		}

	}

	return localctx
}

// ISingleTableClauseContext is an interface to support dynamic dispatch.
type ISingleTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleTableClauseContext differentiates from other interfaces.
	IsSingleTableClauseContext()
}

type SingleTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableClauseContext() *SingleTableClauseContext {
	var p = new(SingleTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_singleTableClause
	return p
}

func (*SingleTableClauseContext) IsSingleTableClauseContext() {}

func NewSingleTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableClauseContext {
	var p = new(SingleTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_singleTableClause

	return p
}

func (s *SingleTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *SingleTableClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *SingleTableClauseContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *SingleTableClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAS, 0)
}

func (s *SingleTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSingleTableClause(s)
	}
}

func (s *SingleTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSingleTableClause(s)
	}
}

func (s *SingleTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSingleTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SingleTableClause() (localctx ISingleTableClauseContext) {
	this := p
	_ = this

	localctx = NewSingleTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SQL92StatementParserRULE_singleTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(378)
		p.TableName()
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserAS || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ || _la == SQL92StatementParserSTRING_ {
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserAS {
			{
				p.SetState(379)
				p.Match(SQL92StatementParserAS)
			}

		}
		{
			p.SetState(382)
			p.Alias()
		}

	}

	return localctx
}

// ISelectContext is an interface to support dynamic dispatch.
type ISelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectContext differentiates from other interfaces.
	IsSelectContext()
}

type SelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectContext() *SelectContext {
	var p = new(SelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_select
	return p
}

func (*SelectContext) IsSelectContext() {}

func NewSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectContext {
	var p = new(SelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_select

	return p
}

func (s *SelectContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectContext) UnionClause() IUnionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionClauseContext)
}

func (s *SelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSelect(s)
	}
}

func (s *SelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSelect(s)
	}
}

func (s *SelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Select() (localctx ISelectContext) {
	this := p
	_ = this

	localctx = NewSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SQL92StatementParserRULE_select)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.UnionClause()
	}

	return localctx
}

// IUnionClauseContext is an interface to support dynamic dispatch.
type IUnionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionClauseContext differentiates from other interfaces.
	IsUnionClauseContext()
}

type UnionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionClauseContext() *UnionClauseContext {
	var p = new(UnionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_unionClause
	return p
}

func (*UnionClauseContext) IsUnionClauseContext() {}

func NewUnionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionClauseContext {
	var p = new(UnionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_unionClause

	return p
}

func (s *UnionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionClauseContext) AllSelectClause() []ISelectClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem())
	var tst = make([]ISelectClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectClauseContext)
		}
	}

	return tst
}

func (s *UnionClauseContext) SelectClause(i int) ISelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *UnionClauseContext) AllUNION() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserUNION)
}

func (s *UnionClauseContext) UNION(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNION, i)
}

func (s *UnionClauseContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserALL)
}

func (s *UnionClauseContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALL, i)
}

func (s *UnionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterUnionClause(s)
	}
}

func (s *UnionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitUnionClause(s)
	}
}

func (s *UnionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitUnionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) UnionClause() (localctx IUnionClauseContext) {
	this := p
	_ = this

	localctx = NewUnionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SQL92StatementParserRULE_unionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.SelectClause()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserUNION {
		{
			p.SetState(388)
			p.Match(SQL92StatementParserUNION)
		}
		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserALL {
			{
				p.SetState(389)
				p.Match(SQL92StatementParserALL)
			}

		}
		{
			p.SetState(392)
			p.SelectClause()
		}

		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSELECT, 0)
}

func (s *SelectClauseContext) Projections() IProjectionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProjectionsContext)
}

func (s *SelectClauseContext) AllSelectSpecification() []ISelectSpecificationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectSpecificationContext)(nil)).Elem())
	var tst = make([]ISelectSpecificationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectSpecificationContext)
		}
	}

	return tst
}

func (s *SelectClauseContext) SelectSpecification(i int) ISelectSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectSpecificationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectSpecificationContext)
}

func (s *SelectClauseContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *SelectClauseContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *SelectClauseContext) GroupByClause() IGroupByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *SelectClauseContext) HavingClause() IHavingClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHavingClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *SelectClauseContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *SelectClauseContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SelectClause() (localctx ISelectClauseContext) {
	this := p
	_ = this

	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SQL92StatementParserRULE_selectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(398)
		p.Match(SQL92StatementParserSELECT)
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserDISTINCT || _la == SQL92StatementParserALL {
		{
			p.SetState(399)
			p.SelectSpecification()
		}

		p.SetState(404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(405)
		p.Projections()
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserFROM {
		{
			p.SetState(406)
			p.FromClause()
		}

	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserWHERE {
		{
			p.SetState(409)
			p.WhereClause()
		}

	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserGROUP {
		{
			p.SetState(412)
			p.GroupByClause()
		}

	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserHAVING {
		{
			p.SetState(415)
			p.HavingClause()
		}

	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserORDER {
		{
			p.SetState(418)
			p.OrderByClause()
		}

	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLIMIT {
		{
			p.SetState(421)
			p.LimitClause()
		}

	}

	return localctx
}

// ISelectSpecificationContext is an interface to support dynamic dispatch.
type ISelectSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectSpecificationContext differentiates from other interfaces.
	IsSelectSpecificationContext()
}

type SelectSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecificationContext() *SelectSpecificationContext {
	var p = new(SelectSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_selectSpecification
	return p
}

func (*SelectSpecificationContext) IsSelectSpecificationContext() {}

func NewSelectSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecificationContext {
	var p = new(SelectSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_selectSpecification

	return p
}

func (s *SelectSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecificationContext) DuplicateSpecification() IDuplicateSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDuplicateSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDuplicateSpecificationContext)
}

func (s *SelectSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSelectSpecification(s)
	}
}

func (s *SelectSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSelectSpecification(s)
	}
}

func (s *SelectSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSelectSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SelectSpecification() (localctx ISelectSpecificationContext) {
	this := p
	_ = this

	localctx = NewSelectSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SQL92StatementParserRULE_selectSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.DuplicateSpecification()
	}

	return localctx
}

// IDuplicateSpecificationContext is an interface to support dynamic dispatch.
type IDuplicateSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDuplicateSpecificationContext differentiates from other interfaces.
	IsDuplicateSpecificationContext()
}

type DuplicateSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDuplicateSpecificationContext() *DuplicateSpecificationContext {
	var p = new(DuplicateSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_duplicateSpecification
	return p
}

func (*DuplicateSpecificationContext) IsDuplicateSpecificationContext() {}

func NewDuplicateSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DuplicateSpecificationContext {
	var p = new(DuplicateSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_duplicateSpecification

	return p
}

func (s *DuplicateSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DuplicateSpecificationContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALL, 0)
}

func (s *DuplicateSpecificationContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDISTINCT, 0)
}

func (s *DuplicateSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DuplicateSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DuplicateSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDuplicateSpecification(s)
	}
}

func (s *DuplicateSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDuplicateSpecification(s)
	}
}

func (s *DuplicateSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDuplicateSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DuplicateSpecification() (localctx IDuplicateSpecificationContext) {
	this := p
	_ = this

	localctx = NewDuplicateSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SQL92StatementParserRULE_duplicateSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserDISTINCT || _la == SQL92StatementParserALL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IProjectionsContext is an interface to support dynamic dispatch.
type IProjectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionsContext differentiates from other interfaces.
	IsProjectionsContext()
}

type ProjectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionsContext() *ProjectionsContext {
	var p = new(ProjectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_projections
	return p
}

func (*ProjectionsContext) IsProjectionsContext() {}

func NewProjectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionsContext {
	var p = new(ProjectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_projections

	return p
}

func (s *ProjectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionsContext) UnqualifiedShorthand() IUnqualifiedShorthandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualifiedShorthandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedShorthandContext)
}

func (s *ProjectionsContext) AllProjection() []IProjectionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IProjectionContext)(nil)).Elem())
	var tst = make([]IProjectionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IProjectionContext)
		}
	}

	return tst
}

func (s *ProjectionsContext) Projection(i int) IProjectionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProjectionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IProjectionContext)
}

func (s *ProjectionsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *ProjectionsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *ProjectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterProjections(s)
	}
}

func (s *ProjectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitProjections(s)
	}
}

func (s *ProjectionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitProjections(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Projections() (localctx IProjectionsContext) {
	this := p
	_ = this

	localctx = NewProjectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SQL92StatementParserRULE_projections)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(430)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserASTERISK_:
		{
			p.SetState(428)
			p.UnqualifiedShorthand()
		}

	case SQL92StatementParserNOT_, SQL92StatementParserTILDE_, SQL92StatementParserPLUS_, SQL92StatementParserMINUS_, SQL92StatementParserDOT_, SQL92StatementParserLP_, SQL92StatementParserLBE_, SQL92StatementParserQUESTION_, SQL92StatementParserAT_, SQL92StatementParserPOSITION, SQL92StatementParserCASE, SQL92StatementParserCAST, SQL92StatementParserTRIM, SQL92StatementParserSUBSTRING, SQL92StatementParserIF, SQL92StatementParserNOT, SQL92StatementParserNULL, SQL92StatementParserTRUE, SQL92StatementParserFALSE, SQL92StatementParserEXISTS, SQL92StatementParserINTERVAL, SQL92StatementParserDATE, SQL92StatementParserTIME, SQL92StatementParserTIMESTAMP, SQL92StatementParserLOCALTIME, SQL92StatementParserLOCALTIMESTAMP, SQL92StatementParserMAX, SQL92StatementParserMIN, SQL92StatementParserSUM, SQL92StatementParserCOUNT, SQL92StatementParserAVG, SQL92StatementParserLOCAL, SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserCONVERT, SQL92StatementParserCURRENT_TIMESTAMP, SQL92StatementParserEXTRACT, SQL92StatementParserGLOBAL, SQL92StatementParserIDENTIFIER_, SQL92StatementParserSTRING_, SQL92StatementParserNUMBER_, SQL92StatementParserHEX_DIGIT_, SQL92StatementParserBIT_NUM_:
		{
			p.SetState(429)
			p.Projection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(432)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(433)
			p.Projection()
		}

		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProjectionContext is an interface to support dynamic dispatch.
type IProjectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProjectionContext differentiates from other interfaces.
	IsProjectionContext()
}

type ProjectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectionContext() *ProjectionContext {
	var p = new(ProjectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_projection
	return p
}

func (*ProjectionContext) IsProjectionContext() {}

func NewProjectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectionContext {
	var p = new(ProjectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_projection

	return p
}

func (s *ProjectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ProjectionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ProjectionContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *ProjectionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAS, 0)
}

func (s *ProjectionContext) QualifiedShorthand() IQualifiedShorthandContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedShorthandContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedShorthandContext)
}

func (s *ProjectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterProjection(s)
	}
}

func (s *ProjectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitProjection(s)
	}
}

func (s *ProjectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitProjection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Projection() (localctx IProjectionContext) {
	this := p
	_ = this

	localctx = NewProjectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SQL92StatementParserRULE_projection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(439)
				p.ColumnName()
			}

		case 2:
			{
				p.SetState(440)
				p.expr(0)
			}

		}
		p.SetState(447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserAS || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ || _la == SQL92StatementParserSTRING_ {
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQL92StatementParserAS {
				{
					p.SetState(443)
					p.Match(SQL92StatementParserAS)
				}

			}
			{
				p.SetState(446)
				p.Alias()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(449)
			p.QualifiedShorthand()
		}

	}

	return localctx
}

// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_alias
	return p
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAlias(s)
	}
}

func (s *AliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAlias(s)
	}
}

func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Alias() (localctx IAliasContext) {
	this := p
	_ = this

	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SQL92StatementParserRULE_alias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(454)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(452)
			p.Identifier()
		}

	case SQL92StatementParserSTRING_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(453)
			p.Match(SQL92StatementParserSTRING_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnqualifiedShorthandContext is an interface to support dynamic dispatch.
type IUnqualifiedShorthandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnqualifiedShorthandContext differentiates from other interfaces.
	IsUnqualifiedShorthandContext()
}

type UnqualifiedShorthandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualifiedShorthandContext() *UnqualifiedShorthandContext {
	var p = new(UnqualifiedShorthandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_unqualifiedShorthand
	return p
}

func (*UnqualifiedShorthandContext) IsUnqualifiedShorthandContext() {}

func NewUnqualifiedShorthandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnqualifiedShorthandContext {
	var p = new(UnqualifiedShorthandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_unqualifiedShorthand

	return p
}

func (s *UnqualifiedShorthandContext) GetParser() antlr.Parser { return s.parser }

func (s *UnqualifiedShorthandContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASTERISK_, 0)
}

func (s *UnqualifiedShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedShorthandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnqualifiedShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterUnqualifiedShorthand(s)
	}
}

func (s *UnqualifiedShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitUnqualifiedShorthand(s)
	}
}

func (s *UnqualifiedShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitUnqualifiedShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) UnqualifiedShorthand() (localctx IUnqualifiedShorthandContext) {
	this := p
	_ = this

	localctx = NewUnqualifiedShorthandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SQL92StatementParserRULE_unqualifiedShorthand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Match(SQL92StatementParserASTERISK_)
	}

	return localctx
}

// IQualifiedShorthandContext is an interface to support dynamic dispatch.
type IQualifiedShorthandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedShorthandContext differentiates from other interfaces.
	IsQualifiedShorthandContext()
}

type QualifiedShorthandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedShorthandContext() *QualifiedShorthandContext {
	var p = new(QualifiedShorthandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_qualifiedShorthand
	return p
}

func (*QualifiedShorthandContext) IsQualifiedShorthandContext() {}

func NewQualifiedShorthandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedShorthandContext {
	var p = new(QualifiedShorthandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_qualifiedShorthand

	return p
}

func (s *QualifiedShorthandContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedShorthandContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedShorthandContext) DOT_ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_ASTERISK_, 0)
}

func (s *QualifiedShorthandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedShorthandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedShorthandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterQualifiedShorthand(s)
	}
}

func (s *QualifiedShorthandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitQualifiedShorthand(s)
	}
}

func (s *QualifiedShorthandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitQualifiedShorthand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) QualifiedShorthand() (localctx IQualifiedShorthandContext) {
	this := p
	_ = this

	localctx = NewQualifiedShorthandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SQL92StatementParserRULE_qualifiedShorthand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Identifier()
	}
	{
		p.SetState(459)
		p.Match(SQL92StatementParserDOT_ASTERISK_)
	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *FromClauseContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) FromClause() (localctx IFromClauseContext) {
	this := p
	_ = this

	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SQL92StatementParserRULE_fromClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(462)
		p.TableReferences()
	}

	return localctx
}

// ITableReferencesContext is an interface to support dynamic dispatch.
type ITableReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableReferencesContext differentiates from other interfaces.
	IsTableReferencesContext()
}

type TableReferencesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferencesContext() *TableReferencesContext {
	var p = new(TableReferencesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_tableReferences
	return p
}

func (*TableReferencesContext) IsTableReferencesContext() {}

func NewTableReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferencesContext {
	var p = new(TableReferencesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_tableReferences

	return p
}

func (s *TableReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferencesContext) AllEscapedTableReference() []IEscapedTableReferenceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedTableReferenceContext)(nil)).Elem())
	var tst = make([]IEscapedTableReferenceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedTableReferenceContext)
		}
	}

	return tst
}

func (s *TableReferencesContext) EscapedTableReference(i int) IEscapedTableReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedTableReferenceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedTableReferenceContext)
}

func (s *TableReferencesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *TableReferencesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *TableReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTableReferences(s)
	}
}

func (s *TableReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTableReferences(s)
	}
}

func (s *TableReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTableReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TableReferences() (localctx ITableReferencesContext) {
	this := p
	_ = this

	localctx = NewTableReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SQL92StatementParserRULE_tableReferences)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.EscapedTableReference()
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(465)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(466)
			p.EscapedTableReference()
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEscapedTableReferenceContext is an interface to support dynamic dispatch.
type IEscapedTableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscapedTableReferenceContext differentiates from other interfaces.
	IsEscapedTableReferenceContext()
}

type EscapedTableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedTableReferenceContext() *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_escapedTableReference
	return p
}

func (*EscapedTableReferenceContext) IsEscapedTableReferenceContext() {}

func NewEscapedTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_escapedTableReference

	return p
}

func (s *EscapedTableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedTableReferenceContext) TableReference() ITableReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *EscapedTableReferenceContext) LBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLBE_, 0)
}

func (s *EscapedTableReferenceContext) RBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRBE_, 0)
}

func (s *EscapedTableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedTableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedTableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitEscapedTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) EscapedTableReference() (localctx IEscapedTableReferenceContext) {
	this := p
	_ = this

	localctx = NewEscapedTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SQL92StatementParserRULE_escapedTableReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserLP_, SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(472)
			p.TableReference()
		}

	case SQL92StatementParserLBE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(473)
			p.Match(SQL92StatementParserLBE_)
		}
		{
			p.SetState(474)
			p.TableReference()
		}
		{
			p.SetState(475)
			p.Match(SQL92StatementParserRBE_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_tableReference
	return p
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TableFactor() ITableFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *TableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinedTableContext)(nil)).Elem())
	var tst = make([]IJoinedTableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinedTableContext)
		}
	}

	return tst
}

func (s *TableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinedTableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (s *TableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TableReference() (localctx ITableReferenceContext) {
	this := p
	_ = this

	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SQL92StatementParserRULE_tableReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		p.TableFactor()
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(SQL92StatementParserNATURAL-80))|(1<<(SQL92StatementParserJOIN-80))|(1<<(SQL92StatementParserINNER-80))|(1<<(SQL92StatementParserLEFT-80))|(1<<(SQL92StatementParserRIGHT-80))|(1<<(SQL92StatementParserCROSS-80)))) != 0 {
		{
			p.SetState(480)
			p.JoinedTable()
		}

		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableFactorContext is an interface to support dynamic dispatch.
type ITableFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableFactorContext differentiates from other interfaces.
	IsTableFactorContext()
}

type TableFactorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFactorContext() *TableFactorContext {
	var p = new(TableFactorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_tableFactor
	return p
}

func (*TableFactorContext) IsTableFactorContext() {}

func NewTableFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFactorContext {
	var p = new(TableFactorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_tableFactor

	return p
}

func (s *TableFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFactorContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableFactorContext) Alias() IAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *TableFactorContext) AS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAS, 0)
}

func (s *TableFactorContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *TableFactorContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *TableFactorContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *TableFactorContext) TableReferences() ITableReferencesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableReferencesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableReferencesContext)
}

func (s *TableFactorContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *TableFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTableFactor(s)
	}
}

func (s *TableFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTableFactor(s)
	}
}

func (s *TableFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTableFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TableFactor() (localctx ITableFactorContext) {
	this := p
	_ = this

	localctx = NewTableFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SQL92StatementParserRULE_tableFactor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(486)
			p.TableName()
		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserAS || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ || _la == SQL92StatementParserSTRING_ {
			p.SetState(488)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == SQL92StatementParserAS {
				{
					p.SetState(487)
					p.Match(SQL92StatementParserAS)
				}

			}
			{
				p.SetState(490)
				p.Alias()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(493)
			p.Subquery()
		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserAS {
			{
				p.SetState(494)
				p.Match(SQL92StatementParserAS)
			}

		}
		{
			p.SetState(497)
			p.Alias()
		}
		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserLP_ || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ {
			{
				p.SetState(498)
				p.ColumnNames()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(501)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(502)
			p.TableReferences()
		}
		{
			p.SetState(503)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// IJoinedTableContext is an interface to support dynamic dispatch.
type IJoinedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinedTableContext differentiates from other interfaces.
	IsJoinedTableContext()
}

type JoinedTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedTableContext() *JoinedTableContext {
	var p = new(JoinedTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_joinedTable
	return p
}

func (*JoinedTableContext) IsJoinedTableContext() {}

func NewJoinedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedTableContext {
	var p = new(JoinedTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_joinedTable

	return p
}

func (s *JoinedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedTableContext) TableFactor() ITableFactorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableFactorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *JoinedTableContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserJOIN, 0)
}

func (s *JoinedTableContext) JoinSpecification() IJoinSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinSpecificationContext)
}

func (s *JoinedTableContext) INNER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINNER, 0)
}

func (s *JoinedTableContext) CROSS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCROSS, 0)
}

func (s *JoinedTableContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLEFT, 0)
}

func (s *JoinedTableContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRIGHT, 0)
}

func (s *JoinedTableContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOUTER, 0)
}

func (s *JoinedTableContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNATURAL, 0)
}

func (s *JoinedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterJoinedTable(s)
	}
}

func (s *JoinedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitJoinedTable(s)
	}
}

func (s *JoinedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitJoinedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) JoinedTable() (localctx IJoinedTableContext) {
	this := p
	_ = this

	localctx = NewJoinedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SQL92StatementParserRULE_joinedTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(532)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserJOIN, SQL92StatementParserINNER, SQL92StatementParserCROSS:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserINNER || _la == SQL92StatementParserCROSS {
			{
				p.SetState(507)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQL92StatementParserINNER || _la == SQL92StatementParserCROSS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(510)
			p.Match(SQL92StatementParserJOIN)
		}

		{
			p.SetState(512)
			p.TableFactor()
		}
		p.SetState(514)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserUSING || _la == SQL92StatementParserON {
			{
				p.SetState(513)
				p.JoinSpecification()
			}

		}

	case SQL92StatementParserLEFT, SQL92StatementParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(516)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserLEFT || _la == SQL92StatementParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserOUTER {
			{
				p.SetState(517)
				p.Match(SQL92StatementParserOUTER)
			}

		}
		{
			p.SetState(520)
			p.Match(SQL92StatementParserJOIN)
		}
		{
			p.SetState(521)
			p.TableFactor()
		}
		{
			p.SetState(522)
			p.JoinSpecification()
		}

	case SQL92StatementParserNATURAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(524)
			p.Match(SQL92StatementParserNATURAL)
		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case SQL92StatementParserINNER:
			{
				p.SetState(525)
				p.Match(SQL92StatementParserINNER)
			}

		case SQL92StatementParserLEFT, SQL92StatementParserRIGHT:
			{
				p.SetState(526)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQL92StatementParserLEFT || _la == SQL92StatementParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			{
				p.SetState(527)
				p.Match(SQL92StatementParserOUTER)
			}

		case SQL92StatementParserJOIN:

		default:
		}
		{
			p.SetState(530)
			p.Match(SQL92StatementParserJOIN)
		}
		{
			p.SetState(531)
			p.TableFactor()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinSpecificationContext is an interface to support dynamic dispatch.
type IJoinSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinSpecificationContext differentiates from other interfaces.
	IsJoinSpecificationContext()
}

type JoinSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinSpecificationContext() *JoinSpecificationContext {
	var p = new(JoinSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_joinSpecification
	return p
}

func (*JoinSpecificationContext) IsJoinSpecificationContext() {}

func NewJoinSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinSpecificationContext {
	var p = new(JoinSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_joinSpecification

	return p
}

func (s *JoinSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinSpecificationContext) ON() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserON, 0)
}

func (s *JoinSpecificationContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JoinSpecificationContext) USING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUSING, 0)
}

func (s *JoinSpecificationContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *JoinSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterJoinSpecification(s)
	}
}

func (s *JoinSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitJoinSpecification(s)
	}
}

func (s *JoinSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitJoinSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) JoinSpecification() (localctx IJoinSpecificationContext) {
	this := p
	_ = this

	localctx = NewJoinSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SQL92StatementParserRULE_joinSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Match(SQL92StatementParserON)
		}
		{
			p.SetState(535)
			p.expr(0)
		}

	case SQL92StatementParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Match(SQL92StatementParserUSING)
		}
		{
			p.SetState(537)
			p.ColumnNames()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWHERE, 0)
}

func (s *WhereClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) WhereClause() (localctx IWhereClauseContext) {
	this := p
	_ = this

	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SQL92StatementParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Match(SQL92StatementParserWHERE)
	}
	{
		p.SetState(541)
		p.expr(0)
	}

	return localctx
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_groupByClause
	return p
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGROUP, 0)
}

func (s *GroupByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBY, 0)
}

func (s *GroupByClauseContext) AllOrderByItem() []IOrderByItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem())
	var tst = make([]IOrderByItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByItemContext)
		}
	}

	return tst
}

func (s *GroupByClauseContext) OrderByItem(i int) IOrderByItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByItemContext)
}

func (s *GroupByClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *GroupByClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) GroupByClause() (localctx IGroupByClauseContext) {
	this := p
	_ = this

	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SQL92StatementParserRULE_groupByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(SQL92StatementParserGROUP)
	}
	{
		p.SetState(544)
		p.Match(SQL92StatementParserBY)
	}
	{
		p.SetState(545)
		p.OrderByItem()
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(546)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(547)
			p.OrderByItem()
		}

		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_havingClause
	return p
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserHAVING, 0)
}

func (s *HavingClauseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) HavingClause() (localctx IHavingClauseContext) {
	this := p
	_ = this

	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SQL92StatementParserRULE_havingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(SQL92StatementParserHAVING)
	}
	{
		p.SetState(554)
		p.expr(0)
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLIMIT, 0)
}

func (s *LimitClauseContext) LimitRowCount() ILimitRowCountContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitRowCountContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitRowCountContext)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOFFSET, 0)
}

func (s *LimitClauseContext) LimitOffset() ILimitOffsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitOffsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitOffsetContext)
}

func (s *LimitClauseContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) LimitClause() (localctx ILimitClauseContext) {
	this := p
	_ = this

	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SQL92StatementParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(SQL92StatementParserLIMIT)
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.SetState(560)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(557)
				p.LimitOffset()
			}
			{
				p.SetState(558)
				p.Match(SQL92StatementParserCOMMA_)
			}

		}
		{
			p.SetState(562)
			p.LimitRowCount()
		}

	case 2:
		{
			p.SetState(563)
			p.LimitRowCount()
		}
		{
			p.SetState(564)
			p.Match(SQL92StatementParserOFFSET)
		}
		{
			p.SetState(565)
			p.LimitOffset()
		}

	}

	return localctx
}

// ILimitRowCountContext is an interface to support dynamic dispatch.
type ILimitRowCountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitRowCountContext differentiates from other interfaces.
	IsLimitRowCountContext()
}

type LimitRowCountContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitRowCountContext() *LimitRowCountContext {
	var p = new(LimitRowCountContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_limitRowCount
	return p
}

func (*LimitRowCountContext) IsLimitRowCountContext() {}

func NewLimitRowCountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitRowCountContext {
	var p = new(LimitRowCountContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_limitRowCount

	return p
}

func (s *LimitRowCountContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitRowCountContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *LimitRowCountContext) ParameterMarker() IParameterMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterMarkerContext)
}

func (s *LimitRowCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitRowCountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitRowCountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitLimitRowCount(s)
	}
}

func (s *LimitRowCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitLimitRowCount(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) LimitRowCount() (localctx ILimitRowCountContext) {
	this := p
	_ = this

	localctx = NewLimitRowCountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SQL92StatementParserRULE_limitRowCount)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(571)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserMINUS_, SQL92StatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.NumberLiterals()
		}

	case SQL92StatementParserQUESTION_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(570)
			p.ParameterMarker()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILimitOffsetContext is an interface to support dynamic dispatch.
type ILimitOffsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitOffsetContext differentiates from other interfaces.
	IsLimitOffsetContext()
}

type LimitOffsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitOffsetContext() *LimitOffsetContext {
	var p = new(LimitOffsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_limitOffset
	return p
}

func (*LimitOffsetContext) IsLimitOffsetContext() {}

func NewLimitOffsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitOffsetContext {
	var p = new(LimitOffsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_limitOffset

	return p
}

func (s *LimitOffsetContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitOffsetContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *LimitOffsetContext) ParameterMarker() IParameterMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterMarkerContext)
}

func (s *LimitOffsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitOffsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitOffsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterLimitOffset(s)
	}
}

func (s *LimitOffsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitLimitOffset(s)
	}
}

func (s *LimitOffsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitLimitOffset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) LimitOffset() (localctx ILimitOffsetContext) {
	this := p
	_ = this

	localctx = NewLimitOffsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SQL92StatementParserRULE_limitOffset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(575)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserMINUS_, SQL92StatementParserNUMBER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(573)
			p.NumberLiterals()
		}

	case SQL92StatementParserQUESTION_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(574)
			p.ParameterMarker()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *SubqueryContext) UnionClause() IUnionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionClauseContext)
}

func (s *SubqueryContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Subquery() (localctx ISubqueryContext) {
	this := p
	_ = this

	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SQL92StatementParserRULE_subquery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(578)
		p.UnionClause()
	}
	{
		p.SetState(579)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IParameterMarkerContext is an interface to support dynamic dispatch.
type IParameterMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameterMarkerContext differentiates from other interfaces.
	IsParameterMarkerContext()
}

type ParameterMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterMarkerContext() *ParameterMarkerContext {
	var p = new(ParameterMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_parameterMarker
	return p
}

func (*ParameterMarkerContext) IsParameterMarkerContext() {}

func NewParameterMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterMarkerContext {
	var p = new(ParameterMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_parameterMarker

	return p
}

func (s *ParameterMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterMarkerContext) QUESTION_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserQUESTION_, 0)
}

func (s *ParameterMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterParameterMarker(s)
	}
}

func (s *ParameterMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitParameterMarker(s)
	}
}

func (s *ParameterMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitParameterMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ParameterMarker() (localctx IParameterMarkerContext) {
	this := p
	_ = this

	localctx = NewParameterMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SQL92StatementParserRULE_parameterMarker)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(SQL92StatementParserQUESTION_)
	}

	return localctx
}

// ILiteralsContext is an interface to support dynamic dispatch.
type ILiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralsContext differentiates from other interfaces.
	IsLiteralsContext()
}

type LiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralsContext() *LiteralsContext {
	var p = new(LiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_literals
	return p
}

func (*LiteralsContext) IsLiteralsContext() {}

func NewLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralsContext {
	var p = new(LiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_literals

	return p
}

func (s *LiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralsContext) StringLiterals() IStringLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralsContext)
}

func (s *LiteralsContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *LiteralsContext) DateTimeLiterals() IDateTimeLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateTimeLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateTimeLiteralsContext)
}

func (s *LiteralsContext) HexadecimalLiterals() IHexadecimalLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexadecimalLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralsContext)
}

func (s *LiteralsContext) BitValueLiterals() IBitValueLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitValueLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitValueLiteralsContext)
}

func (s *LiteralsContext) BooleanLiterals() IBooleanLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralsContext)
}

func (s *LiteralsContext) NullValueLiterals() INullValueLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullValueLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullValueLiteralsContext)
}

func (s *LiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterLiterals(s)
	}
}

func (s *LiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitLiterals(s)
	}
}

func (s *LiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Literals() (localctx ILiteralsContext) {
	this := p
	_ = this

	localctx = NewLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SQL92StatementParserRULE_literals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(583)
			p.StringLiterals()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(584)
			p.NumberLiterals()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(585)
			p.DateTimeLiterals()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(586)
			p.HexadecimalLiterals()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(587)
			p.BitValueLiterals()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(588)
			p.BooleanLiterals()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(589)
			p.NullValueLiterals()
		}

	}

	return localctx
}

// IStringLiteralsContext is an interface to support dynamic dispatch.
type IStringLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralsContext differentiates from other interfaces.
	IsStringLiteralsContext()
}

type StringLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralsContext() *StringLiteralsContext {
	var p = new(StringLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_stringLiterals
	return p
}

func (*StringLiteralsContext) IsStringLiteralsContext() {}

func NewStringLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralsContext {
	var p = new(StringLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_stringLiterals

	return p
}

func (s *StringLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *StringLiteralsContext) CharacterSetName() ICharacterSetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetNameContext)
}

func (s *StringLiteralsContext) CollateClause() ICollateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *StringLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterStringLiterals(s)
	}
}

func (s *StringLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitStringLiterals(s)
	}
}

func (s *StringLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitStringLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) StringLiterals() (localctx IStringLiteralsContext) {
	this := p
	_ = this

	localctx = NewStringLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SQL92StatementParserRULE_stringLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserIDENTIFIER_ {
		{
			p.SetState(592)
			p.CharacterSetName()
		}

	}
	{
		p.SetState(595)
		p.Match(SQL92StatementParserSTRING_)
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(596)
			p.CollateClause()
		}

	}

	return localctx
}

// INumberLiteralsContext is an interface to support dynamic dispatch.
type INumberLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberLiteralsContext differentiates from other interfaces.
	IsNumberLiteralsContext()
}

type NumberLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralsContext() *NumberLiteralsContext {
	var p = new(NumberLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_numberLiterals
	return p
}

func (*NumberLiteralsContext) IsNumberLiteralsContext() {}

func NewNumberLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralsContext {
	var p = new(NumberLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_numberLiterals

	return p
}

func (s *NumberLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralsContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMBER_, 0)
}

func (s *NumberLiteralsContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMINUS_, 0)
}

func (s *NumberLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterNumberLiterals(s)
	}
}

func (s *NumberLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitNumberLiterals(s)
	}
}

func (s *NumberLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitNumberLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) NumberLiterals() (localctx INumberLiteralsContext) {
	this := p
	_ = this

	localctx = NewNumberLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SQL92StatementParserRULE_numberLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserMINUS_ {
		{
			p.SetState(599)
			p.Match(SQL92StatementParserMINUS_)
		}

	}
	{
		p.SetState(602)
		p.Match(SQL92StatementParserNUMBER_)
	}

	return localctx
}

// IDateTimeLiteralsContext is an interface to support dynamic dispatch.
type IDateTimeLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateTimeLiteralsContext differentiates from other interfaces.
	IsDateTimeLiteralsContext()
}

type DateTimeLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeLiteralsContext() *DateTimeLiteralsContext {
	var p = new(DateTimeLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dateTimeLiterals
	return p
}

func (*DateTimeLiteralsContext) IsDateTimeLiteralsContext() {}

func NewDateTimeLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeLiteralsContext {
	var p = new(DateTimeLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dateTimeLiterals

	return p
}

func (s *DateTimeLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeLiteralsContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *DateTimeLiteralsContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDATE, 0)
}

func (s *DateTimeLiteralsContext) TIME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTIME, 0)
}

func (s *DateTimeLiteralsContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTIMESTAMP, 0)
}

func (s *DateTimeLiteralsContext) LBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLBE_, 0)
}

func (s *DateTimeLiteralsContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DateTimeLiteralsContext) RBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRBE_, 0)
}

func (s *DateTimeLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDateTimeLiterals(s)
	}
}

func (s *DateTimeLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDateTimeLiterals(s)
	}
}

func (s *DateTimeLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDateTimeLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DateTimeLiterals() (localctx IDateTimeLiteralsContext) {
	this := p
	_ = this

	localctx = NewDateTimeLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SQL92StatementParserRULE_dateTimeLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(611)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserDATE, SQL92StatementParserTIME, SQL92StatementParserTIMESTAMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(604)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(SQL92StatementParserDATE-128))|(1<<(SQL92StatementParserTIME-128))|(1<<(SQL92StatementParserTIMESTAMP-128)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(605)
			p.Match(SQL92StatementParserSTRING_)
		}

	case SQL92StatementParserLBE_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(606)
			p.Match(SQL92StatementParserLBE_)
		}
		{
			p.SetState(607)
			p.Identifier()
		}
		{
			p.SetState(608)
			p.Match(SQL92StatementParserSTRING_)
		}
		{
			p.SetState(609)
			p.Match(SQL92StatementParserRBE_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHexadecimalLiteralsContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralsContext differentiates from other interfaces.
	IsHexadecimalLiteralsContext()
}

type HexadecimalLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralsContext() *HexadecimalLiteralsContext {
	var p = new(HexadecimalLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_hexadecimalLiterals
	return p
}

func (*HexadecimalLiteralsContext) IsHexadecimalLiteralsContext() {}

func NewHexadecimalLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralsContext {
	var p = new(HexadecimalLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_hexadecimalLiterals

	return p
}

func (s *HexadecimalLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralsContext) HEX_DIGIT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserHEX_DIGIT_, 0)
}

func (s *HexadecimalLiteralsContext) CharacterSetName() ICharacterSetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetNameContext)
}

func (s *HexadecimalLiteralsContext) CollateClause() ICollateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *HexadecimalLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterHexadecimalLiterals(s)
	}
}

func (s *HexadecimalLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitHexadecimalLiterals(s)
	}
}

func (s *HexadecimalLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitHexadecimalLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) HexadecimalLiterals() (localctx IHexadecimalLiteralsContext) {
	this := p
	_ = this

	localctx = NewHexadecimalLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SQL92StatementParserRULE_hexadecimalLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserIDENTIFIER_ {
		{
			p.SetState(613)
			p.CharacterSetName()
		}

	}
	{
		p.SetState(616)
		p.Match(SQL92StatementParserHEX_DIGIT_)
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(617)
			p.CollateClause()
		}

	}

	return localctx
}

// IBitValueLiteralsContext is an interface to support dynamic dispatch.
type IBitValueLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitValueLiteralsContext differentiates from other interfaces.
	IsBitValueLiteralsContext()
}

type BitValueLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitValueLiteralsContext() *BitValueLiteralsContext {
	var p = new(BitValueLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_bitValueLiterals
	return p
}

func (*BitValueLiteralsContext) IsBitValueLiteralsContext() {}

func NewBitValueLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitValueLiteralsContext {
	var p = new(BitValueLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_bitValueLiterals

	return p
}

func (s *BitValueLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *BitValueLiteralsContext) BIT_NUM_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBIT_NUM_, 0)
}

func (s *BitValueLiteralsContext) CharacterSetName() ICharacterSetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetNameContext)
}

func (s *BitValueLiteralsContext) CollateClause() ICollateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *BitValueLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitValueLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitValueLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterBitValueLiterals(s)
	}
}

func (s *BitValueLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitBitValueLiterals(s)
	}
}

func (s *BitValueLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitBitValueLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) BitValueLiterals() (localctx IBitValueLiteralsContext) {
	this := p
	_ = this

	localctx = NewBitValueLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SQL92StatementParserRULE_bitValueLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserIDENTIFIER_ {
		{
			p.SetState(620)
			p.CharacterSetName()
		}

	}
	{
		p.SetState(623)
		p.Match(SQL92StatementParserBIT_NUM_)
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(624)
			p.CollateClause()
		}

	}

	return localctx
}

// IBooleanLiteralsContext is an interface to support dynamic dispatch.
type IBooleanLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralsContext differentiates from other interfaces.
	IsBooleanLiteralsContext()
}

type BooleanLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralsContext() *BooleanLiteralsContext {
	var p = new(BooleanLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_booleanLiterals
	return p
}

func (*BooleanLiteralsContext) IsBooleanLiteralsContext() {}

func NewBooleanLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralsContext {
	var p = new(BooleanLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_booleanLiterals

	return p
}

func (s *BooleanLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralsContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTRUE, 0)
}

func (s *BooleanLiteralsContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFALSE, 0)
}

func (s *BooleanLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterBooleanLiterals(s)
	}
}

func (s *BooleanLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitBooleanLiterals(s)
	}
}

func (s *BooleanLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitBooleanLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) BooleanLiterals() (localctx IBooleanLiteralsContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SQL92StatementParserRULE_booleanLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserTRUE || _la == SQL92StatementParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INullValueLiteralsContext is an interface to support dynamic dispatch.
type INullValueLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullValueLiteralsContext differentiates from other interfaces.
	IsNullValueLiteralsContext()
}

type NullValueLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullValueLiteralsContext() *NullValueLiteralsContext {
	var p = new(NullValueLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_nullValueLiterals
	return p
}

func (*NullValueLiteralsContext) IsNullValueLiteralsContext() {}

func NewNullValueLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullValueLiteralsContext {
	var p = new(NullValueLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_nullValueLiterals

	return p
}

func (s *NullValueLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *NullValueLiteralsContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULL, 0)
}

func (s *NullValueLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullValueLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullValueLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterNullValueLiterals(s)
	}
}

func (s *NullValueLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitNullValueLiterals(s)
	}
}

func (s *NullValueLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitNullValueLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) NullValueLiterals() (localctx INullValueLiteralsContext) {
	this := p
	_ = this

	localctx = NewNullValueLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SQL92StatementParserRULE_nullValueLiterals)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		p.Match(SQL92StatementParserNULL)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIDENTIFIER_, 0)
}

func (s *IdentifierContext) UnreservedWord() IUnreservedWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnreservedWordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnreservedWordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SQL92StatementParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(633)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Match(SQL92StatementParserIDENTIFIER_)
		}

	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.UnreservedWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnreservedWordContext is an interface to support dynamic dispatch.
type IUnreservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnreservedWordContext differentiates from other interfaces.
	IsUnreservedWordContext()
}

type UnreservedWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnreservedWordContext() *UnreservedWordContext {
	var p = new(UnreservedWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_unreservedWord
	return p
}

func (*UnreservedWordContext) IsUnreservedWordContext() {}

func NewUnreservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnreservedWordContext {
	var p = new(UnreservedWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_unreservedWord

	return p
}

func (s *UnreservedWordContext) GetParser() antlr.Parser { return s.parser }

func (s *UnreservedWordContext) ADA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserADA, 0)
}

func (s *UnreservedWordContext) C92() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserC92, 0)
}

func (s *UnreservedWordContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCATALOG_NAME, 0)
}

func (s *UnreservedWordContext) CHARACTER_SET_CATALOG() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER_SET_CATALOG, 0)
}

func (s *UnreservedWordContext) CHARACTER_SET_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER_SET_NAME, 0)
}

func (s *UnreservedWordContext) CHARACTER_SET_SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER_SET_SCHEMA, 0)
}

func (s *UnreservedWordContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCLASS_ORIGIN, 0)
}

func (s *UnreservedWordContext) COBOL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOBOL, 0)
}

func (s *UnreservedWordContext) COLLATION_CATALOG() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLLATION_CATALOG, 0)
}

func (s *UnreservedWordContext) COLLATION_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLLATION_NAME, 0)
}

func (s *UnreservedWordContext) COLLATION_SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLLATION_SCHEMA, 0)
}

func (s *UnreservedWordContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLUMN_NAME, 0)
}

func (s *UnreservedWordContext) COMMAND_FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMAND_FUNCTION, 0)
}

func (s *UnreservedWordContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMITTED, 0)
}

func (s *UnreservedWordContext) CONDITION_NUMBER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONDITION_NUMBER, 0)
}

func (s *UnreservedWordContext) CONNECTION_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONNECTION_NAME, 0)
}

func (s *UnreservedWordContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONSTRAINT_CATALOG, 0)
}

func (s *UnreservedWordContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONSTRAINT_NAME, 0)
}

func (s *UnreservedWordContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONSTRAINT_SCHEMA, 0)
}

func (s *UnreservedWordContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCURSOR_NAME, 0)
}

func (s *UnreservedWordContext) DATA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDATA, 0)
}

func (s *UnreservedWordContext) DATETIME_INTERVAL_CODE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDATETIME_INTERVAL_CODE, 0)
}

func (s *UnreservedWordContext) DATETIME_INTERVAL_PRECISION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDATETIME_INTERVAL_PRECISION, 0)
}

func (s *UnreservedWordContext) DYNAMIC_FUNCTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDYNAMIC_FUNCTION, 0)
}

func (s *UnreservedWordContext) FORTRAN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFORTRAN, 0)
}

func (s *UnreservedWordContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLENGTH, 0)
}

func (s *UnreservedWordContext) MESSAGE_LENGTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMESSAGE_LENGTH, 0)
}

func (s *UnreservedWordContext) MESSAGE_OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMESSAGE_OCTET_LENGTH, 0)
}

func (s *UnreservedWordContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMESSAGE_TEXT, 0)
}

func (s *UnreservedWordContext) MORE92() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMORE92, 0)
}

func (s *UnreservedWordContext) MUMPS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMUMPS, 0)
}

func (s *UnreservedWordContext) NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNAME, 0)
}

func (s *UnreservedWordContext) NULLABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULLABLE, 0)
}

func (s *UnreservedWordContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMBER, 0)
}

func (s *UnreservedWordContext) PASCAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPASCAL, 0)
}

func (s *UnreservedWordContext) PLI() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPLI, 0)
}

func (s *UnreservedWordContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREPEATABLE, 0)
}

func (s *UnreservedWordContext) RETURNED_LENGTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRETURNED_LENGTH, 0)
}

func (s *UnreservedWordContext) RETURNED_OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRETURNED_OCTET_LENGTH, 0)
}

func (s *UnreservedWordContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRETURNED_SQLSTATE, 0)
}

func (s *UnreservedWordContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserROW_COUNT, 0)
}

func (s *UnreservedWordContext) SCALE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSCALE, 0)
}

func (s *UnreservedWordContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSCHEMA_NAME, 0)
}

func (s *UnreservedWordContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSERIALIZABLE, 0)
}

func (s *UnreservedWordContext) SERVER_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSERVER_NAME, 0)
}

func (s *UnreservedWordContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSUBCLASS_ORIGIN, 0)
}

func (s *UnreservedWordContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTABLE_NAME, 0)
}

func (s *UnreservedWordContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTYPE, 0)
}

func (s *UnreservedWordContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNCOMMITTED, 0)
}

func (s *UnreservedWordContext) UNNAMED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNNAMED, 0)
}

func (s *UnreservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnreservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnreservedWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterUnreservedWord(s)
	}
}

func (s *UnreservedWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitUnreservedWord(s)
	}
}

func (s *UnreservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitUnreservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) UnreservedWord() (localctx IUnreservedWordContext) {
	this := p
	_ = this

	localctx = NewUnreservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SQL92StatementParserRULE_unreservedWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_variable
	return p
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableContext) AllAT_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserAT_)
}

func (s *VariableContext) AT_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAT_, i)
}

func (s *VariableContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_, 0)
}

func (s *VariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGLOBAL, 0)
}

func (s *VariableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLOCAL, 0)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Variable() (localctx IVariableContext) {
	this := p
	_ = this

	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SQL92StatementParserRULE_variable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserAT_ {
		p.SetState(638)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(637)
				p.Match(SQL92StatementParserAT_)
			}

		}
		{
			p.SetState(640)
			p.Match(SQL92StatementParserAT_)
		}

	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLOCAL || _la == SQL92StatementParserGLOBAL {
		{
			p.SetState(643)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserLOCAL || _la == SQL92StatementParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserDOT_ {
		{
			p.SetState(646)
			p.Match(SQL92StatementParserDOT_)
		}

	}
	{
		p.SetState(649)
		p.Identifier()
	}

	return localctx
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_schemaName
	return p
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (s *SchemaNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSchemaName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SchemaName() (localctx ISchemaNameContext) {
	this := p
	_ = this

	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SQL92StatementParserRULE_schemaName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Identifier()
	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *TableNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *TableNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_, 0)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TableName() (localctx ITableNameContext) {
	this := p
	_ = this

	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SQL92StatementParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(656)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(653)
			p.Owner()
		}
		{
			p.SetState(654)
			p.Match(SQL92StatementParserDOT_)
		}

	}
	{
		p.SetState(658)
		p.Name()
	}

	return localctx
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_columnName
	return p
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ColumnNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ColumnNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_, 0)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ColumnName() (localctx IColumnNameContext) {
	this := p
	_ = this

	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SQL92StatementParserRULE_columnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(663)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(660)
			p.Owner()
		}
		{
			p.SetState(661)
			p.Match(SQL92StatementParserDOT_)
		}

	}
	{
		p.SetState(665)
		p.Name()
	}

	return localctx
}

// IViewNameContext is an interface to support dynamic dispatch.
type IViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsViewNameContext differentiates from other interfaces.
	IsViewNameContext()
}

type ViewNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewNameContext() *ViewNameContext {
	var p = new(ViewNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_viewName
	return p
}

func (*ViewNameContext) IsViewNameContext() {}

func NewViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewNameContext {
	var p = new(ViewNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_viewName

	return p
}

func (s *ViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ViewNameContext) Owner() IOwnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOwnerContext)
}

func (s *ViewNameContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_, 0)
}

func (s *ViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterViewName(s)
	}
}

func (s *ViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitViewName(s)
	}
}

func (s *ViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitViewName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ViewName() (localctx IViewNameContext) {
	this := p
	_ = this

	localctx = NewViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SQL92StatementParserRULE_viewName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(671)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(668)
				p.Owner()
			}
			{
				p.SetState(669)
				p.Match(SQL92StatementParserDOT_)
			}

		}
		{
			p.SetState(673)
			p.Identifier()
		}

	}

	return localctx
}

// IOwnerContext is an interface to support dynamic dispatch.
type IOwnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOwnerContext differentiates from other interfaces.
	IsOwnerContext()
}

type OwnerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwnerContext() *OwnerContext {
	var p = new(OwnerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_owner
	return p
}

func (*OwnerContext) IsOwnerContext() {}

func NewOwnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OwnerContext {
	var p = new(OwnerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_owner

	return p
}

func (s *OwnerContext) GetParser() antlr.Parser { return s.parser }

func (s *OwnerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OwnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OwnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OwnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterOwner(s)
	}
}

func (s *OwnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitOwner(s)
	}
}

func (s *OwnerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitOwner(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Owner() (localctx IOwnerContext) {
	this := p
	_ = this

	localctx = NewOwnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SQL92StatementParserRULE_owner)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Identifier()
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Name() (localctx INameContext) {
	this := p
	_ = this

	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SQL92StatementParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Identifier()
	}

	return localctx
}

// IConstraintNameContext is an interface to support dynamic dispatch.
type IConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintNameContext differentiates from other interfaces.
	IsConstraintNameContext()
}

type ConstraintNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintNameContext() *ConstraintNameContext {
	var p = new(ConstraintNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_constraintName
	return p
}

func (*ConstraintNameContext) IsConstraintNameContext() {}

func NewConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintNameContext {
	var p = new(ConstraintNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_constraintName

	return p
}

func (s *ConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterConstraintName(s)
	}
}

func (s *ConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitConstraintName(s)
	}
}

func (s *ConstraintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitConstraintName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ConstraintName() (localctx IConstraintNameContext) {
	this := p
	_ = this

	localctx = NewConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SQL92StatementParserRULE_constraintName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Identifier()
	}

	return localctx
}

// IColumnNamesContext is an interface to support dynamic dispatch.
type IColumnNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnNamesContext differentiates from other interfaces.
	IsColumnNamesContext()
}

type ColumnNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNamesContext() *ColumnNamesContext {
	var p = new(ColumnNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_columnNames
	return p
}

func (*ColumnNamesContext) IsColumnNamesContext() {}

func NewColumnNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNamesContext {
	var p = new(ColumnNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_columnNames

	return p
}

func (s *ColumnNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNamesContext) AllColumnName() []IColumnNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IColumnNameContext)(nil)).Elem())
	var tst = make([]IColumnNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IColumnNameContext)
		}
	}

	return tst
}

func (s *ColumnNamesContext) ColumnName(i int) IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnNamesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *ColumnNamesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *ColumnNamesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *ColumnNamesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *ColumnNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterColumnNames(s)
	}
}

func (s *ColumnNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitColumnNames(s)
	}
}

func (s *ColumnNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitColumnNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ColumnNames() (localctx IColumnNamesContext) {
	this := p
	_ = this

	localctx = NewColumnNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SQL92StatementParserRULE_columnNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ {
		{
			p.SetState(682)
			p.Match(SQL92StatementParserLP_)
		}

	}
	{
		p.SetState(685)
		p.ColumnName()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(686)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(687)
				p.ColumnName()
			}

		}
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(693)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// ITableNamesContext is an interface to support dynamic dispatch.
type ITableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNamesContext differentiates from other interfaces.
	IsTableNamesContext()
}

type TableNamesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNamesContext() *TableNamesContext {
	var p = new(TableNamesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_tableNames
	return p
}

func (*TableNamesContext) IsTableNamesContext() {}

func NewTableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNamesContext {
	var p = new(TableNamesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_tableNames

	return p
}

func (s *TableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNamesContext) AllTableName() []ITableNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableNameContext)(nil)).Elem())
	var tst = make([]ITableNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableNameContext)
		}
	}

	return tst
}

func (s *TableNamesContext) TableName(i int) ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableNamesContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *TableNamesContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *TableNamesContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *TableNamesContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *TableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTableNames(s)
	}
}

func (s *TableNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTableNames(s)
	}
}

func (s *TableNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTableNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TableNames() (localctx ITableNamesContext) {
	this := p
	_ = this

	localctx = NewTableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SQL92StatementParserRULE_tableNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ {
		{
			p.SetState(696)
			p.Match(SQL92StatementParserLP_)
		}

	}
	{
		p.SetState(699)
		p.TableName()
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(700)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(701)
			p.TableName()
		}

		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserRP_ {
		{
			p.SetState(707)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// ICharacterSetNameContext is an interface to support dynamic dispatch.
type ICharacterSetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterSetNameContext differentiates from other interfaces.
	IsCharacterSetNameContext()
}

type CharacterSetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterSetNameContext() *CharacterSetNameContext {
	var p = new(CharacterSetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_characterSetName
	return p
}

func (*CharacterSetNameContext) IsCharacterSetNameContext() {}

func NewCharacterSetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterSetNameContext {
	var p = new(CharacterSetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_characterSetName

	return p
}

func (s *CharacterSetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterSetNameContext) IDENTIFIER_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIDENTIFIER_, 0)
}

func (s *CharacterSetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterSetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterSetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCharacterSetName(s)
	}
}

func (s *CharacterSetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCharacterSetName(s)
	}
}

func (s *CharacterSetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCharacterSetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CharacterSetName() (localctx ICharacterSetNameContext) {
	this := p
	_ = this

	localctx = NewCharacterSetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SQL92StatementParserRULE_characterSetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(SQL92StatementParserIDENTIFIER_)
	}

	return localctx
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) NotOperator() INotOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INotOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INotOperatorContext)
}

func (s *ExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *ExprContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *ExprContext) BooleanPrimary() IBooleanPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanPrimaryContext)
}

func (s *ExprContext) AndOperator() IAndOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAndOperatorContext)
}

func (s *ExprContext) OrOperator() IOrOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrOperatorContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *SQL92StatementParser) expr(_p int) (localctx IExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, SQL92StatementParserRULE_expr, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(713)
			p.NotOperator()
		}
		{
			p.SetState(714)
			p.expr(3)
		}

	case 2:
		{
			p.SetState(716)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(717)
			p.expr(0)
		}
		{
			p.SetState(718)
			p.Match(SQL92StatementParserRP_)
		}

	case 3:
		{
			p.SetState(720)
			p.booleanPrimary(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(731)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_expr)
				p.SetState(723)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(724)
					p.AndOperator()
				}
				{
					p.SetState(725)
					p.expr(6)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_expr)
				p.SetState(727)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(728)
					p.OrOperator()
				}
				{
					p.SetState(729)
					p.expr(5)
				}

			}

		}
		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}

	return localctx
}

// IAndOperatorContext is an interface to support dynamic dispatch.
type IAndOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndOperatorContext differentiates from other interfaces.
	IsAndOperatorContext()
}

type AndOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndOperatorContext() *AndOperatorContext {
	var p = new(AndOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_andOperator
	return p
}

func (*AndOperatorContext) IsAndOperatorContext() {}

func NewAndOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndOperatorContext {
	var p = new(AndOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_andOperator

	return p
}

func (s *AndOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AndOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAND, 0)
}

func (s *AndOperatorContext) AND_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAND_, 0)
}

func (s *AndOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAndOperator(s)
	}
}

func (s *AndOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAndOperator(s)
	}
}

func (s *AndOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAndOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AndOperator() (localctx IAndOperatorContext) {
	this := p
	_ = this

	localctx = NewAndOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SQL92StatementParserRULE_andOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserAND_ || _la == SQL92StatementParserAND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOrOperatorContext is an interface to support dynamic dispatch.
type IOrOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrOperatorContext differentiates from other interfaces.
	IsOrOperatorContext()
}

type OrOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrOperatorContext() *OrOperatorContext {
	var p = new(OrOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_orOperator
	return p
}

func (*OrOperatorContext) IsOrOperatorContext() {}

func NewOrOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrOperatorContext {
	var p = new(OrOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_orOperator

	return p
}

func (s *OrOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *OrOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOR, 0)
}

func (s *OrOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterOrOperator(s)
	}
}

func (s *OrOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitOrOperator(s)
	}
}

func (s *OrOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitOrOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) OrOperator() (localctx IOrOperatorContext) {
	this := p
	_ = this

	localctx = NewOrOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SQL92StatementParserRULE_orOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(SQL92StatementParserOR)
	}

	return localctx
}

// INotOperatorContext is an interface to support dynamic dispatch.
type INotOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOperatorContext differentiates from other interfaces.
	IsNotOperatorContext()
}

type NotOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOperatorContext() *NotOperatorContext {
	var p = new(NotOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_notOperator
	return p
}

func (*NotOperatorContext) IsNotOperatorContext() {}

func NewNotOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOperatorContext {
	var p = new(NotOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_notOperator

	return p
}

func (s *NotOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT, 0)
}

func (s *NotOperatorContext) NOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT_, 0)
}

func (s *NotOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterNotOperator(s)
	}
}

func (s *NotOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitNotOperator(s)
	}
}

func (s *NotOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitNotOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) NotOperator() (localctx INotOperatorContext) {
	this := p
	_ = this

	localctx = NewNotOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SQL92StatementParserRULE_notOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserNOT_ || _la == SQL92StatementParserNOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanPrimaryContext is an interface to support dynamic dispatch.
type IBooleanPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanPrimaryContext differentiates from other interfaces.
	IsBooleanPrimaryContext()
}

type BooleanPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanPrimaryContext() *BooleanPrimaryContext {
	var p = new(BooleanPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_booleanPrimary
	return p
}

func (*BooleanPrimaryContext) IsBooleanPrimaryContext() {}

func NewBooleanPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanPrimaryContext {
	var p = new(BooleanPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_booleanPrimary

	return p
}

func (s *BooleanPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanPrimaryContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanPrimaryContext) BooleanPrimary() IBooleanPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanPrimaryContext)
}

func (s *BooleanPrimaryContext) IS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIS, 0)
}

func (s *BooleanPrimaryContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTRUE, 0)
}

func (s *BooleanPrimaryContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFALSE, 0)
}

func (s *BooleanPrimaryContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNKNOWN, 0)
}

func (s *BooleanPrimaryContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULL, 0)
}

func (s *BooleanPrimaryContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT, 0)
}

func (s *BooleanPrimaryContext) SAFE_EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSAFE_EQ_, 0)
}

func (s *BooleanPrimaryContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BooleanPrimaryContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *BooleanPrimaryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALL, 0)
}

func (s *BooleanPrimaryContext) ANY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserANY, 0)
}

func (s *BooleanPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterBooleanPrimary(s)
	}
}

func (s *BooleanPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitBooleanPrimary(s)
	}
}

func (s *BooleanPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitBooleanPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) BooleanPrimary() (localctx IBooleanPrimaryContext) {
	return p.booleanPrimary(0)
}

func (p *SQL92StatementParser) booleanPrimary(_p int) (localctx IBooleanPrimaryContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, SQL92StatementParserRULE_booleanPrimary, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(763)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_booleanPrimary)
				p.SetState(745)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(746)
					p.Match(SQL92StatementParserIS)
				}
				p.SetState(748)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == SQL92StatementParserNOT {
					{
						p.SetState(747)
						p.Match(SQL92StatementParserNOT)
					}

				}
				{
					p.SetState(750)
					_la = p.GetTokenStream().LA(1)

					if !((((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(SQL92StatementParserNULL-101))|(1<<(SQL92StatementParserTRUE-101))|(1<<(SQL92StatementParserFALSE-101)))) != 0) || _la == SQL92StatementParserUNKNOWN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 2:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_booleanPrimary)
				p.SetState(751)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(752)
					p.Match(SQL92StatementParserSAFE_EQ_)
				}
				{
					p.SetState(753)
					p.Predicate()
				}

			case 3:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_booleanPrimary)
				p.SetState(754)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(755)
					p.ComparisonOperator()
				}
				{
					p.SetState(756)
					p.Predicate()
				}

			case 4:
				localctx = NewBooleanPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_booleanPrimary)
				p.SetState(758)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(759)
					p.ComparisonOperator()
				}
				{
					p.SetState(760)
					_la = p.GetTokenStream().LA(1)

					if !(_la == SQL92StatementParserALL || _la == SQL92StatementParserANY) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(761)
					p.Subquery()
				}

			}

		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEQ_, 0)
}

func (s *ComparisonOperatorContext) GTE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGTE_, 0)
}

func (s *ComparisonOperatorContext) GT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGT_, 0)
}

func (s *ComparisonOperatorContext) LTE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLTE_, 0)
}

func (s *ComparisonOperatorContext) LT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLT_, 0)
}

func (s *ComparisonOperatorContext) NEQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNEQ_, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	this := p
	_ = this

	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, SQL92StatementParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQL92StatementParserEQ_)|(1<<SQL92StatementParserNEQ_)|(1<<SQL92StatementParserGT_)|(1<<SQL92StatementParserGTE_)|(1<<SQL92StatementParserLT_)|(1<<SQL92StatementParserLTE_))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) AllBitExpr() []IBitExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitExprContext)(nil)).Elem())
	var tst = make([]IBitExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) BitExpr(i int) IBitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIN, 0)
}

func (s *PredicateContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT, 0)
}

func (s *PredicateContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *PredicateContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *PredicateContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *PredicateContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBETWEEN, 0)
}

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAND, 0)
}

func (s *PredicateContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLIKE, 0)
}

func (s *PredicateContext) AllSimpleExpr() []ISimpleExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem())
	var tst = make([]ISimpleExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleExprContext)
		}
	}

	return tst
}

func (s *PredicateContext) SimpleExpr(i int) ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *PredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserESCAPE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Predicate() (localctx IPredicateContext) {
	this := p
	_ = this

	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, SQL92StatementParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(770)
			p.bitExpr(0)
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserNOT {
			{
				p.SetState(771)
				p.Match(SQL92StatementParserNOT)
			}

		}
		{
			p.SetState(774)
			p.Match(SQL92StatementParserIN)
		}
		{
			p.SetState(775)
			p.Subquery()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(777)
			p.bitExpr(0)
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserNOT {
			{
				p.SetState(778)
				p.Match(SQL92StatementParserNOT)
			}

		}
		{
			p.SetState(781)
			p.Match(SQL92StatementParserIN)
		}
		{
			p.SetState(782)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(783)
			p.expr(0)
		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(784)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(785)
				p.expr(0)
			}

			p.SetState(790)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(791)
			p.Match(SQL92StatementParserRP_)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(793)
			p.bitExpr(0)
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserNOT {
			{
				p.SetState(794)
				p.Match(SQL92StatementParserNOT)
			}

		}
		{
			p.SetState(797)
			p.Match(SQL92StatementParserBETWEEN)
		}
		{
			p.SetState(798)
			p.bitExpr(0)
		}
		{
			p.SetState(799)
			p.Match(SQL92StatementParserAND)
		}
		{
			p.SetState(800)
			p.Predicate()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(802)
			p.bitExpr(0)
		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserNOT {
			{
				p.SetState(803)
				p.Match(SQL92StatementParserNOT)
			}

		}
		{
			p.SetState(806)
			p.Match(SQL92StatementParserLIKE)
		}
		{
			p.SetState(807)
			p.simpleExpr(0)
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(808)
				p.Match(SQL92StatementParserESCAPE)
			}
			{
				p.SetState(809)
				p.simpleExpr(0)
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(812)
			p.bitExpr(0)
		}

	}

	return localctx
}

// IBitExprContext is an interface to support dynamic dispatch.
type IBitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitExprContext differentiates from other interfaces.
	IsBitExprContext()
}

type BitExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitExprContext() *BitExprContext {
	var p = new(BitExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_bitExpr
	return p
}

func (*BitExprContext) IsBitExprContext() {}

func NewBitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitExprContext {
	var p = new(BitExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_bitExpr

	return p
}

func (s *BitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitExprContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *BitExprContext) AllBitExpr() []IBitExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBitExprContext)(nil)).Elem())
	var tst = make([]IBitExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBitExprContext)
		}
	}

	return tst
}

func (s *BitExprContext) BitExpr(i int) IBitExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *BitExprContext) VERTICAL_BAR_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVERTICAL_BAR_, 0)
}

func (s *BitExprContext) AMPERSAND_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAMPERSAND_, 0)
}

func (s *BitExprContext) SIGNED_LEFT_SHIFT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSIGNED_LEFT_SHIFT_, 0)
}

func (s *BitExprContext) SIGNED_RIGHT_SHIFT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSIGNED_RIGHT_SHIFT_, 0)
}

func (s *BitExprContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPLUS_, 0)
}

func (s *BitExprContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMINUS_, 0)
}

func (s *BitExprContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASTERISK_, 0)
}

func (s *BitExprContext) SLASH_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSLASH_, 0)
}

func (s *BitExprContext) MOD_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMOD_, 0)
}

func (s *BitExprContext) CARET_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCARET_, 0)
}

func (s *BitExprContext) IntervalExpression() IIntervalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalExpressionContext)
}

func (s *BitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterBitExpr(s)
	}
}

func (s *BitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitBitExpr(s)
	}
}

func (s *BitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitBitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) BitExpr() (localctx IBitExprContext) {
	return p.bitExpr(0)
}

func (p *SQL92StatementParser) bitExpr(_p int) (localctx IBitExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBitExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, SQL92StatementParserRULE_bitExpr, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.simpleExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(854)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(818)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(819)
					p.Match(SQL92StatementParserVERTICAL_BAR_)
				}
				{
					p.SetState(820)
					p.bitExpr(14)
				}

			case 2:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(821)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(822)
					p.Match(SQL92StatementParserAMPERSAND_)
				}
				{
					p.SetState(823)
					p.bitExpr(13)
				}

			case 3:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(824)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(825)
					p.Match(SQL92StatementParserSIGNED_LEFT_SHIFT_)
				}
				{
					p.SetState(826)
					p.bitExpr(12)
				}

			case 4:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(827)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(828)
					p.Match(SQL92StatementParserSIGNED_RIGHT_SHIFT_)
				}
				{
					p.SetState(829)
					p.bitExpr(11)
				}

			case 5:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(830)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(831)
					p.Match(SQL92StatementParserPLUS_)
				}
				{
					p.SetState(832)
					p.bitExpr(10)
				}

			case 6:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(833)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(834)
					p.Match(SQL92StatementParserMINUS_)
				}
				{
					p.SetState(835)
					p.bitExpr(9)
				}

			case 7:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(836)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(837)
					p.Match(SQL92StatementParserASTERISK_)
				}
				{
					p.SetState(838)
					p.bitExpr(8)
				}

			case 8:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(839)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(840)
					p.Match(SQL92StatementParserSLASH_)
				}
				{
					p.SetState(841)
					p.bitExpr(7)
				}

			case 9:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(842)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(843)
					p.Match(SQL92StatementParserMOD_)
				}
				{
					p.SetState(844)
					p.bitExpr(6)
				}

			case 10:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(845)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(846)
					p.Match(SQL92StatementParserCARET_)
				}
				{
					p.SetState(847)
					p.bitExpr(5)
				}

			case 11:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(848)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(849)
					p.Match(SQL92StatementParserPLUS_)
				}
				{
					p.SetState(850)
					p.IntervalExpression()
				}

			case 12:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_bitExpr)
				p.SetState(851)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(852)
					p.Match(SQL92StatementParserMINUS_)
				}
				{
					p.SetState(853)
					p.IntervalExpression()
				}

			}

		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext())
	}

	return localctx
}

// ISimpleExprContext is an interface to support dynamic dispatch.
type ISimpleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleExprContext differentiates from other interfaces.
	IsSimpleExprContext()
}

type SimpleExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprContext() *SimpleExprContext {
	var p = new(SimpleExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_simpleExpr
	return p
}

func (*SimpleExprContext) IsSimpleExprContext() {}

func NewSimpleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprContext {
	var p = new(SimpleExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_simpleExpr

	return p
}

func (s *SimpleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SimpleExprContext) ParameterMarker() IParameterMarkerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameterMarkerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameterMarkerContext)
}

func (s *SimpleExprContext) Literals() ILiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralsContext)
}

func (s *SimpleExprContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *SimpleExprContext) Variable() IVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SimpleExprContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprContext) PLUS_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPLUS_, 0)
}

func (s *SimpleExprContext) MINUS_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMINUS_, 0)
}

func (s *SimpleExprContext) TILDE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTILDE_, 0)
}

func (s *SimpleExprContext) NOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT_, 0)
}

func (s *SimpleExprContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *SimpleExprContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *SimpleExprContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *SimpleExprContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *SimpleExprContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *SimpleExprContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SimpleExprContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEXISTS, 0)
}

func (s *SimpleExprContext) LBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLBE_, 0)
}

func (s *SimpleExprContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleExprContext) RBE_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRBE_, 0)
}

func (s *SimpleExprContext) MatchExpression() IMatchExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMatchExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMatchExpressionContext)
}

func (s *SimpleExprContext) CaseExpression() ICaseExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *SimpleExprContext) IntervalExpression() IIntervalExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalExpressionContext)
}

func (s *SimpleExprContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLLATE, 0)
}

func (s *SimpleExprContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *SimpleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSimpleExpr(s)
	}
}

func (s *SimpleExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSimpleExpr(s)
	}
}

func (s *SimpleExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSimpleExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SimpleExpr() (localctx ISimpleExprContext) {
	return p.simpleExpr(0)
}

func (p *SQL92StatementParser) simpleExpr(_p int) (localctx ISimpleExprContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSimpleExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, SQL92StatementParserRULE_simpleExpr, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(860)
			p.FunctionCall()
		}

	case 2:
		{
			p.SetState(861)
			p.ParameterMarker()
		}

	case 3:
		{
			p.SetState(862)
			p.Literals()
		}

	case 4:
		{
			p.SetState(863)
			p.ColumnName()
		}

	case 5:
		{
			p.SetState(864)
			p.Variable()
		}

	case 6:
		{
			p.SetState(865)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQL92StatementParserNOT_)|(1<<SQL92StatementParserTILDE_)|(1<<SQL92StatementParserPLUS_)|(1<<SQL92StatementParserMINUS_))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(866)
			p.simpleExpr(7)
		}

	case 7:
		{
			p.SetState(867)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(868)
			p.expr(0)
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(869)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(870)
				p.expr(0)
			}

			p.SetState(875)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(876)
			p.Match(SQL92StatementParserRP_)
		}

	case 8:
		p.SetState(879)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserEXISTS {
			{
				p.SetState(878)
				p.Match(SQL92StatementParserEXISTS)
			}

		}
		{
			p.SetState(881)
			p.Subquery()
		}

	case 9:
		{
			p.SetState(882)
			p.Match(SQL92StatementParserLBE_)
		}
		{
			p.SetState(883)
			p.Identifier()
		}
		{
			p.SetState(884)
			p.expr(0)
		}
		{
			p.SetState(885)
			p.Match(SQL92StatementParserRBE_)
		}

	case 10:
		{
			p.SetState(887)
			p.MatchExpression()
		}

	case 11:
		{
			p.SetState(888)
			p.CaseExpression()
		}

	case 12:
		{
			p.SetState(889)
			p.IntervalExpression()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSimpleExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SQL92StatementParserRULE_simpleExpr)
			p.SetState(892)

			if !(p.Precpred(p.GetParserRuleContext(), 9)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
			}
			{
				p.SetState(893)
				p.Match(SQL92StatementParserCOLLATE)
			}
			p.SetState(896)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case SQL92StatementParserSTRING_:
				{
					p.SetState(894)
					p.Match(SQL92StatementParserSTRING_)
				}

			case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
				{
					p.SetState(895)
					p.Identifier()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(902)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *FunctionCallContext) SpecialFunction() ISpecialFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionContext)
}

func (s *FunctionCallContext) RegularFunction() IRegularFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularFunctionContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, SQL92StatementParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(906)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserMAX, SQL92StatementParserMIN, SQL92StatementParserSUM, SQL92StatementParserCOUNT, SQL92StatementParserAVG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(903)
			p.AggregationFunction()
		}

	case SQL92StatementParserPOSITION, SQL92StatementParserCAST, SQL92StatementParserTRIM, SQL92StatementParserSUBSTRING, SQL92StatementParserCONVERT, SQL92StatementParserEXTRACT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(904)
			p.SpecialFunction()
		}

	case SQL92StatementParserIF, SQL92StatementParserINTERVAL, SQL92StatementParserLOCALTIME, SQL92StatementParserLOCALTIMESTAMP, SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserCURRENT_TIMESTAMP, SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(905)
			p.RegularFunction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_aggregationFunction
	return p
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AggregationFunctionName() IAggregationFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregationFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionNameContext)
}

func (s *AggregationFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *AggregationFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *AggregationFunctionContext) Distinct() IDistinctContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDistinctContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDistinctContext)
}

func (s *AggregationFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AggregationFunctionContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASTERISK_, 0)
}

func (s *AggregationFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *AggregationFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	this := p
	_ = this

	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, SQL92StatementParserRULE_aggregationFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.AggregationFunctionName()
	}
	{
		p.SetState(909)
		p.Match(SQL92StatementParserLP_)
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserDISTINCT {
		{
			p.SetState(910)
			p.Distinct()
		}

	}
	p.SetState(922)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserNOT_, SQL92StatementParserTILDE_, SQL92StatementParserPLUS_, SQL92StatementParserMINUS_, SQL92StatementParserDOT_, SQL92StatementParserLP_, SQL92StatementParserLBE_, SQL92StatementParserQUESTION_, SQL92StatementParserAT_, SQL92StatementParserPOSITION, SQL92StatementParserCASE, SQL92StatementParserCAST, SQL92StatementParserTRIM, SQL92StatementParserSUBSTRING, SQL92StatementParserIF, SQL92StatementParserNOT, SQL92StatementParserNULL, SQL92StatementParserTRUE, SQL92StatementParserFALSE, SQL92StatementParserEXISTS, SQL92StatementParserINTERVAL, SQL92StatementParserDATE, SQL92StatementParserTIME, SQL92StatementParserTIMESTAMP, SQL92StatementParserLOCALTIME, SQL92StatementParserLOCALTIMESTAMP, SQL92StatementParserMAX, SQL92StatementParserMIN, SQL92StatementParserSUM, SQL92StatementParserCOUNT, SQL92StatementParserAVG, SQL92StatementParserLOCAL, SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserCONVERT, SQL92StatementParserCURRENT_TIMESTAMP, SQL92StatementParserEXTRACT, SQL92StatementParserGLOBAL, SQL92StatementParserIDENTIFIER_, SQL92StatementParserSTRING_, SQL92StatementParserNUMBER_, SQL92StatementParserHEX_DIGIT_, SQL92StatementParserBIT_NUM_:
		{
			p.SetState(913)
			p.expr(0)
		}
		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(914)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(915)
				p.expr(0)
			}

			p.SetState(920)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SQL92StatementParserASTERISK_:
		{
			p.SetState(921)
			p.Match(SQL92StatementParserASTERISK_)
		}

	case SQL92StatementParserRP_:

	default:
	}
	{
		p.SetState(924)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IAggregationFunctionNameContext is an interface to support dynamic dispatch.
type IAggregationFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregationFunctionNameContext differentiates from other interfaces.
	IsAggregationFunctionNameContext()
}

type AggregationFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionNameContext() *AggregationFunctionNameContext {
	var p = new(AggregationFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_aggregationFunctionName
	return p
}

func (*AggregationFunctionNameContext) IsAggregationFunctionNameContext() {}

func NewAggregationFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionNameContext {
	var p = new(AggregationFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_aggregationFunctionName

	return p
}

func (s *AggregationFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionNameContext) MAX() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMAX, 0)
}

func (s *AggregationFunctionNameContext) MIN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMIN, 0)
}

func (s *AggregationFunctionNameContext) SUM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSUM, 0)
}

func (s *AggregationFunctionNameContext) COUNT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOUNT, 0)
}

func (s *AggregationFunctionNameContext) AVG() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAVG, 0)
}

func (s *AggregationFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAggregationFunctionName(s)
	}
}

func (s *AggregationFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAggregationFunctionName(s)
	}
}

func (s *AggregationFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAggregationFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AggregationFunctionName() (localctx IAggregationFunctionNameContext) {
	this := p
	_ = this

	localctx = NewAggregationFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, SQL92StatementParserRULE_aggregationFunctionName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-142)&-(0x1f+1)) == 0 && ((1<<uint((_la-142)))&((1<<(SQL92StatementParserMAX-142))|(1<<(SQL92StatementParserMIN-142))|(1<<(SQL92StatementParserSUM-142))|(1<<(SQL92StatementParserCOUNT-142))|(1<<(SQL92StatementParserAVG-142)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDistinctContext is an interface to support dynamic dispatch.
type IDistinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDistinctContext differentiates from other interfaces.
	IsDistinctContext()
}

type DistinctContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctContext() *DistinctContext {
	var p = new(DistinctContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_distinct
	return p
}

func (*DistinctContext) IsDistinctContext() {}

func NewDistinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctContext {
	var p = new(DistinctContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_distinct

	return p
}

func (s *DistinctContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDISTINCT, 0)
}

func (s *DistinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDistinct(s)
	}
}

func (s *DistinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDistinct(s)
	}
}

func (s *DistinctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDistinct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Distinct() (localctx IDistinctContext) {
	this := p
	_ = this

	localctx = NewDistinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, SQL92StatementParserRULE_distinct)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(SQL92StatementParserDISTINCT)
	}

	return localctx
}

// ISpecialFunctionContext is an interface to support dynamic dispatch.
type ISpecialFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialFunctionContext differentiates from other interfaces.
	IsSpecialFunctionContext()
}

type SpecialFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionContext() *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_specialFunction
	return p
}

func (*SpecialFunctionContext) IsSpecialFunctionContext() {}

func NewSpecialFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_specialFunction

	return p
}

func (s *SpecialFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionContext) CastFunction() ICastFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastFunctionContext)
}

func (s *SpecialFunctionContext) ConvertFunction() IConvertFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConvertFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConvertFunctionContext)
}

func (s *SpecialFunctionContext) PositionFunction() IPositionFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositionFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositionFunctionContext)
}

func (s *SpecialFunctionContext) SubstringFunction() ISubstringFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubstringFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubstringFunctionContext)
}

func (s *SpecialFunctionContext) ExtractFunction() IExtractFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtractFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtractFunctionContext)
}

func (s *SpecialFunctionContext) TrimFunction() ITrimFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrimFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrimFunctionContext)
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSpecialFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SpecialFunction() (localctx ISpecialFunctionContext) {
	this := p
	_ = this

	localctx = NewSpecialFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, SQL92StatementParserRULE_specialFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(936)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserCAST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(930)
			p.CastFunction()
		}

	case SQL92StatementParserCONVERT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(931)
			p.ConvertFunction()
		}

	case SQL92StatementParserPOSITION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(932)
			p.PositionFunction()
		}

	case SQL92StatementParserSUBSTRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(933)
			p.SubstringFunction()
		}

	case SQL92StatementParserEXTRACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(934)
			p.ExtractFunction()
		}

	case SQL92StatementParserTRIM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(935)
			p.TrimFunction()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICastFunctionContext is an interface to support dynamic dispatch.
type ICastFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastFunctionContext differentiates from other interfaces.
	IsCastFunctionContext()
}

type CastFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastFunctionContext() *CastFunctionContext {
	var p = new(CastFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_castFunction
	return p
}

func (*CastFunctionContext) IsCastFunctionContext() {}

func NewCastFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastFunctionContext {
	var p = new(CastFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_castFunction

	return p
}

func (s *CastFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastFunctionContext) CAST() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCAST, 0)
}

func (s *CastFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *CastFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAS, 0)
}

func (s *CastFunctionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *CastFunctionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CastFunctionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULL, 0)
}

func (s *CastFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCastFunction(s)
	}
}

func (s *CastFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCastFunction(s)
	}
}

func (s *CastFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCastFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CastFunction() (localctx ICastFunctionContext) {
	this := p
	_ = this

	localctx = NewCastFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, SQL92StatementParserRULE_castFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.Match(SQL92StatementParserCAST)
	}
	{
		p.SetState(939)
		p.Match(SQL92StatementParserLP_)
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(940)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(941)
			p.Match(SQL92StatementParserNULL)
		}

	}
	{
		p.SetState(944)
		p.Match(SQL92StatementParserAS)
	}
	{
		p.SetState(945)
		p.DataType()
	}
	{
		p.SetState(946)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IConvertFunctionContext is an interface to support dynamic dispatch.
type IConvertFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConvertFunctionContext differentiates from other interfaces.
	IsConvertFunctionContext()
}

type ConvertFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertFunctionContext() *ConvertFunctionContext {
	var p = new(ConvertFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_convertFunction
	return p
}

func (*ConvertFunctionContext) IsConvertFunctionContext() {}

func NewConvertFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertFunctionContext {
	var p = new(ConvertFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_convertFunction

	return p
}

func (s *ConvertFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertFunctionContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONVERT, 0)
}

func (s *ConvertFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *ConvertFunctionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ConvertFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUSING, 0)
}

func (s *ConvertFunctionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConvertFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *ConvertFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConvertFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterConvertFunction(s)
	}
}

func (s *ConvertFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitConvertFunction(s)
	}
}

func (s *ConvertFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitConvertFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ConvertFunction() (localctx IConvertFunctionContext) {
	this := p
	_ = this

	localctx = NewConvertFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, SQL92StatementParserRULE_convertFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Match(SQL92StatementParserCONVERT)
	}
	{
		p.SetState(949)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(950)
		p.expr(0)
	}
	{
		p.SetState(951)
		p.Match(SQL92StatementParserUSING)
	}
	{
		p.SetState(952)
		p.Identifier()
	}
	{
		p.SetState(953)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IPositionFunctionContext is an interface to support dynamic dispatch.
type IPositionFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPositionFunctionContext differentiates from other interfaces.
	IsPositionFunctionContext()
}

type PositionFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPositionFunctionContext() *PositionFunctionContext {
	var p = new(PositionFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_positionFunction
	return p
}

func (*PositionFunctionContext) IsPositionFunctionContext() {}

func NewPositionFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PositionFunctionContext {
	var p = new(PositionFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_positionFunction

	return p
}

func (s *PositionFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *PositionFunctionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPOSITION, 0)
}

func (s *PositionFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *PositionFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *PositionFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PositionFunctionContext) IN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIN, 0)
}

func (s *PositionFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *PositionFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PositionFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPositionFunction(s)
	}
}

func (s *PositionFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPositionFunction(s)
	}
}

func (s *PositionFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPositionFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PositionFunction() (localctx IPositionFunctionContext) {
	this := p
	_ = this

	localctx = NewPositionFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, SQL92StatementParserRULE_positionFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(SQL92StatementParserPOSITION)
	}
	{
		p.SetState(956)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(957)
		p.expr(0)
	}
	{
		p.SetState(958)
		p.Match(SQL92StatementParserIN)
	}
	{
		p.SetState(959)
		p.expr(0)
	}
	{
		p.SetState(960)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// ISubstringFunctionContext is an interface to support dynamic dispatch.
type ISubstringFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubstringFunctionContext differentiates from other interfaces.
	IsSubstringFunctionContext()
}

type SubstringFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubstringFunctionContext() *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_substringFunction
	return p
}

func (*SubstringFunctionContext) IsSubstringFunctionContext() {}

func NewSubstringFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_substringFunction

	return p
}

func (s *SubstringFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubstringFunctionContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSUBSTRING, 0)
}

func (s *SubstringFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *SubstringFunctionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SubstringFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *SubstringFunctionContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserNUMBER_)
}

func (s *SubstringFunctionContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMBER_, i)
}

func (s *SubstringFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *SubstringFunctionContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFOR, 0)
}

func (s *SubstringFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubstringFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSubstringFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SubstringFunction() (localctx ISubstringFunctionContext) {
	this := p
	_ = this

	localctx = NewSubstringFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, SQL92StatementParserRULE_substringFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(962)
		p.Match(SQL92StatementParserSUBSTRING)
	}
	{
		p.SetState(963)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(964)
		p.expr(0)
	}
	{
		p.SetState(965)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(966)
		p.Match(SQL92StatementParserNUMBER_)
	}
	p.SetState(969)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserFOR {
		{
			p.SetState(967)
			p.Match(SQL92StatementParserFOR)
		}
		{
			p.SetState(968)
			p.Match(SQL92StatementParserNUMBER_)
		}

	}
	{
		p.SetState(971)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IExtractFunctionContext is an interface to support dynamic dispatch.
type IExtractFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtractFunctionContext differentiates from other interfaces.
	IsExtractFunctionContext()
}

type ExtractFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtractFunctionContext() *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_extractFunction
	return p
}

func (*ExtractFunctionContext) IsExtractFunctionContext() {}

func NewExtractFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtractFunctionContext {
	var p = new(ExtractFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_extractFunction

	return p
}

func (s *ExtractFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtractFunctionContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEXTRACT, 0)
}

func (s *ExtractFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *ExtractFunctionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *ExtractFunctionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExtractFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *ExtractFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtractFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterExtractFunction(s)
	}
}

func (s *ExtractFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitExtractFunction(s)
	}
}

func (s *ExtractFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitExtractFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ExtractFunction() (localctx IExtractFunctionContext) {
	this := p
	_ = this

	localctx = NewExtractFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, SQL92StatementParserRULE_extractFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(973)
		p.Match(SQL92StatementParserEXTRACT)
	}
	{
		p.SetState(974)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(975)
		p.Identifier()
	}
	{
		p.SetState(976)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(977)
		p.expr(0)
	}
	{
		p.SetState(978)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// ITrimFunctionContext is an interface to support dynamic dispatch.
type ITrimFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrimFunctionContext differentiates from other interfaces.
	IsTrimFunctionContext()
}

type TrimFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimFunctionContext() *TrimFunctionContext {
	var p = new(TrimFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_trimFunction
	return p
}

func (*TrimFunctionContext) IsTrimFunctionContext() {}

func NewTrimFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimFunctionContext {
	var p = new(TrimFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_trimFunction

	return p
}

func (s *TrimFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimFunctionContext) TRIM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTRIM, 0)
}

func (s *TrimFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *TrimFunctionContext) AllSTRING_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserSTRING_)
}

func (s *TrimFunctionContext) STRING_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, i)
}

func (s *TrimFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *TrimFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *TrimFunctionContext) LEADING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLEADING, 0)
}

func (s *TrimFunctionContext) BOTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBOTH, 0)
}

func (s *TrimFunctionContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTRAILING, 0)
}

func (s *TrimFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterTrimFunction(s)
	}
}

func (s *TrimFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitTrimFunction(s)
	}
}

func (s *TrimFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitTrimFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) TrimFunction() (localctx ITrimFunctionContext) {
	this := p
	_ = this

	localctx = NewTrimFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, SQL92StatementParserRULE_trimFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(SQL92StatementParserTRIM)
	}
	{
		p.SetState(981)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(982)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserBOTH || _la == SQL92StatementParserLEADING || _la == SQL92StatementParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(983)
		p.Match(SQL92StatementParserSTRING_)
	}
	{
		p.SetState(984)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(985)
		p.Match(SQL92StatementParserSTRING_)
	}
	{
		p.SetState(986)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IRegularFunctionContext is an interface to support dynamic dispatch.
type IRegularFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularFunctionContext differentiates from other interfaces.
	IsRegularFunctionContext()
}

type RegularFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularFunctionContext() *RegularFunctionContext {
	var p = new(RegularFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_regularFunction
	return p
}

func (*RegularFunctionContext) IsRegularFunctionContext() {}

func NewRegularFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularFunctionContext {
	var p = new(RegularFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_regularFunction

	return p
}

func (s *RegularFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularFunctionContext) RegularFunctionName() IRegularFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRegularFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRegularFunctionNameContext)
}

func (s *RegularFunctionContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *RegularFunctionContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *RegularFunctionContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *RegularFunctionContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RegularFunctionContext) ASTERISK_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASTERISK_, 0)
}

func (s *RegularFunctionContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *RegularFunctionContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *RegularFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterRegularFunction(s)
	}
}

func (s *RegularFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitRegularFunction(s)
	}
}

func (s *RegularFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitRegularFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) RegularFunction() (localctx IRegularFunctionContext) {
	this := p
	_ = this

	localctx = NewRegularFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, SQL92StatementParserRULE_regularFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.RegularFunctionName()
	}
	{
		p.SetState(989)
		p.Match(SQL92StatementParserLP_)
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserNOT_, SQL92StatementParserTILDE_, SQL92StatementParserPLUS_, SQL92StatementParserMINUS_, SQL92StatementParserDOT_, SQL92StatementParserLP_, SQL92StatementParserLBE_, SQL92StatementParserQUESTION_, SQL92StatementParserAT_, SQL92StatementParserPOSITION, SQL92StatementParserCASE, SQL92StatementParserCAST, SQL92StatementParserTRIM, SQL92StatementParserSUBSTRING, SQL92StatementParserIF, SQL92StatementParserNOT, SQL92StatementParserNULL, SQL92StatementParserTRUE, SQL92StatementParserFALSE, SQL92StatementParserEXISTS, SQL92StatementParserINTERVAL, SQL92StatementParserDATE, SQL92StatementParserTIME, SQL92StatementParserTIMESTAMP, SQL92StatementParserLOCALTIME, SQL92StatementParserLOCALTIMESTAMP, SQL92StatementParserMAX, SQL92StatementParserMIN, SQL92StatementParserSUM, SQL92StatementParserCOUNT, SQL92StatementParserAVG, SQL92StatementParserLOCAL, SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserCONVERT, SQL92StatementParserCURRENT_TIMESTAMP, SQL92StatementParserEXTRACT, SQL92StatementParserGLOBAL, SQL92StatementParserIDENTIFIER_, SQL92StatementParserSTRING_, SQL92StatementParserNUMBER_, SQL92StatementParserHEX_DIGIT_, SQL92StatementParserBIT_NUM_:
		{
			p.SetState(990)
			p.expr(0)
		}
		p.SetState(995)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(991)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(992)
				p.expr(0)
			}

			p.SetState(997)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case SQL92StatementParserASTERISK_:
		{
			p.SetState(998)
			p.Match(SQL92StatementParserASTERISK_)
		}

	case SQL92StatementParserRP_:

	default:
	}
	{
		p.SetState(1001)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IRegularFunctionNameContext is an interface to support dynamic dispatch.
type IRegularFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegularFunctionNameContext differentiates from other interfaces.
	IsRegularFunctionNameContext()
}

type RegularFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegularFunctionNameContext() *RegularFunctionNameContext {
	var p = new(RegularFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_regularFunctionName
	return p
}

func (*RegularFunctionNameContext) IsRegularFunctionNameContext() {}

func NewRegularFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegularFunctionNameContext {
	var p = new(RegularFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_regularFunctionName

	return p
}

func (s *RegularFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RegularFunctionNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegularFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserIF, 0)
}

func (s *RegularFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCURRENT_TIMESTAMP, 0)
}

func (s *RegularFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLOCALTIME, 0)
}

func (s *RegularFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLOCALTIMESTAMP, 0)
}

func (s *RegularFunctionNameContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINTERVAL, 0)
}

func (s *RegularFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegularFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterRegularFunctionName(s)
	}
}

func (s *RegularFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitRegularFunctionName(s)
	}
}

func (s *RegularFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitRegularFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) RegularFunctionName() (localctx IRegularFunctionNameContext) {
	this := p
	_ = this

	localctx = NewRegularFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, SQL92StatementParserRULE_regularFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1003)
			p.Identifier()
		}

	case SQL92StatementParserIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1004)
			p.Match(SQL92StatementParserIF)
		}

	case SQL92StatementParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1005)
			p.Match(SQL92StatementParserCURRENT_TIMESTAMP)
		}

	case SQL92StatementParserLOCALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1006)
			p.Match(SQL92StatementParserLOCALTIME)
		}

	case SQL92StatementParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1007)
			p.Match(SQL92StatementParserLOCALTIMESTAMP)
		}

	case SQL92StatementParserINTERVAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1008)
			p.Match(SQL92StatementParserINTERVAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMatchExpressionContext is an interface to support dynamic dispatch.
type IMatchExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMatchExpressionContext differentiates from other interfaces.
	IsMatchExpressionContext()
}

type MatchExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExpressionContext() *MatchExpressionContext {
	var p = new(MatchExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_matchExpression
	return p
}

func (*MatchExpressionContext) IsMatchExpressionContext() {}

func NewMatchExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExpressionContext {
	var p = new(MatchExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_matchExpression

	return p
}

func (s *MatchExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExpressionContext) Literals() ILiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralsContext)
}

func (s *MatchExpressionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMATCH, 0)
}

func (s *MatchExpressionContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *MatchExpressionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPARTIAL, 0)
}

func (s *MatchExpressionContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFULL, 0)
}

func (s *MatchExpressionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNIQUE, 0)
}

func (s *MatchExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterMatchExpression(s)
	}
}

func (s *MatchExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitMatchExpression(s)
	}
}

func (s *MatchExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitMatchExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) MatchExpression() (localctx IMatchExpressionContext) {
	this := p
	_ = this

	localctx = NewMatchExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, SQL92StatementParserRULE_matchExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Literals()
	}
	{
		p.SetState(1012)
		p.Match(SQL92StatementParserMATCH)
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserUNIQUE {
		{
			p.SetState(1013)
			p.Match(SQL92StatementParserUNIQUE)
		}

	}
	{
		p.SetState(1016)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserFULL || _la == SQL92StatementParserPARTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1017)
		p.Subquery()
	}

	return localctx
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_caseExpression
	return p
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCASE, 0)
}

func (s *CaseExpressionContext) END() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEND, 0)
}

func (s *CaseExpressionContext) SimpleExpr() ISimpleExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *CaseExpressionContext) AllCaseWhen() []ICaseWhenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseWhenContext)(nil)).Elem())
	var tst = make([]ICaseWhenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseWhenContext)
		}
	}

	return tst
}

func (s *CaseExpressionContext) CaseWhen(i int) ICaseWhenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseWhenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseWhenContext)
}

func (s *CaseExpressionContext) CaseElse() ICaseElseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseElseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICaseElseContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CaseExpression() (localctx ICaseExpressionContext) {
	this := p
	_ = this

	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, SQL92StatementParserRULE_caseExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1019)
		p.Match(SQL92StatementParserCASE)
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<SQL92StatementParserNOT_)|(1<<SQL92StatementParserTILDE_)|(1<<SQL92StatementParserPLUS_)|(1<<SQL92StatementParserMINUS_)|(1<<SQL92StatementParserDOT_)|(1<<SQL92StatementParserLP_)|(1<<SQL92StatementParserLBE_))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(SQL92StatementParserQUESTION_-37))|(1<<(SQL92StatementParserAT_-37))|(1<<(SQL92StatementParserPOSITION-37)))) != 0) || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(SQL92StatementParserCASE-74))|(1<<(SQL92StatementParserCAST-74))|(1<<(SQL92StatementParserTRIM-74))|(1<<(SQL92StatementParserSUBSTRING-74))|(1<<(SQL92StatementParserIF-74))|(1<<(SQL92StatementParserNULL-74))|(1<<(SQL92StatementParserTRUE-74))|(1<<(SQL92StatementParserFALSE-74))|(1<<(SQL92StatementParserEXISTS-74)))) != 0) || (((_la-127)&-(0x1f+1)) == 0 && ((1<<uint((_la-127)))&((1<<(SQL92StatementParserINTERVAL-127))|(1<<(SQL92StatementParserDATE-127))|(1<<(SQL92StatementParserTIME-127))|(1<<(SQL92StatementParserTIMESTAMP-127))|(1<<(SQL92StatementParserLOCALTIME-127))|(1<<(SQL92StatementParserLOCALTIMESTAMP-127))|(1<<(SQL92StatementParserMAX-127))|(1<<(SQL92StatementParserMIN-127))|(1<<(SQL92StatementParserSUM-127))|(1<<(SQL92StatementParserCOUNT-127))|(1<<(SQL92StatementParserAVG-127)))) != 0) || (((_la-159)&-(0x1f+1)) == 0 && ((1<<uint((_la-159)))&((1<<(SQL92StatementParserLOCAL-159))|(1<<(SQL92StatementParserNAME-159))|(1<<(SQL92StatementParserTYPE-159))|(1<<(SQL92StatementParserADA-159))|(1<<(SQL92StatementParserC92-159))|(1<<(SQL92StatementParserCATALOG_NAME-159))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-159))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-159))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-159))|(1<<(SQL92StatementParserCLASS_ORIGIN-159))|(1<<(SQL92StatementParserCOBOL-159))|(1<<(SQL92StatementParserCOLLATION_CATALOG-159))|(1<<(SQL92StatementParserCOLLATION_NAME-159))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-159))|(1<<(SQL92StatementParserCOLUMN_NAME-159))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-159))|(1<<(SQL92StatementParserCOMMITTED-159))|(1<<(SQL92StatementParserCONDITION_NUMBER-159))|(1<<(SQL92StatementParserCONNECTION_NAME-159))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-159))|(1<<(SQL92StatementParserCONSTRAINT_NAME-159)))) != 0) || (((_la-191)&-(0x1f+1)) == 0 && ((1<<uint((_la-191)))&((1<<(SQL92StatementParserCONSTRAINT_SCHEMA-191))|(1<<(SQL92StatementParserCURSOR_NAME-191))|(1<<(SQL92StatementParserDATA-191))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-191))|(1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-191))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-191))|(1<<(SQL92StatementParserFORTRAN-191))|(1<<(SQL92StatementParserLENGTH-191))|(1<<(SQL92StatementParserMESSAGE_LENGTH-191))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-191))|(1<<(SQL92StatementParserMESSAGE_TEXT-191))|(1<<(SQL92StatementParserMORE92-191))|(1<<(SQL92StatementParserMUMPS-191))|(1<<(SQL92StatementParserNULLABLE-191))|(1<<(SQL92StatementParserNUMBER-191))|(1<<(SQL92StatementParserPASCAL-191))|(1<<(SQL92StatementParserPLI-191))|(1<<(SQL92StatementParserREPEATABLE-191))|(1<<(SQL92StatementParserRETURNED_LENGTH-191))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-191))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-191))|(1<<(SQL92StatementParserROW_COUNT-191))|(1<<(SQL92StatementParserSCALE-191))|(1<<(SQL92StatementParserSCHEMA_NAME-191))|(1<<(SQL92StatementParserSERIALIZABLE-191))|(1<<(SQL92StatementParserSERVER_NAME-191))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-191))|(1<<(SQL92StatementParserTABLE_NAME-191))|(1<<(SQL92StatementParserUNCOMMITTED-191))|(1<<(SQL92StatementParserUNNAMED-191)))) != 0) || (((_la-242)&-(0x1f+1)) == 0 && ((1<<uint((_la-242)))&((1<<(SQL92StatementParserCONVERT-242))|(1<<(SQL92StatementParserCURRENT_TIMESTAMP-242))|(1<<(SQL92StatementParserEXTRACT-242))|(1<<(SQL92StatementParserGLOBAL-242)))) != 0) || (((_la-340)&-(0x1f+1)) == 0 && ((1<<uint((_la-340)))&((1<<(SQL92StatementParserIDENTIFIER_-340))|(1<<(SQL92StatementParserSTRING_-340))|(1<<(SQL92StatementParserNUMBER_-340))|(1<<(SQL92StatementParserHEX_DIGIT_-340))|(1<<(SQL92StatementParserBIT_NUM_-340)))) != 0) {
		{
			p.SetState(1020)
			p.simpleExpr(0)
		}

	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SQL92StatementParserWHEN {
		{
			p.SetState(1023)
			p.CaseWhen()
		}

		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1029)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserELSE {
		{
			p.SetState(1028)
			p.CaseElse()
		}

	}
	{
		p.SetState(1031)
		p.Match(SQL92StatementParserEND)
	}

	return localctx
}

// ICaseWhenContext is an interface to support dynamic dispatch.
type ICaseWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseWhenContext differentiates from other interfaces.
	IsCaseWhenContext()
}

type CaseWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseWhenContext() *CaseWhenContext {
	var p = new(CaseWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_caseWhen
	return p
}

func (*CaseWhenContext) IsCaseWhenContext() {}

func NewCaseWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseWhenContext {
	var p = new(CaseWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_caseWhen

	return p
}

func (s *CaseWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWHEN, 0)
}

func (s *CaseWhenContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *CaseWhenContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseWhenContext) THEN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTHEN, 0)
}

func (s *CaseWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCaseWhen(s)
	}
}

func (s *CaseWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCaseWhen(s)
	}
}

func (s *CaseWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCaseWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CaseWhen() (localctx ICaseWhenContext) {
	this := p
	_ = this

	localctx = NewCaseWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, SQL92StatementParserRULE_caseWhen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.Match(SQL92StatementParserWHEN)
	}
	{
		p.SetState(1034)
		p.expr(0)
	}
	{
		p.SetState(1035)
		p.Match(SQL92StatementParserTHEN)
	}
	{
		p.SetState(1036)
		p.expr(0)
	}

	return localctx
}

// ICaseElseContext is an interface to support dynamic dispatch.
type ICaseElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCaseElseContext differentiates from other interfaces.
	IsCaseElseContext()
}

type CaseElseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseElseContext() *CaseElseContext {
	var p = new(CaseElseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_caseElse
	return p
}

func (*CaseElseContext) IsCaseElseContext() {}

func NewCaseElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseElseContext {
	var p = new(CaseElseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_caseElse

	return p
}

func (s *CaseElseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserELSE, 0)
}

func (s *CaseElseContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCaseElse(s)
	}
}

func (s *CaseElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCaseElse(s)
	}
}

func (s *CaseElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCaseElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CaseElse() (localctx ICaseElseContext) {
	this := p
	_ = this

	localctx = NewCaseElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, SQL92StatementParserRULE_caseElse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(SQL92StatementParserELSE)
	}
	{
		p.SetState(1039)
		p.expr(0)
	}

	return localctx
}

// IIntervalExpressionContext is an interface to support dynamic dispatch.
type IIntervalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalExpressionContext differentiates from other interfaces.
	IsIntervalExpressionContext()
}

type IntervalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalExpressionContext() *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_intervalExpression
	return p
}

func (*IntervalExpressionContext) IsIntervalExpressionContext() {}

func NewIntervalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalExpressionContext {
	var p = new(IntervalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_intervalExpression

	return p
}

func (s *IntervalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalExpressionContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINTERVAL, 0)
}

func (s *IntervalExpressionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IntervalExpressionContext) IntervalUnit() IIntervalUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalUnitContext)
}

func (s *IntervalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitIntervalExpression(s)
	}
}

func (s *IntervalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitIntervalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) IntervalExpression() (localctx IIntervalExpressionContext) {
	this := p
	_ = this

	localctx = NewIntervalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, SQL92StatementParserRULE_intervalExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1041)
		p.Match(SQL92StatementParserINTERVAL)
	}
	{
		p.SetState(1042)
		p.expr(0)
	}
	{
		p.SetState(1043)
		p.IntervalUnit()
	}

	return localctx
}

// IIntervalUnitContext is an interface to support dynamic dispatch.
type IIntervalUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalUnitContext differentiates from other interfaces.
	IsIntervalUnitContext()
}

type IntervalUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalUnitContext() *IntervalUnitContext {
	var p = new(IntervalUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_intervalUnit
	return p
}

func (*IntervalUnitContext) IsIntervalUnitContext() {}

func NewIntervalUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalUnitContext {
	var p = new(IntervalUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_intervalUnit

	return p
}

func (s *IntervalUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalUnitContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMICROSECOND, 0)
}

func (s *IntervalUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSECOND, 0)
}

func (s *IntervalUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMINUTE, 0)
}

func (s *IntervalUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserHOUR, 0)
}

func (s *IntervalUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDAY, 0)
}

func (s *IntervalUnitContext) WEEK() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWEEK, 0)
}

func (s *IntervalUnitContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMONTH, 0)
}

func (s *IntervalUnitContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserQUARTER, 0)
}

func (s *IntervalUnitContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserYEAR, 0)
}

func (s *IntervalUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterIntervalUnit(s)
	}
}

func (s *IntervalUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitIntervalUnit(s)
	}
}

func (s *IntervalUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitIntervalUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) IntervalUnit() (localctx IIntervalUnitContext) {
	this := p
	_ = this

	localctx = NewIntervalUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, SQL92StatementParserRULE_intervalUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(SQL92StatementParserYEAR-133))|(1<<(SQL92StatementParserQUARTER-133))|(1<<(SQL92StatementParserMONTH-133))|(1<<(SQL92StatementParserWEEK-133))|(1<<(SQL92StatementParserDAY-133))|(1<<(SQL92StatementParserHOUR-133))|(1<<(SQL92StatementParserMINUTE-133))|(1<<(SQL92StatementParserSECOND-133))|(1<<(SQL92StatementParserMICROSECOND-133)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByItem() []IOrderByItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem())
	var tst = make([]IOrderByItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByItemContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByItem(i int) IOrderByItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByItemContext)
}

func (s *OrderByClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *OrderByClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) OrderByClause() (localctx IOrderByClauseContext) {
	this := p
	_ = this

	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, SQL92StatementParserRULE_orderByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1047)
		p.Match(SQL92StatementParserORDER)
	}
	{
		p.SetState(1048)
		p.Match(SQL92StatementParserBY)
	}
	{
		p.SetState(1049)
		p.OrderByItem()
	}
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1050)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1051)
			p.OrderByItem()
		}

		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOrderByItemContext is an interface to support dynamic dispatch.
type IOrderByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByItemContext differentiates from other interfaces.
	IsOrderByItemContext()
}

type OrderByItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByItemContext() *OrderByItemContext {
	var p = new(OrderByItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_orderByItem
	return p
}

func (*OrderByItemContext) IsOrderByItemContext() {}

func NewOrderByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByItemContext {
	var p = new(OrderByItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_orderByItem

	return p
}

func (s *OrderByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByItemContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *OrderByItemContext) NumberLiterals() INumberLiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberLiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberLiteralsContext)
}

func (s *OrderByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASC, 0)
}

func (s *OrderByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDESC, 0)
}

func (s *OrderByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterOrderByItem(s)
	}
}

func (s *OrderByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitOrderByItem(s)
	}
}

func (s *OrderByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitOrderByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) OrderByItem() (localctx IOrderByItemContext) {
	this := p
	_ = this

	localctx = NewOrderByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, SQL92StatementParserRULE_orderByItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		{
			p.SetState(1057)
			p.ColumnName()
		}

	case SQL92StatementParserMINUS_, SQL92StatementParserNUMBER_:
		{
			p.SetState(1058)
			p.NumberLiterals()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserASC || _la == SQL92StatementParserDESC {
		{
			p.SetState(1061)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserASC || _la == SQL92StatementParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) DataTypeName() IDataTypeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *DataTypeContext) DataTypeLength() IDataTypeLengthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeLengthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeLengthContext)
}

func (s *DataTypeContext) CharacterSet() ICharacterSetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetContext)
}

func (s *DataTypeContext) CollateClause() ICollateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *DataTypeContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *DataTypeContext) AllSTRING_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserSTRING_)
}

func (s *DataTypeContext) STRING_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, i)
}

func (s *DataTypeContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *DataTypeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *DataTypeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DataType() (localctx IDataTypeContext) {
	this := p
	_ = this

	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, SQL92StatementParserRULE_dataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1064)
			p.DataTypeName()
		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserLP_ {
			{
				p.SetState(1065)
				p.DataTypeLength()
			}

		}
		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserCHAR || _la == SQL92StatementParserCHARACTER {
			{
				p.SetState(1068)
				p.CharacterSet()
			}

		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1071)
				p.CollateClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1074)
			p.DataTypeName()
		}
		{
			p.SetState(1075)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(1076)
			p.Match(SQL92StatementParserSTRING_)
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(1077)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(1078)
				p.Match(SQL92StatementParserSTRING_)
			}

			p.SetState(1083)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1084)
			p.Match(SQL92StatementParserRP_)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserCHAR || _la == SQL92StatementParserCHARACTER {
			{
				p.SetState(1085)
				p.CharacterSet()
			}

		}
		p.SetState(1089)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1088)
				p.CollateClause()
			}

		}

	}

	return localctx
}

// IDataTypeNameContext is an interface to support dynamic dispatch.
type IDataTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeNameContext differentiates from other interfaces.
	IsDataTypeNameContext()
}

type DataTypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeNameContext() *DataTypeNameContext {
	var p = new(DataTypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dataTypeName
	return p
}

func (*DataTypeNameContext) IsDataTypeNameContext() {}

func NewDataTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeNameContext {
	var p = new(DataTypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dataTypeName

	return p
}

func (s *DataTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeNameContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER, 0)
}

func (s *DataTypeNameContext) VARYING() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVARYING, 0)
}

func (s *DataTypeNameContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNATIONAL, 0)
}

func (s *DataTypeNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHAR, 0)
}

func (s *DataTypeNameContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVARCHAR, 0)
}

func (s *DataTypeNameContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNCHAR, 0)
}

func (s *DataTypeNameContext) BIT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserBIT, 0)
}

func (s *DataTypeNameContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMERIC, 0)
}

func (s *DataTypeNameContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDECIMAL, 0)
}

func (s *DataTypeNameContext) DEC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDEC, 0)
}

func (s *DataTypeNameContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINTEGER, 0)
}

func (s *DataTypeNameContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSMALLINT, 0)
}

func (s *DataTypeNameContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFLOAT, 0)
}

func (s *DataTypeNameContext) REAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREAL, 0)
}

func (s *DataTypeNameContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOUBLE, 0)
}

func (s *DataTypeNameContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPRECISION, 0)
}

func (s *DataTypeNameContext) DATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDATE, 0)
}

func (s *DataTypeNameContext) AllTIME() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserTIME)
}

func (s *DataTypeNameContext) TIME(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTIME, i)
}

func (s *DataTypeNameContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTIMESTAMP, 0)
}

func (s *DataTypeNameContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINTERVAL, 0)
}

func (s *DataTypeNameContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWITH, 0)
}

func (s *DataTypeNameContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserZONE, 0)
}

func (s *DataTypeNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDataTypeName(s)
	}
}

func (s *DataTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDataTypeName(s)
	}
}

func (s *DataTypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDataTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DataTypeName() (localctx IDataTypeNameContext) {
	this := p
	_ = this

	localctx = NewDataTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, SQL92StatementParserRULE_dataTypeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1093)
			p.Match(SQL92StatementParserCHARACTER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.Match(SQL92StatementParserCHARACTER)
		}
		{
			p.SetState(1095)
			p.Match(SQL92StatementParserVARYING)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1096)
			p.Match(SQL92StatementParserNATIONAL)
		}
		{
			p.SetState(1097)
			p.Match(SQL92StatementParserCHARACTER)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1098)
			p.Match(SQL92StatementParserNATIONAL)
		}
		{
			p.SetState(1099)
			p.Match(SQL92StatementParserCHARACTER)
		}
		{
			p.SetState(1100)
			p.Match(SQL92StatementParserVARYING)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1101)
			p.Match(SQL92StatementParserCHAR)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1102)
			p.Match(SQL92StatementParserVARCHAR)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1103)
			p.Match(SQL92StatementParserNCHAR)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1104)
			p.Match(SQL92StatementParserNATIONAL)
		}
		{
			p.SetState(1105)
			p.Match(SQL92StatementParserCHAR)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1106)
			p.Match(SQL92StatementParserNATIONAL)
		}
		{
			p.SetState(1107)
			p.Match(SQL92StatementParserCHAR)
		}
		{
			p.SetState(1108)
			p.Match(SQL92StatementParserVARYING)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1109)
			p.Match(SQL92StatementParserBIT)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1110)
			p.Match(SQL92StatementParserBIT)
		}
		{
			p.SetState(1111)
			p.Match(SQL92StatementParserVARYING)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1112)
			p.Match(SQL92StatementParserNUMERIC)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1113)
			p.Match(SQL92StatementParserDECIMAL)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1114)
			p.Match(SQL92StatementParserDEC)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1115)
			p.Match(SQL92StatementParserINTEGER)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1116)
			p.Match(SQL92StatementParserSMALLINT)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1117)
			p.Match(SQL92StatementParserFLOAT)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1118)
			p.Match(SQL92StatementParserREAL)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1119)
			p.Match(SQL92StatementParserDOUBLE)
		}
		{
			p.SetState(1120)
			p.Match(SQL92StatementParserPRECISION)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1121)
			p.Match(SQL92StatementParserDATE)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1122)
			p.Match(SQL92StatementParserTIME)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1123)
			p.Match(SQL92StatementParserTIMESTAMP)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1124)
			p.Match(SQL92StatementParserINTERVAL)
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1125)
			p.Match(SQL92StatementParserTIME)
		}
		{
			p.SetState(1126)
			p.Match(SQL92StatementParserWITH)
		}
		{
			p.SetState(1127)
			p.Match(SQL92StatementParserTIME)
		}
		{
			p.SetState(1128)
			p.Match(SQL92StatementParserZONE)
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1129)
			p.Match(SQL92StatementParserTIMESTAMP)
		}
		{
			p.SetState(1130)
			p.Match(SQL92StatementParserWITH)
		}
		{
			p.SetState(1131)
			p.Match(SQL92StatementParserTIME)
		}
		{
			p.SetState(1132)
			p.Match(SQL92StatementParserZONE)
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1133)
			p.Identifier()
		}

	}

	return localctx
}

// IDataTypeLengthContext is an interface to support dynamic dispatch.
type IDataTypeLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeLengthContext differentiates from other interfaces.
	IsDataTypeLengthContext()
}

type DataTypeLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeLengthContext() *DataTypeLengthContext {
	var p = new(DataTypeLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dataTypeLength
	return p
}

func (*DataTypeLengthContext) IsDataTypeLengthContext() {}

func NewDataTypeLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeLengthContext {
	var p = new(DataTypeLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dataTypeLength

	return p
}

func (s *DataTypeLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeLengthContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *DataTypeLengthContext) AllNUMBER_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserNUMBER_)
}

func (s *DataTypeLengthContext) NUMBER_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMBER_, i)
}

func (s *DataTypeLengthContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *DataTypeLengthContext) COMMA_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, 0)
}

func (s *DataTypeLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDataTypeLength(s)
	}
}

func (s *DataTypeLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDataTypeLength(s)
	}
}

func (s *DataTypeLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDataTypeLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DataTypeLength() (localctx IDataTypeLengthContext) {
	this := p
	_ = this

	localctx = NewDataTypeLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, SQL92StatementParserRULE_dataTypeLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(1137)
		p.Match(SQL92StatementParserNUMBER_)
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1138)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1139)
			p.Match(SQL92StatementParserNUMBER_)
		}

	}
	{
		p.SetState(1142)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// ICharacterSetContext is an interface to support dynamic dispatch.
type ICharacterSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterSetContext differentiates from other interfaces.
	IsCharacterSetContext()
}

type CharacterSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterSetContext() *CharacterSetContext {
	var p = new(CharacterSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_characterSet
	return p
}

func (*CharacterSetContext) IsCharacterSetContext() {}

func NewCharacterSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterSetContext {
	var p = new(CharacterSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_characterSet

	return p
}

func (s *CharacterSetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterSetContext) SET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSET, 0)
}

func (s *CharacterSetContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *CharacterSetContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER, 0)
}

func (s *CharacterSetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHAR, 0)
}

func (s *CharacterSetContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEQ_, 0)
}

func (s *CharacterSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCharacterSet(s)
	}
}

func (s *CharacterSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCharacterSet(s)
	}
}

func (s *CharacterSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCharacterSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CharacterSet() (localctx ICharacterSetContext) {
	this := p
	_ = this

	localctx = NewCharacterSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, SQL92StatementParserRULE_characterSet)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserCHAR || _la == SQL92StatementParserCHARACTER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1145)
		p.Match(SQL92StatementParserSET)
	}
	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserEQ_ {
		{
			p.SetState(1146)
			p.Match(SQL92StatementParserEQ_)
		}

	}
	{
		p.SetState(1149)
		p.IgnoredIdentifier()
	}

	return localctx
}

// ICollateClauseContext is an interface to support dynamic dispatch.
type ICollateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollateClauseContext differentiates from other interfaces.
	IsCollateClauseContext()
}

type CollateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateClauseContext() *CollateClauseContext {
	var p = new(CollateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_collateClause
	return p
}

func (*CollateClauseContext) IsCollateClauseContext() {}

func NewCollateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateClauseContext {
	var p = new(CollateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_collateClause

	return p
}

func (s *CollateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateClauseContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLLATE, 0)
}

func (s *CollateClauseContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *CollateClauseContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *CollateClauseContext) EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEQ_, 0)
}

func (s *CollateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCollateClause(s)
	}
}

func (s *CollateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCollateClause(s)
	}
}

func (s *CollateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCollateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CollateClause() (localctx ICollateClauseContext) {
	this := p
	_ = this

	localctx = NewCollateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, SQL92StatementParserRULE_collateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		p.Match(SQL92StatementParserCOLLATE)
	}
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserEQ_ {
		{
			p.SetState(1152)
			p.Match(SQL92StatementParserEQ_)
		}

	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserSTRING_:
		{
			p.SetState(1155)
			p.Match(SQL92StatementParserSTRING_)
		}

	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		{
			p.SetState(1156)
			p.IgnoredIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIgnoredIdentifierContext is an interface to support dynamic dispatch.
type IIgnoredIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIgnoredIdentifierContext differentiates from other interfaces.
	IsIgnoredIdentifierContext()
}

type IgnoredIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoredIdentifierContext() *IgnoredIdentifierContext {
	var p = new(IgnoredIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_ignoredIdentifier
	return p
}

func (*IgnoredIdentifierContext) IsIgnoredIdentifierContext() {}

func NewIgnoredIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoredIdentifierContext {
	var p = new(IgnoredIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_ignoredIdentifier

	return p
}

func (s *IgnoredIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoredIdentifierContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *IgnoredIdentifierContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IgnoredIdentifierContext) DOT_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDOT_, 0)
}

func (s *IgnoredIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoredIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoredIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterIgnoredIdentifier(s)
	}
}

func (s *IgnoredIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitIgnoredIdentifier(s)
	}
}

func (s *IgnoredIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitIgnoredIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) IgnoredIdentifier() (localctx IIgnoredIdentifierContext) {
	this := p
	_ = this

	localctx = NewIgnoredIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, SQL92StatementParserRULE_ignoredIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Identifier()
	}
	p.SetState(1162)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1160)
			p.Match(SQL92StatementParserDOT_)
		}
		{
			p.SetState(1161)
			p.Identifier()
		}

	}

	return localctx
}

// IDropBehaviourContext is an interface to support dynamic dispatch.
type IDropBehaviourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropBehaviourContext differentiates from other interfaces.
	IsDropBehaviourContext()
}

type DropBehaviourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBehaviourContext() *DropBehaviourContext {
	var p = new(DropBehaviourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropBehaviour
	return p
}

func (*DropBehaviourContext) IsDropBehaviourContext() {}

func NewDropBehaviourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBehaviourContext {
	var p = new(DropBehaviourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropBehaviour

	return p
}

func (s *DropBehaviourContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBehaviourContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCASCADE, 0)
}

func (s *DropBehaviourContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRESTRICT, 0)
}

func (s *DropBehaviourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBehaviourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBehaviourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropBehaviour(s)
	}
}

func (s *DropBehaviourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropBehaviour(s)
	}
}

func (s *DropBehaviourContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropBehaviour(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropBehaviour() (localctx IDropBehaviourContext) {
	this := p
	_ = this

	localctx = NewDropBehaviourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, SQL92StatementParserRULE_dropBehaviour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1165)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCASCADE || _la == SQL92StatementParserRESTRICT {
		{
			p.SetState(1164)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserCASCADE || _la == SQL92StatementParserRESTRICT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createTable
	return p
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTABLE, 0)
}

func (s *CreateTableContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableContext) CreateDefinitionClause() ICreateDefinitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDefinitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionClauseContext)
}

func (s *CreateTableContext) CreateLikeClause() ICreateLikeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateLikeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateLikeClauseContext)
}

func (s *CreateTableContext) CreateTableSpecification() ICreateTableSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateTableSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreateTableSpecificationContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateTable() (localctx ICreateTableContext) {
	this := p
	_ = this

	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, SQL92StatementParserRULE_createTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(SQL92StatementParserCREATE)
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLOCAL || _la == SQL92StatementParserGLOBAL {
		{
			p.SetState(1168)
			p.CreateTableSpecification()
		}

	}
	{
		p.SetState(1171)
		p.Match(SQL92StatementParserTABLE)
	}
	{
		p.SetState(1172)
		p.TableName()
	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1173)
			p.CreateDefinitionClause()
		}

	case 2:
		{
			p.SetState(1174)
			p.CreateLikeClause()
		}

	}

	return localctx
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_alterTable
	return p
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTABLE, 0)
}

func (s *AlterTableContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterTableContext) AlterDefinitionClause() IAlterDefinitionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterDefinitionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlterDefinitionClauseContext)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AlterTable() (localctx IAlterTableContext) {
	this := p
	_ = this

	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, SQL92StatementParserRULE_alterTable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1177)
		p.Match(SQL92StatementParserALTER)
	}
	{
		p.SetState(1178)
		p.Match(SQL92StatementParserTABLE)
	}
	{
		p.SetState(1179)
		p.TableName()
	}
	{
		p.SetState(1180)
		p.AlterDefinitionClause()
	}

	return localctx
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropTable
	return p
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTABLE, 0)
}

func (s *DropTableContext) TableNames() ITableNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNamesContext)
}

func (s *DropTableContext) DropBehaviour() IDropBehaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropBehaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropBehaviourContext)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropTable() (localctx IDropTableContext) {
	this := p
	_ = this

	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, SQL92StatementParserRULE_dropTable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.Match(SQL92StatementParserDROP)
	}
	{
		p.SetState(1183)
		p.Match(SQL92StatementParserTABLE)
	}
	{
		p.SetState(1184)
		p.TableNames()
	}
	{
		p.SetState(1185)
		p.DropBehaviour()
	}

	return localctx
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createDatabase
	return p
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCREATE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseSpecification_() []ICreateDatabaseSpecification_Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICreateDatabaseSpecification_Context)(nil)).Elem())
	var tst = make([]ICreateDatabaseSpecification_Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICreateDatabaseSpecification_Context)
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseSpecification_(i int) ICreateDatabaseSpecification_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDatabaseSpecification_Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseSpecification_Context)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	this := p
	_ = this

	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, SQL92StatementParserRULE_createDatabase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Match(SQL92StatementParserCREATE)
	}
	{
		p.SetState(1188)
		p.Match(SQL92StatementParserSCHEMA)
	}
	{
		p.SetState(1189)
		p.SchemaName()
	}
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserDEFAULT {
		{
			p.SetState(1190)
			p.CreateDatabaseSpecification_()
		}

		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropDatabase
	return p
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDROP, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSCHEMA, 0)
}

func (s *DropDatabaseContext) SchemaName() ISchemaNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *DropDatabaseContext) DropBehaviour() IDropBehaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropBehaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropBehaviourContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropDatabase() (localctx IDropDatabaseContext) {
	this := p
	_ = this

	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, SQL92StatementParserRULE_dropDatabase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		p.Match(SQL92StatementParserDROP)
	}
	{
		p.SetState(1197)
		p.Match(SQL92StatementParserSCHEMA)
	}
	{
		p.SetState(1198)
		p.SchemaName()
	}
	{
		p.SetState(1199)
		p.DropBehaviour()
	}

	return localctx
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createView
	return p
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVIEW, 0)
}

func (s *CreateViewContext) ViewName() IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserAS, 0)
}

func (s *CreateViewContext) Select() ISelectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectContext)
}

func (s *CreateViewContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *CreateViewContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *CreateViewContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateViewContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *CreateViewContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWITH, 0)
}

func (s *CreateViewContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHECK, 0)
}

func (s *CreateViewContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOPTION, 0)
}

func (s *CreateViewContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *CreateViewContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *CreateViewContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCASCADED, 0)
}

func (s *CreateViewContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLOCAL, 0)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateView() (localctx ICreateViewContext) {
	this := p
	_ = this

	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, SQL92StatementParserRULE_createView)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Match(SQL92StatementParserCREATE)
	}
	{
		p.SetState(1202)
		p.Match(SQL92StatementParserVIEW)
	}
	{
		p.SetState(1203)
		p.ViewName()
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ {
		{
			p.SetState(1204)
			p.Match(SQL92StatementParserLP_)
		}
		{
			p.SetState(1205)
			p.Identifier()
		}
		p.SetState(1210)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == SQL92StatementParserCOMMA_ {
			{
				p.SetState(1206)
				p.Match(SQL92StatementParserCOMMA_)
			}
			{
				p.SetState(1207)
				p.Identifier()
			}

			p.SetState(1212)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1213)
			p.Match(SQL92StatementParserRP_)
		}

	}
	{
		p.SetState(1217)
		p.Match(SQL92StatementParserAS)
	}
	{
		p.SetState(1218)
		p.Select()
	}
	p.SetState(1225)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserWITH {
		{
			p.SetState(1219)
			p.Match(SQL92StatementParserWITH)
		}
		p.SetState(1221)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserCASCADED || _la == SQL92StatementParserLOCAL {
			{
				p.SetState(1220)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SQL92StatementParserCASCADED || _la == SQL92StatementParserLOCAL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1223)
			p.Match(SQL92StatementParserCHECK)
		}
		{
			p.SetState(1224)
			p.Match(SQL92StatementParserOPTION)
		}

	}

	return localctx
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropView
	return p
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserVIEW, 0)
}

func (s *DropViewContext) ViewName() IViewNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *DropViewContext) DropBehaviour() IDropBehaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropBehaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropBehaviourContext)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropView() (localctx IDropViewContext) {
	this := p
	_ = this

	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, SQL92StatementParserRULE_dropView)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1227)
		p.Match(SQL92StatementParserDROP)
	}
	{
		p.SetState(1228)
		p.Match(SQL92StatementParserVIEW)
	}
	{
		p.SetState(1229)
		p.ViewName()
	}
	{
		p.SetState(1230)
		p.DropBehaviour()
	}

	return localctx
}

// ICreateTableSpecificationContext is an interface to support dynamic dispatch.
type ICreateTableSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateTableSpecificationContext differentiates from other interfaces.
	IsCreateTableSpecificationContext()
}

type CreateTableSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableSpecificationContext() *CreateTableSpecificationContext {
	var p = new(CreateTableSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createTableSpecification
	return p
}

func (*CreateTableSpecificationContext) IsCreateTableSpecificationContext() {}

func NewCreateTableSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableSpecificationContext {
	var p = new(CreateTableSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createTableSpecification

	return p
}

func (s *CreateTableSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableSpecificationContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTEMPORARY, 0)
}

func (s *CreateTableSpecificationContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGLOBAL, 0)
}

func (s *CreateTableSpecificationContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLOCAL, 0)
}

func (s *CreateTableSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateTableSpecification(s)
	}
}

func (s *CreateTableSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateTableSpecification(s)
	}
}

func (s *CreateTableSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateTableSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateTableSpecification() (localctx ICreateTableSpecificationContext) {
	this := p
	_ = this

	localctx = NewCreateTableSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, SQL92StatementParserRULE_createTableSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SQL92StatementParserLOCAL || _la == SQL92StatementParserGLOBAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1233)
		p.Match(SQL92StatementParserTEMPORARY)
	}

	return localctx
}

// ICreateDefinitionClauseContext is an interface to support dynamic dispatch.
type ICreateDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDefinitionClauseContext differentiates from other interfaces.
	IsCreateDefinitionClauseContext()
}

type CreateDefinitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionClauseContext() *CreateDefinitionClauseContext {
	var p = new(CreateDefinitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createDefinitionClause
	return p
}

func (*CreateDefinitionClauseContext) IsCreateDefinitionClauseContext() {}

func NewCreateDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionClauseContext {
	var p = new(CreateDefinitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createDefinitionClause

	return p
}

func (s *CreateDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *CreateDefinitionClauseContext) AllCreateDefinition() []ICreateDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICreateDefinitionContext)(nil)).Elem())
	var tst = make([]ICreateDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICreateDefinitionContext)
		}
	}

	return tst
}

func (s *CreateDefinitionClauseContext) CreateDefinition(i int) ICreateDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreateDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICreateDefinitionContext)
}

func (s *CreateDefinitionClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *CreateDefinitionClauseContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *CreateDefinitionClauseContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *CreateDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateDefinitionClause(s)
	}
}

func (s *CreateDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateDefinitionClause(s)
	}
}

func (s *CreateDefinitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateDefinitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateDefinitionClause() (localctx ICreateDefinitionClauseContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, SQL92StatementParserRULE_createDefinitionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(1236)
		p.CreateDefinition()
	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1237)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1238)
			p.CreateDefinition()
		}

		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1244)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// ICreateDatabaseSpecification_Context is an interface to support dynamic dispatch.
type ICreateDatabaseSpecification_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDatabaseSpecification_Context differentiates from other interfaces.
	IsCreateDatabaseSpecification_Context()
}

type CreateDatabaseSpecification_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseSpecification_Context() *CreateDatabaseSpecification_Context {
	var p = new(CreateDatabaseSpecification_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createDatabaseSpecification_
	return p
}

func (*CreateDatabaseSpecification_Context) IsCreateDatabaseSpecification_Context() {}

func NewCreateDatabaseSpecification_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseSpecification_Context {
	var p = new(CreateDatabaseSpecification_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createDatabaseSpecification_

	return p
}

func (s *CreateDatabaseSpecification_Context) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseSpecification_Context) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDEFAULT, 0)
}

func (s *CreateDatabaseSpecification_Context) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHARACTER, 0)
}

func (s *CreateDatabaseSpecification_Context) SET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSET, 0)
}

func (s *CreateDatabaseSpecification_Context) CharacterSetName() ICharacterSetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharacterSetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharacterSetNameContext)
}

func (s *CreateDatabaseSpecification_Context) EQ_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserEQ_, 0)
}

func (s *CreateDatabaseSpecification_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseSpecification_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseSpecification_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateDatabaseSpecification_(s)
	}
}

func (s *CreateDatabaseSpecification_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateDatabaseSpecification_(s)
	}
}

func (s *CreateDatabaseSpecification_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateDatabaseSpecification_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateDatabaseSpecification_() (localctx ICreateDatabaseSpecification_Context) {
	this := p
	_ = this

	localctx = NewCreateDatabaseSpecification_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, SQL92StatementParserRULE_createDatabaseSpecification_)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Match(SQL92StatementParserDEFAULT)
	}
	{
		p.SetState(1247)
		p.Match(SQL92StatementParserCHARACTER)
	}
	{
		p.SetState(1248)
		p.Match(SQL92StatementParserSET)
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserEQ_ {
		{
			p.SetState(1249)
			p.Match(SQL92StatementParserEQ_)
		}

	}
	{
		p.SetState(1252)
		p.CharacterSetName()
	}

	return localctx
}

// ICreateDefinitionContext is an interface to support dynamic dispatch.
type ICreateDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateDefinitionContext differentiates from other interfaces.
	IsCreateDefinitionContext()
}

type CreateDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDefinitionContext() *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createDefinition
	return p
}

func (*CreateDefinitionContext) IsCreateDefinitionContext() {}

func NewCreateDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDefinitionContext {
	var p = new(CreateDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createDefinition

	return p
}

func (s *CreateDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDefinitionContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *CreateDefinitionContext) ConstraintDefinition() IConstraintDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintDefinitionContext)
}

func (s *CreateDefinitionContext) CheckConstraintDefinition() ICheckConstraintDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckConstraintDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintDefinitionContext)
}

func (s *CreateDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateDefinition(s)
	}
}

func (s *CreateDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateDefinition(s)
	}
}

func (s *CreateDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateDefinition() (localctx ICreateDefinitionContext) {
	this := p
	_ = this

	localctx = NewCreateDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, SQL92StatementParserRULE_createDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1254)
			p.ColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1255)
			p.ConstraintDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1256)
			p.CheckConstraintDefinition()
		}

	}

	return localctx
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_columnDefinition
	return p
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) AllDataTypeOption() []IDataTypeOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDataTypeOptionContext)(nil)).Elem())
	var tst = make([]IDataTypeOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDataTypeOptionContext)
		}
	}

	return tst
}

func (s *ColumnDefinitionContext) DataTypeOption(i int) IDataTypeOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDataTypeOptionContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	this := p
	_ = this

	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, SQL92StatementParserRULE_columnDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1259)
		p.ColumnName()
	}
	{
		p.SetState(1260)
		p.DataType()
	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(SQL92StatementParserCONSTRAINT-58))|(1<<(SQL92StatementParserPRIMARY-58))|(1<<(SQL92StatementParserUNIQUE-58)))) != 0) || _la == SQL92StatementParserNOT || _la == SQL92StatementParserNULL || _la == SQL92StatementParserDEFAULT || _la == SQL92StatementParserCHECK || _la == SQL92StatementParserCOLLATE || _la == SQL92StatementParserREFERENCES || _la == SQL92StatementParserSTRING_ {
		{
			p.SetState(1261)
			p.DataTypeOption()
		}

		p.SetState(1266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataTypeOptionContext is an interface to support dynamic dispatch.
type IDataTypeOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeOptionContext differentiates from other interfaces.
	IsDataTypeOptionContext()
}

type DataTypeOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeOptionContext() *DataTypeOptionContext {
	var p = new(DataTypeOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dataTypeOption
	return p
}

func (*DataTypeOptionContext) IsDataTypeOptionContext() {}

func NewDataTypeOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeOptionContext {
	var p = new(DataTypeOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dataTypeOption

	return p
}

func (s *DataTypeOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeOptionContext) PrimaryKey() IPrimaryKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *DataTypeOptionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNIQUE, 0)
}

func (s *DataTypeOptionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserKEY, 0)
}

func (s *DataTypeOptionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULL, 0)
}

func (s *DataTypeOptionContext) NOT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNOT, 0)
}

func (s *DataTypeOptionContext) CollateClause() ICollateClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollateClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollateClauseContext)
}

func (s *DataTypeOptionContext) CheckConstraintDefinition() ICheckConstraintDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICheckConstraintDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintDefinitionContext)
}

func (s *DataTypeOptionContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *DataTypeOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDEFAULT, 0)
}

func (s *DataTypeOptionContext) Literals() ILiteralsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralsContext)
}

func (s *DataTypeOptionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DataTypeOptionContext) STRING_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSTRING_, 0)
}

func (s *DataTypeOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDataTypeOption(s)
	}
}

func (s *DataTypeOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDataTypeOption(s)
	}
}

func (s *DataTypeOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDataTypeOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DataTypeOption() (localctx IDataTypeOptionContext) {
	this := p
	_ = this

	localctx = NewDataTypeOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, SQL92StatementParserRULE_dataTypeOption)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1285)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1267)
			p.PrimaryKey()
		}

	case SQL92StatementParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1268)
			p.Match(SQL92StatementParserUNIQUE)
		}
		p.SetState(1270)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserKEY {
			{
				p.SetState(1269)
				p.Match(SQL92StatementParserKEY)
			}

		}

	case SQL92StatementParserNOT, SQL92StatementParserNULL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1273)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserNOT {
			{
				p.SetState(1272)
				p.Match(SQL92StatementParserNOT)
			}

		}
		{
			p.SetState(1275)
			p.Match(SQL92StatementParserNULL)
		}

	case SQL92StatementParserCOLLATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1276)
			p.CollateClause()
		}

	case SQL92StatementParserCONSTRAINT, SQL92StatementParserCHECK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1277)
			p.CheckConstraintDefinition()
		}

	case SQL92StatementParserREFERENCES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1278)
			p.ReferenceDefinition()
		}

	case SQL92StatementParserDEFAULT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1279)
			p.Match(SQL92StatementParserDEFAULT)
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1280)
				p.Literals()
			}

		case 2:
			{
				p.SetState(1281)
				p.expr(0)
			}

		}

	case SQL92StatementParserSTRING_:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1284)
			p.Match(SQL92StatementParserSTRING_)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICheckConstraintDefinitionContext is an interface to support dynamic dispatch.
type ICheckConstraintDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCheckConstraintDefinitionContext differentiates from other interfaces.
	IsCheckConstraintDefinitionContext()
}

type CheckConstraintDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckConstraintDefinitionContext() *CheckConstraintDefinitionContext {
	var p = new(CheckConstraintDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_checkConstraintDefinition
	return p
}

func (*CheckConstraintDefinitionContext) IsCheckConstraintDefinitionContext() {}

func NewCheckConstraintDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintDefinitionContext {
	var p = new(CheckConstraintDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_checkConstraintDefinition

	return p
}

func (s *CheckConstraintDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintDefinitionContext) CHECK() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCHECK, 0)
}

func (s *CheckConstraintDefinitionContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckConstraintDefinitionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONSTRAINT, 0)
}

func (s *CheckConstraintDefinitionContext) IgnoredIdentifier() IIgnoredIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIgnoredIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIgnoredIdentifierContext)
}

func (s *CheckConstraintDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckConstraintDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCheckConstraintDefinition(s)
	}
}

func (s *CheckConstraintDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCheckConstraintDefinition(s)
	}
}

func (s *CheckConstraintDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCheckConstraintDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CheckConstraintDefinition() (localctx ICheckConstraintDefinitionContext) {
	this := p
	_ = this

	localctx = NewCheckConstraintDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, SQL92StatementParserRULE_checkConstraintDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCONSTRAINT {
		{
			p.SetState(1287)
			p.Match(SQL92StatementParserCONSTRAINT)
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ {
			{
				p.SetState(1288)
				p.IgnoredIdentifier()
			}

		}

	}
	{
		p.SetState(1293)
		p.Match(SQL92StatementParserCHECK)
	}
	{
		p.SetState(1294)
		p.expr(0)
	}

	return localctx
}

// IReferenceDefinitionContext is an interface to support dynamic dispatch.
type IReferenceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceDefinitionContext differentiates from other interfaces.
	IsReferenceDefinitionContext()
}

type ReferenceDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceDefinitionContext() *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_referenceDefinition
	return p
}

func (*ReferenceDefinitionContext) IsReferenceDefinitionContext() {}

func NewReferenceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceDefinitionContext {
	var p = new(ReferenceDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_referenceDefinition

	return p
}

func (s *ReferenceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceDefinitionContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREFERENCES, 0)
}

func (s *ReferenceDefinitionContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ReferenceDefinitionContext) KeyParts() IKeyPartsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyPartsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyPartsContext)
}

func (s *ReferenceDefinitionContext) MATCH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserMATCH, 0)
}

func (s *ReferenceDefinitionContext) FULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFULL, 0)
}

func (s *ReferenceDefinitionContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPARTIAL, 0)
}

func (s *ReferenceDefinitionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNIQUE, 0)
}

func (s *ReferenceDefinitionContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserON)
}

func (s *ReferenceDefinitionContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserON, i)
}

func (s *ReferenceDefinitionContext) AllReferenceOption() []IReferenceOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IReferenceOptionContext)(nil)).Elem())
	var tst = make([]IReferenceOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IReferenceOptionContext)
		}
	}

	return tst
}

func (s *ReferenceDefinitionContext) ReferenceOption(i int) IReferenceOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IReferenceOptionContext)
}

func (s *ReferenceDefinitionContext) AllUPDATE() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserUPDATE)
}

func (s *ReferenceDefinitionContext) UPDATE(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUPDATE, i)
}

func (s *ReferenceDefinitionContext) AllDELETE() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserDELETE)
}

func (s *ReferenceDefinitionContext) DELETE(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDELETE, i)
}

func (s *ReferenceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitReferenceDefinition(s)
	}
}

func (s *ReferenceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitReferenceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ReferenceDefinition() (localctx IReferenceDefinitionContext) {
	this := p
	_ = this

	localctx = NewReferenceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, SQL92StatementParserRULE_referenceDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1296)
		p.Match(SQL92StatementParserREFERENCES)
	}
	{
		p.SetState(1297)
		p.TableName()
	}
	{
		p.SetState(1298)
		p.KeyParts()
	}
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1299)
			p.Match(SQL92StatementParserMATCH)
		}
		{
			p.SetState(1300)
			p.Match(SQL92StatementParserFULL)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1301)
			p.Match(SQL92StatementParserMATCH)
		}
		{
			p.SetState(1302)
			p.Match(SQL92StatementParserPARTIAL)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1303)
			p.Match(SQL92StatementParserMATCH)
		}
		{
			p.SetState(1304)
			p.Match(SQL92StatementParserUNIQUE)
		}

	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserON {
		{
			p.SetState(1307)
			p.Match(SQL92StatementParserON)
		}
		{
			p.SetState(1308)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserUPDATE || _la == SQL92StatementParserDELETE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1309)
			p.ReferenceOption()
		}

		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReferenceOptionContext is an interface to support dynamic dispatch.
type IReferenceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceOptionContext differentiates from other interfaces.
	IsReferenceOptionContext()
}

type ReferenceOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceOptionContext() *ReferenceOptionContext {
	var p = new(ReferenceOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_referenceOption
	return p
}

func (*ReferenceOptionContext) IsReferenceOptionContext() {}

func NewReferenceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceOptionContext {
	var p = new(ReferenceOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_referenceOption

	return p
}

func (s *ReferenceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceOptionContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRESTRICT, 0)
}

func (s *ReferenceOptionContext) CASCADE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCASCADE, 0)
}

func (s *ReferenceOptionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSET, 0)
}

func (s *ReferenceOptionContext) NULL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNULL, 0)
}

func (s *ReferenceOptionContext) NO() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNO, 0)
}

func (s *ReferenceOptionContext) ACTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserACTION, 0)
}

func (s *ReferenceOptionContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDEFAULT, 0)
}

func (s *ReferenceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterReferenceOption(s)
	}
}

func (s *ReferenceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitReferenceOption(s)
	}
}

func (s *ReferenceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitReferenceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ReferenceOption() (localctx IReferenceOptionContext) {
	this := p
	_ = this

	localctx = NewReferenceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, SQL92StatementParserRULE_referenceOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1315)
			p.Match(SQL92StatementParserRESTRICT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1316)
			p.Match(SQL92StatementParserCASCADE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1317)
			p.Match(SQL92StatementParserSET)
		}
		{
			p.SetState(1318)
			p.Match(SQL92StatementParserNULL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1319)
			p.Match(SQL92StatementParserNO)
		}
		{
			p.SetState(1320)
			p.Match(SQL92StatementParserACTION)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1321)
			p.Match(SQL92StatementParserSET)
		}
		{
			p.SetState(1322)
			p.Match(SQL92StatementParserDEFAULT)
		}

	}

	return localctx
}

// IKeyPartsContext is an interface to support dynamic dispatch.
type IKeyPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyPartsContext differentiates from other interfaces.
	IsKeyPartsContext()
}

type KeyPartsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartsContext() *KeyPartsContext {
	var p = new(KeyPartsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_keyParts
	return p
}

func (*KeyPartsContext) IsKeyPartsContext() {}

func NewKeyPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartsContext {
	var p = new(KeyPartsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_keyParts

	return p
}

func (s *KeyPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartsContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *KeyPartsContext) AllKeyPart() []IKeyPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyPartContext)(nil)).Elem())
	var tst = make([]IKeyPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyPartContext)
		}
	}

	return tst
}

func (s *KeyPartsContext) KeyPart(i int) IKeyPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyPartContext)
}

func (s *KeyPartsContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *KeyPartsContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *KeyPartsContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *KeyPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterKeyParts(s)
	}
}

func (s *KeyPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitKeyParts(s)
	}
}

func (s *KeyPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitKeyParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) KeyParts() (localctx IKeyPartsContext) {
	this := p
	_ = this

	localctx = NewKeyPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, SQL92StatementParserRULE_keyParts)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1325)
		p.Match(SQL92StatementParserLP_)
	}
	{
		p.SetState(1326)
		p.KeyPart()
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1327)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1328)
			p.KeyPart()
		}

		p.SetState(1333)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1334)
		p.Match(SQL92StatementParserRP_)
	}

	return localctx
}

// IKeyPartContext is an interface to support dynamic dispatch.
type IKeyPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyPartContext differentiates from other interfaces.
	IsKeyPartContext()
}

type KeyPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartContext() *KeyPartContext {
	var p = new(KeyPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_keyPart
	return p
}

func (*KeyPartContext) IsKeyPartContext() {}

func NewKeyPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartContext {
	var p = new(KeyPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_keyPart

	return p
}

func (s *KeyPartContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *KeyPartContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *KeyPartContext) ASC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserASC, 0)
}

func (s *KeyPartContext) DESC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDESC, 0)
}

func (s *KeyPartContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *KeyPartContext) NUMBER_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserNUMBER_, 0)
}

func (s *KeyPartContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *KeyPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterKeyPart(s)
	}
}

func (s *KeyPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitKeyPart(s)
	}
}

func (s *KeyPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitKeyPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) KeyPart() (localctx IKeyPartContext) {
	this := p
	_ = this

	localctx = NewKeyPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, SQL92StatementParserRULE_keyPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1336)
			p.ColumnName()
		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == SQL92StatementParserLP_ {
			{
				p.SetState(1337)
				p.Match(SQL92StatementParserLP_)
			}
			{
				p.SetState(1338)
				p.Match(SQL92StatementParserNUMBER_)
			}
			{
				p.SetState(1339)
				p.Match(SQL92StatementParserRP_)
			}

		}

	case 2:
		{
			p.SetState(1342)
			p.expr(0)
		}

	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserASC || _la == SQL92StatementParserDESC {
		{
			p.SetState(1345)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SQL92StatementParserASC || _la == SQL92StatementParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IConstraintDefinitionContext is an interface to support dynamic dispatch.
type IConstraintDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintDefinitionContext differentiates from other interfaces.
	IsConstraintDefinitionContext()
}

type ConstraintDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintDefinitionContext() *ConstraintDefinitionContext {
	var p = new(ConstraintDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_constraintDefinition
	return p
}

func (*ConstraintDefinitionContext) IsConstraintDefinitionContext() {}

func NewConstraintDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintDefinitionContext {
	var p = new(ConstraintDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_constraintDefinition

	return p
}

func (s *ConstraintDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintDefinitionContext) PrimaryKeyOption() IPrimaryKeyOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyOptionContext)
}

func (s *ConstraintDefinitionContext) UniqueOption() IUniqueOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUniqueOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUniqueOptionContext)
}

func (s *ConstraintDefinitionContext) ForeignKeyOption() IForeignKeyOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeignKeyOptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForeignKeyOptionContext)
}

func (s *ConstraintDefinitionContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCONSTRAINT, 0)
}

func (s *ConstraintDefinitionContext) ConstraintName() IConstraintNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ConstraintDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterConstraintDefinition(s)
	}
}

func (s *ConstraintDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitConstraintDefinition(s)
	}
}

func (s *ConstraintDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitConstraintDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ConstraintDefinition() (localctx IConstraintDefinitionContext) {
	this := p
	_ = this

	localctx = NewConstraintDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, SQL92StatementParserRULE_constraintDefinition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCONSTRAINT {
		{
			p.SetState(1348)
			p.Match(SQL92StatementParserCONSTRAINT)
		}
		p.SetState(1350)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(SQL92StatementParserNAME-163))|(1<<(SQL92StatementParserTYPE-163))|(1<<(SQL92StatementParserADA-163))|(1<<(SQL92StatementParserC92-163))|(1<<(SQL92StatementParserCATALOG_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_CATALOG-163))|(1<<(SQL92StatementParserCHARACTER_SET_NAME-163))|(1<<(SQL92StatementParserCHARACTER_SET_SCHEMA-163))|(1<<(SQL92StatementParserCLASS_ORIGIN-163))|(1<<(SQL92StatementParserCOBOL-163))|(1<<(SQL92StatementParserCOLLATION_CATALOG-163))|(1<<(SQL92StatementParserCOLLATION_NAME-163))|(1<<(SQL92StatementParserCOLLATION_SCHEMA-163))|(1<<(SQL92StatementParserCOLUMN_NAME-163))|(1<<(SQL92StatementParserCOMMAND_FUNCTION-163))|(1<<(SQL92StatementParserCOMMITTED-163))|(1<<(SQL92StatementParserCONDITION_NUMBER-163))|(1<<(SQL92StatementParserCONNECTION_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_CATALOG-163))|(1<<(SQL92StatementParserCONSTRAINT_NAME-163))|(1<<(SQL92StatementParserCONSTRAINT_SCHEMA-163))|(1<<(SQL92StatementParserCURSOR_NAME-163))|(1<<(SQL92StatementParserDATA-163))|(1<<(SQL92StatementParserDATETIME_INTERVAL_CODE-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(SQL92StatementParserDATETIME_INTERVAL_PRECISION-195))|(1<<(SQL92StatementParserDYNAMIC_FUNCTION-195))|(1<<(SQL92StatementParserFORTRAN-195))|(1<<(SQL92StatementParserLENGTH-195))|(1<<(SQL92StatementParserMESSAGE_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_OCTET_LENGTH-195))|(1<<(SQL92StatementParserMESSAGE_TEXT-195))|(1<<(SQL92StatementParserMORE92-195))|(1<<(SQL92StatementParserMUMPS-195))|(1<<(SQL92StatementParserNULLABLE-195))|(1<<(SQL92StatementParserNUMBER-195))|(1<<(SQL92StatementParserPASCAL-195))|(1<<(SQL92StatementParserPLI-195))|(1<<(SQL92StatementParserREPEATABLE-195))|(1<<(SQL92StatementParserRETURNED_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_OCTET_LENGTH-195))|(1<<(SQL92StatementParserRETURNED_SQLSTATE-195))|(1<<(SQL92StatementParserROW_COUNT-195))|(1<<(SQL92StatementParserSCALE-195))|(1<<(SQL92StatementParserSCHEMA_NAME-195))|(1<<(SQL92StatementParserSERIALIZABLE-195))|(1<<(SQL92StatementParserSERVER_NAME-195))|(1<<(SQL92StatementParserSUBCLASS_ORIGIN-195))|(1<<(SQL92StatementParserTABLE_NAME-195))|(1<<(SQL92StatementParserUNCOMMITTED-195))|(1<<(SQL92StatementParserUNNAMED-195)))) != 0) || _la == SQL92StatementParserIDENTIFIER_ {
			{
				p.SetState(1349)
				p.ConstraintName()
			}

		}

	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserPRIMARY:
		{
			p.SetState(1354)
			p.PrimaryKeyOption()
		}

	case SQL92StatementParserUNIQUE:
		{
			p.SetState(1355)
			p.UniqueOption()
		}

	case SQL92StatementParserFOREIGN:
		{
			p.SetState(1356)
			p.ForeignKeyOption()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimaryKeyOptionContext is an interface to support dynamic dispatch.
type IPrimaryKeyOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyOptionContext differentiates from other interfaces.
	IsPrimaryKeyOptionContext()
}

type PrimaryKeyOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyOptionContext() *PrimaryKeyOptionContext {
	var p = new(PrimaryKeyOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_primaryKeyOption
	return p
}

func (*PrimaryKeyOptionContext) IsPrimaryKeyOptionContext() {}

func NewPrimaryKeyOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyOptionContext {
	var p = new(PrimaryKeyOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_primaryKeyOption

	return p
}

func (s *PrimaryKeyOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyOptionContext) PrimaryKey() IPrimaryKeyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryKeyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyContext)
}

func (s *PrimaryKeyOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *PrimaryKeyOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrimaryKeyOption(s)
	}
}

func (s *PrimaryKeyOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrimaryKeyOption(s)
	}
}

func (s *PrimaryKeyOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrimaryKeyOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PrimaryKeyOption() (localctx IPrimaryKeyOptionContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, SQL92StatementParserRULE_primaryKeyOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.PrimaryKey()
	}
	{
		p.SetState(1360)
		p.ColumnNames()
	}

	return localctx
}

// IPrimaryKeyContext is an interface to support dynamic dispatch.
type IPrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryKeyContext differentiates from other interfaces.
	IsPrimaryKeyContext()
}

type PrimaryKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyContext() *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_primaryKey
	return p
}

func (*PrimaryKeyContext) IsPrimaryKeyContext() {}

func NewPrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyContext {
	var p = new(PrimaryKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_primaryKey

	return p
}

func (s *PrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPRIMARY, 0)
}

func (s *PrimaryKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserKEY, 0)
}

func (s *PrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrimaryKey(s)
	}
}

func (s *PrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrimaryKey(s)
	}
}

func (s *PrimaryKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrimaryKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PrimaryKey() (localctx IPrimaryKeyContext) {
	this := p
	_ = this

	localctx = NewPrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, SQL92StatementParserRULE_primaryKey)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1362)
		p.Match(SQL92StatementParserPRIMARY)
	}
	{
		p.SetState(1363)
		p.Match(SQL92StatementParserKEY)
	}

	return localctx
}

// IUniqueOptionContext is an interface to support dynamic dispatch.
type IUniqueOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUniqueOptionContext differentiates from other interfaces.
	IsUniqueOptionContext()
}

type UniqueOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUniqueOptionContext() *UniqueOptionContext {
	var p = new(UniqueOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_uniqueOption
	return p
}

func (*UniqueOptionContext) IsUniqueOptionContext() {}

func NewUniqueOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UniqueOptionContext {
	var p = new(UniqueOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_uniqueOption

	return p
}

func (s *UniqueOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UniqueOptionContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNIQUE, 0)
}

func (s *UniqueOptionContext) KeyParts() IKeyPartsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyPartsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyPartsContext)
}

func (s *UniqueOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UniqueOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UniqueOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterUniqueOption(s)
	}
}

func (s *UniqueOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitUniqueOption(s)
	}
}

func (s *UniqueOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitUniqueOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) UniqueOption() (localctx IUniqueOptionContext) {
	this := p
	_ = this

	localctx = NewUniqueOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, SQL92StatementParserRULE_uniqueOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.Match(SQL92StatementParserUNIQUE)
	}
	{
		p.SetState(1366)
		p.KeyParts()
	}

	return localctx
}

// IForeignKeyOptionContext is an interface to support dynamic dispatch.
type IForeignKeyOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeignKeyOptionContext differentiates from other interfaces.
	IsForeignKeyOptionContext()
}

type ForeignKeyOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeignKeyOptionContext() *ForeignKeyOptionContext {
	var p = new(ForeignKeyOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_foreignKeyOption
	return p
}

func (*ForeignKeyOptionContext) IsForeignKeyOptionContext() {}

func NewForeignKeyOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeignKeyOptionContext {
	var p = new(ForeignKeyOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_foreignKeyOption

	return p
}

func (s *ForeignKeyOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeignKeyOptionContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFOREIGN, 0)
}

func (s *ForeignKeyOptionContext) KEY() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserKEY, 0)
}

func (s *ForeignKeyOptionContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *ForeignKeyOptionContext) ReferenceDefinition() IReferenceDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReferenceDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReferenceDefinitionContext)
}

func (s *ForeignKeyOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeignKeyOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeignKeyOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterForeignKeyOption(s)
	}
}

func (s *ForeignKeyOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitForeignKeyOption(s)
	}
}

func (s *ForeignKeyOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitForeignKeyOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ForeignKeyOption() (localctx IForeignKeyOptionContext) {
	this := p
	_ = this

	localctx = NewForeignKeyOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, SQL92StatementParserRULE_foreignKeyOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1368)
		p.Match(SQL92StatementParserFOREIGN)
	}
	{
		p.SetState(1369)
		p.Match(SQL92StatementParserKEY)
	}
	{
		p.SetState(1370)
		p.ColumnNames()
	}
	{
		p.SetState(1371)
		p.ReferenceDefinition()
	}

	return localctx
}

// ICreateLikeClauseContext is an interface to support dynamic dispatch.
type ICreateLikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreateLikeClauseContext differentiates from other interfaces.
	IsCreateLikeClauseContext()
}

type CreateLikeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateLikeClauseContext() *CreateLikeClauseContext {
	var p = new(CreateLikeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_createLikeClause
	return p
}

func (*CreateLikeClauseContext) IsCreateLikeClauseContext() {}

func NewCreateLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLikeClauseContext {
	var p = new(CreateLikeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_createLikeClause

	return p
}

func (s *CreateLikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLikeClauseContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLIKE, 0)
}

func (s *CreateLikeClauseContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateLikeClauseContext) LP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLP_, 0)
}

func (s *CreateLikeClauseContext) RP_() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserRP_, 0)
}

func (s *CreateLikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCreateLikeClause(s)
	}
}

func (s *CreateLikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCreateLikeClause(s)
	}
}

func (s *CreateLikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCreateLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) CreateLikeClause() (localctx ICreateLikeClauseContext) {
	this := p
	_ = this

	localctx = NewCreateLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, SQL92StatementParserRULE_createLikeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserLP_ {
		{
			p.SetState(1373)
			p.Match(SQL92StatementParserLP_)
		}

	}
	{
		p.SetState(1376)
		p.Match(SQL92StatementParserLIKE)
	}
	{
		p.SetState(1377)
		p.TableName()
	}
	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserRP_ {
		{
			p.SetState(1378)
			p.Match(SQL92StatementParserRP_)
		}

	}

	return localctx
}

// IAlterDefinitionClauseContext is an interface to support dynamic dispatch.
type IAlterDefinitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterDefinitionClauseContext differentiates from other interfaces.
	IsAlterDefinitionClauseContext()
}

type AlterDefinitionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDefinitionClauseContext() *AlterDefinitionClauseContext {
	var p = new(AlterDefinitionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_alterDefinitionClause
	return p
}

func (*AlterDefinitionClauseContext) IsAlterDefinitionClauseContext() {}

func NewAlterDefinitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDefinitionClauseContext {
	var p = new(AlterDefinitionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_alterDefinitionClause

	return p
}

func (s *AlterDefinitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDefinitionClauseContext) AddColumnSpecification() IAddColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddColumnSpecificationContext)
}

func (s *AlterDefinitionClauseContext) ModifyColumnSpecification() IModifyColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifyColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifyColumnSpecificationContext)
}

func (s *AlterDefinitionClauseContext) DropColumnSpecification() IDropColumnSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropColumnSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropColumnSpecificationContext)
}

func (s *AlterDefinitionClauseContext) AddConstraintSpecification() IAddConstraintSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddConstraintSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddConstraintSpecificationContext)
}

func (s *AlterDefinitionClauseContext) DropConstraintSpecification() IDropConstraintSpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropConstraintSpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropConstraintSpecificationContext)
}

func (s *AlterDefinitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDefinitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDefinitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAlterDefinitionClause(s)
	}
}

func (s *AlterDefinitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAlterDefinitionClause(s)
	}
}

func (s *AlterDefinitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAlterDefinitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AlterDefinitionClause() (localctx IAlterDefinitionClauseContext) {
	this := p
	_ = this

	localctx = NewAlterDefinitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, SQL92StatementParserRULE_alterDefinitionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1381)
			p.AddColumnSpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1382)
			p.ModifyColumnSpecification()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1383)
			p.DropColumnSpecification()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1384)
			p.AddConstraintSpecification()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1385)
			p.DropConstraintSpecification()
		}

	}

	return localctx
}

// IAddColumnSpecificationContext is an interface to support dynamic dispatch.
type IAddColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddColumnSpecificationContext differentiates from other interfaces.
	IsAddColumnSpecificationContext()
}

type AddColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddColumnSpecificationContext() *AddColumnSpecificationContext {
	var p = new(AddColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_addColumnSpecification
	return p
}

func (*AddColumnSpecificationContext) IsAddColumnSpecificationContext() {}

func NewAddColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnSpecificationContext {
	var p = new(AddColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_addColumnSpecification

	return p
}

func (s *AddColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnSpecificationContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserADD, 0)
}

func (s *AddColumnSpecificationContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *AddColumnSpecificationContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLUMN, 0)
}

func (s *AddColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAddColumnSpecification(s)
	}
}

func (s *AddColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAddColumnSpecification(s)
	}
}

func (s *AddColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAddColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AddColumnSpecification() (localctx IAddColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewAddColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, SQL92StatementParserRULE_addColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1388)
		p.Match(SQL92StatementParserADD)
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCOLUMN {
		{
			p.SetState(1389)
			p.Match(SQL92StatementParserCOLUMN)
		}

	}
	{
		p.SetState(1392)
		p.ColumnDefinition()
	}

	return localctx
}

// IModifyColumnSpecificationContext is an interface to support dynamic dispatch.
type IModifyColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifyColumnSpecificationContext differentiates from other interfaces.
	IsModifyColumnSpecificationContext()
}

type ModifyColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyColumnSpecificationContext() *ModifyColumnSpecificationContext {
	var p = new(ModifyColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_modifyColumnSpecification
	return p
}

func (*ModifyColumnSpecificationContext) IsModifyColumnSpecificationContext() {}

func NewModifyColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnSpecificationContext {
	var p = new(ModifyColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_modifyColumnSpecification

	return p
}

func (s *ModifyColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnSpecificationContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALTER, 0)
}

func (s *ModifyColumnSpecificationContext) ColumnDefinition() IColumnDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ModifyColumnSpecificationContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLUMN, 0)
}

func (s *ModifyColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterModifyColumnSpecification(s)
	}
}

func (s *ModifyColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitModifyColumnSpecification(s)
	}
}

func (s *ModifyColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitModifyColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ModifyColumnSpecification() (localctx IModifyColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewModifyColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, SQL92StatementParserRULE_modifyColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.Match(SQL92StatementParserALTER)
	}
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCOLUMN {
		{
			p.SetState(1395)
			p.Match(SQL92StatementParserCOLUMN)
		}

	}
	{
		p.SetState(1398)
		p.ColumnDefinition()
	}

	return localctx
}

// IDropColumnSpecificationContext is an interface to support dynamic dispatch.
type IDropColumnSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropColumnSpecificationContext differentiates from other interfaces.
	IsDropColumnSpecificationContext()
}

type DropColumnSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropColumnSpecificationContext() *DropColumnSpecificationContext {
	var p = new(DropColumnSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropColumnSpecification
	return p
}

func (*DropColumnSpecificationContext) IsDropColumnSpecificationContext() {}

func NewDropColumnSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnSpecificationContext {
	var p = new(DropColumnSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropColumnSpecification

	return p
}

func (s *DropColumnSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnSpecificationContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDROP, 0)
}

func (s *DropColumnSpecificationContext) ColumnName() IColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *DropColumnSpecificationContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOLUMN, 0)
}

func (s *DropColumnSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropColumnSpecification(s)
	}
}

func (s *DropColumnSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropColumnSpecification(s)
	}
}

func (s *DropColumnSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropColumnSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropColumnSpecification() (localctx IDropColumnSpecificationContext) {
	this := p
	_ = this

	localctx = NewDropColumnSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, SQL92StatementParserRULE_dropColumnSpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)
		p.Match(SQL92StatementParserDROP)
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserCOLUMN {
		{
			p.SetState(1401)
			p.Match(SQL92StatementParserCOLUMN)
		}

	}
	{
		p.SetState(1404)
		p.ColumnName()
	}

	return localctx
}

// IAddConstraintSpecificationContext is an interface to support dynamic dispatch.
type IAddConstraintSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddConstraintSpecificationContext differentiates from other interfaces.
	IsAddConstraintSpecificationContext()
}

type AddConstraintSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddConstraintSpecificationContext() *AddConstraintSpecificationContext {
	var p = new(AddConstraintSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_addConstraintSpecification
	return p
}

func (*AddConstraintSpecificationContext) IsAddConstraintSpecificationContext() {}

func NewAddConstraintSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddConstraintSpecificationContext {
	var p = new(AddConstraintSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_addConstraintSpecification

	return p
}

func (s *AddConstraintSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *AddConstraintSpecificationContext) ADD() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserADD, 0)
}

func (s *AddConstraintSpecificationContext) ConstraintDefinition() IConstraintDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintDefinitionContext)
}

func (s *AddConstraintSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddConstraintSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterAddConstraintSpecification(s)
	}
}

func (s *AddConstraintSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitAddConstraintSpecification(s)
	}
}

func (s *AddConstraintSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitAddConstraintSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) AddConstraintSpecification() (localctx IAddConstraintSpecificationContext) {
	this := p
	_ = this

	localctx = NewAddConstraintSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, SQL92StatementParserRULE_addConstraintSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Match(SQL92StatementParserADD)
	}
	{
		p.SetState(1407)
		p.ConstraintDefinition()
	}

	return localctx
}

// IDropConstraintSpecificationContext is an interface to support dynamic dispatch.
type IDropConstraintSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDropConstraintSpecificationContext differentiates from other interfaces.
	IsDropConstraintSpecificationContext()
}

type DropConstraintSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropConstraintSpecificationContext() *DropConstraintSpecificationContext {
	var p = new(DropConstraintSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_dropConstraintSpecification
	return p
}

func (*DropConstraintSpecificationContext) IsDropConstraintSpecificationContext() {}

func NewDropConstraintSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropConstraintSpecificationContext {
	var p = new(DropConstraintSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_dropConstraintSpecification

	return p
}

func (s *DropConstraintSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DropConstraintSpecificationContext) DROP() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDROP, 0)
}

func (s *DropConstraintSpecificationContext) ConstraintDefinition() IConstraintDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintDefinitionContext)
}

func (s *DropConstraintSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropConstraintSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterDropConstraintSpecification(s)
	}
}

func (s *DropConstraintSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitDropConstraintSpecification(s)
	}
}

func (s *DropConstraintSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitDropConstraintSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) DropConstraintSpecification() (localctx IDropConstraintSpecificationContext) {
	this := p
	_ = this

	localctx = NewDropConstraintSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, SQL92StatementParserRULE_dropConstraintSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.Match(SQL92StatementParserDROP)
	}
	{
		p.SetState(1410)
		p.ConstraintDefinition()
	}

	return localctx
}

// ISetTransactionContext is an interface to support dynamic dispatch.
type ISetTransactionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetTransactionContext differentiates from other interfaces.
	IsSetTransactionContext()
}

type SetTransactionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetTransactionContext() *SetTransactionContext {
	var p = new(SetTransactionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_setTransaction
	return p
}

func (*SetTransactionContext) IsSetTransactionContext() {}

func NewSetTransactionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetTransactionContext {
	var p = new(SetTransactionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_setTransaction

	return p
}

func (s *SetTransactionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTRANSACTION, 0)
}

func (s *SetTransactionContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserISOLATION, 0)
}

func (s *SetTransactionContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserLEVEL, 0)
}

func (s *SetTransactionContext) LevelOfIsolation() ILevelOfIsolationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelOfIsolationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelOfIsolationContext)
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) SetTransaction() (localctx ISetTransactionContext) {
	this := p
	_ = this

	localctx = NewSetTransactionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, SQL92StatementParserRULE_setTransaction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.Match(SQL92StatementParserSET)
	}
	{
		p.SetState(1413)
		p.Match(SQL92StatementParserTRANSACTION)
	}
	{
		p.SetState(1414)
		p.Match(SQL92StatementParserISOLATION)
	}
	{
		p.SetState(1415)
		p.Match(SQL92StatementParserLEVEL)
	}
	{
		p.SetState(1416)
		p.LevelOfIsolation()
	}

	return localctx
}

// ICommitContext is an interface to support dynamic dispatch.
type ICommitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitContext differentiates from other interfaces.
	IsCommitContext()
}

type CommitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitContext() *CommitContext {
	var p = new(CommitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_commit
	return p
}

func (*CommitContext) IsCommitContext() {}

func NewCommitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitContext {
	var p = new(CommitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_commit

	return p
}

func (s *CommitContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMIT, 0)
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitCommit(s)
	}
}

func (s *CommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Commit() (localctx ICommitContext) {
	this := p
	_ = this

	localctx = NewCommitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, SQL92StatementParserRULE_commit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1418)
		p.Match(SQL92StatementParserCOMMIT)
	}

	return localctx
}

// IRollbackContext is an interface to support dynamic dispatch.
type IRollbackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRollbackContext differentiates from other interfaces.
	IsRollbackContext()
}

type RollbackContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackContext() *RollbackContext {
	var p = new(RollbackContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_rollback
	return p
}

func (*RollbackContext) IsRollbackContext() {}

func NewRollbackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackContext {
	var p = new(RollbackContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_rollback

	return p
}

func (s *RollbackContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserROLLBACK, 0)
}

func (s *RollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterRollback(s)
	}
}

func (s *RollbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitRollback(s)
	}
}

func (s *RollbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitRollback(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Rollback() (localctx IRollbackContext) {
	this := p
	_ = this

	localctx = NewRollbackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, SQL92StatementParserRULE_rollback)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(SQL92StatementParserROLLBACK)
	}

	return localctx
}

// ILevelOfIsolationContext is an interface to support dynamic dispatch.
type ILevelOfIsolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelOfIsolationContext differentiates from other interfaces.
	IsLevelOfIsolationContext()
}

type LevelOfIsolationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelOfIsolationContext() *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_levelOfIsolation
	return p
}

func (*LevelOfIsolationContext) IsLevelOfIsolationContext() {}

func NewLevelOfIsolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelOfIsolationContext {
	var p = new(LevelOfIsolationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_levelOfIsolation

	return p
}

func (s *LevelOfIsolationContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelOfIsolationContext) READ() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREAD, 0)
}

func (s *LevelOfIsolationContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUNCOMMITTED, 0)
}

func (s *LevelOfIsolationContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMITTED, 0)
}

func (s *LevelOfIsolationContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREPEATABLE, 0)
}

func (s *LevelOfIsolationContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSERIALIZABLE, 0)
}

func (s *LevelOfIsolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelOfIsolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelOfIsolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterLevelOfIsolation(s)
	}
}

func (s *LevelOfIsolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitLevelOfIsolation(s)
	}
}

func (s *LevelOfIsolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitLevelOfIsolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) LevelOfIsolation() (localctx ILevelOfIsolationContext) {
	this := p
	_ = this

	localctx = NewLevelOfIsolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, SQL92StatementParserRULE_levelOfIsolation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.Match(SQL92StatementParserREAD)
		}
		{
			p.SetState(1423)
			p.Match(SQL92StatementParserUNCOMMITTED)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1424)
			p.Match(SQL92StatementParserREAD)
		}
		{
			p.SetState(1425)
			p.Match(SQL92StatementParserCOMMITTED)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1426)
			p.Match(SQL92StatementParserREPEATABLE)
		}
		{
			p.SetState(1427)
			p.Match(SQL92StatementParserREAD)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1428)
			p.Match(SQL92StatementParserSERIALIZABLE)
		}

	}

	return localctx
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_grant
	return p
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserGRANT)
}

func (s *GrantContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGRANT, i)
}

func (s *GrantContext) PrivilegeClause() IPrivilegeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeClauseContext)
}

func (s *GrantContext) TO() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTO, 0)
}

func (s *GrantContext) AllGrantee() []IGranteeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGranteeContext)(nil)).Elem())
	var tst = make([]IGranteeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGranteeContext)
		}
	}

	return tst
}

func (s *GrantContext) Grantee(i int) IGranteeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGranteeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGranteeContext)
}

func (s *GrantContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *GrantContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *GrantContext) WITH() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserWITH, 0)
}

func (s *GrantContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOPTION, 0)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Grant() (localctx IGrantContext) {
	this := p
	_ = this

	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, SQL92StatementParserRULE_grant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1431)
		p.Match(SQL92StatementParserGRANT)
	}
	{
		p.SetState(1432)
		p.PrivilegeClause()
	}
	{
		p.SetState(1433)
		p.Match(SQL92StatementParserTO)
	}
	{
		p.SetState(1434)
		p.Grantee()
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1435)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1436)
			p.Grantee()
		}

		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserWITH {
		{
			p.SetState(1442)
			p.Match(SQL92StatementParserWITH)
		}
		{
			p.SetState(1443)
			p.Match(SQL92StatementParserGRANT)
		}
		{
			p.SetState(1444)
			p.Match(SQL92StatementParserOPTION)
		}

	}

	return localctx
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_revoke
	return p
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREVOKE, 0)
}

func (s *RevokeContext) PrivilegeClause() IPrivilegeClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeClauseContext)
}

func (s *RevokeContext) FROM() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFROM, 0)
}

func (s *RevokeContext) AllGrantee() []IGranteeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGranteeContext)(nil)).Elem())
	var tst = make([]IGranteeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGranteeContext)
		}
	}

	return tst
}

func (s *RevokeContext) Grantee(i int) IGranteeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGranteeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGranteeContext)
}

func (s *RevokeContext) DropBehaviour() IDropBehaviourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDropBehaviourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDropBehaviourContext)
}

func (s *RevokeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserGRANT, 0)
}

func (s *RevokeContext) OPTION() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserOPTION, 0)
}

func (s *RevokeContext) FOR() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserFOR, 0)
}

func (s *RevokeContext) AllCOMMA_() []antlr.TerminalNode {
	return s.GetTokens(SQL92StatementParserCOMMA_)
}

func (s *RevokeContext) COMMA_(i int) antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserCOMMA_, i)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Revoke() (localctx IRevokeContext) {
	this := p
	_ = this

	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, SQL92StatementParserRULE_revoke)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Match(SQL92StatementParserREVOKE)
	}
	p.SetState(1451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserGRANT {
		{
			p.SetState(1448)
			p.Match(SQL92StatementParserGRANT)
		}
		{
			p.SetState(1449)
			p.Match(SQL92StatementParserOPTION)
		}
		{
			p.SetState(1450)
			p.Match(SQL92StatementParserFOR)
		}

	}
	{
		p.SetState(1453)
		p.PrivilegeClause()
	}
	{
		p.SetState(1454)
		p.Match(SQL92StatementParserFROM)
	}
	{
		p.SetState(1455)
		p.Grantee()
	}
	p.SetState(1460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == SQL92StatementParserCOMMA_ {
		{
			p.SetState(1456)
			p.Match(SQL92StatementParserCOMMA_)
		}
		{
			p.SetState(1457)
			p.Grantee()
		}

		p.SetState(1462)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1463)
		p.DropBehaviour()
	}

	return localctx
}

// IPrivilegeClauseContext is an interface to support dynamic dispatch.
type IPrivilegeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeClauseContext differentiates from other interfaces.
	IsPrivilegeClauseContext()
}

type PrivilegeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeClauseContext() *PrivilegeClauseContext {
	var p = new(PrivilegeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_privilegeClause
	return p
}

func (*PrivilegeClauseContext) IsPrivilegeClauseContext() {}

func NewPrivilegeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeClauseContext {
	var p = new(PrivilegeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_privilegeClause

	return p
}

func (s *PrivilegeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeClauseContext) Privileges() IPrivilegesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegesContext)
}

func (s *PrivilegeClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserON, 0)
}

func (s *PrivilegeClauseContext) OnObjectClause() IOnObjectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnObjectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnObjectClauseContext)
}

func (s *PrivilegeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrivilegeClause(s)
	}
}

func (s *PrivilegeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrivilegeClause(s)
	}
}

func (s *PrivilegeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrivilegeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PrivilegeClause() (localctx IPrivilegeClauseContext) {
	this := p
	_ = this

	localctx = NewPrivilegeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, SQL92StatementParserRULE_privilegeClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		p.Privileges()
	}
	{
		p.SetState(1466)
		p.Match(SQL92StatementParserON)
	}
	{
		p.SetState(1467)
		p.OnObjectClause()
	}

	return localctx
}

// IPrivilegesContext is an interface to support dynamic dispatch.
type IPrivilegesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegesContext differentiates from other interfaces.
	IsPrivilegesContext()
}

type PrivilegesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesContext() *PrivilegesContext {
	var p = new(PrivilegesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_privileges
	return p
}

func (*PrivilegesContext) IsPrivilegesContext() {}

func NewPrivilegesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesContext {
	var p = new(PrivilegesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_privileges

	return p
}

func (s *PrivilegesContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesContext) PrivilegeType() IPrivilegeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivilegesContext) ColumnNames() IColumnNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnNamesContext)
}

func (s *PrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrivileges(s)
	}
}

func (s *PrivilegesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrivileges(s)
	}
}

func (s *PrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Privileges() (localctx IPrivilegesContext) {
	this := p
	_ = this

	localctx = NewPrivilegesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, SQL92StatementParserRULE_privileges)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		p.PrivilegeType()
	}
	{
		p.SetState(1470)
		p.ColumnNames()
	}

	return localctx
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_privilegeType
	return p
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserSELECT, 0)
}

func (s *PrivilegeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserDELETE, 0)
}

func (s *PrivilegeTypeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserINSERT, 0)
}

func (s *PrivilegeTypeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUPDATE, 0)
}

func (s *PrivilegeTypeContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserREFERENCES, 0)
}

func (s *PrivilegeTypeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserUSAGE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	this := p
	_ = this

	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, SQL92StatementParserRULE_privilegeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1480)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1472)
			p.Match(SQL92StatementParserALL)
		}
		{
			p.SetState(1473)
			p.Match(SQL92StatementParserPRIVILEGES)
		}

	case SQL92StatementParserSELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1474)
			p.Match(SQL92StatementParserSELECT)
		}

	case SQL92StatementParserDELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1475)
			p.Match(SQL92StatementParserDELETE)
		}

	case SQL92StatementParserINSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1476)
			p.Match(SQL92StatementParserINSERT)
		}

	case SQL92StatementParserUPDATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1477)
			p.Match(SQL92StatementParserUPDATE)
		}

	case SQL92StatementParserREFERENCES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1478)
			p.Match(SQL92StatementParserREFERENCES)
		}

	case SQL92StatementParserUSAGE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1479)
			p.Match(SQL92StatementParserUSAGE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGranteeContext is an interface to support dynamic dispatch.
type IGranteeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGranteeContext differentiates from other interfaces.
	IsGranteeContext()
}

type GranteeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGranteeContext() *GranteeContext {
	var p = new(GranteeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_grantee
	return p
}

func (*GranteeContext) IsGranteeContext() {}

func NewGranteeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GranteeContext {
	var p = new(GranteeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_grantee

	return p
}

func (s *GranteeContext) GetParser() antlr.Parser { return s.parser }

func (s *GranteeContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserPUBLIC, 0)
}

func (s *GranteeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GranteeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GranteeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GranteeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterGrantee(s)
	}
}

func (s *GranteeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitGrantee(s)
	}
}

func (s *GranteeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitGrantee(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) Grantee() (localctx IGranteeContext) {
	this := p
	_ = this

	localctx = NewGranteeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, SQL92StatementParserRULE_grantee)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1484)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case SQL92StatementParserPUBLIC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1482)
			p.Match(SQL92StatementParserPUBLIC)
		}

	case SQL92StatementParserNAME, SQL92StatementParserTYPE, SQL92StatementParserADA, SQL92StatementParserC92, SQL92StatementParserCATALOG_NAME, SQL92StatementParserCHARACTER_SET_CATALOG, SQL92StatementParserCHARACTER_SET_NAME, SQL92StatementParserCHARACTER_SET_SCHEMA, SQL92StatementParserCLASS_ORIGIN, SQL92StatementParserCOBOL, SQL92StatementParserCOLLATION_CATALOG, SQL92StatementParserCOLLATION_NAME, SQL92StatementParserCOLLATION_SCHEMA, SQL92StatementParserCOLUMN_NAME, SQL92StatementParserCOMMAND_FUNCTION, SQL92StatementParserCOMMITTED, SQL92StatementParserCONDITION_NUMBER, SQL92StatementParserCONNECTION_NAME, SQL92StatementParserCONSTRAINT_CATALOG, SQL92StatementParserCONSTRAINT_NAME, SQL92StatementParserCONSTRAINT_SCHEMA, SQL92StatementParserCURSOR_NAME, SQL92StatementParserDATA, SQL92StatementParserDATETIME_INTERVAL_CODE, SQL92StatementParserDATETIME_INTERVAL_PRECISION, SQL92StatementParserDYNAMIC_FUNCTION, SQL92StatementParserFORTRAN, SQL92StatementParserLENGTH, SQL92StatementParserMESSAGE_LENGTH, SQL92StatementParserMESSAGE_OCTET_LENGTH, SQL92StatementParserMESSAGE_TEXT, SQL92StatementParserMORE92, SQL92StatementParserMUMPS, SQL92StatementParserNULLABLE, SQL92StatementParserNUMBER, SQL92StatementParserPASCAL, SQL92StatementParserPLI, SQL92StatementParserREPEATABLE, SQL92StatementParserRETURNED_LENGTH, SQL92StatementParserRETURNED_OCTET_LENGTH, SQL92StatementParserRETURNED_SQLSTATE, SQL92StatementParserROW_COUNT, SQL92StatementParserSCALE, SQL92StatementParserSCHEMA_NAME, SQL92StatementParserSERIALIZABLE, SQL92StatementParserSERVER_NAME, SQL92StatementParserSUBCLASS_ORIGIN, SQL92StatementParserTABLE_NAME, SQL92StatementParserUNCOMMITTED, SQL92StatementParserUNNAMED, SQL92StatementParserIDENTIFIER_:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1483)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnObjectClauseContext is an interface to support dynamic dispatch.
type IOnObjectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnObjectClauseContext differentiates from other interfaces.
	IsOnObjectClauseContext()
}

type OnObjectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnObjectClauseContext() *OnObjectClauseContext {
	var p = new(OnObjectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_onObjectClause
	return p
}

func (*OnObjectClauseContext) IsOnObjectClauseContext() {}

func NewOnObjectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnObjectClauseContext {
	var p = new(OnObjectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_onObjectClause

	return p
}

func (s *OnObjectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnObjectClauseContext) PrivilegeLevel() IPrivilegeLevelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegeLevelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegeLevelContext)
}

func (s *OnObjectClauseContext) ObjectType() IObjectTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObjectTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *OnObjectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnObjectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnObjectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterOnObjectClause(s)
	}
}

func (s *OnObjectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitOnObjectClause(s)
	}
}

func (s *OnObjectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitOnObjectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) OnObjectClause() (localctx IOnObjectClauseContext) {
	this := p
	_ = this

	localctx = NewOnObjectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, SQL92StatementParserRULE_onObjectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == SQL92StatementParserTABLE {
		{
			p.SetState(1486)
			p.ObjectType()
		}

	}
	{
		p.SetState(1489)
		p.PrivilegeLevel()
	}

	return localctx
}

// IObjectTypeContext is an interface to support dynamic dispatch.
type IObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectTypeContext differentiates from other interfaces.
	IsObjectTypeContext()
}

type ObjectTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeContext() *ObjectTypeContext {
	var p = new(ObjectTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_objectType
	return p
}

func (*ObjectTypeContext) IsObjectTypeContext() {}

func NewObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeContext {
	var p = new(ObjectTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_objectType

	return p
}

func (s *ObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SQL92StatementParserTABLE, 0)
}

func (s *ObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterObjectType(s)
	}
}

func (s *ObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitObjectType(s)
	}
}

func (s *ObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) ObjectType() (localctx IObjectTypeContext) {
	this := p
	_ = this

	localctx = NewObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, SQL92StatementParserRULE_objectType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1491)
		p.Match(SQL92StatementParserTABLE)
	}

	return localctx
}

// IPrivilegeLevelContext is an interface to support dynamic dispatch.
type IPrivilegeLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegeLevelContext differentiates from other interfaces.
	IsPrivilegeLevelContext()
}

type PrivilegeLevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeLevelContext() *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = SQL92StatementParserRULE_privilegeLevel
	return p
}

func (*PrivilegeLevelContext) IsPrivilegeLevelContext() {}

func NewPrivilegeLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeLevelContext {
	var p = new(PrivilegeLevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = SQL92StatementParserRULE_privilegeLevel

	return p
}

func (s *PrivilegeLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeLevelContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *PrivilegeLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.EnterPrivilegeLevel(s)
	}
}

func (s *PrivilegeLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SQL92StatementListener); ok {
		listenerT.ExitPrivilegeLevel(s)
	}
}

func (s *PrivilegeLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case SQL92StatementVisitor:
		return t.VisitPrivilegeLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *SQL92StatementParser) PrivilegeLevel() (localctx IPrivilegeLevelContext) {
	this := p
	_ = this

	localctx = NewPrivilegeLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, SQL92StatementParserRULE_privilegeLevel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1493)
		p.TableName()
	}

	return localctx
}

func (p *SQL92StatementParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 58:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 62:
		var t *BooleanPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*BooleanPrimaryContext)
		}
		return p.BooleanPrimary_Sempred(t, predIndex)

	case 65:
		var t *BitExprContext = nil
		if localctx != nil {
			t = localctx.(*BitExprContext)
		}
		return p.BitExpr_Sempred(t, predIndex)

	case 66:
		var t *SimpleExprContext = nil
		if localctx != nil {
			t = localctx.(*SimpleExprContext)
		}
		return p.SimpleExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SQL92StatementParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQL92StatementParser) BooleanPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQL92StatementParser) BitExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SQL92StatementParser) SimpleExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
